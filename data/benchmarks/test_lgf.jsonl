{"title": "Special Stack", "description": "Write a function block FB that implements a special stack feature that removes the minimum value from the stack during the pop operation.\n1. Push operation: When a new element is pushed, first check if the stack is full. If the stack is full, do nothing. Otherwise, add it to the top of the stack array and update the top position.\n2. Pop operation: When performing a pop operation, first check if the stack is empty. If the stack is empty, do nothing. Otherwise, remove the minimum value from the stack and return the value of that element, while updating the top position. Status codes:\n16#0000: Execution of FB without error\n16#8A04: The stack is full\n16#8A05: The stack is empty", "type": "FUNCTION_BLOCK", "name": "StackMin", "input": [{"name": "push", "type": "Bool", "description": "Push operation, add an element to the stack if it is not full"}, {"name": "pop", "type": "Bool", "description": "Pop operation, remove the minimum value element from the stack and return its value if the stack is not empty"}, {"name": "reset", "type": "Bool", "description": "Reset operation, the top position of the stack will be reset"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error occurred; TRUE: An error occurred during the execution of FB"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "item", "type": "Int", "description": "The value used to push into the stack or to return from the stack"}, {"name": "stack", "type": "Array[0..3] of Int", "description": "The array used as the stack"}]}
{"title": "LReal Array Min/Max Value and Index Searcher", "name": "LGF_SearchMinMax_LReal", "description": "## Short description ##\n\nThis function searches, in an array of the data type LReal, for the maximum and minimum value \nand the respective index in the array.\n\n## Functional description ##\n\nAn array of any size is connected via the values input. The elements are then compared in turn. \nThe smallest and largest values, as well as their corresponding index are output to the array.\nNote If there are several identical min. or max. values, the index of the first min. or max. value is \noutput.", "type": "FUNCTION", "input": [], "output": [{"name": "minValue", "type": "LReal", "description": "Minimum value found in the array"}, {"name": "minValueIndex", "type": "DInt", "description": "Index of the minimum found value in the array"}, {"name": "maxValue", "type": "LReal", "description": "Maximum value found in the array"}, {"name": "maxValueIndex", "type": "DInt", "description": "Index of the maximum found value in the array"}], "in/out": [{"name": "values", "type": "Array[*] of LReal", "description": "Array in whose fields the maximum and minimum are searched"}], "return_value": [], "status_codes": {}, "user_defined_types": []}
{"title": "Boxplot Calculation for Real Data", "name": "LGF_Boxplot_LReal", "description": "## Short description ##\n\nIf you want to get an overview of existing data, you can use a Boxplot diagram. A Boxplot shows \nyou in which area the data is located and how it is distributed over this area. A Boxplot consists \nof the following parameters:\n• Minimum (smallest occurring value of the sample)\n• Lower or first quartile (below this value are 25% of the sample values)\n• Median or second quartile (below this value are 50% of the sample values)\n• Upper or third quartile (below this value are 75% of the sample values)\n• Maximum (largest occurring value of the sample)\nFigure: Boxplot\n\n## Functional description ##\n\nThe block sorts the data series and then calculates the so-called “five-point summary”:\nTable: Five-point summary\nCharacteristic value of the five-point summary Output parameter of the block\nMinimum (smallest occurring value of the sample) min\nLower or first quartile (below this value are 25% of \nthe sample values)\nq25\nMedian or second quartile (below this value are \n50% of the sample values)\nmedian\nUpper or third quartile (below this value are 75% of \nthe sample values)\nq75\nMaximum (largest occurring value of the sample) max\nIf outlier detection is activated, the block first calculates the limits. From these limit values, the \nvalues are recognized as outliers:\n\nThe block then calculates new values for the parameters max and min, which lie within the outlier \nlimits. The outliers are counted and output as a percentage.\nTo make it easier to judge how the data is distributed, the block also calculates the skew. The \nskewness lies between the values -1 and 1 with the following meaning:\n• -1: extremely left skewed distribution\n• 0: symmetrical distribution\n• 1: extreme right-skew distribution\nThe elements of the passed array are sorted in ascending order by the block. The \nLGF_Shellsort_LReal block is used for sorting.\nThe parameters are calculated as follows:\nTable: Boxplot formulas Parameters Formula", "type": "FUNCTION_BLOCK", "input": [{"name": "execute", "type": "Bool", "description": "Activation of the calculation with each positive edge."}, {"name": "rangeOutlier", "type": "LReal", "description": "Outlier detection parameter."}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "outlierMax", "type": "LReal", "description": "Upper outliers in %"}, {"name": "max", "type": "LReal", "description": "Maximum Value, not an outlier."}, {"name": "q75", "type": "LReal", "description": "3rd quartile or Q75 of the data series."}, {"name": "median", "type": "LReal", "description": "2nd quartile or Median of the data series."}, {"name": "q25", "type": "LReal", "description": "1st quartile or Q25 of the data series."}, {"name": "min", "type": "LReal", "description": "Minimum Value, not an outlier."}, {"name": "outlierMin", "type": "LReal", "description": "Lower outliers in %"}, {"name": "skewness", "type": "LReal", "description": "Skewness of the data series."}], "in/out": [{"name": "values", "type": "Array[*] of LReal", "description": "The array containing the data series for calculation"}], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED", "16#7000": "STATUS_NO_CALL", "16#7001": "STATUS_FIRST_CALL", "16#8200": "ERR_NEG_ARR_BOUND", "16#8600": "ERR_SHELL_SORT", "16#9101": "ERR_RANGE_NOT_OK"}, "user_defined_types": []}
{"title": "String Extractor from Character Array", "name": "LGF_ExtractStringFromCharArray", "description": "## Short description ##\n\nThe function extracts a String specified by a text before and after from an array", "type": "FUNCTION", "input": [{"name": "textBefore", "type": "String", "description": "Text in front of the characters which has to be extracted"}, {"name": "textAfter", "type": "String", "description": "Text behind the characters which has to be extracted"}], "output": [{"name": "extractedString", "type": "String", "description": "Extracted string"}, {"name": "status", "type": "Word", "description": "Status of the FB"}], "in/out": [{"name": "searchIn", "type": "Variant", "description": "Array of Character or Byte to search in"}], "return_value": [{"type": "Word", "description": "Status of the FB"}], "status_codes": {"16#0000": "STATUS_TEXT_FOUND", "16#8200": "ERR_NO_ARRAY", "16#9001": "WARNING_ONLY_START", "16#9002": "WARNING_NOTHING_FOUND"}, "user_defined_types": []}
{"title": "Odd Parity Checker for DWord", "name": "LGF_IsParityOdd", "description": "## Short description ##\n\nThe function checks whether the parity of the input variable of type DWord is odd. The return \nvalue is set to TRUE if the number of bits that are assigned TRUE in the sequence is odd.", "type": "FUNCTION", "input": [{"name": "doubleWord", "type": "DWord", "description": "Variable for which the parity is to be determined."}], "output": [], "in/out": [], "return_value": [{"type": "Bool", "description": "TRUE: When the number of bits that are assigned `TRUE` is odd"}], "status_codes": {"16#0000": "STATUS_NO_ERROR"}, "user_defined_types": []}
{"title": "Byte to 8-Bit Splitter", "name": "LGF_SplitByteToBits", "description": "## Short description ##\n\nThis function splits a Byte variable into 8 Boolean / 8 Bit variables.", "type": "FUNCTION", "input": [{"name": "byte", "type": "Byte", "description": "Bit sequence to be split"}], "output": [{"name": "bit7", "type": "Bool", "description": "Output Bit 7 - MSB"}, {"name": "bit6", "type": "Bool", "description": "Output Bit 6"}, {"name": "bit5", "type": "Bool", "description": "Output Bit 5"}, {"name": "bit4", "type": "Bool", "description": "Output Bit 4"}, {"name": "bit3", "type": "Bool", "description": "Output Bit 3"}, {"name": "bit2", "type": "Bool", "description": "Output Bit 2"}, {"name": "bit1", "type": "Bool", "description": "Output Bit 1"}, {"name": "bit0", "type": "Bool", "description": "Output Bit 0 - LSB"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": []}
{"title": "Matrix Comparator", "name": "LGF_MatrixCompare", "description": "## Short description ##\n\nThis function compares two matrices of the data type ARRAY[*,*] of LREAL of equal size.\nIf both matrices are identical, the return value of the function is set to TRUE.\nNote Note that all input matrices must have the same lower and upper limit, and, therefore, the \nsame number of columns and rows.", "type": "FUNCTION", "input": [], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "matrix1", "type": "Array[*, *] of LReal", "description": "First Matrix"}, {"name": "matrix2", "type": "Array[*, *] of LReal", "description": "Second Matrix"}], "return_value": [{"type": "Bool", "description": "TRUE: Both matrices are identical."}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_MATR1_LOWBOUND_ROWS_MATR2_LOWBOUND_ROWS", "16#8201": "ERR_MATR1_LOWBOUND_COLUMNS_MATR2_LOWBOUND_COLUMNS", "16#8202": "ERR_MATR1_UPPBOUND_ROWS_MATR2_UPPBOUND_ROWS", "16#8203": "ERR_MATR1_UPPBOUND_COLUMNS_MATR2_UPPBOUND_COLUMNS"}, "user_defined_types": []}