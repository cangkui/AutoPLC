{"title": "Value Min/Max Storer", "name": "LGF_StoreMinMax", "description": "## Short description ##\n\nThis function reads-in a value of a variable at each call and outputs the maximum and minimum \nvalue that has been read in since the first call.\nThe evaluation can be reset if necessary. The block supports the data type LReal.", "type": "FUNCTION_BLOCK", "input": [{"name": "value", "type": "LReal", "description": "Value to be compared with min/max"}, {"name": "reset", "type": "Bool", "description": "TRUE: The min/max history is reset and the evaluation starts over again."}], "output": [{"name": "minValue", "type": "LReal", "description": "Minimum value since first call or `reset`."}, {"name": "maxValue", "type": "LReal", "description": "Maximum values since first call or `reset`."}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": []}
{"title": "Natural number factorial calculation", "name": "LGF_GetFactorial", "description": "## Short description ##\n\nThe function calculates the faculty of a natural number (‚Ñï!) and returns the result.\nThe permissible value range of the input parameter naturalNumber is between 0 and 12, as 12 \nis the maximum factorial result fitting into a DInt type", "type": "FUNCTION", "input": [{"name": "naturalNumber", "type": "Int", "description": "Natural number (0..12)"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB 16#8000-16#FFFF: Error identification"}], "in/out": [], "return_value": [{"type": "DInt", "description": "Calculated factorial"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8101": "ERR_WRONG_VALUE_RANGE"}, "user_defined_types": []}
{"title": "System time, local time, and time zone setting", "name": "LGF_SetTime", "description": "## Short description ##\n\nThis block combines the functions of system time, local time, and set time zone.\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nNote The function uses internally the system function WR_LOC_T to write the local time of the CPU \nor WR_SYS_T to write the coordinated world time (UTC). Further it uses the system function \nSET_TIMEZONE to set the time zone of the PLC.\nThis block combines the functions of system time, local time, and set time zone.", "type": "FUNCTION_BLOCK", "input": [{"name": "execute", "type": "Bool", "description": "Rising edge starts action once"}, {"name": "systemTime", "type": "DTL", "description": "System time to be set in PLC"}, {"name": "isLocalTime", "type": "Bool", "description": "TRUE: `systemTime` is local time, FALSE: `systemTime` is UTC time"}, {"name": "timeZone", "type": "Int", "description": "Timezones HHMM [-1200.. -330.. 0.. 930.. 1200.. 1300]"}, {"name": "isDaylightSavingTime", "type": "Bool", "description": "Daylight saving time changeover, TRUE: activated, FALSE: deactivated"}], "output": [{"name": "done", "type": "Bool", "description": "TRUE: Commanded functionality has been completed successfully"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is active and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "FALSE: No error / TRUE: An error occurred during the execution of the FB"}, {"name": "lastSetTimeZone", "type": "String", "description": "Time zone that was set last by this block"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB / 16#8000-16#FFFF: Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED_NO_ERROR", "16#7000": "STATUS_NO_CALL", "16#7001": "STATUS_FIRST_CALL", "16#7002": "STATUS_SUBSEQUENT_CALL", "16#8201": "ERR_SET_TIME_LOCAL", "16#8202": "ERR_SET_TIME_UTC", "16#8203": "ERR_SET_TIMEZONE", "16#8600": "ERR_UNDEFINED_STATE", "16#8601": "ERR_WRONG_TIMEZONE"}, "user_defined_types": []}
{"title": "Advanced CRC-16 Calculator", "name": "LGF_CalcCRC16Advanced", "description": "## Short description ##\n\nThe CRC calculation is used for error detection at data transmission. The result of a calculation \nreturns a CRC value via the data sent. The receiver detects a faulty transmission due to the \nunequal CRC value. The function LGF_CalcCRC16Advanced uses 16 bits as the generator \npolynomial (mask) and the parameters finalXorValue, reflectInput, and reflectResult.\n\n## Functional description ##\n\nThe function calculates the CRC value from a data stream of any size. The data stream is \ncomposed of the individual elements of the array at the input/output parameter array. The start \nvalue initValue and the generator polynomial mask can be freely selected.\nVia the Boolean input parameters reflectInput and reflectResult, you may optionally mirror \nthe bits of the input data or the CRC value. An XOR operation is also performed with the CRC \nvalue at the end and the value finalXorValue.\nThe input noOfELements can be used to specify the desired number of elements for calculation, it \napplies:\nùëÅùë¢ùëöùëèùëíùëüùëÇùëìùê∏ùëôùëíùëöùëíùëõùë°ùë† <= (ùê¥ùëüùëüùëéùë¶ùëàùëùùëùùëíùëüùêøùëñùëöùëñùë° ‚àí ùê¥ùëüùëüùëéùë¶ùêøùëúùë§ùëíùëüùëàùëõùëëùëíùëüùêøùëñùëöùëñùë° + 1)\nNote Various online tools are available for calculating the CRC values. The function of the block \nwas tested with the following online tool, since it supports the input parameters mask\n(Polynomial) and initValue (Initial Value):\nhttp://www.sunshine2k.de/coding/javascript/crc/crc_js.html", "type": "FUNCTION", "input": [{"name": "initValue", "type": "Word", "description": "Start value for the calculation"}, {"name": "mask", "type": "Word", "description": "Generator polynomial for the calculation"}, {"name": "finalXorValue", "type": "Word", "description": "Value for final XOR operation"}, {"name": "reflectInput", "type": "Bool", "description": "Mirror the bits within the input byte"}, {"name": "reflectResult", "type": "Bool", "description": "Mirror the order of the bits within the result"}, {"name": "noOfElements", "type": "UInt", "description": "Number of elements to be used in CRC calculation"}], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "array", "type": "Array[*] of Byte", "description": "Data stream for which the CRC value will be calculated"}], "return_value": [{"type": "Word", "description": "Calculated CRC value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8400": "ERR_NO_OF_ELEMENTS"}, "user_defined_types": []}
{"title": "IEC_Timer implementation", "name": "LGF_IecTimerOnOff", "description": "## Short description ##\n\nThe Block implements an IEC_Timer TON and TOF", "type": "FUNCTION_BLOCK", "input": [{"name": "in", "type": "Bool", "description": "FALSE Boolean Input value"}, {"name": "timeOnDelay", "type": "Time", "description": "T#0s Preset Time on Delay"}, {"name": "timeOffDelay", "type": "Time", "description": "T#0s Preset Time off Delay"}], "output": [{"name": "out", "type": "Bool", "description": "Delayed Input signal from input `in`"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": []}
{"title": "Value Tolerance Checker by Time", "name": "LGF_IsValueInToleranceByTime", "description": "## Short description ##\n\nChecks if a given value is within a specified tolerance in percent of a given set point.\nThe block has a configurable timing for set point change hiding, lower limit and as well for upper \nlimit violation hiding.\n\n## Functional description ##\n\nThe setpoint, lowerMinimum and upperMaximum variables define a value range.\nThe function checks whether the value is below, in or above the value range. The outputs \nbelowLowLimit, inLimits, or overHighLimit show where the value is located.\nBy the configuration it is possible to define whether the borders are given as absolute values or \nin percentage from set point.\nThe timing could be adjusted for set point changes and as well for hiding the violating of the \nlower or upper limit in case of peaks.\nFigure: Principle of operation", "type": "FUNCTION_BLOCK", "input": [{"name": "value", "type": "Real", "description": "Value to check if in range of setpoint"}, {"name": "setpoint", "type": "Real", "description": "Setpoint"}, {"name": "lowerMinimum", "type": "Real", "description": "Lower limit/tolerance of the setpoint in percent or absolut"}, {"name": "upperMaximum", "type": "Real", "description": "Upper limit/tolerance of the setpoint in percent or absolut"}, {"name": "reset", "type": "Bool", "description": "Reset Block"}, {"name": "configuration", "type": "LGF_typeIsValueInToleranceByTimeConfiguration", "description": "Module related configuration parameters"}], "output": [{"name": "overHighLimit", "type": "Bool", "description": "TRUE: if value is above high limit"}, {"name": "belowLowLimit", "type": "Bool", "description": "TRUE: if value is below low limit"}, {"name": "inLimits", "type": "Bool", "description": "TRUE: if value is in between the limits"}, {"name": "setpointChange", "type": "Bool", "description": "TRUE: when a setpoint change has been detected"}, {"name": "error", "type": "Bool", "description": "Error occured"}, {"name": "status", "type": "Word", "description": "Status of the function"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8401": "ERR_RANGE_LIMIT_VALUE_CALC", "16#8402": "ERR_SETPOINT_ABOVE_HIGH_LIMIT", "16#8403": "ERR_SETPOINT_BELOW_LOW_LIMIT"}, "user_defined_types": [{"name": "LGF_typeIsValueInToleranceByTimeConfiguration", "description": "Module related configuration parameters", "member": [{"name": "disableLimits", "type": "Bool", "default": "FALSE", "description": "TRUE: Disable the monitoring timer. Leaving the tolerance triggers immediately"}, {"name": "limitsAsAbsoluteValues", "type": "Bool", "default": "FALSE", "description": "TRUE: Limit given as absolut value / FALSE: Limits given as tolerance from setpoint"}, {"name": "toleranceAsAbsoluteValues", "type": "Bool", "default": "FALSE", "description": "TRUE: Toleranze given as absolut value / FALSE: Toleranze in percent from Setpoint"}, {"name": "upperLimitMonitoringTime", "type": "Time", "default": "T#10S", "description": "Monitoring time for the upper limit violation"}, {"name": "lowerLimitMonitoringTime", "type": "Time", "default": "T#10S", "description": "Monitoring time for the lower limit violation"}, {"name": "setpointChangeMonitoringTime", "type": "Time", "default": "T#20S", "description": "Monitoring time for setpoint changes"}]}]}
{"title": "LIFO Buffer Management", "name": "LGF_LIFO", "description": "## Short description ##\n\nLIFO (Last-In First-Out / Stack buffer memory)\nThis function stores incoming data and outputs the latest/most recent not-yet-processed data.\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nNote I computer science the stack is also based on the LIFO principle.\nWith the push input, a new item is stored from the InOut parameter item in the next free position \nin the buffer. The output elementCount is incremented by one.\nWith the pop input, the latest / most recent item is output to the InOut parameter item, and this \nfield in the buffer is replaced by the value at the parameter initialItem. The output \nelementCount is decremented by one.\nThe peek input allows the last entry in the buffer to be read out. The buffer is not changed.\nWith the reset input, the buffer is initialized and the index and counter are reset. The \nelementCount output is set to zero and the isEmpty output is set to TRUE.\nWith the clear input, the buffer is emptied and initialized with the initial value initialItem. Index \nand counter are reset. The elementCount output is set to zero and the isEmpty output is set to \nTRUE.", "type": "FUNCTION_BLOCK", "input": [{"name": "push", "type": "Bool", "description": "Push item to the buffer"}, {"name": "pop", "type": "Bool", "description": "Pop item from the buffer"}, {"name": "peek", "type": "Bool", "description": "Peek item from the buffer (buffer not changed/modified)"}, {"name": "reset", "type": "Bool", "description": "Initializing the buffer (reset the index and the counter)"}, {"name": "clear", "type": "Bool", "description": "Clearing the buffer and initialize with the initial value initialItem (Reset index and counter)."}, {"name": "initialItem", "type": "Variant", "description": "Value with which the ARRAY of the buffer is initialized (usually: 0 / default value)"}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "elementCount", "type": "DInt", "description": "Number of elements in the buffer"}, {"name": "isEmpty", "type": "Bool", "description": "Buffer is empty"}], "in/out": [{"name": "item", "type": "Variant", "description": "The entry that is either returned from the ring buffer or written into the buffer"}, {"name": "buffer", "type": "Variant", "description": "The ARRAY that is used as the ring buffer."}], "return_value": [], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#7000": "STATUS_NO_CURRENT_JOBS", "16#8001": "ERR_BUFFER_EMPTY", "16#8002": "ERR_BUFFER_FULL", "16#8200": "ERR_NO_ARRAY", "16#8201": "ERR_WRONG_TYPE_ITEM", "16#8202": "ERR_WRONG_TYPE_INITIAL_ITEM", "16#8610": "ERR_CLEAR_BUFFER", "16#8611": "ERR_RETURN_LAST_ENTRY", "16#8612": "ERR_POP_REPLACE_ITEM_BY_INIT_VALUE", "16#8613": "ERR_WRITE_ENTRY"}, "user_defined_types": []}
{"title": "GPS-based Sunrise and Sunset Time Determination", "name": "LGF_AstroClock", "description": "## Short description ##\n\nThis function calculates the times of sunrise and sunset based on the local time for a specific  place on Earth. The exact position is transferred in the form of geographical GPS coordinates (longitude and latitude).\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nIf processes must run automatically depending on the change between day and night, the \nfunction of an astronomical clock is required. Examples of this would be switching outdoor \nlighting on and off or opening and closing roller shutters.\nIf these processes are to be executed with a time delay i.e. a defined time before or after \nsunrise or sunset an offset is required in each case.\nNote For precise execution of the function, it must be ensured that system time and local time of \nthe SIMATIC controller are set correctly.\nBased on the system time/local time of the SIMATIC controller and the set coordinates, the \nblock calculates the times for sunrise and sunset. The offset times are added to the sunrise and \nsunset and output on the sunrise and sunset outputs. If the systems local time of the SIMATIC \ncontroller is between these values, the output isDaytime is set to the value TRUE.\nNote Since the times for sunrise and sunset change daily, it is possible that the isDaytime output \nremains permanently on TRUE or FALSE over a longer period of time:\n‚Ä¢ with correspondingly large offset values\n‚Ä¢ for a place on the other side of the Arctic Circle\nThe input of the GPS coordinate values is checked for valid values. If there are invalid values, \nan appropriate error code is output to status.\nIf there is an invalid coordinate value for a formal parameter, the outputs sunrise and sunset\nare set to the value DTL#1970-01-01-00:00:00.", "type": "FUNCTION_BLOCK", "input": [{"name": "enable", "type": "Bool", "description": "TRUE: Activates the functionality of the FB"}, {"name": "positionGps", "type": "LGF_typeGPS_DD", "description": "GPS position to calculate the time of sunrise and sunset"}, {"name": "offsetSunrise", "type": "Time", "description": "Offset to sunrise (added to sunrise time, considered at `isDaytime`, negative time allowed)"}, {"name": "positionGps", "type": "Time", "description": "Offset to sunset (added to sunset time, considered at `isDaytime`, negative time allowed)"}], "output": [{"name": "valid", "type": "Bool", "description": "TRUE: Valid set of output values available at the FB"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is active and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "FALSE: No error / TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB / 16#8000-16#FFFF: Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "actualLocalTime", "type": "DTL", "description": "Current time (local time)"}, {"name": "sunriseTime", "type": "DTL", "description": "Sunrise time (localtime)"}, {"name": "sunsetTime", "type": "DTL", "description": "Sunset time (localtime)"}, {"name": "isDaytime", "type": "Bool", "description": "TRUE: If the local time of the controller is between ‚Äúsunrise‚Äù and ‚Äúsunset‚Äù"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED_NO_ERROR", "16#7000": "STATUS_NO_CALL", "16#7001": "STATUS_IN_OPERATION", "16#8204": "ERR_LATITUDE_VALUE", "16#8205": "ERR_LONGITUDE_VALUE", "16#8601": "ERR_RD_SYS_T", "16#8602": "ERR_RD_LOC_T"}, "user_defined_types": [{"name": "LGF_typeGPS_DD", "description": "Datatype for GPS Coordinates in decimal degrees. For a whole GPS Data set.", "member": [{"name": "latitude", "type": "Real", "default": "0.0", "description": "Degrees latitude with decimal places (Unit: degree decimal), North = positive; South = negative) valid value range [-90.00000..90.00000] "}, {"name": "longitude", "type": "Real", "default": "0.0", "description": "Degrees longitude with decimal places (Unit: degree decimal), East = positive; West = negative) valid value range [-180.00000..180.00000] "}]}]}
{"title": "Ramp Function Generator", "name": "LGF_RampCI", "description": "## Short description ##\n\nThe function generates a speed curve based on an interpolation point table. Linear interpolation \noccurs between the points within the prescribed time.\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nGlobal data\nTogether with the block, you automatically receive the PLC data type LGF_typeRampTimeTable, \nwhich is composed of the parameters outVal for the value of a base point and time for the time, \nuntil the next base point is reached. The declaration takes place in a one-dimensional array of \nthe data type LGF_typeRampTimeTable beginning with the index 0. The array is created in a global \ndata block and then passed to the module LGF_RampCI.\nPrinciple of operation\nWith this block, speed curves can be executed based on parameterized interpolation points; in \neach call cycle values are output according to a schedule, and interpolation takes place \nbetween the interpolation points.\nIn each cycle the currently approached interpolation point number stepNumber, the actual \nremaining time remainTime until reaching the interpolation point, the total time totalTime, and \nthe total remaining time until reaching the end of the speed curve remainTotalTime, are output. \nIn addition, the output actTimeTable is set if the projected speed curve is currently being output.\nThe time interval of the calling cyclic interrupt OB is determined by interconnecting the calling \ncyclic interrupt OB at the input parameter callOB.\nFigure: Interconnecting the cyclic interrupt OB\nThe following operating modes can be selected via control inputs:\n‚Ä¢ Restart\n‚Ä¢ Pre-assigning an output\n‚Ä¢ Output a speed curve\n‚Ä¢ Stop processing\n‚Ä¢ Specify processing step and processing time\n‚Ä¢ Switch-on cyclic operation+F1\n‚Ä¢ Update total time and remaining time\nRestart\nThe output outValue is reset to 0.0 with a rising edge at the input reset. With \nenDefaultOutValue = TRUE, defaultOutValue is output at outputValue. The total time and total \nremaining time are updated and output.\nPre-assigning an output\nIf the speed curve should begin with a certain output value, then enDefaultOutValue must be \nTRUE. In this case the value defaultOutValue is present on the output of the timer. The internal \nprocessing of the speed curve continues during this time. If enDefaultOutValue changes to \nFALSE again, interpolation is performed to the currently active calibration point.\nOutput a speed curve\nWith a rising edge at the input start, the speed curve is output - as long as start is TRUE or until \nthe speed curve is terminated by reaching the last interpolation point. Through a subsequent \nrising edge, the speed curve is output again. In addition, the total time is updated at each \nswitch-on.\nSwitch-on cyclic operation\nIf, in addition to the input start, the input cyclicOP is also set to TRUE, the speed curve \nautomatically returns to the start point after outputting the last interpolation point value and \nstarts a new cycle.\nThere is no interpolation between the last interpolation point value and the starting point. The \nfollowing must apply for a smooth transition: last interpolation point value = start point.\nStop speed curve\nWith hold = TRUE the value of the output variable (including time processing) is frozen. When \nresetting hold = FALSE, the program continues at the point of interruption or at a parameterized \npoint (see ‚ÄúDefining the processing step and processing time‚Äù). The processing time of the \nspeed curve is extended by the holding time T1*. (see Figure below).\nSpecify processing step and processing time\nIf the input parameter continue is set to TRUE for continuation while the speed curve is stopped \n(hold = TRUE), then after the input hold has been reset the interpolation point number \ncontStepNbr (target interpolation point) will be approached within the time contStepTime\n(interpolation). The total remaining time will be recalculated.\nUpdating total time and total remaining time\nIf values of the interpolation points are changed, the total time and the total remaining time of \nthe speed curve can change. Since calculation of totalTime and remainTotalTime can \nsignificantly increase the processing time of the function block at many interpolation points, the \ncalculation is only executed once with a rising edge on the updateTime input.", "type": "FUNCTION_BLOCK", "input": [{"name": "defaultOutValue", "type": "LReal", "description": "Value for pre-assignment of the output variable"}, {"name": "contStepNbr", "type": "Int", "description": "Number of the next interpolation point for continuing"}, {"name": "contStepTime", "type": "Time", "description": "Remaining time to continue to the interpolation point"}, {"name": "enDefaultOutValue", "type": "Bool", "description": "Assign default output value"}, {"name": "start", "type": "Bool", "description": "Run down the interpolation point table"}, {"name": "hold", "type": "Bool", "description": "Freeze/hold output at actual value"}, {"name": "continue", "type": "Bool", "description": "Continuing"}, {"name": "cyclicOP", "type": "Bool", "description": "Repeat interpolation point table cyclically"}, {"name": "updateTime", "type": "Bool", "description": "Update time values"}, {"name": "reset", "type": "Bool", "description": "Complete reset of function"}, {"name": "callOB", "type": "OB_CYCLIC", "description": "Calling wake-alarm interrupt OB"}], "output": [{"name": "outputValue", "type": "LReal", "description": "Output value"}, {"name": "actTimeTable", "type": "Bool", "description": "Interpolation point table will be edited"}, {"name": "stepNumber", "type": "Int", "description": "Current interpolation point number"}, {"name": "remainTime", "type": "Time", "description": "Remaining time until reaching the next interpolation point"}, {"name": "totalTime", "type": "Time", "description": "Total time for setpoint table"}, {"name": "remainTotalTime", "type": "Time", "description": "Total remaining time"}, {"name": "error", "type": "Bool", "description": "Error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [{"name": "setpoints", "type": "Array[*] of LGF_typeRampTimeTable", "description": "Interpolation point table."}], "return_value": [], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#7000": "STATUS_NO_CALL", "16#7001": "STATUS_FIRST_CALL", "16#7002": "STATUS_FURTHER_CALLS", "16#8200": "ERR_OB_UNAVAILABLE", "16#8201": "ERR_ARRAY_LOWER_BOUND", "16#8400": "ERR_QRY_CINT"}, "user_defined_types": [{"name": "LGF_typeRampTimeTable", "description": "Data type for setup a speed curve", "member": [{"name": "outputValue", "type": "LReal", "default": "0.0", "description": "Setpoint Value to reach by the interpolation curve"}, {"name": "time", "type": "Time", "default": "T#0s", "description": "Time until the interpolation point is reached"}]}]}
{"title": "DWORD rising edge counting", "name": "LGF_CountRisInDWord", "description": "## Short description ##\n\nThe function analyzes a variable of the type DWORD and outputs how often a 0-1 sequence \n(rising edge) occurs in the variable.\nNote LEGACY FUNCTION\nPlease update and use the FB with the same name LGF_CountRisInDWord in the future!\nThis function is no longer maintained!\n\n## Functional description ##\n\nIn a variable of the data type DWORD, the block counts the rising edges (0-1 transitions) from \nleft to right. The output countRisInDWord outputs the number of rising edges.\nSo that rising edges at the variable limit are also detected, the input value is copied to the static \nvariable statDWordPrevCycle at the end of the evaluation and evaluated in the next cycle.", "type": "FUNCTION_BLOCK", "input": [{"name": "value", "type": "DWord", "description": "Input Double word in which the rising edges are counted"}], "output": [{"name": "numberOfEdges", "type": "Int", "description": "Number of rising edges in the DWord"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": []}
{"title": "Value range limit check", "name": "LGF_IsValueInLimits", "description": "## Short description ##\n\nThe function checks whether a value is within a defined value range. The value range is defined \nwith a lower and an upper limit.\n\n## Functional description ##\n\nThe variables lowLimit and highLimit define a value range.\nThe function checks whether the value is below, in or above the value range. The outputs \nbelowLowLimit, Ret_Val, or overHighLimit show where the value is located.", "type": "FUNCTION", "input": [{"name": "value", "type": "LReal", "description": "Value to be checked to determine whether it is within the defined value range"}, {"name": "lowLimit", "type": "LReal", "description": "Low limit where the value is checked against to be greater"}, {"name": "highLimit", "type": "LReal", "description": "High limit where the value is checked against to to be less"}], "output": [{"name": "overHighLimit", "type": "Bool", "description": "TRUE if the ‚Äúvalue‚Äù is greater than the upper limit value"}, {"name": "belowLowLimit", "type": "Bool", "description": "TRUE, if the ‚Äúvalue‚Äù is less than the lower limit value"}, {"name": "error", "type": "Bool", "description": "FALSE: No error TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB 16#8000-16#FFFF: Error identification"}], "in/out": [], "return_value": [{"type": "Bool", "description": "Return: TRUE if the ‚Äúvalue‚Äù is in the value range (range of the set point)"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8401": "ERR_RANGE_HIGH_BELOW_LOW_LIMIT"}, "user_defined_types": []}
{"title": "Unsigned Integer Histogram Calculation Function Block", "name": "LGF_Histogram_UDInt", "description": "## Short description ##\n\nThe histogram shows the frequency distribution of a sample by class. A class describes a value \ninterval in which the individual frequencies are added together. After specifying the number of \nclasses, the class width and the respective class center are calculated. The number of classes \nis limited to 15.\nThe distribution is represented as a rectangle around the class mean with the class width and \nthe cumulated frequency as height.\nFigure: Distribution\n\n## Functional description ##\n\nThe block sorts the transferred data and calculates the general class width using the transferred \nclass count and data range. The block then counts the values that lie within a class. In order to \ndraw a histogram, the block also calculates the necessary X and Y coordinates.\nThe elements of the passed array values are sorted in ascending order by the block. The \nLGF_Shellsort_UDInt block is used for sorting.\nThe number of classes can be specified using the following rule of thumb:\n\nFormulas\nThe block uses the following formula to calculate the class width:", "type": "FUNCTION_BLOCK", "input": [{"name": "execute", "type": "Bool", "description": "Activation of the calculation with each positive edge."}, {"name": "numberOfClasses", "type": "UInt", "description": "Number of desired classes."}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error, TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB and error identification."}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "histValues", "type": "Array[0..1, 0..#CLASSES_COUNTER_UP_LIMIT] of LReal", "description": "Displays the relative frequency and class centers."}, {"name": "axis", "type": "Array[0..3] of LReal", "description": "Specifies the axis values."}, {"name": "classWidth", "type": "LReal", "description": "Returns the calculated class width."}], "in/out": [{"name": "values", "type": "Array[*] of UDInt", "description": "The array containing the data series for calculation."}], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED: Execution finished without errors", "16#7000": "STATUS_NO_CALL: No call of FB. The block waits for activation.", "16#7001": "STATUS_FIRST_CALL: First call of FB after enabling", "16#8600": "ERR_SHELL_SORT: Error in command `LGF_ShellSort_UDInt`.", "16#9101": "ERR_WRONG_NO_CLASSES: Incorrect number of classes."}, "user_defined_types": []}
{"title": "Double word edge detection", "name": "LGF_GetBitStates", "description": "## Short description ##\n\nThis function checks a DWord for falling as well as rising edges.\nIt returns the number of edges, a DWord with the edge bits, and a boolean value if edge(s) are \npresent.", "type": "FUNCTION_BLOCK", "input": [{"name": "value", "type": "DWord", "description": "Check input value for changes and edges"}], "output": [{"name": "hasChanged", "type": "Bool", "description": "Input value has changed (compared to the previous cycle)"}, {"name": "hasRisingEdges", "type": "Bool", "description": "Input value has rising edges"}, {"name": "risingBits", "type": "DWord", "description": "Bitstream with the rising edges"}, {"name": "noOfRisingBits", "type": "USInt", "description": "Number of rising edges in the input value"}, {"name": "hasFallingEdges", "type": "Bool", "description": "Input value has falling edges"}, {"name": "fallingBits", "type": "DWord", "description": "Bitstream with the falling edges"}, {"name": "noOfFallingBits", "type": "USInt", "description": "Number of falling edges in the input value"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": []}
{"title": "FIFO Buffer Management", "name": "LGF_FIFO", "description": "## Short description ##\n\nFIFO (First-In First-Out / Queue / ring buffer memory)\nThis function stores incoming data and outputs the oldest unprocessed data.\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nNote In computer science, the queue is also based on the FIFO principle.\nWith the enqueue input, a new item is stored from the InOut parameter item in the next free \nposition in the buffer. The output elementCount is incremented by one.\nWith the dequeue input, the next element to be processed is output to the InOut parameter item, \nand this field in the buffer is replaced by the value in the parameter initialItem. The output \nelementCount decremented by one.\nWith the reset input, the buffer is initialized and the index and counter are reset. The \nelementCount output is set to zero and the isEmpty output is set to TRUE.\nWith the clear input, the buffer is emptied and initialized with the initial value initialItem. Index \nand counter are reset. The elementCount output is set to zero and the isEmpty output is set to \nTRUE.", "type": "FUNCTION_BLOCK", "input": [{"name": "enqueue", "type": "Bool", "description": "Enqueue item to the buffer"}, {"name": "dequeue", "type": "Bool", "description": "Dequeue item from the buffer and return it on `item`"}, {"name": "reset", "type": "Bool", "description": "Initializing the buffer (reset the index and the counter)"}, {"name": "clear", "type": "Bool", "description": "Clearing the buffer and initialize with the initial value `initialItem` (Reset index and counter)."}, {"name": "initialItem", "type": "Variant", "description": "Value with which the ARRAY of the buffer is initialized (usually: `0` / default value)"}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "elementCount", "type": "DInt", "description": "Number of elements in the buffer"}, {"name": "isEmpty", "type": "Bool", "description": "Buffer is empty"}], "in/out": [{"name": "item", "type": "Variant", "description": "The entry that is either returned from the ring buffer or written into the buffer"}, {"name": "buffer", "type": "Variant", "description": "The ARRAY that is used as the ring buffer."}], "return_value": [], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#7000": "STATUS_NO_CURRENT_JOBS", "16#8001": "ERR_BUFFER_EMPTY", "16#8002": "ERR_BUFFER_FULL", "16#8200": "ERR_NO_ARRAY", "16#8201": "ERR_WRONG_TYPE_ITEM", "16#8202": "ERR_WRONG_TYPE_INITIAL_ITEM", "16#8601": "ERR_INDEX_IN_ARRAY_LIMITS_1", "16#8602": "ERR_INDEX_IN_ARRAY_LIMITS_2", "16#8610": "ERR_CLEAR_BUFFER", "16#8611": "ERR_RETURN_FIRST_ENTRY", "16#8612": "ERR_REPLACE_ITEM_BY_INIT_VALUE", "16#8613": "ERR_WRITE_ENTRY"}, "user_defined_types": []}
{"title": "File Writing to UserFiles Folder", "name": "LGF_FileWrite", "description": "## Short description ##\n\nThis function block offers writing data as binary / serialized data stream to a file which is then \nstored on the PLC's memory card in the folder UserFiles.\n\n## Functional description ##\n\nWith the function LGF_FileWrite the data budget of a variable can be written to data in a file. For \nwriting the data it is necessary to serialize it, which the function already takes from the user.\nFor serialization an external buffer in the form of a byte array must be connected which can take \nup the data quantity, if the buffer is too small an error is output.\nThe file name must always be specified in full together with the folder name and the file \nextension in the following format: UserFiles/test.dat.\nNote The file extension (here e.g. dat) can be freely selected or omitted, it is useful for external \nprocessing to indicate the format of the file to the user.\nA file extension in the file name has no influence on the content of the file as well as its \nformatting, to provide the data in an appropriate file format is up to the user.", "type": "FUNCTION_BLOCK", "input": [{"name": "execute", "type": "Bool", "description": "Rising edge starts file write once"}, {"name": "fileName", "type": "String", "description": "Name of file including path: UserFiles/test.dat"}], "output": [{"name": "done", "type": "Bool", "description": "Commanded functionality has been completed successfully"}, {"name": "busy", "type": "Bool", "description": "FB is not finished and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}, {"name": "dataLength", "type": "DInt", "description": "Data length written to file (serialized length of data)"}], "in/out": [{"name": "bufferByteArray", "type": "Array[*] of Byte", "description": "Byte array buffer for read / write from / to file"}, {"name": "data", "type": "Variant", "description": "Data set to write into file"}], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED", "16#7000": "STATUS_NO_CALL", "16#7001": "STATUS_FIRST_CALL", "16#7002": "STATUS_SUBSEQUENT_CALL", "16#8201": "ERR_BUFFER_LOWERBOUND", "16#8202": "ERR_BUFFER_ARRAY_TO_SMALL_TO_COPY", "16#8401": "ERR_FILE_PATH", "16#8600": "ERR_UNDEFINED_STATE", "16#8601": "ERR_MOVE_BLK_VARIANT", "16#8603": "ERR_DATA_SERIALIZE", "16#8604": "ERR_FILE_WRITE_INIT", "16#8605": "ERR_FILE_WRITE"}, "user_defined_types": [{"name": "LGF_typeDiagnostics", "description": "Diagnostic structure to store and transfer diagnostic information from blocks trough the interface.", "member": [{"name": "status", "type": "Word", "default": "16#0000", "description": "Status of the Block or error identification when error occurred"}, {"name": "subfunctionStatus", "type": "Word", "default": "16#0000", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "stateNumber", "type": "DInt", "default": "0", "description": "State in the state machine of the block where the error occurred"}]}]}
{"title": "Shift Register for Datatype Variant", "name": "LGF_ShiftRegister", "description": "## Short description ##\n\nThe Function represents a shift register for any kind of Datatype (using variant).\nIt is possible to shift the elements in the array at bufferRegister to the left (index \narray[n]:=array[n+1]) or right (index array[n]:=array[n-1]).\nIt could be used for material tracking trough a machine or a process, e.g. for a rotary indexing \ntable.\nNote As this is a real shift operation, it may cause some runtime effects while using big array sizes \nto move at the input bufferRegister.\nPlease consider that a FIFO or LIFO storage, based on indexes, could be used as well for \nmost applications.", "type": "FUNCTION_BLOCK", "input": [{"name": "shiftLeft", "type": "Bool", "description": "Rising edge: Elements in the array bufferRegister shifted left."}, {"name": "shiftRight", "type": "Bool", "description": "Rising edge: Elements in the array bufferRegister shifted right."}, {"name": "shiftRange", "type": "UInt", "description": "Number of places to be shifted in the bufferRegister input array"}, {"name": "clear", "type": "Bool", "description": "Clear buffer elements in bufferRegister with initalItem"}, {"name": "fill", "type": "Bool", "description": "Overwrite buffer elements after shift operation."}, {"name": "initialItem", "type": "Variant", "description": "Value with which the array at input bufferRegister is initialized."}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [{"name": "bufferRegister", "type": "Variant", "description": "Buffer / Register memory as ARRAY, which keeps the data."}], "return_value": [], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#7000": "STATUS_NO_CURRENT_JOBS", "16#8200": "ERR_NO_ARRAY", "16#8201": "ERR_CLEARING_WITHOUT_INITIAL_ITEM", "16#8202": "ERR_FILL_WITHOUT_INITIAL_ITEM", "16#8203": "ERR_WRONG_TYPE_INITIAL_ITEM", "16#8401": "ERR_MORE_THAN_ONE_COMMAND", "16#8402": "ERR_IN_SHIFT_RANGE", "16#8610": "ERR_CLEAR_BUFFER", "16#8611": "ERR_SHIFT_BUFFER_LEFT", "16#8612": "ERR_SHIFT_BUFFER_LEFT_FILL", "16#8622": "ERR_SHIFT_BUFFER_RIGHT_FILL"}, "user_defined_types": []}
{"title": "Simple Smoothing Function", "name": "LGF_SimpleSmoothingFC", "description": "## Short description ##\n\nThe function calculates the linear mean value acyclically.\nThe simplest form of smoothing a sequence of measured values is to calculate the linear mean \nvalue by three points.\nThe function reads an array that is smoothed. ùëÅ ‚àí 2 smoothed measured values can be \ncalculated from N measured values. Therefore, the output array in the index (0) and index (N) \ncontains the value 0.\n\n## Functional description ##\n\nThe function calculates the smoothed values using the following formula:\n\nThe calculated value is output or the calculated values are output at output smoothedValue.\nBased on this formula, the function cannot calculate values for the elements 0 and N.", "type": "FUNCTION", "input": [], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB"}], "in/out": [{"name": "values", "type": "Array[*] of LReal", "description": "Values that are to be included in the smoothing."}, {"name": "smoothedValues", "type": "Array[*] of LReal", "description": "The smoothed values."}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8400": "ERR_NOT_ENOUGH_VALUES Error: Not enough values.", "16#8401": "ERR_ARRAY_DIFFERENT Error: The Arraysizes are not equal."}, "user_defined_types": []}
{"title": "DWORD falling edge counting", "name": "LGF_CountFalInDWord", "description": "## Short description ##\n\nThe function analyzes a variable of the type DWORD and outputs how often a 1-0 sequence \n(falling edge) occurs in the variable.\nNote LEGACY FUNCTION\nPlease update and use the FB with the same name LGF_CountFalInDWord in the future!\nThis function is no longer maintained!\n\n## Functional description ##\n\nIn a variable of the data type DWORD, the block counts the falling edges (1-0 transitions) from \nleft to right. The output countFalInDWord outputs the number of falling edges.\nSo that falling edges at the variable limit are also detected, the input value is copied to the static \nvariable statDWordPrevCycle at the end of the evaluation and evaluated in the next cycle.", "type": "FUNCTION_BLOCK", "input": [{"name": "value", "type": "DWord", "description": "Input Double word in which the falling edges are counted"}], "output": [{"name": "numberOfEdges", "type": "Int", "description": "Number of falling edges in the DWord"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": []}
{"title": "Profinet Interface Parameter Reader", "name": "LGF_ReadPnInterfaceParameter", "description": "## Short description ##\n\nThe function block provides Interface parameter like the IP Address settings, MAC Address and \nthe PN Name.\n\n## Functional description ##\n\nThe function reads the Interface settings / parameters using the system function RDREC (Read \ndata record).\nTo read the MAC and IP address of the interface provided via it's hardware ID, it is mandatory \nto read the PD_INTERFACE_DATA_REAL data record of any PROFINET compliant interface.\nNote Upon TIA Portal V17, it‚Äôs possible to use as well the system function CommConfig, which is in \nthe Instructions / Communication / Open user communication (Version >= V8.1) located.", "type": "FUNCTION_BLOCK", "input": [{"name": "execute", "type": "Bool", "description": "Rising edge starts action once"}, {"name": "hardwareId", "type": "HW_ANY", "description": "Hardware ID of the Interface where the parameter should be read"}], "output": [{"name": "done", "type": "Bool", "description": "Commanded functionality has been completed successfully"}, {"name": "busy", "type": "Bool", "description": "FB is not finished, new output values can be expected"}, {"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "DWord", "description": "Status of the FB and error identification"}, {"name": "address", "type": "IP_V4", "description": "IP Address from interface"}, {"name": "subnetMask", "type": "IP_V4", "description": "Subnet mask from interface"}, {"name": "standardGateway", "type": "IP_V4", "description": "Standard gateway address from interface"}, {"name": "macAddress", "type": "Array[0..5] of Byte", "description": "MAC Address from interface"}, {"name": "pnName", "type": "String", "description": "Profinet name from interface"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED: Execution finished without errors", "16#7000": "STATUS_NO_CALL: No job being currently processed", "16#7001": "STATUS_FIRST_CALL: First call after incoming new job", "16#7002": "STATUS_SUBSEQUENT_CALL: Subsequent call during active processing", "16#9000": "ERR_UNDEFINED_STATE: Due to an undefined state in state machine"}, "user_defined_types": []}
{"title": "Structured data comparison", "name": "LGF_CompareVariant", "description": "## Short description ##\n\nThe function compares two structured actual parameters (array, PLC data type) and outputs \nwhether they are of the same type and have the same values.\nCompare arrays or plc datatypes and their values up to a max lengh of 200 Bytes of the \nconnected variables. If at least one value of an element is not identical ‚Äì> set function result = \nfalse\nRestrictions:\nThe attached structure must not include Strings\nThe attached structure can not exceed 200 bytes, because of the internal buffer size\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nThis block compares two (structured) actual parameters and shows whether they equate to the \nsame value.\nNote The following differences cannot be detected with the comparison method (byte level):\n‚Ä¢ Variables of the data type Struct cannot be compared.\n‚Ä¢ For strings, there may be differences in the range between the actual length and the maximum \nlength.\n‚Ä¢ With REAL numbers in the structure, a disparity can also be displayed for ‚Äúsame‚Äù variables.\n‚Ä¢ Variables of the type ARRAY of BOOL cannot be checked for equality with the function, because \nthe command used, CountOfElements, also counts the filling elements (e.g. 8 is returned with an \nARRAY[0..1] of BOOL).", "type": "FUNCTION", "input": [], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error / TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB / 16#8000-16#FFFF: Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [{"name": "variableA", "type": "Variant", "description": "First comparison variable with any data type"}, {"name": "variableB", "type": "Variant", "description": "Second comparison variable with any data type"}], "return_value": [{"type": "Bool", "description": "FALSE: Values of comparison variables or PLC data types are different. TRUE: Values of the comparison variables are equal and PLC data types are identical."}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8201": "ERR_INPUT_TYPES_MUST_MATCH", "16#8202": "ERR_INPUT_TYPES_LENGTH_NOT_EQUAL", "16#8601": "ERR_SERIALIZE_VARIABLE_A", "16#8602": "ERR_SERIALIZE_VARIABLE_B"}, "user_defined_types": []}
{"title": "Function Curve Area Calculator", "name": "LGF_Integration", "description": "## Short description ##\n\nThe function approximately calculates the area under a function curve. The function curve is \ntransferred as an analog value (LReal) which varies over time. The integral value is output on \nintegral.\nThe implementation is based on the trapezoidal rule and uses [ms] as time base.\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nThe integral calculation includes the summation of those trapezoidal areas that span between \nthe last two function values on the ‚Äúvalue‚Äù input and the time. The elapsed time is calculated via \nthe system time of the CPU. This trapezoidal area is identical to the product of the mean value \nof the two process values and the time interval.\nNote The calculation takes [ms] as time base. So the analoge value hase to use the same time \nbase, e.g. [volume flow/ms].\nùê¥ = 1/2 * (ùêπùë°1 + ùêπùë°0) * (ùë°1 ‚àí ùë°0) + 1/2 * (ùêπùë°2 + ùêπùë°1) *(ùë°2‚àí ùë°1) + ...\nStart the integral calculation for the inputvalue at the parameter value:\n‚Ä¢ Set the parameter enable to the value TRUE\n‚Ä¢ Set the parameter reset to the value FALSE\nIf the parameter enable is set to the value FALSE, the integral calculation is stopped and the \noutput integral outputs the last calculated value.\nIf the parameter reset is set to the value TRUE, the output integral is reset to 0.0", "type": "FUNCTION_BLOCK", "input": [{"name": "enable", "type": "Bool", "description": "Enables integral calculation"}, {"name": "value", "type": "LReal", "description": "Analog value of the continuous function curve, based on [ms]"}, {"name": "reset", "type": "Bool", "description": "Sets the output 'integral' to '0.0'"}], "output": [{"name": "integral", "type": "LReal", "description": "Integral value"}, {"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called blocks"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED_NO_ERROR", "16#8600": "ERR_READ_SYS_TIME"}, "user_defined_types": []}
{"title": "Pulse relay and toggle flip-flop operation", "name": "LGF_PulseRelay", "description": "## Short description ##\n\nThis block corresponds to an impulse relay or a toggle flip-flop including set and reset input.   Pulse relay, Surge relay, Toggle-Flip-Flop, Frequency divider reset is leading / prior to set or trigger\n\n## Functional description ##\n\nFigure: LGF_PulseRelay Signal diagram\n1.   Each rising edge of the input trigger changes the Boolean value of the output out.    \n2.   Each rising edge of the input set sets the Bboolean value of the output out to TRUE.    \n3.   Each rising edge of the input reset sets the Boolean value of the output out to FALSE. \n4.   If the inputs set and reset are set in the same cycle, the reset input has priority.\nThe block can also be used as a frequency divider. If the input trigger is supplied with a fixed frequency, the output out delivers half the frequency.", "type": "FUNCTION_BLOCK", "input": [{"name": "trigger", "type": "Bool", "description": "FALSE Trigger to toggle output signal (rising edge)"}, {"name": "set", "type": "Bool", "description": "FALSE Set output signal. rising edge"}, {"name": "reset", "type": "Bool", "description": "FALSE Reset signal, rising edge (prior to set)"}], "output": [{"name": "out", "type": "Bool", "description": "Ooutput signal"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": []}
{"title": "Value tolerance range check", "name": "LGF_IsValueInTolerance", "description": "## Short description ##\n\nThe function checks whether a value is within a defined value range.\nThe value range is defined with a set point, as well as a tolerance range, around the set point in \npercent (%). The function calculates the low limit and high limit of the value range.\n\n## Functional description ##\n\nThe setpoint and tolerance percentage variables define a value range.\nThe function checks whether the value is below, in or above the value range. The outputs \nbelowLowLimit, Ret_Val, or overHighLimit show where the value is located.", "type": "FUNCTION", "input": [{"name": "value", "type": "LReal", "description": "Value to be checked"}, {"name": "setpoint", "type": "LReal", "description": "Set point"}, {"name": "tolerance", "type": "LReal", "description": "Tolerance range around the set point in percent"}], "output": [{"name": "overHighLimit", "type": "Bool", "description": "TRUE if the value exceeds the upper limit"}, {"name": "belowLowLimit", "type": "Bool", "description": "TRUE if the value is below the lower limit"}, {"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [], "return_value": [{"type": "Bool", "description": "TRUE if the value is in the value range"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8401": "ERR_RANGE_LIMIT_VALUES"}, "user_defined_types": []}
{"title": "Shell Sort for DInt Arrays", "name": "LGF_ShellSort_DInt", "description": "## Short description ##\n\nThis block sorts an array of type DInt with any number of elements (max. 1000) in ascending or \ndescending order and returns the sorted version of the array in the same variable.\n\n## Functional description ##\n\nThe block sorts according to the shell sort procedure. Note that the execution time of the block \ndepends significantly on how many elements the array to be sorted has. The overview below \nshows several measured values of the block depending on the number of array elements.\nAverage steps needed for execution: ùí™(ùëõ ‚ãÖ log(ùëõ)^2)\nTable: Execution times of the block LGF_ShellSort‚Ä¶\nNumber of array elements S7-1212C DC/DC/DC S7-1516-3 PN/DP\n100 approx. 11-16 ms approx. 1-2 ms\nNumber of array elements S7-1212C DC/DC/DC S7-1516-3 PN/DP\n1000 approx. 185-205 ms approx. 10-12 ms\nNote The block is executed synchronously and is not split over several PLC cycles. Thus the \nexecution time has a direct effect on the PLC cycle time. Note this behavior for your project \nof the controller used and adjust the monitoring time of the controller if necessary.", "type": "FUNCTION", "input": [{"name": "sortDirection", "type": "Bool", "description": "FALSE: Sort ascending; TRUE: Sort descending"}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}], "in/out": [{"name": "array", "type": "Array[*] of DInt", "description": "Array to be sorted"}], "return_value": [], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_NO_ARRAY", "16#8201": "ERR_TOO_MANY_ELEMENTS"}, "user_defined_types": []}
{"title": "Numeric Differentiation Function", "name": "LGF_DifferenceQuotientFC", "description": "## Short description ##\n\nThis function numerically differentiates a signal sampled equidistantly in time. For example, the \nvelocity can be calculated from a measured locus curve, or the acceleration can be calculated \nfrom the measured velocity. In order to minimize the effects of a scattering measurement signal, \nthis algorithm uses a compensating polynomial.\nThe function calculates the differentiated values acyclically.\nThe function reads an array that is differentiated. ùëÅ ‚àí 4 smoothed measured values can be \ncalculated from N measured values. The output array contains the value 0 in the index (0,1,N-\n1,N). However, replacement values can be calculated.\n\n## Functional description ##\n\nTo calculate the difference quotient of a scattering signal, a third-degree compensation \npolynomial is first placed through the measured values. This polynomial is then differentiated. \nWith this method, even a distorted input signal can be sensibly differentiated.\nThe difference quotient is calculated with the following formula:\ny'(n)= $ \\frac {y(n-2)-8y(n-1)+8y(n+1)-y(n+2)}{12 \\cdot deltaT} $ \nùëëùëíùëôùë°ùëéùëá: equidistant distance between two measured values (e.g. 1s).\nThe function (FC) can calculate ùëÅ ‚àí 4 differentiated and smoothed measured values from N \nmeasured values. The output array would be assigned with 0 in the index (0,1,N-1,N). However, \nthe following formalisms can be used to calculate substitute values:\ny'(n-2)= $ \\frac {-125y(n-2)+136y(n-1)+48y(n)-88y(n+1)+29y(n+2)}{84\\cdot deltaT} $ \ny'(n-1)= $ \\frac {-38y(n-2)-2y(n-1)+24y(n)+26y(n+1)-10y(n+2)}{84\\cdot deltaT} $ \ny'(n+1)= $ \\frac {10y(n-2)-26y(n-1)-24y(n)+2y(n+1)+38y(n+2)}{84\\cdot deltaT} $ \ny'(n+2)= $ \\frac {-29y(n-2)+88y(n-1)-48y(n)-136y(n+1)+125y(n+2)}{84\\cdot deltaT} $", "type": "FUNCTION", "input": [{"name": "deltaT", "type": "LReal", "description": "Equidistant distance between two measured values. (e.g. 1s)"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB"}], "in/out": [{"name": "values", "type": "Array[*] of LReal", "description": "Values that will be included in the differentiation."}, {"name": "derivatedValues", "type": "Array[*] of LReal", "description": "The differentiated value range."}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8200": "ERR_DELTA_T Error: Delta time `deltaT` must not be zero.", "16#8400": "ERR_ARRAYS_DIFFERENT Error: The Array sizes are not equal.", "16#8401": "ERR_NOT_ENOUGH_VALUES Error: Not enough values."}, "user_defined_types": []}
{"title": "Device Activation and Deactivation State Machine", "name": "LGF_ActDeactDevice", "description": "## Short description ##\n\nLGF_ActDeactDevice implements a compact state machine to activate and monitor or deactivate \ndecentral devices.\nThe module monitors as well the device connection and error state after activation.\nIt works for PN (S7-1200 / S7-1500) and DP (S7-1500) devices.\n\n## Functional description ##\n\nThe module provides the procedure for activating and deactivating remote IO-Devices in the \nProfinet (PN, S7-1500 & S7-1200) and Profibus (DP, S7-1500) network.\nThe activation of the device (defined at hwId) is initiated by a rising edge at activate, after \ncomplete activation this is indicated at the output isActivated and deviceStateOK. After that the \nconnection status is displayed at the deviceStateOK output.\nThe connection is monitored and in case of a failure of this of more than the set monitoring time \ntimeOutStateMonitoring at the output and reported as an error. After successful recovery of the \nconnection by the system, the configured time is also waited until the error is reset to ensure \nstability.\nNote The connection status of the decentralized device can also be displayed in the TIA Portal \nproject navigation in the PLC, which is the controller, under the item ‚ÄòDistributed I/O‚Äô, if they \nare online with the engineering system.\nDeactivation of the device (defined at hwId) is initiated by a rising edge at deactivate, after \ncomplete activation this is indicated at the output isDeactivated.\nIt is possible to define the states for switching on and off, as well as the monitoring times for \nactivating and deactivating and the connection monitoring.All errors are automatically reset as soon as the faulty state is eliminated.\nThe exception to this are errors that can only be corrected by an intervention in the software, \nsuch as an incorrect or non-existent hardware ID of a non-existent decentralized IO device.", "type": "FUNCTION_BLOCK", "input": [{"name": "enable", "type": "Bool", "description": "Enable functionality of FB"}, {"name": "activate", "type": "Bool", "description": "Rising edge: Activate device given by `hwId`"}, {"name": "deactivate", "type": "Bool", "description": "Rising edge: Deactivate device given by `hwId`"}, {"name": "hwId", "type": "HW_DEVICE", "description": "Hardware ID of the device which should be activated / deactivated"}, {"name": "parameter", "type": "LGF_typeActDeactDeviceParameter", "description": "Parameter dataset for the function `LGF_ActDeactDevice`"}], "output": [{"name": "valid", "type": "Bool", "description": "TRUE: Valid set of output values available at the FB"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is not finished and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status and error identification"}, {"name": "activating", "type": "Bool", "description": "Activation of device active"}, {"name": "isActivated", "type": "Bool", "description": "Device activated"}, {"name": "deactivating", "type": "Bool", "description": "Deactivating of device active"}, {"name": "isDeactivated", "type": "Bool", "description": "Device deactivated"}, {"name": "deviceStateOK", "type": "Bool", "description": "Device is activated and connected to IO-System"}, {"name": "diagnostics", "type": "LGF_typeDiagnostics", "description": "Diagnostic structure to store and transfer diagnostic information from blocks trough the interface."}], "in/out": [], "return_value": [], "status_codes": {"16#7000": "STATUS_NO_CALL: No job being currently processed", "16#7001": "STATUS_FIRST_CALL: First call after incoming new job", "16#7002": "STATUS_SUBSEQUENT_CALL: Subsequent call during active processing", "16#8600": "ERR_UNDEFINED_STATE: Due to an undefined state in state machine", "16#8601": "ERR_LOG2GEO / ERR_GEO2LOG: Log2Geo or Geo2Log error, check diagnostics for more info", "16#8640": "ERR_DEVICE_DEACTIVATING: Error during device deactivation", "16#8641": "ERR_DEVICE_DEACTIVATING_TIME_OUT: Deactivation timeout error", "16#8660": "ERR_DEVICE_ACTIVATING: Error during device activation", "16#8661": "ERR_DEVICE_ACTIVATING_TIME_OUT: Activation timeout error", "16#8662": "ERR_READ_DEVICES_STATES_DURING_ACTIVATION: Error: Read Device states (DeviceStates) during device activation", "16#8670": "ERR_READ_DEVICES_STATES_WHILE_ACTIVE:Error: Read Device states (DeviceStates) while device active", "16#8671": "ERR_DEVICE_STATE_WHILE_ACTIVE: Device states present error and is unreachable, faulty Device or IO-System", "16#8672": "ERR_READ_ACTIVATION_STATE_WHILE_ACTIVE:Activation state (D_ACT_DP) of device is wrong", "16#8690": "ERR_DISABLING_DEACT_DEVICE: Deactivation (D_ACT_DP) of device throws an error while disabling", "16#8691": "ERR_DISABLING_WATCHDOG:Watchdog timer expired while disabling"}, "user_defined_types": [{"name": "LGF_typeActDeactDeviceParameter", "description": "UDT for configuring the behavior of the activation and deactivation process.", "member": [{"name": "timeOutActDeact", "type": "Time", "default": "T#2500ms", "description": "Time to monitor activation and deactivation commands"}, {"name": "timeOutStateMonitoring", "type": "Time", "default": "T#100ms", "description": "Time to monitor device state"}, {"name": "enableAndDeactivate", "type": "Bool", "default": "TRUE", "description": "Disable device during startup"}, {"name": "enableAndActivate", "type": "Bool", "default": "FALSE", "description": "Enable device during startup"}, {"name": "disableAndDeactivate", "type": "Bool", "default": "TRUE", "description": "Disable device during module disabling"}]}, {"name": "LGF_typeDiagnostics", "description": "UDT for diagnostic information from blocks.", "member": [{"name": "status", "type": "Word", "default": "16#0000", "description": "Status of the block or error identification"}, {"name": "subfunctionStatus", "type": "Word", "default": "16#0000", "description": "Status or return value of called blocks"}, {"name": "stateNumber", "type": "DInt", "default": "0", "description": "State in the state machine where error occurred"}]}]}
{"title": "Frequency Signal Generator", "name": "LGF_Frequency", "description": "## Short description ##\n\nThis function generates a signal that changes between the values FALSE and TRUE depending on \na defined frequency and a pulse pause ratio.\n\n## Functional description ##\n\nThe clock output is a Boolean value that toggles at the desired frequency. The pulsePauseRatio\ninput is used to set the pulse pause ratio.\nThe output countdown outputs the remaining time of the current state of clock.\nIf the desired frequency or pulse pause ratio is less than or equal to 0.0, the output clock = \nFALSE and countdown = 0s.", "type": "FUNCTION_BLOCK", "input": [{"name": "frequency", "type": "Real", "description": "0.0"}, {"name": "pulsePauseRatio", "type": "Real", "description": "1.0"}], "output": [{"name": "clock", "type": "Bool", "description": "Output changes with defined frequency."}, {"name": "countdown", "type": "Time", "description": "Remaining time of the current clock state."}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": []}
{"title": "Rectangle Signal Generator", "name": "LGF_RectangleCI", "description": "## Short description ##\n\nThis function generates a rectangular signal profile. For this it uses the time interval of the \ncalling Cyclic Interrupt OB.\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nThe block calculates the values for a rectangular signal profile, which is output to the output \nparameter value.\nThe amplitude, the offset in the Y-direction, the period, and the phase shift can be set at the \ninput parameters.\nThe input parameter reset resets the signal profile. At the value output parameter, the value 0 is \noutput as long as reset is set to TRUE.\nThe block must be called in a cyclic interrupt OB. The time interval of the calling cyclic interrupt \nOB is determined in the FB with the command QRY_CINT. For this, the constant name of the \ncalling cyclic interrupt OB must be interconnected at the input parameter callOB.\nThe number of calculated values of the signal profile per period duration is calculated as follows:\nùëÑùë¢ùëéùëõùë°ùëñùë°ùë¶ùëâùëéùëôùë¢ùëíùë† =\nùëÉùëíùëüùëñùëúùëëùëëùë¢ùëüùëéùë°ùëñùëúùëõ\n/ùëáùëñùëöùëíùëñùëõùë°ùëíùëüùë£ùëéùëòùê∂ùë¶ùëêùëôùëñùëêùëñùëõùë°ùëíùëüùëüùë¢ùëùùë°ùëÇùêµ\nNote To obtain a continuous signal profile of the curve, the time interval of the cyclic interrupt OB \nshould not be selected too large depending on the period duration.\nThe Figure below shows the signal profile of the calculated values.", "type": "FUNCTION_BLOCK", "input": [{"name": "amplitude", "type": "Real", "description": "1.0"}, {"name": "offset", "type": "Real", "description": "0.0"}, {"name": "periode", "type": "UDInt", "description": "1000"}, {"name": "phaseShift", "type": "Real", "description": "0.0"}, {"name": "callOB", "type": "OB_CYCLIC", "description": ""}, {"name": "reset", "type": "Bool", "description": "FALSE"}], "output": [{"name": "value", "type": "Real", "description": "Current value of the rectangular signal."}, {"name": "error", "type": "Bool", "description": "FALSE: No error"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB 16#8000-16#FFFF: Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8600": "ERR_OB_UNAVAILABLE", "16#8601": "ERR_QRY_CINT"}, "user_defined_types": []}
{"title": "Shell Sort for LReal Arrays", "name": "LGF_ShellSort_LReal", "description": "## Short description ##\n\nThis block sorts an array of type LReal with any number of elements (max. 1000) in ascending \nor descending order and returns the sorted version of the array in the same variable.\n\n## Functional description ##\n\nThe block sorts according to the shell sort procedure. Note that the execution time of the block \ndepends significantly on how many elements the array to be sorted has. The overview below \nshows several measured values of the block depending on the number of array elements.\nAverage steps needed for execution: ùí™(ùëõ ‚ãÖ log(ùëõ)^2)\nTable: Execution times of the block LGF_ShellSort‚Ä¶\nNumber of array elements S7-1212C DC/DC/DC S7-1516-3 PN/DP\n100 approx. 11-16 ms approx. 1-2 ms\n1000 approx. 185-205 ms approx. 10-12 ms\nNote The block is executed synchronously and is not split over several PLC cycles. Thus the \nexecution time has a direct effect on the PLC cycle time. Note this behavior for your project \nof the controller used and adjust the monitoring time of the controller if necessary.", "type": "FUNCTION", "input": [{"name": "sortDirection", "type": "Bool", "description": "FALSE: Sort ascending; TRUE: Sort descending"}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}], "in/out": [{"name": "array", "type": "Array[*] of LReal", "description": "Array to be sorted"}], "return_value": [], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_NO_ARRAY", "16#8201": "ERR_TOO_MANY_ELEMENTS"}, "user_defined_types": []}
{"title": "Sinusoidal Signal Generator", "name": "LGF_SinusCI", "description": "## Short description ##\n\nThis function generates a sinusoidal signal profile. For this it uses the time interval of the calling \nCyclic Interrupt OB.\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nThe block calculates the values for a sinusoidal signal profile, which is output to the output \nparameter value.\nThe amplitude, the offset in the Y-direction, the period (in ms) and the phase shift (in ms) can \nbe set at the input parameters.\nThe input parameter reset resets the signal profile. At the value output parameter, the value 0 is \noutput as long as reset is set to TRUE.\nThe block must be called in a cyclic interrupt OB. The time interval of the calling cyclic interrupt \nOB is determined in the FB with the command QRY_CINT. For this, the constant name of the \ncalling cyclic interrupt OB must be interconnected at the input parameter callOB.\nThe number of calculated values of the signal profile per period duration is calculated as follows:\nùëÑùë¢ùëéùëõùë°ùëñùë°ùë¶ùëâùëéùëôùë¢ùëíùë† =\nùëÉùëíùëüùëñùëúùëëùëëùë¢ùëüùëéùë°ùëñùëúùëõ\n/ùëáùëñùëöùëíùëñùëõùë°ùëíùëüùë£ùëéùëòùê∂ùë¶ùëêùëôùëñùëêùëñùëõùë°ùëíùëüùëüùë¢ùëùùë°ùëÇùêµ\nNote To obtain a continuous signal profile of the curve, the time interval of the cyclic interrupt OB \nshould not be selected too large depending on the period duration.The Figure below shows the signal profile of the calculated values.", "type": "FUNCTION_BLOCK", "input": [{"name": "amplitude", "type": "Real", "description": "1.0"}, {"name": "offset", "type": "Real", "description": "0.0"}, {"name": "periode", "type": "UDInt", "description": "1000"}, {"name": "phaseShift", "type": "Real", "description": "0.0"}, {"name": "callOB", "type": "OB_CYCLIC", "description": ""}, {"name": "reset", "type": "Bool", "description": "FALSE"}], "output": [{"name": "value", "type": "Real", "description": "Current value of the sinusoidal signal."}, {"name": "error", "type": "Bool", "description": "FALSE: No error"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB 16#8000-16#FFFF: Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8600": "ERR_OB_UNAVAILABLE", "16#8601": "ERR_QRY_CINT"}, "user_defined_types": []}
{"title": "Random Real Range Number Generator", "name": "LGF_RandomRange_Real", "description": "## Short description ##\n\nThis function generates a random value in defined limits with each call.\nThe random number has the data type Real in the specified range.\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nThe block generates random values that are between the specified minValue and the maxValue. \nThis random value is output via the Ret_Val.The random value is formed from the nanoseconds of the current system time of the CPU. The byte order of this value is inverted and then converted to a floating point.", "type": "FUNCTION", "input": [{"name": "minValue", "type": "Real", "description": "Minimum value of the range of the random number - lower border"}, {"name": "maxValue", "type": "Real", "description": "Maximum value of the range of the random number - upper border"}], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called blocks"}], "in/out": [], "return_value": [{"type": "Real", "description": "Random Real number in the predefined range"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8200": "ERR_MAX_LESS_MIN", "16#8600": "ERR_RD_SYS_T"}, "user_defined_types": []}
{"title": "Advanced String Extractor from Character Array", "name": "LGF_ExtractStringFromCharArrayAdv", "description": "## Short description ##\n\nThe function extracts a String specified by a text before and after from an array of characters \nwith extended options.", "type": "FUNCTION", "input": [{"name": "textBefore", "type": "String", "description": "Text in front of the characters which has to be extracted"}, {"name": "textAfter", "type": "String", "description": "Text behind the characters which has to be extracted"}, {"name": "includeBeforeAfter", "type": "Bool", "description": "TRUE: textBefore and textAfter are included in the extracted string"}, {"name": "startPos", "type": "DInt", "description": "Position within the array to start search from (index zero based)"}], "output": [{"name": "extractedString", "type": "String", "description": "Extracted string"}, {"name": "position", "type": "DInt", "description": "Position (index) within the array where text begins (index zero based)"}, {"name": "length", "type": "Int", "description": "Length of text that was extracted"}, {"name": "status", "type": "Word", "description": "Status of the FB"}], "in/out": [{"name": "searchIn", "type": "Variant", "description": "Array of Character or Byte to search in"}], "return_value": [{"type": "Word", "description": "Return value: Status of the FB"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_NO_ARRAY", "16#9001": "WARNING_ONLY_START", "16#9002": "WARNING_NOTHING_FOUND"}, "user_defined_types": []}
{"title": "Advanced Rate of Change Limiter", "name": "LGF_LimRateOfChangeAdvancedCI", "description": "## Short description ##\n\nThe function LGF_LimRateOfChangeAdvanced limits the rate of change of an input variable. Jump \nfunctions become ramp functions. In addition, the block has various operating modes.\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nFor the positive/negative value range, two rates of change in each case for the ramp (rising and \nfalling values) can be parameterized. The following operating modes can be selected via control \ninputs:\n‚Ä¢ Restart\n‚Ä¢ Pre-assigning an output\n‚Ä¢ Normal operation (automatic)\n‚Ä¢ Switch through controlled variable (manual)\n‚Ä¢ Tracking\nThe output variable can be limited through two parametrize able limits. An active limitation of the \nrate of change of a ramp, as well as an active limitation of the output variable are reported via \noutputs.\nThe time interval of the calling cyclic interrupt OB is determined by interconnecting the calling \ncyclic interrupt OB at the input parameter callOB.\nRestart\nAt restart reset = TRUE, the output outputValue is reset to 0.0.\nIf enDefaultOutValue = TRUE is set, defaultOutValue is output. All signal outputs are set to \nFALSE.\nPre-assigning an output\nIf enDefaultOutValue = TRUE is set, the value at defaultOutValue is output. When changing \nfrom TRUE to FALSE, outputValue is ramped from defaultOutValue to autoValue. When changing \nfrom FALSE to TRUE, the output outputValue immediately jumps to defaultOutValue.\nNormal operation\nThe ramps are straight lines of limitation and are based on a rate of change per second; if, for \nexample, the parameter setPosUpRateLim = 10.0 is assigned, then at a sampling time of \n1s/100ms/10ms, 10.0/1.0/0.1 will be added to outputValue at each block call, if autoValue > \noutputValue, until autoValue is reached.\nThe limitation of the rate of change can be parameterized in both positive and negative ranges \nfor the increase and decrease.\nTable: Marking of the ramps\nParameters Ramp\nsetPosUpRateLim outputValue > 0.0 and |outputValue| rising\nsetPosDownRateLim\noutputValue > 0.0 and |outputValue| falling\nsetNegUpRateLim outputValue < 0.0 and |outputValue| rising\nsetNegDownRateLim\noutputValue < 0.0 and |outputValue| falling\nIf the ramps are not parameterized (setPosUpRateLim, setPosDownRateLim, setNegUpRateLim, \nand setNegDownRateLim equal 0.0), the output remains at 0.0 and normal operation is disabled.\nTracking\nIf the input track = TRUE is set, the input variable autoValue is interconnected directly to the \noutput variable outputValue. Thus, jumps of the input variable will also be output.\nSwitch through controlled variable\nIf manOp = TRUE is set, the controlled variable manualValue is interconnected directly to the \noutput variable outputValue.\nIn this operating mode, the parameterization of the ramps or the high/low limitation of the output \nvariable, and the pre-assignment of the output, are ineffective.\nWhen changing from TRUE to FALSE, the output outputValue is ramped again after autoValue.\nAs soon as the value range between the low and high limits is reached, the high and low limits \nare reactivated.\nFigure: Ramp function sequence, operating modes", "type": "FUNCTION_BLOCK", "input": [{"name": "autoValue", "type": "LReal", "description": "Signal to be processed and limited in its rate of change"}, {"name": "manualValue", "type": "LReal", "description": "Manually controlled output value"}, {"name": "posUpRateLim", "type": "LReal", "description": "Rate of change per second for the rising ramp in the positive value range"}, {"name": "posDownRateLim", "type": "LReal", "description": "Rate of change per second for the falling ramp in the positive value range"}, {"name": "negUpRateLim", "type": "LReal", "description": "Rate of change per second for the rising ramp in the negative value range"}, {"name": "negDownRateLim", "type": "LReal", "description": "Rate of change per second for the falling ramp in the negative value range"}, {"name": "highLim", "type": "LReal", "description": "High limit value"}, {"name": "lowLim", "type": "LReal", "description": "Low limit value"}, {"name": "defaultOutValue", "type": "LReal", "description": "Value for pre-assignment of the output variable"}, {"name": "enDefaultOutValue", "type": "Bool", "description": "Assign default output value"}, {"name": "track", "type": "Bool", "description": "Follow / tracking of Input variable"}, {"name": "manOp", "type": "Bool", "description": "Manual mode on"}, {"name": "reset", "type": "Bool", "description": "Complete restart of function"}, {"name": "callOB", "type": "OB_CYCLIC", "description": "Calling wake-alarm interrupt OB"}], "output": [{"name": "outputValue", "type": "LReal", "description": "Output variable"}, {"name": "posUpRateLim", "type": "Bool", "description": "Rise limitation in positive range tripped"}, {"name": "posDownRateLim", "type": "Bool", "description": "Down rate limit in positive range reached"}, {"name": "negUpRateLim", "type": "Bool", "description": "Up rate limit in negative range reached"}, {"name": "negDownRateLim", "type": "Bool", "description": "Down rate limit in negative range reached"}, {"name": "highLim", "type": "Bool", "description": "High limit reached"}, {"name": "lowLim", "type": "Bool", "description": "Low limit reached"}, {"name": "error", "type": "Bool", "description": "Error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8200": "ERR_NEG_RATE_LIM", "16#8202": "ERR_NEG_RATE_OF_CHANGE", "16#8600": "ERR_QRY_CINT", "16#8601": "ERR_OB_UNAVAILABLE"}, "user_defined_types": [{"name": "LGF_typeNonLinSetpoints", "description": "Data type for setup a setpoint table for function", "member": [{"name": "inputValue", "type": "LReal", "default": "0.0", "description": "Input value to be interpolated"}, {"name": "outputValue", "type": "LReal", "default": "0.0", "description": "Corresponding interpolated value"}]}]}
{"title": "Triangular Signal Generator", "name": "LGF_TriangleCI", "description": "## Short description ##\n\nThis function generates a triangular signal profile. For this it uses the time interval of the calling \nCyclic Interrupt OB.\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nThe block calculates the values for a triangular signal profile, which is output to the output \nparameter value.\nThe amplitude, the offset in the Y-direction, the period, and the phase shift can be set at the \ninput parameters.\nThe input parameter reset resets the signal profile. At the value output parameter, the value 0 is \noutput as long as reset is set to TRUE.\nThe block must be called in a cyclic interrupt OB. The time interval of the calling cyclic interrupt \nOB is determined in the FB with the command QRY_CINT. For this, the constant name of the \ncalling cyclic interrupt OB must be interconnected at the input parameter callOB.\nThe number of calculated values of the signal profile per period duration is calculated as follows:\nùëÑùë¢ùëéùëõùë°ùëñùë°ùë¶ùëâùëéùëôùë¢ùëíùë† =\nùëÉùëíùëüùëñùëúùëëùëëùë¢ùëüùëéùë°ùëñùëúùëõ\n/ùëáùëñùëöùëíùëñùëõùë°ùëíùëüùë£ùëéùëòùê∂ùë¶ùëêùëôùëñùëêùëñùëõùë°ùëíùëüùëüùë¢ùëùùë°ùëÇùêµ\nNote To obtain a continuous signal profile of the curve, the time interval of the cyclic interrupt OB \nshould not be selected too large depending on the period duration.The Figure below shows the signal profile of the calculated values.", "type": "FUNCTION_BLOCK", "input": [{"name": "amplitude", "type": "Real", "description": "1.0"}, {"name": "offset", "type": "Real", "description": "0.0"}, {"name": "periode", "type": "UDInt", "description": "1000"}, {"name": "phaseShift", "type": "Real", "description": "0.0"}, {"name": "callOB", "type": "OB_CYCLIC", "description": ""}, {"name": "reset", "type": "Bool", "description": "FALSE"}], "output": [{"name": "value", "type": "Real", "description": "Current value of the triangular signal."}, {"name": "error", "type": "Bool", "description": "FALSE: No error"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB 16#8000-16#FFFF: Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8600": "ERR_OB_UNAVAILABLE", "16#8601": "ERR_QRY_CINT"}, "user_defined_types": []}
{"title": "Moving Average Calculation Function Block", "name": "LGF_FloatingAverage", "description": "## Short description ##\n\nThis function calculates a moving arithmetic mean value from REAL values. This method can be \nused to smooth data series. The values can be read in cyclically or triggered.\n\n## Functional description ##\n\nNote The block LGF_FloatingAverage does not query the data type for the input parameter value. \nFor data types other than REAL, either an implicit conversion is performed automatically or \nan error is generated during compilation.\nYou can find further information in the Chapter ‚ÄúOverview of Data Type Conversion‚Äù in the \nOnline Help section of the TIA Portal or under:\nhttps://support.industry.siemens.com/cs/ww/en/view/109773506/100611494667\nThe block calculates the (moving) mean value based on the set window width. The window \nwidth indicates the maximum number of values read in last. After the maximum number of \nvalues has been read, the output windowSizeReached is set and each newly read value replaces \nthe oldest value (FIFO principle).\nTwo options are available for reading the values. With the input cyclicExecution, the values are \nread and calculated cyclically. With the trigger input, the values are read in and calculated with \neach pulse.", "type": "FUNCTION_BLOCK", "input": [{"name": "cyclicExecution", "type": "Bool", "description": "TRUE: cyclic operation, trigger not in use"}, {"name": "trigger", "type": "Bool", "description": "Read in `value` with every pulse at input `trigger`"}, {"name": "value", "type": "LReal", "description": "Value/s from which the moving average is to be determined."}, {"name": "windowSize", "type": "Int", "description": "Window length for sliding averaging in the range from 1..100. The standard value is 100."}, {"name": "reset", "type": "Bool", "description": "TRUE: The block is reset and the calculation starts again."}], "output": [{"name": "average", "type": "LReal", "description": "Moving / Floating average"}, {"name": "windowSizeReached", "type": "Bool", "description": "FALSE: Maximum window width not yet reached, TRUE: Maximum window width reached"}, {"name": "error", "type": "Bool", "description": "FALSE: No error, TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB and error identification."}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR: Execution finished without errors", "16#8200": "ERR_WRONG_WINDOW_SIZE: Incorrect window size/width set."}, "user_defined_types": []}
{"title": "Sawtooth Signal Generator", "name": "LGF_SawToothCI", "description": "## Short description ##\n\nThis function generates a sawtooth-shaped signal profile. For this it uses the time interval of the \ncalling Cyclic Interrupt OB.\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nThe block calculates the values for a sawtooth-shaped signal profile, which is output to the \noutput parameter value.\nThe amplitude, the offset in the Y-direction, the period, and the phase shift can be set at the \ninput parameters.\nThe input parameter reset resets the signal profile. At the value output parameter, the value 0 is \noutput as long as reset is set to TRUE.\nThe block must be called in a cyclic interrupt OB. The time interval of the calling cyclic interrupt \nOB is determined in the FB with the command QRY_CINT. For this, the constant name of the \ncalling cyclic interrupt OB must be interconnected at the input parameter callOB.\nThe number of calculated values of the signal profile per period duration is calculated as follows:\nùëÑùë¢ùëéùëõùë°ùëñùë°ùë¶ùëâùëéùëôùë¢ùëíùë† =\nùëÉùëíùëüùëñùëúùëëùëëùë¢ùëüùëéùë°ùëñùëúùëõ\n/ùëáùëñùëöùëíùëñùëõùë°ùëíùëüùë£ùëéùëòùê∂ùë¶ùëêùëôùëñùëêùëñùëõùë°ùëíùëüùëüùë¢ùëùùë°ùëÇùêµ\nNote To obtain a continuous signal profile of the curve, the time interval of the cyclic interrupt OB \nshould not be selected too large depending on the period duration.The Figure below shows the signal profile of the calculated values.", "type": "FUNCTION_BLOCK", "input": [{"name": "amplitude", "type": "Real", "description": "1.0"}, {"name": "offset", "type": "Real", "description": "0.0"}, {"name": "periode", "type": "UDInt", "description": "1000"}, {"name": "phaseShift", "type": "Real", "description": "0.0"}, {"name": "callOB", "type": "OB_CYCLIC", "description": ""}, {"name": "reset", "type": "Bool", "description": "FALSE"}], "output": [{"name": "value", "type": "Real", "description": "Current value of the sawtooth signal."}, {"name": "error", "type": "Bool", "description": "FALSE: No error"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB 16#8000-16#FFFF: Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8600": "ERR_OB_UNAVAILABLE", "16#8601": "ERR_QRY_CINT"}, "user_defined_types": []}
{"title": "Value set point range check", "name": "LGF_IsValueInRange", "description": "## Short description ##\n\nThe function checks whether a value is within a defined value range.\nThe value range is defined with a set point and a range around this set point. The function \ncalculates the low limit and high limit of the value range.\n\n## Functional description ##\n\nThe setpoint and range variables define a range of values.\nThe function checks whether the value is below, in or above the value range. The outputs \nbelowLowLimit, Ret_Val, or overHighLimit show where the value is located.", "type": "FUNCTION", "input": [{"name": "value", "type": "LReal", "description": "Value to be checked to determine whether it is within the defined value range"}, {"name": "setpoint", "type": "LReal", "description": "Set point"}, {"name": "range", "type": "LReal", "description": "Area where the setpoint is in range"}], "output": [{"name": "overHighLimit", "type": "Bool", "description": "TRUE if the ‚Äúvalue‚Äù is greater than the upper limit value"}, {"name": "belowLowLimit", "type": "Bool", "description": "TRUE, if the ‚Äúvalue‚Äù is less than the lower limit value"}, {"name": "error", "type": "Bool", "description": "FALSE: No error TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB 16#8000-16#FFFF: Error identification"}], "in/out": [], "return_value": [{"type": "Bool", "description": "Return: TRUE if the ‚Äúvalue‚Äù is in the value range (range of the set point)"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8401": "ERR_RANGE_LIMIT_VALUES"}, "user_defined_types": []}
{"title": "Boolean signal edge detection", "name": "LGF_CountBooleanEdges", "description": "## Short description ##\n\nThis function evaluates a input signal for different states in a certain amount of time.\nThe states are:\n‚Ä¢ One edge and input present over the whole monitoring time\n‚Ä¢ Single edge\n‚Ä¢ Double edge\n‚Ä¢ N-Edges in between the monitoring time\nThe Output signal is present for at least on cycle after the monitoring time has expired, or as \nlong as the input trigger remains TRUE.", "type": "FUNCTION_BLOCK", "input": [{"name": "trigger", "type": "Bool", "description": "Trigger to evaluate signal"}, {"name": "monitorTime", "type": "Time", "description": "Time to monitor and count edges on `trigger` input"}], "output": [{"name": "single", "type": "Bool", "description": "Single edge until monitoring time expires"}, {"name": "double", "type": "Bool", "description": "Two edges in between the monitoring time"}, {"name": "long", "type": "Bool", "description": "Just a single edge in the monitoring time, the `trigger` input stays TRUE after the edge appears"}, {"name": "severalEdges", "type": "Bool", "description": "Numerous Edges occur within the monitoring time"}, {"name": "noOfEdges", "type": "USInt", "description": "Number of edges in between the monitoring time frame"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": []}
{"title": "Sawtooth Signal Profile Generator", "name": "LGF_SawTooth", "description": "## Short description ##\n\nThis function generates a sawtooth-shaped signal profile. Each sawtooth consists of a defined \nnumber of steps (increments).\nNote LEGACY FUNCTION\nPlease update and use the FB with the same name LGF_CountRisInDWord in the future!\nThis function is no longer maintained\n\n## Functional description ##\n\nNote Please note that changes at the input parameters only become effective with reset.\nThe block calculates the values for a sawtooth-shaped signal profile, which is output to the \noutput parameter value. The signal begins with the start value startValue and is added with the \nvalue increment after each elapse of the time interval timeRange. The value can also be \nnegative.\nIf the variable endlessSteps is set to FALSE, the number of add operations is counted. If this \nexceeds the value numberSteps, the output parameter value is set back to the start value. A new \nsawtooth begins.\nIf the variable endlessSteps is set to TRUE, the value increment is added without interruption, \nstarting once at startValue. If the maximum positive INT value range (32767) of the output \nparameter value is exceeded, value changes to the maximum negative INT value range (-32768) and will continue to be added up.\nNote The duration of a sawtooth at endlessSteps on FALSE is calculated as follows:\nDuration = #timeRange * (#numberSteps + 1)", "type": "FUNCTION_BLOCK", "input": [{"name": "startValue", "type": "Int", "description": "0"}, {"name": "timeRange", "type": "Time", "description": "T#0s"}, {"name": "incrementRange", "type": "Int", "description": "0"}, {"name": "numberSteps", "type": "Int", "description": "0"}, {"name": "endlessSteps", "type": "Bool", "description": "FALSE"}, {"name": "reset", "type": "Bool", "description": "FALSE"}], "output": [{"name": "value", "type": "Int", "description": "Current value of the sawtooth signal."}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": []}
{"title": "Numeric Differentiation Function Block", "name": "LGF_DifferenceQuotientFB", "description": "## Short description ##\n\nThis function numerically differentiates a signal sampled equidistantly in time. For example, the \nvelocity can be calculated from a measured locus curve, or the acceleration can be calculated \nfrom the measured velocity. In order to minimize the effects of a scattering measurement signal, \nthis algorithm uses a compensating polynomial.\nThe function block calculates the differentiated values cyclically.\nThe function block reads-in a value with each positive edge on the insert been read in, the \nblock calculates a differentiated value and outputs it.\n\n## Functional description ##\n\nTo calculate the difference quotient of a scattering signal, a third-degree compensation \npolynomial is first placed through the measured values. This polynomial is then differentiated. \nWith this method, even a distorted input signal can be sensibly differentiated.\nThe difference quotient is calculated with the following formula:\n\nThe function (FC) can calculate ùëÅ ‚àí 4 differentiated and smoothed measured values from N \nmeasured values. The output array would be assigned with 0 in the index (0,1,N-1,N). However, \nthe following formalisms can be used to calculate substitute values:", "type": "FUNCTION_BLOCK", "input": [{"name": "enable", "type": "Bool", "description": "Activates the block."}, {"name": "insert", "type": "Bool", "description": "Accepts the value at the input `value` at positive edge and outputs a `derivatedValue` if five values have been read in."}, {"name": "value", "type": "LReal", "description": "Value that must be included in the differentiation."}, {"name": "deltaT", "type": "LReal", "description": "Equidistant distance between two measured values. (e.g. 1s)"}], "output": [{"name": "derivatedValue", "type": "LReal", "description": "The differentiated value."}, {"name": "error", "type": "Bool", "description": "FALSE: No error, TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status and error identification of the FB"}], "in/out": [], "return_value": [], "status_codes": {"16#7000": "STATUS_NO_CALL: The block waits for activation through the parameter `enable`.", "16#7001": "STATUS_FIRST_CALL: First call of FB after enabling", "16#7002": "STATUS_SUBSEQUENT_CALL: Processing is active. Subsequent call of FB.", "16#7010": "STATUS_NOT_ENOUGH_VALUES: The block requires five (5) values to calculate a differentiated value.", "16#8200": "ERR_DELTA_T: Delta time `deltaT` must not be zero."}, "user_defined_types": []}
{"title": "Cosine Signal Generator", "name": "LGF_CosinusCI", "description": "## Short description ##\n\nThis function generates a cosinusoidal signal profile. For this it uses the time interval of the \ncalling Cyclic Interrupt OB.\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nThe block calculates the values for a cosinusoidal signal profile, which is output to the output \nparameter value.\nThe amplitude, the offset in the Y-direction, the period (in ms) and the phase shift (in ms) can \nbe set at the input parameters.\nThe input parameter reset resets the signal profile. At the value output parameter, the value 0 is \noutput as long as reset is set to TRUE.\nThe block must be called in a cyclic interrupt OB. The time interval of the calling cyclic interrupt \nOB is determined in the FB with the command QRY_CINT. For this, the constant name of the \ncalling cyclic interrupt OB must be interconnected at the input parameter callOB.\nThe number of calculated values of the signal profile per period duration is calculated as follows:\nùëÑùë¢ùëéùëõùë°ùëñùë°ùë¶ùëâùëéùëôùë¢ùëíùë† =ùëÉùëíùëüùëñùëúùëëùëëùë¢ùëüùëéùë°ùëñùëúùëõ/ùëáùëñùëöùëíùëñùëõùë°ùëíùëüùë£ùëéùëòùê∂ùë¶ùëêùëôùëñùëêùëñùëõùë°ùëíùëüùëüùë¢ùëùùë°ùëÇùêµ\nNote To obtain a continuous signal profile of the curve, the time interval of the cyclic interrupt OB \nshould not be selected too large depending on the period duration.\nThe Figure below shows the signal profile of the calculated values.", "type": "FUNCTION_BLOCK", "input": [{"name": "amplitude", "type": "Real", "description": "1.0"}, {"name": "offset", "type": "Real", "description": "0.0"}, {"name": "periode", "type": "UDInt", "description": "1000"}, {"name": "phaseShift", "type": "Real", "description": "0.0"}, {"name": "callOB", "type": "OB_CYCLIC", "description": ""}, {"name": "reset", "type": "Bool", "description": "FALSE"}], "output": [{"name": "value", "type": "Real", "description": "Current value of the cosinusoidal signal."}, {"name": "error", "type": "Bool", "description": "FALSE: No error"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB 16#8000-16#FFFF: Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8600": "ERR_OB_UNAVAILABLE", "16#8601": "ERR_QRY_CINT"}, "user_defined_types": []}
{"title": "File Reading from UserFiles Folder", "name": "LGF_FileRead", "description": "## Short description ##\n\nThis function block offers reading data as binary / serialized data stream from files stored on the \nPLC's memory card in the folder UserFiles.\n\n## Functional description ##\n\nWith the function LGF_FileRead a file can be read into the data budget of a variable at data. To \nread the data it is necessary to deserialize it, which the function already takes from the user.\nFor deserialization an external buffer in the form of a byte array must be connected which can \ntake up the amount of data, if the buffer is too small an error is output.\nThe file name must always be specified in full together with the folder name and the file \nextension in the following format: UserFiles/test.dat.", "type": "FUNCTION_BLOCK", "input": [{"name": "execute", "type": "Bool", "description": "Rising edge starts file read once"}, {"name": "dataLengthMustMatch", "type": "Bool", "description": "The length of the file data set and the dataset in the PLC have to match."}, {"name": "fileName", "type": "String", "description": "Name of file including path: `UserFiles/test.dat`"}], "output": [{"name": "done", "type": "Bool", "description": "Commanded functionality has been completed successfully"}, {"name": "busy", "type": "Bool", "description": "FB is not finished and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}, {"name": "dataLength", "type": "DInt", "description": "Data length read from file (serialized length of `data`)"}], "in/out": [{"name": "bufferByteArray", "type": "Array[*] of Byte", "description": "Byte array buffer for read / write from / to file"}, {"name": "data", "type": "Variant", "description": "Data set read from file"}], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED", "16#7000": "STATUS_NO_CALL", "16#7001": "STATUS_FIRST_CALL", "16#7002": "STATUS_SUBSEQUENT_CALL", "16#8201": "ERR_BUFFER_LOWERBOUND", "16#8202": "ERR_BUFFER_ARRAY_TO_SMALL_TO_COPY", "16#8401": "ERR_FILE_PATH", "16#8411": "ERR_FILE_SIZE_GRATER_THEN_DATA_SIZE", "16#8412": "ERR_FILE_SIZE_LESS_THEN_DATA_SIZE", "16#8600": "ERR_UNDEFINED_STATE", "16#8601": "ERR_MOVE_BLK_VARIANT", "16#8602": "ERR_DATA_SERIALIZE", "16#8603": "ERR_DATA_DESERIALIZE", "16#8604": "ERR_FILE_READ_INIT", "16#8605": "ERR_FILE_READ"}, "user_defined_types": [{"name": "LGF_typeDiagnostics", "description": "Diagnostic structure to store and transfer diagnostic information from blocks trough the interface.", "member": [{"name": "status", "type": "Word", "default": "16#0000", "description": "Status of the Block or error identification when error occurred"}, {"name": "subfunctionStatus", "type": "Word", "default": "16#0000", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "stateNumber", "type": "DInt", "default": "0", "description": "State in the state machine of the block where the error occurred"}]}]}
{"title": "Polynomial Smoothing Function", "name": "LGF_SmoothByPolynomFC", "description": "## Short description ##\n\nThis function calculates the smoothed values by polynomial acyclically.\nFor smoothing, a 3rd degree polynomial is placed through five value points. The error squares \nof the distances between polynomial and real value are minimized. The smoothed values can \nbe determined from the polynomial parameters obtained in this way.\nThe function reads an array that is smoothed. ùëÅ ‚àí 4 smoothed measured values can be \ncalculated from N measured values. The output array contains the value 0 in the index (0,1,N-\n1,N). However, replacement values can be calculated.\n\n## Functional description ##\n\nThe 3rd degree compensation polynomial is calculated as follows:\n\nùëÅ ‚àí 4 smoothed measured values can thus be calculated from the N measured values. The \noutput array contains the value 0 in the index (0.1, N-1, N).\nThese ‚Äúmissing‚Äù values are calculated with the following formalisms:", "type": "FUNCTION", "input": [], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB"}], "in/out": [{"name": "values", "type": "Array[*] of LReal", "description": "Values that are to be included in the smoothing."}, {"name": "smoothedValues", "type": "Array[*] of LReal", "description": "The smoothed values."}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8400": "ERR_ARRAYS_DIFFERENT Error: The Array sizes are not equal.", "16#8401": "ERR_NOT_ENOUGH_VALUES Error: Not enough values."}, "user_defined_types": []}
{"title": "Simple Smoothing Function Block", "name": "LGF_SimpleSmoothingFB", "description": "## Short description ##\n\nThe function calculates the linear mean value cyclically.\nThe simplest form of smoothing a sequence of measured values is to calculate the linear mean \nvalue by three points.\nThe function reads-in a value with each positive edge on the insert input. As soon as three \nvalues have been read in, the block calculates a smoothed value and outputs it.\n\n## Functional description ##\n\nThe function calculates the smoothed values using the following formula:\nùë¶(ùëõ) = (ùë¶(ùëõ ‚àí 1) + ùë¶(ùëõ) + ùë¶(ùëõ + 1)) / 3\nThe calculated value is output or the calculated values are output at output smoothedValue.\nBased on this formula, the function cannot calculate values for the elements 0 and N.", "type": "FUNCTION_BLOCK", "input": [{"name": "enable", "type": "Bool", "description": "Activates the block."}, {"name": "insert", "type": "Bool", "description": "Accepts the value at the input `value` at positive edge and outputs a `smoothedValue` if three values have been read in."}, {"name": "value", "type": "LReal", "description": "Value that is to be included in the smoothing."}], "output": [{"name": "smoothedValue", "type": "LReal", "description": "The smoothed value."}, {"name": "error", "type": "Bool", "description": "FALSE: No error, TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB and error identification."}], "in/out": [], "return_value": [], "status_codes": {"16#7000": "STATUS_NO_CALL: The block waits for activation through the parameter `enable`.", "16#7001": "STATUS_FIRST_CALL: First call of FB after enabling", "16#7002": "STATUS_SUBSEQUENT_CALL: Processing is active. Subsequent call of FB.", "16#7010": "STATUS_NOT_ENOUGH_VALUES: The block requires three (3) values to calculate a smoothed value."}, "user_defined_types": []}
{"title": "Bit status check operation", "name": "LGF_BitTest", "description": "## Short description ##\n\nThis block checks whether a bit is TRUE or FALSE at a given position in a variable of the data type DWORD.\nAlternatively, Word and Byte can be used instead of DWord by converting the passed\nparameter with, for example, BYTE_TO_DWORD and the result with DWORD_TO_BYTE.", "type": "FUNCTION", "input": [{"name": "value", "type": "DWord", "description": "Tag where the bit has to be tested"}, {"name": "bitNo", "type": "USInt", "description": "bit number to test in \"value\" parameter"}], "output": [], "in/out": [], "return_value": [{"type": "Bool", "description": "Value of the checked bit."}], "status_codes": {}, "user_defined_types": []}
{"title": "Polynomial Smoothing Function Block", "name": "LGF_SmoothByPolynomFB", "description": "## Short description ##\n\nThis function calculates the smoothed values by polynomial cyclically.\nFor smoothing, a 3rd degree polynomial is placed through five value points. The error squares \nof the distances between polynomial and real value are minimized. The smoothed values can \nbe determined from the polynomial parameters obtained in this way.\nThe function reads-in a value with each positive edge on the insert input. As soon as five \nvalues have been read in, the block calculates a smoothed value and outputs it.\n\n## Functional description ##\n\nThe 3rd degree compensation polynomial is calculated as follows:\n\nùëÅ ‚àí 4 smoothed measured values can thus be calculated from the N measured values. The \noutput array contains the value 0 in the index (0.1, N-1, N).\nThese ‚Äúmissing‚Äù values are calculated with the following formalisms:", "type": "FUNCTION_BLOCK", "input": [{"name": "enable", "type": "Bool", "description": "Activates the block."}, {"name": "insert", "type": "Bool", "description": "Accepts the value at the input `value` at positive edge and outputs a `smoothedValue` if five values have been read in."}, {"name": "value", "type": "LReal", "description": "Value that is to be included in the smoothing."}], "output": [{"name": "smoothedValue", "type": "LReal", "description": "The smoothed value."}, {"name": "error", "type": "Bool", "description": "FALSE: No error, TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB and error identification."}], "in/out": [], "return_value": [], "status_codes": {"16#7000": "STATUS_NO_CALL: The block waits for activation through the parameter `enable`.", "16#7001": "STATUS_FIRST_CALL: First call of FB after enabling", "16#7002": "STATUS_SUBSEQUENT_CALL: Processing is active. Subsequent call of FB.", "16#7010": "STATUS_NOT_ENOUGH_VALUES: The block requires five (5) values to calculate a smoothed value."}, "user_defined_types": []}
{"title": "Timer with various time switch points", "name": "LGF_TimerSwitch", "description": "## Short description ##\n\nThis block is a timer. It is possible to define daily, weekly, monthly, yearly time switch points and \ntime switch points for working days or weekend days.\nMode: Permanently off: 0, Daily: 1, Weekly: 2, Monthly: 3, Yearly: 4, Workday: 5, Weekend: 6, \nPermanently on: 10\nThe time value is always compared with the local time of the PLC, therefore the time value \nspecified at the On and Off parameters must be specified as local time.\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nNote The function uses internally the system function RD_LOC_T to read the local time of the CPU, \nfor the correct function it is therefore necessary that the local time of the CPU is set correctly.\nThe block offers various timer types, which are determined in the mode parameter:\n‚Ä¢ Permanently off (mode = 0)\n‚Ä¢ Daily timer (mode = 1)\n‚Ä¢ Weekly timer (mode = 2)\n‚Ä¢ Monthly timer (mode = 3)\n‚Ä¢ Yearly timer (mode = 4)\n‚Ä¢ Weekdays, Monday to Friday (mode = 5)\n‚Ä¢ Weekend, Saturday and Sunday (mode = 6)\n‚Ä¢ Permanently on (mode = 10)\nThe time value is always compared with the local time of the PLC, therefore the time value \nspecified at the On and Off parameters must be specified as local time.\nDepending on the mode, the following formal parameters must be interconnected:\nMode. Mode Required - formal parameters\n0 . Permanently OFF ‚Äì none\n1 . Daily timer ‚Äì onHour / offHour\n‚Äì onMinute / offMinute\n2 . Weekly timer ‚Äì onWeekday / offWeekday\n‚Äì onHour / offHour\n‚Äì onMinute / offMinute\n3 . Monthly timer ‚Äì onDay / offDay\n‚Äì onHour / offHour\n‚Äì onMinute / offMinute\n4 . Yearly timer ‚Äì onMonth / offMonth\n‚Äì onDay / offDay\n‚Äì onHour / offHour\n‚Äì onMinute / offMinute\n5 . Weekdays ‚Äì onHour / offHour\n‚Äì onMinute / offMinute\n6 . Weekend ‚Äì onHour / offHour\n‚Äì onMinute / offMinute\n10 . Permanently ON ‚Äì none\nIf the set start time equals the current local time of the controller, the output signal is set to \nTRUE. If the set switch-off time equals the current local time of the controller, the signal output is \nreset again.\nNote Please note that the block can be used in the ‚ÄúMonthly timer‚Äù modes (mode = 3) or ‚Äúyearly \ntimer‚Äù (mode = 4) the block only switches if the days that you specify at the input parameters, \n‚ÄúonDay‚Äù and ‚ÄúoffDay‚Äù, actually occur in this month.", "type": "FUNCTION_BLOCK", "input": [{"name": "onMonth", "type": "USInt", "description": "Month, in which the signal shall be set."}, {"name": "onDay", "type": "USInt", "description": "Day, at which the signal shall be set."}, {"name": "onWeekday", "type": "USInt", "description": "Day of the week on which the signal will be set; Sunday: 1, Monday: 2, Tuesday: 3, ..."}, {"name": "onHour", "type": "USInt", "description": "Hour, at which the signal shall be set."}, {"name": "onMinute", "type": "USInt", "description": "Minute, at which the signal shall be set."}, {"name": "offMonth", "type": "USInt", "description": "Month, in which the signal shall be reset."}, {"name": "offDay", "type": "USInt", "description": "Day, at which the signal shall be reset."}, {"name": "offWeekday", "type": "USInt", "description": "Day of the week on which the signal will be reset; Sunday: 1, Monday: 2, Tuesday: 3, ..."}, {"name": "offHour", "type": "USInt", "description": "Hour, at which the signal shall be reset."}, {"name": "offMinute", "type": "USInt", "description": "Minute, at which the signal shall be reset."}, {"name": "mode", "type": "USInt", "description": "Specifies the mode (see Principle of operation)"}], "output": [{"name": "signal", "type": "Bool", "description": "Output signal"}, {"name": "actLocalTime", "type": "DTL", "description": "Current local time"}, {"name": "error", "type": "Bool", "description": "FALSE: No error / TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB / 16#8000-16#FFFF: Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Sub function status code"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_NO_MODE_SELECTED", "16#8600": "ERR_RD_LOC_T"}, "user_defined_types": []}
{"title": "Rate of Change Limiter", "name": "LGF_LimRateOfChangeCI", "description": "## Short description ##\n\nThis function limits the rate of change of an input variable. A jump function becomes a ramp \nfunction.\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nThe ramp is a limit line and refers to a rate of change per second; if, for example, setChangeRate \n= 10.0 is parameterized at a sampling time of 1s/100ms/10ms for every block call, then if value \n> delayedValue, 10.0/1.0/0.1 is added to delayedValue until value is reached.\nThe limitation of the rate of change applies to both positive and negative values for the rise and \nfall.\nThe output delayedValue can be preset or initialized.\nThe time interval of the calling cyclic interrupt OB is determined by interconnecting the calling \ncyclic interrupt OB at the input parameter callOB.\nPre-assigning an output\nIf enDefaultOutValue = TRUE is set, the value at defaultOutValue is output. When changing \nfrom TRUE to FALSE, the output delayedValue is ramped from defaultOutValue to value. When \nchanging from FALSE to TRUE, the output delayedValue immediately jumps to defaultOutValue.", "type": "FUNCTION_BLOCK", "input": [{"name": "value", "type": "LReal", "description": "Signal to be processed and limited in its rate of change"}, {"name": "setChangeRate", "type": "LReal", "description": "Rate of change of ramp function"}, {"name": "defaultOutValue", "type": "LReal", "description": "Value for pre-assignment of the output variable"}, {"name": "enDefaultOutValue", "type": "Bool", "description": "Assign default output value"}, {"name": "callOB", "type": "OB_CYCLIC", "description": "Calling wake-alarm interrupt OB"}], "output": [{"name": "delayedValue", "type": "LReal", "description": "Output variable"}, {"name": "error", "type": "Bool", "description": "Error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8200": "ERR_NEG_RATE_LIM", "16#8600": "ERR_QRY_CINT", "16#8601": "ERR_OB_UNAVAILABLE"}, "user_defined_types": []}
{"title": "Standalone Data Logger with Advanced Configuration", "name": "LGF_DataLogC", "description": "## Short description ##\n\nLGF_DataLogC (C -> Compact) function integrates all the datalog system functions and can be \nused as standalone data logger.\n\n## Functional description ##\n\nThe function LGF_DataLogC combines the system functions for creating and writing data logs in \none block.\nThe procedure provides that an existing Datalog is opened on the basis of the name (name), if it \nwas not created before, this is recognized and the function creates the Datalog.\nAfterwards, depending on the parameterization, the data is written from data in an adjustable \ninterval or only on request to triggerLogEntry.\nReadMe The functionality of Datalogs can be found in the user manual:\n‚Ä¢ DataLogCreate\n‚Ä¢ DataLogOpen\n‚Ä¢ DataLogClose\n‚Ä¢ DataLogWrite\n‚Ä¢ DataLogClear\n‚Ä¢ DataLogDelete\nNOTICE The following parameters are only effective when creating a data log:\n‚Ä¢ parameter.header\n‚Ä¢ parameter.maxNumberOfEntries\n‚Ä¢ parameter.timestampFormat (S7-1200 and the S7-1500 support different formats, see the \nmanual DataLogCreate)\nNOTICE When logging data by interval (isLoggingByInterval) time variances occur, which are \ncaused by a fluctuating cycle time.\nTherefore it is recommended to call the function in a time interrupt OB besides the call in the \ncyclic program and to set the trigger for writing in this interrupt OB.\nNOTICE A data log which is deleted by the function without deleting the file cannot be created again \nas long as the file exists, it must first be deleted manually in the system.\nPlease also note the parameter parameter.deleteFile which also deletes the file next to the \ndata in case of a delete command deleteLog.", "type": "FUNCTION_BLOCK", "input": [{"name": "enable", "type": "Bool", "description": "TRUE: Enable functionality of FB"}, {"name": "name", "type": "String", "description": "Name of datalog, also used as file name"}, {"name": "triggerLogEntry", "type": "Bool", "description": "Rising edge trigger one entry in data log (only if `parameter.isLoggingByInterval` := FALSE)"}, {"name": "clearLog", "type": "Bool", "description": "Rising edge triggering clearing of datalog file"}, {"name": "deleteLog", "type": "Bool", "description": "Rising edge triggering deletion of datalog file if exist"}, {"name": "parameter", "type": "LGF_typeDataLogParameter", "description": "This UDT belongs to the Module `LGF_DataLogC` and lists all possible parameter to configure its behaviour."}], "output": [{"name": "valid", "type": "Bool", "description": "TRUE: Valid set of output values available at the FB"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is not finished and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}, {"name": "writeEntryDone", "type": "Bool", "description": "TRUE: DataLog write done successfully"}, {"name": "clearLogDone", "type": "Bool", "description": "TRUE: DataLog clear done successfully"}, {"name": "deleteLogDone", "type": "Bool", "description": "TRUE: DataLog delete done successfully"}, {"name": "lastEntryReached", "type": "Bool", "description": "TRUE: Last entry of datalog reached, if `enableRingBuffer` is set, start from beginning, otherwise block ends here"}, {"name": "noOfEntries", "type": "UDInt", "description": "Number of entries in datalog"}, {"name": "diagnostics", "type": "LGF_typeDiagnostics", "description": "Diagnostic structure to store and transfer diagnostic information from blocks trough the interface."}], "in/out": [{"name": "data", "type": "Variant", "description": "Data structure to log in datalog file"}], "return_value": [], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#7000": "STATUS_NO_CALL", "16#7001": "STATUS_FIRST_CALL", "16#7002": "STATUS_SUBSEQUENT_CALL", "16#7010": "STATUS_MAX_ENTRIES_REACHED", "16#8401": "ERR_WRONG_COMMAND_CALL_ORDER", "16#8600": "ERR_UNDEFINED_STATE", "16#8601": "ERR_DATALOG_OPEN", "16#8602": "ERR_DATALOG_CREATE", "16#8603": "ERR_DATALOG_CLOSE", "16#8604": "ERR_DATALOG_WRITE", "16#8605": "ERR_DATALOG_DELETE"}, "user_defined_types": [{"name": "LGF_typeDataLogParameter", "description": "This UDT belongs to the Module LGF_DataLogC and lists all possible parameter to configure its behaviour.", "member": [{"name": "header", "type": "String", "default": "", "description": "Headline of datalog, string of all data fields, separated by a comma: \"field1,field2,field3,...\""}, {"name": "maxNumberOfEntries", "type": "UDInt", "default": "1000", "description": "Maximum number of entries in datalog"}, {"name": "timestampFormat", "type": "USInt", "default": "0", "description": "Timestamp format"}, {"name": "clearOnOpen", "type": "Bool", "default": "FALSE", "description": "Clear datalog during opening datalog while enabling block"}, {"name": "deleteFile", "type": "Bool", "default": "FALSE", "description": "Delete as well datalog file during datalog delete"}, {"name": "enableRingBuffer", "type": "Bool", "default": "FALSE", "description": "TRUE: Overwrite old values and start from the beginning if datalog reaches its maximum entries FALSE: Stop logging if `maxNumberOfEntries` entries reached"}, {"name": "loggingByInterval", "type": "Bool", "default": "FALSE", "description": "TRUE: Log on interval time parameter FALSE: log on \"triggerEntry\""}, {"name": "loggingInterval", "type": "Time", "default": "T#1M", "description": "Time for automatic logging interval"}]}, {"name": "LGF_typeDiagnostics", "description": "Diagnostic structure to store and transfer diagnostic information from blocks trough the interface.", "member": [{"name": "status", "type": "Word", "default": "16#0000", "description": "Status of the Block or error identification when error occurred"}, {"name": "subfunctionStatus", "type": "Word", "default": "16#0000", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "stateNumber", "type": "DInt", "default": "0", "description": "State in the state machine of the block where the error occurred"}]}]}
{"title": "Non-Linear Interpolation Function", "name": "LGF_NonLinearInterpolation", "description": "## Short description ##\n\nThis function implements a characteristic curve. The characteristic curve is defined via an \ninterpolation point table with linear interpolation between the interpolation points. A prescribed \ninput value generates an output value in each cycle based on the characteristic curve from the \ninterpolation point table.\n\n## Functional description ##\n\nThe value of the output outputValue based on the following priority:\n1. As long as the input enDefaultOutValue is set, the value defined via the parameter \ndefaultOutValue will be output as output value.\n2. As long as the input reset is set, the block is reset and the output value is 0.0.\n3. If the input track is set, the output value will be output directly as input value, without \nconsideration of the characteristic curve.\n4. Based on the input value, a characteristic curve value is calculated via the linearly \ninterpolated, interpolation point table and output as an output value.\n‚Äì If the input value is between two interpolation points within the interpolation point table, \nthe output value is calculated as the intersection with the connecting line between the \npreceding and following interpolation points (see Figure below).\n‚Äì If the input value is before the first interpolation point (lowest value defined in the \ninterpolation point table), the output value will be calculated as the intersection of the \nline formed by the first two interpolation points of the interpolation point table.\n‚Äì If the input value is after the last interpolation point (highest value defined in the \ninterpolation point table), the output value will be calculated as the intersection of the \nline formed by the last two interpolation points of the interpolation point table.\nInterpolation point table\nThe interpolation point table is implemented through a variable of the data type Array. The type \nof the array corresponds to the PLC data type LGF_typeNonLinSetpoints.\nYou can create the interpolation point table in any global data block. The size of the array \ndepends on the number of interpolation points.\nNOTICE To keep the computing time of the block as short as possible, there is no check of the \nparameterization or the data of the interpolation point table.\nWhen entering the interpolation points in the interpolation point table, the following \nparticularities must be considered. If these particularities are not taken into account, it can \nlead to a malfunction of the block.\n‚Ä¢ At least two interpolation points must be entered in the interpolation point table.\n‚Ä¢ The interpolation points in the interpolation point table must be entered in the Table in ascending \norder of the input values.", "type": "FUNCTION_BLOCK", "input": [{"name": "value", "type": "LReal", "description": "Input value for calculating the output value"}, {"name": "defaultOutValue", "type": "LReal", "description": "Value for pre-assignment of the output variable"}, {"name": "enDefaultOutValue", "type": "Bool", "description": "Assign default output value"}, {"name": "track", "type": "Bool", "description": "Follow the value of the input without using the characteristic curve"}, {"name": "reset", "type": "Bool", "description": "Reset the interpolation if the point table is changed in running operation"}], "output": [{"name": "outputValue", "type": "LReal", "description": "The calculated output value from the input value"}], "in/out": [{"name": "setpoints", "type": "Array[*] of LGF_typeNonLinSetpoints", "description": "Setpoint table for defining the characteristic curve"}], "return_value": [], "status_codes": {}, "user_defined_types": [{"name": "LGF_typeNonLinSetpoints", "description": "Data type for setup a setpoint table", "member": [{"name": "inputValue", "type": "LReal", "default": "0.0", "description": "Input value to be interpolated"}, {"name": "outputValue", "type": "LReal", "default": "0.0", "description": "Corresponding interpolated value"}]}]}
