{"title": "LLCCA_ErrAcc", "description": "This function block LLCCA_ErrAcc calculates the error accumulator between the process value and the setpoint. It takes in process value (iPv), setpoint (iSp) and a reset signal (iReset) as input. When iReset is True, the error accumulator is set to 0, otherwise it updates the error accumulator by adding the product of the absolute difference between setpoint and process value and the time elapsed. The calculated error accumulator value is output as oErrAcc.", "type": "FUNCTION_BLOCK", "name": "LLCCA_ErrAcc", "input": [{"name": "iPv", "type": "Real", "description": "process value"}, {"name": "iSp", "type": "Real", "description": "setpoint"}, {"name": "iReset", "type": "Bool", "description": "reset"}], "output": [{"name": "oErrAcc", "type": "LReal", "description": "error accumulator output"}], "in/out": [], "return_value": []}
{"title": "LLCCA_MedianFilter", "description": "This function block LLCCA_MedianFilter is a median filter. It takes an input value (iVal) and a reset signal (iReset) as inputs. When the reset signal (iReset) is True, it fills the buffer with the input value and sets the output equal to the input. When iReset is False, it shifts the static buffer, saves the new input value to the buffer, sorts the temporary buffer, and then calculates and sets the output value (oVal) as the median of the sorted buffer values.", "type": "FUNCTION_BLOCK", "name": "LLCCA_MedianFilter", "input": [{"name": "iVal", "type": "Real", "description": "input value"}, {"name": "iReset", "type": "Bool", "description": "reset"}], "output": [{"name": "oVal", "type": "Real", "description": "output value"}], "in/out": [], "return_value": []}
{"title": "LLCCA_PID", "description": "This function block LLCCA_PID is a PID controller with step tuning. It takes in a setpoint (Setpoint), current process value (Input), manual value (ManualValue), and a reset signal (Reset) as input parameters. Based on the operation mode (ioMode), it performs different actions such as step tuning when in step tuning mode, calculates PID terms including proportional, integral, and derivative terms in automatic mode, and sets the output to the manual value in manual mode. It also has features like input filtering using median and PT1 filters, derivative calculation, and anti-integral windup control. The step tuning mode is designed to work with a FOPDT process model and calculates tuning parameters based on the process data collected during the tuning process.", "type": "FUNCTION_BLOCK", "name": "LLCCA_PID", "input": [{"name": "Setpoint", "type": "Real", "description": "controller setpoint"}, {"name": "Input", "type": "Real", "description": "current value from the process"}, {"name": "ManualValue", "type": "Real", "description": "manual value"}, {"name": "Reset", "type": "Bool", "description": "reset i term and all filters"}], "output": [{"name": "Out", "type": "Real", "description": "output value"}, {"name": "Terms", "type": "Struct", "description": "controller terms", "structMembers": [{"name": "p", "type": "Real", "description": "proportional term"}, {"name": "i", "type": "Real", "description": "integral term"}, {"name": "d", "type": "Real", "description": "derivative term"}]}], "in/out": [{"name": "ioMode", "type": "USInt", "description": "current mode of operation (0-Inactive, 1-Step tuning, 2-Reserved, 3-Automatic, 4-Manual)"}, {"name": "ioKp", "type": "Real", "description": "proportional gain", "default": 1.0}, {"name": "ioTi", "type": "Real", "description": "integral action time [s]", "default": 3.0}, {"name": "ioTd", "type": "Real", "description": "derivative action time [s]", "default": 0.0}], "return_value": []}
{"title": "LLCCA_PvSim", "description": "The LLCCA_PvSim function block is a process value simulator. It simulates a process value based on input parameters, considering additive and subtracting components with time lags and filters. It can be enabled or reset, and allows for configuration of factors, time lags, filters, and a noise factor. The simulation takes into account the change over time and random noise.", "type": "FUNCTION_BLOCK", "name": "LLCCA_PvSim", "input": [{"name": "enable", "type": "Bool", "description": "enable simulation"}, {"name": "input", "type": "Real", "description": "input (Output from PID) [%]"}, {"name": "reset", "type": "Bool", "description": "reset"}], "output": [{"name": "out", "type": "Real", "description": "simulated process value [unit]"}, {"name": "addComp", "type": "Real", "description": "additive component [unit/min]"}, {"name": "subComp", "type": "Real", "description": "subtracting component [unit/min]"}], "in/out": [{"name": "ioAddFactor", "type": "Real", "description": "additive component factor ( addComp := input * addFactor ; 100% * 0.01 = 1 unit/min )", "default": 1.0}, {"name": "ioAddTimeLag", "type": "USInt", "description": "additive component time lag [s]", "default": 1}, {"name": "ioAddFilter", "type": "Real", "description": "additive component filter [s]", "default": 5.0}, {"name": "ioSubType", "type": "USInt", "description": "0:start val proportial 1:constant"}, {"name": "ioSubFactor", "type": "Real", "description": "subtracting component factor ( subComp := ( out - subStartVal ) * subFactor ; sub (120 unit - 20 unit *0.01 = 1 unit/min)", "default": 1.0}, {"name": "ioSubTimeLag", "type": "USInt", "description": "subtracting component time lag [s]"}, {"name": "ioSubFilter", "type": "Real", "description": "subtracting component filter [s]"}, {"name": "ioSubConstant", "type": "Real", "description": "substracting constant", "default": 20.0}, {"name": "ioSubStartValue", "type": "Real", "description": "subtracting component start value [unit]", "default": 20.0}, {"name": "ioNoiceFactor", "type": "Real", "description": "random noice factor of simulated process value", "default": 0.1}], "return_value": []}
{"title": "LLCCA_TimeLag", "description": "This function block LLCCA_TimeLag is used to delay the output value by an adjustable time. It takes an input value (in), an initialization signal (init) to set the time lag memory to the input value, and a reset signal (reset) to set the time lag memory to 0.0 as input parameters. The time lag duration can be adjusted through the timeLag in/out variable. Based on the input signals and the current time lag setting, it saves the input values in an array and outputs a value that is delayed according to the time lag configuration. If the time lag is set to 0, the output is equal to the input.", "type": "FUNCTION_BLOCK", "name": "LLCCA_TimeLag", "input": [{"name": "in", "type": "Real", "description": "input value"}, {"name": "init", "type": "Bool", "description": "time lag memory = in"}, {"name": "reset", "type": "Bool", "description": "time lag memory = 0.0"}], "output": [{"name": "out", "type": "Real", "description": "output value"}], "in/out": [{"name": "timeLag", "type": "USInt", "description": "time lag [s]", "default": 10}], "return_value": []}
{"title": "Backup", "description": "This function block Backup is used for backup and restore operations of data blocks. It defines two user-defined data types (backupMainHeaderUDT and backupBLKHeaderUDT) for control parameters. The function block takes an identification number (Nr) and a timestamp (timestamp) as input. It uses in/out variables including main_header (containing main control parameters), BLK_header (containing control parameters for the current block), and DB_BLK (a reference to the data block to be backed up or restored). The block manages backup and restore processes separately. In the backup process, it checks conditions to start or stop saving a block, writes data to the block, updates counters, and reports status using an alarm function. In the restore process, it initializes the restore counter, starts or stops reading a block when conditions are met, reads data from the block, updates counters, and also reports status via an alarm function.", "type": "FUNCTION_BLOCK", "name": "Backup", "input": [{"name": "Nr", "type": "Int", "description": "Identifies the current block that is being processed"}, {"name": "timestamp", "type": "LDT", "description": "Timestamp for the backup or restore action"}], "output": [], "in/out": [{"name": "main_header", "type": "Struct", "description": "Contains the main control parameters for the process", "fields": [{"name": "save", "type": "Bool", "description": "Starts the backup process if TRUE"}, {"name": "restore", "type": "Bool", "description": "Starts the restore process if TRUE"}, {"name": "wr_counter", "type": "Int", "description": "Counter for the number of completed write operations"}, {"name": "rd_counter", "type": "Int", "description": "Counter for the number of completed read operations"}, {"name": "last_BLK", "type": "Int", "description": "Indicates the number of the last block that should be processed"}]}, {"name": "BLK_header", "type": "Struct", "description": "Contains the control parameters for the current block", "fields": [{"name": "save", "type": "Bool", "description": "Indicates whether the current block should be saved"}, {"name": "restore", "type": "Bool", "description": "Indicates whether the current block should be restored"}, {"name": "write", "type": "Bool", "description": "Starts the write operation if TRUE"}, {"name": "wr_busy", "type": "Bool", "description": "Indicates whether the write operation is currently running"}, {"name": "wr_process", "type": "Bool", "description": "Indicates that the write process is active"}, {"name": "wr_done", "type": "Bool", "description": "Indicates that the write operation is completed"}, {"name": "wr_ret", "type": "Int", "description": "Return value of the write operation, e.g., error codes"}, {"name": "wr_ret_mem", "type": "Int", "description": "Temporary storage of the last return value"}, {"name": "read", "type": "Bool", "description": "Starts the read operation if TRUE"}, {"name": "rd_busy", "type": "Bool", "description": "Indicates whether the read operation is currently running"}, {"name": "rd_process", "type": "Bool", "description": "Indicates that the read process is active"}, {"name": "rd_done", "type": "Bool", "description": "Indicates that the read operation is completed"}, {"name": "rd_ret", "type": "Int", "description": "Return value of the read operation, e.g., error codes"}, {"name": "rd_ret_mem", "type": "Int", "description": "Temporary storage of the last return value"}]}, {"name": "DB_BLK", "type": "Variant", "description": "Reference to the data block to be backed up or restored"}],"return_value": []}
{"title": "BufferManager", "description": "This function BufferManager is used for managing the loading and unloading of sheets in a buffer. It calculates the elapsed time of each loaded sheet, reads the system time, and updates the buffer status such as the number of loaded sheets, the time of the first loaded sheet, and various buffer-related statistics based on the loading and unloading input signals. It also handles operations like buffer reset. The function uses multiple user-defined data types (BufferUDT, BufferStructUDT) and a data block (BufferDB) to store and manage relevant data.", "type": "FUNCTION", "name": "BufferManager", "input": [{"name": "IN_P1", "type": "BOOL", "description": "Input signal for the loading process at position 117"}, {"name": "OUT_P1", "type": "BOOL", "description": "Output signal for the unloading process at position 117"}, {"name": "IN_P2", "type": "BOOL", "description": "Input signal for the loading process at position 217"}, {"name": "OUT_P2", "type": "BOOL", "description": "Output signal for the unloading process at position 217"}], "output": [], "in/out": [], "return_value": [], "dataBlocks": [{"name": "BufferDB", "type": "Struct", "description": "Data block for buffer positions", "fields": [{"name": "currentDT", "type": "DT", "description": "Current system time in the format DATE_AND_TIME"}, {"name": "currentDay", "type": "INT", "description": "Current day of the week"}, {"name": "currentTime", "type": "TOD", "description": "Current time of the day"}, {"name": "Buffer", "type": "ARRAY[1..2] OF BufferStructUDT", "description": "Array for 2 buffer structures", "fields": [{"name": "amountLoaded", "type": "INT", "description": "The current number of loaded sheets in the buffer"}, {"name": "firstLoadedTime", "type": "TOD", "description": "The time of day when the first sheet was loaded"}, {"name": "firstLoadedcurrentDay", "type": "INT", "description": "The day of loading of the first sheet (1 represents Sunday to 7 represents Saturday)"}, {"name": "firstExpiredTime", "type": "TIME", "description": "The elapsed time of the first sheet in the buffer"}, {"name": "load", "type": "BOOL", "description": "Start signal for the loading process"}, {"name": "unload", "type": "BOOL", "description": "Start signal for the unloading process"}, {"name": "manualLoad", "type": "BOOL", "description": "Start signal for the manual loading process"}, {"name": "manualUnload", "type": "BOOL", "description": "Start signal for the manual unloading process"}, {"name": "loadFlag", "type": "BOOL", "description": "Status flag for edge detection of the loading process"}, {"name": "unloadFlag", "type": "BOOL", "description": "Status flag for edge detection of the unloading process"}, {"name": "reset", "type": "BOOL", "description": "Signal to reset the entire buffer"}, {"name": "AmountFlag", "type": "INT", "description": "Previous value (used for calculating StatAmount0)"}, {"name": "currentDayFlag", "type": "INT", "description": "Previous value (used for calculation)"}, {"name": "StatBuffered", "type": "ARRAY[1..7] OF INT", "description": "The maximum number of buffered sheets per day"}, {"name": "firstExpiredTimeD", "type": "INT", "description": "The elapsed days of the first sheet in the buffer"}, {"name": "firstExpiredTimeH", "type": "INT", "description": "The elapsed hours of the first sheet in the buffer"}, {"name": "firstExpiredTimeM", "type": "INT", "description": "The elapsed minutes of the first sheet in the buffer"}, {"name": "firstExpiredTimeS", "type": "INT", "description": "The elapsed seconds of the first sheet in the buffer"}, {"name": "StatMaxTime", "type": "ARRAY[1..7] OF TIME", "description": "The maximum buffered time per day"}, {"name": "StatMaxTimeD", "type": "ARRAY[1..7] OF INT", "description": "The maximum buffered days of StatMaxTime"}, {"name": "StatMaxTimeH", "type": "ARRAY[1..7] OF INT", "description": "The maximum buffered hours of StatMaxTime"}, {"name": "StatMaxTimeM", "type": "ARRAY[1..7] OF INT", "description": "The maximum buffered minutes of StatMaxTime"}, {"name": "StatMaxTimeS", "type": "ARRAY[1..7] OF INT", "description": "The maximum buffered seconds of StatMaxTime"}, {"name": "StatAmount0", "type": "ARRAY[1..7] OF INT", "description": "The number of days when the storage was completely emptied"}, {"name": "StatPorzLoaded", "type": "INT", "description": "The percentage of the loaded buffer"}, {"name": "BufferSize", "type": "INT", "description": "The size of the buffer or the array"}, {"name": "Buffer", "type": "ARRAY [1..100] OF BufferUDT", "description": "Array for 100 buffer positions", "fields": [{"name": "loaded", "type": "BOOL", "description": "TRUE indicates a sheet is loaded"}, {"name": "loadedcurrentDay", "type": "INT", "description": "The day of loading (1 represents Sunday to 7 represents Saturday)"}, {"name": "loadedTime", "type": "TOD", "description": "The time of day when loading occurred"}, {"name": "loadedExpiredTime", "type": "TIME", "description": "The elapsed time since loading (in milliseconds)"}]}]}]}]}
{"title": "Edge Detection for Negative (Falling) Edge", "description": "This function is designed to detect the negative (falling) edge of an input signal. It takes an input signal and uses memory to store the previous state of the input. The function outputs a signal indicating the detection of a falling edge.", "type": "FUNCTION", "name": "EdgeDetectionNeg", "input": [{"name": "InputSignal", "type": "Bool", "description": "Input signal for detecting edges (used for detecting the falling edge)"}], "output": [], "in/out": [{"name": "NegEdgeOut", "type": "Bool", "description": "Output variable for the detected negative edge (falling edge)"}, {"name": "NegEdgeMem", "type": "Bool", "description": "Memory flag to store the previous state of the input signal for detecting the negative edge"}], "return_value": {"name": "EdgeDetectionNeg", "type": "Void", "description": "The function returns nothing as its purpose is to detect the falling edge and update the in/out variables."}}
{"title": "Edge Detection for Positive (Rising) Edge", "description": "This function is designed to detect the positive (rising) edge of an input signal. It takes an input signal and uses memory to store the previous state of the input. The function outputs a signal indicating the detection of a rising edge.", "type": "FUNCTION", "name": "EdgeDetectionPos", "input": [{"name": "InputSignal", "type": "Bool", "description": "Input signal for detecting edges (used for detecting the rising edge)"}], "output": [], "in/out": [{"name": "PosEdgeOut", "type": "Bool", "description": "Output variable for the detected positive edge (rising edge)"}, {"name": "PosEdgeMem", "type": "Bool", "description": "Memory flag to store the previous state of the input signal for detecting the positive edge"}], "return_value": {"name": "EdgeDetectionPos", "type": "Void", "description": "The function returns nothing as its purpose is to detect the rising edge and update the in/out variables."}}
{"title": "fb_alarming FUNCTION_BLOCK", "description": "This function block 'fb_alarming' is used for alarming functionality. It processes alarm messages stored in the 'MeldungenUDT' structure. It checks for errors in the alarm queue, generates reset pulses, resets the queue, detects new errors, and determines the state of the alarm system based on the presence of errors and new errors. It also updates the error and new error flags in the 'MeldungenUDT' structure.", "type": "FUNCTION_BLOCK", "name": "fb_alarming", "input": [], "output": [], "in/out": [{"name": "Meldungen", "type": "Struct", "description": "The user-defined data type containing alarm-related information including HMI acknowledgments, alarm queues, and other alarm status fields.", "fields": [{"name": "HMI", "type": "Struct", "description": "HMI-related alarm information", "fields": [{"name": "ACK", "type": "Bool", "description": "Meldung quittieren (Acknowledge the alarm)"}, {"name": "Meld_Quitt", "type": "Array[0..31] of Word", "description": "Meldungen und Quittiervariablen (Alarm messages and acknowledgment variables)"}]}]}, {"name": "Meld", "type": "Struct", "description": "Alarm status information", "fields": [{"name": "NewError", "type": "Bool", "description": "Indicates if there is a new error"}, {"name": "Error", "type": "Bool", "description": "Indicates if there is an error"}, {"name": "Reset", "type": "Bool", "description": "Reset operation for the alarm"}, {"name": "State", "type": "Byte", "description": "The state of the alarm system"}, {"name": "index", "type": "Int", "description": "Internal index (not externally accessible, visible or writable)", "ExternalAccessible": "False", "ExternalVisible": "False", "ExternalWritable": "False"}, {"name": "indexMax", "type": "Int", "description": "Maximum index (not externally accessible, visible or writable)", "ExternalAccessible": "False", "ExternalVisible": "False", "ExternalWritable": "False"}]}]}
{"title": "Motor_Control FUNCTION_BLOCK", "description": "The 'Motor_Control' function block is designed to manage the operation of a motor in a Programmable Logic Controller (PLC) system. It accepts various input parameters such as operation mode, speed input for a specific mode, run and stop requests, and time durations for running and stop delay. Based on these inputs, it controls the start and stop conditions of the motor using timers and determines the appropriate output values for different operation modes. The function block outputs the motor status in two different formats depending on the selected mode: a boolean value for mode 0 and a double word value representing the speed in mode 1.", "type": "FUNCTION_BLOCK", "name": "Motor_Control", "input": [{"name": "Mode", "type": "Int", "description": "Defines the operation mode of the motor. 0 indicates NoSpeedControling, and 1 indicates Speed Controling"}, {"name": "Speed_Input_Mode_1", "type": "Real", "description": "The speed input value when the motor is in mode 1 (Speed Controling)"}, {"name": "Request_Run", "type": "Bool", "description": "A boolean input to request the motor to start running"}, {"name": "Request_Stop", "type": "Bool", "description": "A boolean input to request the motor to stop running"}, {"name": "Time_Run", "type": "Time", "description": "The time duration for which the motor should run after the start request is made"}, {"name": "Stop_Delay", "type": "Time", "description": "The time delay for the motor to stop after the stop request is made"}], "output": [{"name": "MotorStatus_Mode_0", "type": "Bool", "description": "Represents the motor status in mode 0. TRUE when the motor is running, FALSE when it is stopped"}, {"name": "MotorStatus_Mode_1", "type": "DWord", "description": "Represents the motor status in mode 1. Holds the converted speed value when the motor is running and 0 when it is stopped or not started"}], "in/out": [], "return_value": []}
{"title": "Picker_Station FUNCTION_BLOCK", "description": "The 'Picker_Station' function block is used to control the operation of a pick - and - place station. It takes several input signals related to start, item detection, movement detection, and place sensor status. Based on these inputs and a step counter, it controls the movement of the picker in the Z and X axes and the pick action. The function block operates in three steps: picking and moving, placing and releasing the item, and returning to the base position.", "type": "FUNCTION_BLOCK", "name": "Picker_Station", "input": [{"name": "Start_Pick", "type": "Bool", "description": "Boolean input to start the picking process"}, {"name": "Item_Detected", "type": "Bool", "description": "Indicates whether an item is detected"}, {"name": "Detection_Moving_Z", "type": "Bool", "description": "Indicates movement in the Z - axis"}, {"name": "Detection_Moving_X", "type": "Bool", "description": "Indicates movement in the X - axis"}, {"name": "Place_Sensor", "type": "Bool", "description": "Sensor status for the placement location"}], "output": [{"name": "ZMovement", "type": "Bool", "description": "Control signal for movement in the Z - axis"}, {"name": "XMovement", "type": "Bool", "description": "Control signal for movement in the X - axis"}, {"name": "Pick", "type": "Bool", "description": "Control signal for the pick action, initialized to False"}], "in/out": [], "return_value": []}
{"title": "Elevator FUNCTION_BLOCK","description": "The 'Elevator' function block is designed for controlling an elevator system in a Programmable Logic Controller (PLC) environment. It takes multiple input parameters including operation mode (loading or unloading), base floor for loading/unloading, target floor, various requests like load, jam levels, floor level sensors' statuses, and load delay time. Based on these inputs, it determines the appropriate actions for the elevator such as motor direction (up, down, slow), loading or unloading objects, and generating stop requests. The function block has two main operation modes: load mode and unload mode. In load mode, it checks the current floor, moves the elevator to the base floor for loading if needed, and then to the target floor. In unload mode, it selects a floor for loading based on requests, moves to that floor, loads the object, and then moves to the unloading base floor. It also takes into account jam requests at different floors to trigger unloading. The output variables represent the control signals for the elevator's motor and the actions related to loading and unloading.","type": "FUNCTION_BLOCK","name": "Elevator","input": [{"name": "Mode_0_Load_1_Unload","type": "Int","description": "0 for Load mode and 1 for Unload mode"},{"name": "Load_Unload_Base_Floor","type": "Int","description": "The base floor for loading or unloading operations"},{"name": "Target_Floor_In","type": "Int","description": "The target floor that the elevator is supposed to go to"},{"name": "Load_Request","type": "Bool","description": "A boolean signal to request the elevator to load an object"},{"name": "Jam_Request_Lv1","type": "Bool","description": "Jam request level 1 at floor 1, used to trigger unloading"},{"name": "Jam_Request_Lv2","type": "Bool","description": "Jam request level 2 at floor 2, used to trigger unloading"},{"name": "Jam_Request_Lv3","type": "Bool","description": "Jam request level 3 at floor 3, used to trigger unloading"},{"name": "Floor_1_Low","type": "Bool","description": "Lower sensor status of floor 1, used for floor detection and speed control"},{"name": "Floor_1_High","type": "Bool","description": "Higher sensor status of floor 1, used for floor detection"},{"name": "Floor_2_Low","type": "Bool","description": "Lower sensor status of floor 2, used for floor detection and speed control"},{"name": "Floor_2_High","type": "Bool","description": "Higher sensor status of floor 2, used for floor detection"},{"name": "Floor_3_Low","type": "Bool","description": "Lower sensor status of floor 3, used for floor detection and speed control"},{"name": "Floor_3_High","type": "Bool","description": "Higher sensor status of floor 3, used for floor detection"},{"name": "Load_From_Floor_1","type": "Bool","description": "A boolean signal indicating a request to load from floor 1 in unload mode"},{"name": "Load_From_Floor_2","type": "Bool","description": "A boolean signal indicating a request to load from floor 2 in unload mode"},{"name": "Load_From_Floor_3","type": "Bool","description": "A boolean signal indicating a request to load from floor 3 in unload mode"},{"name": "At_Exit","type": "Bool","description": "A boolean signal indicating the elevator is at the exit position, used for various control decisions"},{"name": "Load_Delay","type": "Time","description": "The time delay for the load operation"}],"output": [{"name": "MotorUp","type": "Bool","description": "A boolean signal to control the elevator motor to move up"},{"name": "MotorDown","type": "Bool","description": "A boolean signal to control the elevator motor to move down"},{"name": "Motor_Slow","type": "Bool","description": "A boolean signal to control the elevator motor to move at a slow speed, usually when approaching a floor"},{"name": "Load_Object","type": "Bool","description": "A boolean signal indicating that the elevator is loading an object"},{"name": "UnLoad_Object","type": "Bool","description": "A boolean signal indicating that the elevator is unloading an object"},{"name": "Stop_Request_1","type": "Bool","description": "A boolean signal to generate a stop request for the elevator, related to specific conditions"},{"name": "Stop_Request_2","type": "Bool","description": "A boolean signal to generate a stop request for the elevator, related to specific conditions"},{"name": "Stop_Request_3","type": "Bool","description": "A boolean signal to generate a stop request for the elevator, related to specific conditions"}],"in/out": [],"return_value": []}
{"title": "Buffer_Station FUNCTION_BLOCK","description": "The 'Buffer_Station' function block is designed for controlling a buffer station in a Programmable Logic Controller (PLC) system. It takes input parameters such as a work request signal, blade delay time, and rest delay time. Based on these inputs, it uses edge trigger functions and timers to determine the working state of the buffer station. When either the blade delay timer or the rest delay timer is active, it sets the internal 'Work' variable to true, which in turn controls the output 'StopBlade_Status' to indicate whether the blade should be stopped or not. The function block uses rising and falling edge trigger instructions to handle the changes in the work request signal and timers to manage the delays for different operations.","type": "FUNCTION_BLOCK","name": "Buffer_Station","input": [{"name": "Work_Request", "type": "Bool", "description": "A boolean signal indicating a request for the buffer station to start working"}, {"name": "Blade_Delay", "type": "Time", "description": "The time delay for the blade operation in the buffer station"}, {"name": "Rest_Delay", "type": "Time", "description": "The time delay for the rest position operation in the buffer station"}],"output": [{"name": "StopBlade_Status", "type": "Bool", "description": "A boolean signal indicating whether the blade in the buffer station should be stopped. True when the buffer station is in a working state according to the delay conditions, and false otherwise"}],"in/out": []}
{"title": "NotAusLeuchtring FUNCTION", "description": "The 'NotAusLeuchtring' function is designed to control the state of a lamp in a Programmable Logic Controller (PLC) system. It takes two input parameters: 'NA_Input' which is a boolean indicating an emergency input, and 'Interval' which is another boolean value. When the 'NA_Input' is true, the function sets the 'Lamp' output to true, turning the lamp on. When the 'NA_Input' is false, the state of the 'Lamp' output is set to the value of the 'Interval' input. In essence, it prioritizes turning on the lamp when there is an emergency input and uses the 'Interval' value to control the lamp's state otherwise.", "type": "FUNCTION", "name": "NotAusLeuchtring", "input": [{"name": "NA_Input", "type": "Bool", "description": "A boolean input indicating an emergency input. When true, it forces the lamp to turn on."}, {"name": "Interval", "type": "Bool", "description": "A boolean input that determines the state of the lamp when there is no emergency input (NA_Input is false)."}], "output": [{"name": "Lamp", "type": "Bool", "description": "A boolean output representing the state of the lamp. True means the lamp is on, and false means the lamp is off."}], "in/out": [], "return_value": []}
{"title": "fb_PSE200U FUNCTION_BLOCK", "description": "The 'fb_PSE200U' function block is designed to control and monitor the PSE200U device. It takes an input signal 'S' to start the operation sequence. The block has multiple output variables including channel statuses (CH1 - CH4), an error indicator, and a detailed status code. It uses timers for sequence timing, step checking, and error detection. The operation sequence consists of initialization, intermediate steps for pauses and channel checks, and a final step for completion and error checking. Error handling is based on different conditions such as sequence not starting, stopping unexpectedly, or issues during channel checks or pauses. Finally, it assigns the channel statuses and error information to the output variables.", "type": "FUNCTION_BLOCK", "name": "fb_PSE200U", "input": [{"name": "S", "type": "Bool", "description": "Input signal indicating the operational status of the PSE200U device"}], "output": [{"name": "CH1", "type": "Bool", "description": "Status of Channel 1 (TRUE if the channel is functioning correctly)"}, {"name": "CH2", "type": "Bool", "description": "Status of Channel 2 (TRUE if the channel is functioning correctly)"}, {"name": "CH3", "type": "Bool", "description": "Status of Channel 3 (TRUE if the channel is functioning correctly)"}, {"name": "CH4", "type": "Bool", "description": "Status of Channel 4 (TRUE if the channel is functioning correctly)"}, {"name": "error", "type": "Bool", "description": "General error indicator for the PSE200U device (TRUE if an error is detected)"}, {"name": "status", "type": "Int", "description": "Detailed status of the PSE200U, reflecting various states or errors"}], "in/out": [], "return_value": [], "status_codes": {"0": "No error", "1": "Channel error (failed during a channel check)", "2": "Pause error (failed during a pause)", "3": "Sequence not started", "4": "Sequence stopped unexpectedly"}}
{"title": "FB_Taktgenerator and udt_tg_takt Definition", "description": "Defines a user - defined data type 'udt_tg_takt' for storing different frequency Takt signals and a function block 'FB_Taktgenerator' to generate and manage these Takt signals along with edge detection signals. The function block reads the system time, assigns Takt intervals, updates Takt signals based on time differences, assigns the generated Takt signals to output, performs edge detection, and assigns edge detection signals to output.", "type": "Function Block and Type Definition", "name": "FB_Taktgenerator and udt_tg_takt", "input": [], "output": [{"name": "Takt_Signals", "type": "udt_tg_takt", "description": "Output struct for Takt signals"}, {"name": "Edge_Signals", "type": "udt_tg_takt", "description": "Output struct for Edge detection signals"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": [{"name": "udt_tg_takt", "description": "A struct type for storing different frequency Takt signals", "member": [{"name": "Takt_10Hz", "type": "Bool", "description": "10 Hz Takt Signal"}, {"name": "Takt_5Hz", "type": "Bool", "description": "5 Hz Takt Signal"}, {"name": "Takt_2_5Hz", "type": "Bool", "description": "2.5 Hz Takt Signal"}, {"name": "Takt_2Hz", "type": "Bool", "description": "2 Hz Takt Signal"}, {"name": "Takt_1_25Hz", "type": "Bool", "description": "1.25 Hz Takt Signal"}, {"name": "Takt_1Hz", "type": "Bool", "description": "1 Hz Takt Signal"}, {"name": "Takt_0_625Hz", "type": "Bool", "description": "0.625 Hz Takt Signal"}, {"name": "Takt_0_5Hz", "type": "Bool", "description": "0.5 Hz Takt Signal"}, {"name": "Takt_0_25Hz", "type": "Bool", "description": "0.25 Hz Takt Signal"}, {"name": "Takt_0_2Hz", "type": "Bool", "description": "0.2 Hz Takt Signal"}]}]} 
{"title": "Zustimmtaster_SSP FUNCTION_BLOCK", "description": "The 'Zustimmtaster_SSP' function block is designed for a specific control system in a Programmable Logic Controller (PLC). It takes multiple input variables including emergency halt status, a three-position switch status, an activity sensor signal, BCD count bits, left and right switch signals, an LED blinking clock signal, and a BCD offset value. Based on these inputs, it controls the state of red and green LED indicators, left and right output signals, and calculates a BCD number. It also manages internal variables like a release signal, edge flags for switches, and caches for BCD numbers. The block determines the bit values from the BCD input bits, sums them to calculate the BCD number, checks for changes in the BCD number, and controls the release signal accordingly. It also generates pulses on the rising edges of certain switches and uses them to control the left and right output signals. Finally, it sets individual output arrays based on the BCD number and the state of the left and right output signals.", "type": "FUNCTION_BLOCK", "name": "Zustimmtaster_SSP", "input": [{"name": "not_halt_OK", "type": "bool", "description": "Emergency halt OK signal. When false, it turns on the red LED."}, {"name": "drei_pos_sw", "type": "Bool", "description": "Three-position switch (agreement switch). Used for enabling release and other control logic."}, {"name": "activity_sensor", "type": "Bool", "description": "Activity sensor on the wall mount. Contributes to the green LED activation and release conditions."}, {"name": "Bit_0", "type": "bool", "description": "Bit 0 for BCD counting. Used to calculate the BCD number."}, {"name": "Bit_1", "type": "bool", "description": "Bit 1 for BCD counting. Used to calculate the BCD number."}, {"name": "Bit_2", "type": "bool", "description": "Bit 2 for BCD counting. Used to calculate the BCD number."}, {"name": "Bit_3", "type": "bool", "description": "Bit 3 for BCD counting. Used to calculate the BCD number."}, {"name": "SW_Right", "type": "bool", "description": "Right switch. Used to block the left output and control the right output."}, {"name": "SW_Left", "type": "bool", "description": "Left switch. Used to control the left output."}, {"name": "LED_Takt", "type": "bool", "description": "Clock for LED blinking. Contributes to the green LED activation."}, {"name": "BCD_offset", "type": "int", "description": "BCD offset value. Added to the sum of the BCD bits to calculate the final BCD number."}], "output": [{"name": "LED_Red", "type": "bool", "description": "Red LED display. Turns on when the emergency halt is not okay."}, {"name": "LED_Green", "type": "bool", "description": "Green LED display. Turns on based on the activity sensor, three-position switch state, and release signal when the emergency halt is okay."}, {"name": "Out_Right", "type": "bool", "description": "Right output. Activated when the right switch is triggered, there is a release, and the left switch is not active, and the emergency halt is okay."}, {"name": "Out_Left", "type": "bool", "description": "Left output. Activated when the left switch is triggered, there is a release, and the right switch is not active, and the emergency halt is okay."}, {"name": "BCD_Nr", "type": "int", "description": "Calculated BCD number based on the BCD input bits and offset."}, {"name": "OutputLeft", "type": "ARRAY[1..16] OF BOOL", "description": "Array of 16 boolean values. Each element is set to true when the BCD number matches the index and the left output is active."}, {"name": "OutputRight", "type": "ARRAY[1..16] OF BOOL", "description": "Array of 16 boolean values. Each element is set to true when the BCD number matches the index and the right output is active."}], "in/out": [], "return_value": []}
{"title": "rezept_ex-import FUNCTION_BLOCK", "description": "The 'rezept_ex-import' function block is designed for handling recipe export and import operations in a Programmable Logic Controller (PLC) system. It utilizes two user-defined data types, 'exportDataUDT' and 'importDataUDT', which contain boolean and word variables to manage request, completion, busy, error, and status information. The function block takes these data types and a 'Variant' type 'DB' as input/output variables. Internally, it instantiates 'RecipeExport' and 'RecipeImport' functions to handle the actual export and import of recipes, along with 'Program_Alarm' functions to manage error and status information. When the export request is active and not already busy, the 'RecipeExport_Instance' function is called, and the request is reset to prevent repeated activation. The error or completion status is used to store the last error status, and the status is converted from word to byte and passed to the 'Export_Data' function. Similarly, for the import operation, the 'RecipeImport_Instance' function is called under appropriate conditions, and the same processing steps for request reset, error handling, and status conversion are applied.", "type": "FUNCTION_BLOCK", "name": "rezept_ex-import", "input": [], "output": [], "in/out": [{"name": "exportDataUDT", "type": "exportDataUDT", "description": "User-defined data type structure for managing export operation status and related information, including request, done, busy, error, status, and last error status."}, {"name": "importDataUDT", "type": "importDataUDT", "description": "User-defined data type structure for managing import operation status and related information, including request, done, busy, error, status, and last error status."}, {"name": "DB", "type": "Variant", "description": "Variant type representing the recipe database used in both export and import operations."}], "return_value": [], "status_codes": {}, "user_defined_types": [{"name": "importDataUDT", "description": "User-defined data type with boolean variables 'req', 'done', 'busy', 'error' and word variables 'status', 'lastErrorStatus' to manage import operation status.", "member": [{"name": "req", "type": "Bool", "description": "Request for the import operation"}, {"name": "done", "type": "Bool", "description": "Indicates if the import operation is completed"}, {"name": "busy", "type": "Bool", "description": "Indicates if the import operation is currently running"}, {"name": "error", "type": "Bool", "description": "Indicates if an error occurred during the import operation"}, {"name": "status", "type": "Word", "description": "Status of the import operation"}, {"name": "lastErrorStatus", "type": "Word", "description": "Last error status of the import operation"}]}, {"name": "exportDataUDT", "description": "User-defined data type with boolean variables 'req', 'done', 'busy', 'error' and word variables 'status', 'lastErrorStatus' to manage export operation status.", "member": [{"name": "req", "type": "Bool", "description": "Request for the export operation"}, {"name": "done", "type": "Bool", "description": "Indicates if the export operation is completed"}, {"name": "busy", "type": "Bool", "description": "Indicates if the export operation is currently running"}, {"name": "error", "type": "Bool", "description": "Indicates if an error occurred during the export operation"}, {"name": "status", "type": "Word", "description": "Status of the export operation"}, {"name": "lastErrorStatus", "type": "Word", "description": "Last error status of the export operation"}]}]}
{"title": "FB_TempSimulation FUNCTION_BLOCK", "description": "The 'FB_TempSimulation' function block is designed to simulate temperature changes in a Programmable Logic Controller (PLC) system. It takes input parameters such as heating power (a percentage value between 0.0 and 100.0), heating time constant, cooling time constant, maximum temperature (scaled by a factor of 10), and ambient temperature (also scaled by a factor of 10). Based on these inputs, it calculates the target temperature according to the heating power. Then, it determines whether to heat or cool by comparing the target temperature with the current temperature (an input/output variable scaled by a factor of 10). When heating, it calculates the change in temperature per cycle based on the heating time constant and updates the current temperature. Similarly, when cooling, it does the same using the cooling time constant. The current temperature is also limited to stay within the range of the ambient and maximum temperatures. Finally, it converts the current temperature from a real number to an integer (scaled by a factor of 10) and outputs it as the simulated temperature.", "type": "FUNCTION_BLOCK", "name": "FB_TempSimulation", "input": [{"name": "Heizleistung", "type": "Real", "description": "Heating power percentage ranging from 0.0 to 100.0 used to calculate the target temperature."}, {"name": "ZeitkonstHeizen", "type": "Real", "description": "Heating time constant with a default value of 8000.0 used in the heating calculation."}, {"name": "ZeitkonstKühlen", "type": "Real", "description": "Cooling time constant with a default value of 15000.0 used in the cooling calculation."}, {"name": "MaxTemp", "type": "Int", "description": "Maximum temperature scaled by a factor of 10 (e.g., 3000 represents 300.0°C)."}, {"name": "UmgebungTemp", "type": "Int", "description": "Ambient temperature scaled by a factor of 10 (e.g., 150 represents 15.0°C)."}], "output": [{"name": "Temperatur", "type": "Int", "description": "Simulated temperature output scaled by a factor of 10 (e.g., 3000 represents 300.0°C)."}], "in/out": [{"name": "Temp_Aktuell", "type": "Real", "description": "Current temperature variable scaled by a factor of 10 (e.g., 105.0 represents 10.5°C), used for internal calculations and updated during the simulation."}], "return_value": [], "status_codes": {}, "user_defined_types": [], "var_constant": [{"name": "CYCLE_TIME", "type": "Real", "value": 0.1, "description": "Constant cycle time value used in the temperature change calculations."}]}
