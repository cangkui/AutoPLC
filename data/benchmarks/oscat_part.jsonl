{"title": "BASE64 Decoder Function", "description": "BASE64_DECODE_STR encoded in BASE64 text can be converted\n\nback to plain text. With a positive edge of RUN the process starts. Here\n\nDONE is immediately reseted, if it has been set by a previous conversion.\n\nThe BASE64 encoded text is passed on STR1, and after the conversion the\n\nplain text is available in STR2, and DONE is set to TRUE.", "type": "FUNCTION", "name": "BASE64_DECODE_STR", "input": [{"name": "RUN", "type": "BOOL", "description": "A boolean value that when set to TRUE by a positive edge initiates the conversion process."}, {"name": "STR1", "type": "STRING(192)", "description": "The BASE64 encoded string that will be converted to plain text."}], "output": [{"name": "DONE", "type": "BOOL", "description": "A boolean value that indicates if the conversion has been completed. It is set to TRUE once the conversion finishes."}, {"name": "STR2", "type": "STRING(144)", "description": "The converted plain text output from the BASE64 encoded input string."}], "in/out": [], "return_value": null}
{"title": "BASE64 Decoder Function", "description": "BASE64_DECODE_STREAM arbitrarily long BASE64 byte streams are\n\ndecoded. In one pass, up to 64 bytes are decoded, which in turn emerged\n\nfrom a maximum of 48 bytes each. Here, the source data is passed to the\n\n73 Version 1.21\n\nChapter 8. Converter\n\ndecoder over BUF1 in the data-stream manner as individual blocks of\n\ndata, and in decoded form re-issued in BUF2. The user has to provide the\n\nfurther processing of the BUF2 data before the next block of data is con￾verted. The number of bytes in BUF2 is issued by SIZE2 from the module.", "type": "FUNCTION", "name": "BASE64_DECODE_STREAM", "input": [{"name": "SIZE1", "type": "INT", "description": "Number of bytes in BUF1 for decode."}, {"name": "BUF1", "type": "ARRAY [0..63] OF BYTES", "description": "BASE64 data for conversion."}], "output": [{"name": "SIZE2", "type": "INT", "description": "Number of bytes in BUF2 of the decoded results."}, {"name": "BUF2", "type": "ARRAY [0..47] OF BYTES", "description": "Converted data."}], "in/out": [], "return_value": {"type": "void", "description": "The function does not return a value; it outputs results via parameters."}}
{"title": "BASE64 Encoding Function Module", "description": "BASE64_ENCODE_STR a standard text can be converted to a BASE64\n\nencoded text. With a positive edge of RUN the process starts. Here DONE\n\nis immediately reseted, if it has been set by a previous conversion. The\n\nBASE64 encoded text is passed on STR1, and after the conversion the BA￾SE64 text is available in STR2, and DONE is set to TRUE.", "type": "FUNCTION", "name": "BASE64_ENCODE_STR", "input": [{"name": "RUN", "type": "BOOL", "description": "A positive edge signal that initiates the BASE64 conversion."}, {"name": "STR1", "type": "STRING(144)", "description": "The standard text input that is to be converted to BASE64 format."}], "output": [{"name": "DONE", "type": "BOOL", "description": "Indicates if the BASE64 conversion has been completed successfully."}, {"name": "STR2", "type": "STRING(192)", "description": "The resulting BASE64 encoded text after the conversion."}], "in/out": [], "return_value": null}
{"title": "Base64 Encode Stream Function", "description": "BASE64_ENCODE_STREAM arbitrarily long byte data stream accor￾ding to BASE64 can be encoded. In one pass, up to 48 bytes are conver￾ted, in turn, result more than 64 bytes. Here, the source data is passed to\n\nthe encoder over BUF1 in the data-stream manner as individual blocks of\n\ndata, and in coded form re-issued in BUF2. The user has to provide the fur￾ther processing of the BUF2 data before the next block of data is conver￾ted. The number of bytes in BUF2 is issued by SIZE2 from the module.", "type": "FUNCTION", "name": "BASE64_ENCODE_STREAM", "input": [{"name": "SIZE1", "type": "INT", "description": "Number of bytes in the BUF1 to encode."}, {"name": "BUF1", "type": "ARRAY", "description": "Data to convert.", "fields": [{"name": "0..47", "type": "BYTES", "description": "Array of bytes containing the data to be Base64 encoded."}]}], "output": [{"name": "SIZE2", "type": "INT", "description": "Number of bytes in the encoded BUF2 results."}, {"name": "BUF2", "type": "ARRAY", "description": "BASE64 converted data.", "fields": [{"name": "0..63", "type": "BYTES", "description": "Array of bytes containing the Base64 encoded data."}]}], "in/out": [], "return_value": null}
{"title": "CSV Parser Buffer Function", "description": "CSV_PARSER_BUF enables the analysis of the elements \n\ncontained in the bufer. The number of data contained on PT.SIZE \n\nspecifed. The separator is specifed in parameter \"SEP\". The search for \n\nelements that always begins, depending on the given \"OFFSET\", so it is \n\nvery easy to look at certain points in order to not always have to search \n\nthe entire bufer. At the beginning should be started with by default the \n\nOFFSET 0 (but need not).\n\nAt the beginning of the default should be started OFFSET 0 (but need not). \n\nOf course this is dependent on the content or the structure of the data.\n\nEvaluate elements:\n\nWill specify in SEP 0, lines are always evaluated completely and parameter \n\n\"VALUE\" is issued. If the elements in the bufer are structured as CSV \n\n(Excel), so at SEP the separator ',' or something else can be specifed. RUN \n\n= 1 startes the evaluation. Since it is not foreseeable how long the search \n\n147 Version 1.21\n\nChapter 10. File-System\n\ntakes, a watchdog function is Integrated that stops the search for the \n\ncurrent cycle, then RESULT = 5 and RUN remains unchanged. In the next \n\ncycle, the analysis proceeds automatically. As soon as the next element is \n\ndetected, the element in VALUE is passed, and RESULT is 1. If the element \n\nis also the last in a line, then RESULT = 2 is the output. As soon as the end \n\nof the data has been reached at RESULT = 10 passed. Always if yet RUN = \n\n0 is output, RESULT defnes the result. If an item is longer than the \n\nmaximum length (string_length) so the characters are cut of \n\nautomatically. The parameter OFFSET is by the module automatically \n\npassed after each result, but can be defned individually before each \n\nevaluation.", "type": "FUNCTION", "name": "CSV_PARSER_BUF", "input": [{"name": "SEP", "type": "BYTE", "description": "The separator used for parsing the buffer."}, {"name": "RUN", "type": "BYTE", "description": "Command code for the current action (0 for no function, 1 to evaluate elements)."}, {"name": "OFFSET", "type": "UDINT", "description": "Current file offset of the query, starting from 0 by default."}, {"name": "VALUE", "type": "STRING", "description": "Output value of the current key processed in the buffer."}, {"name": "PT", "type": "NETWORK_BUFFER", "description": "The read data buffer that contains the elements to be analyzed."}], "output": [{"name": "RESULT", "type": "BYTE", "description": "Result of the query indicating the evaluation status."}], "in/out": [], "return_value": null}
{"title": "CSV Parser File Module", "description": "CSV_PARSER_FILE enables the analysis of the elements of an \n\narbitrarily large fle which is read into the read data bufer block by block \n\nfor automatically processing. The separator is specifed in parameter \n\n\"SEP\". The name of the fle is passed in parameter \"FILENAME\". The search \n\nfor elements that always begins, depending on the given \"OFFSET\", so it is \n\nvery easy to look at certain points in order to not always have to search \n\nthe entire bufer. At the beginning should be started with by default the \n\nOFFSET 0 (but need not).\n\nWhen queried by elements of the fle, there are various procedures. Of \n\ncourse this is dependent on the content or the structure of the data.\n\nEvaluate elements:\n\nWill specify in SEP 0, lines are always evaluated completely and parameter \n\n\"VALUE\" is issued. If the elements in the fle are structured as CSV (Excel), \n\nso at SEP the separator ',' or something else can be specifed. RUN = 1 \n\nstartes the evaluation. Since it is not foreseeable how long the search \n\ntakes, a watchdog function is Integrated that stops the search for the \n\ncurrent cycle, then RESULT = 5 and RUN remains unchanged. In the next \n\ncycle, the analysis proceeds automatically. As soon as the next element is \n\ndetected, the element in VALUE is passed, and RESULT is 1. If the element \n\nis also the last in a line, then RESULT = 2 is the output. As soon as the end \n\nof the data has been reached at RESULT = 10 passed. Always if yet RUN = \n\n0 is output, RESULT defnes the result. If an item is longer than the \n\nmaximum length (string_length) so the characters are cut of \n\nautomatically. The parameter OFFSET is by the module automatically \n\npassed after each result, but can be defned individually before each \n\nevaluation.", "type": "FUNCTION", "name": "CSV_PARSER_FILE", "input": [{"name": "SEP", "type": "BYTE", "description": "The separator used to delineate elements in the file."}, {"name": "FILE_NAME", "type": "STRING", "description": "The name of the file to be processed."}, {"name": "FSD", "type": "FILE_SERVER_DATA", "description": "The file interface for handling file operations."}, {"name": "RUN", "type": "BYTE", "description": "The command code to initiate actions (1 to evaluate elements, 0 when no function to perform)."}, {"name": "OFFSET", "type": "UDINT", "description": "The current file offset for the query."}, {"name": "VALUE", "type": "STRING", "description": "The value of a key that is parsed from the file."}, {"name": "PT", "type": "NETWORK_BUFFER", "description": "Buffer used for reading data from the file."}], "output": [{"name": "RESULT", "type": "BYTE", "description": "The result of the query indicating the status of the evaluation."}], "in/out": [], "return_value": {"type": "void", "description": "The function does not return any value but modifies the parameters as necessary based on the evaluation process."}}
{"title": "DLOG_BOOL Function Module", "description": "DLOG_BOOL is for logging (recording) of a process value of type BOOL, \n\nand can only be used in combination with a DLOG_STORE_* module, as this \n\ncoordinates of the data structure X to record the data. At recording formats that \n\nsupport a process value name, such as at DLOG_STORE_FILE_CSV a name can be \n\nprovided at COLUMN\". Depending on the state of the STATE the TEXT of parameter \n\nOFF or ON is used. If with DELTA parameter a TRUE is specified, the automatic data \n\nlogging is enabled via differential monitoring. By changing the state of STATE \n\nautomatically a record is stored. This feature can be applied in parallel to the central \n\ntrigger on the DLOG_STORE_ * module.", "type": "FUNCTION", "name": "DLOG_BOOL", "input": [{"name": "X", "type": "DLOG_DATA", "description": "The DLOG data structure used for logging.", "fields": []}, {"name": "STATE", "type": "BOOL", "description": "Process value indicating TRUE or FALSE."}, {"name": "ON", "type": "STRING", "description": "Text to use when STATE is TRUE."}, {"name": "OFF", "type": "STRING", "description": "Text to use when STATE is FALSE."}, {"name": "COLUMN", "type": "STRING", "description": "The name of the process value, limited to 40 characters.", "fields": []}, {"name": "DELTA", "type": "DINT", "description": "Difference value for enabling automatic data logging via differential monitoring."}], "output": [], "in/out": [], "return_value": {}}
{"title": "DLOG_DINT Function Module", "description": "DLOG_DINT is for logging (recording) of a process value of type DINT, and \n\ncan only be used in combination with a DLOG_STORE_* module, as this coordinates \n\nof the data structure X to record the data. At recording formats that support a process \n\nvalue name, such as at DLOG_STORE_FILE_CSV a name can be provided at \n\nCOLUMN\". If with DELTA parameter a value not equal 0 is specified, the automatic \n\ndata logging is enabled via differential monitoring. Changing the value of VALUE to \n\n+ / - DELTA automatically stores a record. This feature can be applied in parallel to \n\nthe central trigger on the DLOG_STORE_ * module.", "type": "FUNCTION", "name": "DLOG_DINT", "input": [{"name": "X", "type": "DLOG_DATA", "description": "DLOG data structure for recording data."}, {"name": "VALUE", "type": "DINT", "description": "The process value to be logged."}, {"name": "COLUMN", "type": "STRING (40)", "description": "The name of the process value for logging, relevant for formats that support a process value name."}, {"name": "DELTA", "type": "DINT", "description": "The difference value that triggers automatic logging if it is not equal to 0."}], "output": [], "in/out": [], "return_value": {"type": "void", "description": "The function does not return a value."}}
{"title": "DLOG_DT Module for Data Logging", "description": "DLOG_DT is for logging (recording) of a date or time value of \n\ntype STRING, and can only be used in combination with a DLOG_STORE_* \n\nmodule, as this coordinates the record the data by the data structure X. \n\nUsing FMT parameter, the formatting will be set. In the FMT parameter can \n\nalso be combined with normal text formatting parameters. See \n\ndocumentation on the block DT_TO_STRF. If the FMT parameter is not \n\nspecifed, the default formatting\n\n'#A-#D-#H #N:#R:#T' is used.\n\nAt recording formats that support a process value name, such as at \n\nDLOG_STORE_FILE_CSV a name can be provided at COLUMN\".\n\nIf with DELTA parameter a value greater than 0 is specified, the automatic data \n\nlogging is enabled via differential monitoring. If time changes by the value of DELTA \n\nautomatically a record is stored. This feature can be applied in parallel to the central \n\ntrigger on the DLOG_STORE_ * module. If, for example DELTA is the value 30, \n\nautomatically every 30 seconds a record is saved.\n\n50 Version 1.21\n\nChapter 7. Data Logger", "type": "FUNCTION", "name": "DLOG_DT", "input": [{"name": "X", "type": "DLOG_DATA", "description": "DLOG data structure for recording data."}, {"name": "FMT", "type": "STRING", "description": "Formatting parameters for the date or time value. If not specified, defaults to '#A-#D-#H #N:#R:#T'."}, {"name": "COLUMN", "type": "STRING", "description": "Process value name, limited to 40 characters."}, {"name": "DELTA", "type": "UDINT", "description": "Difference in seconds for enabling automatic data logging via differential monitoring. If greater than 0, records will automatically be stored based on this time difference."}], "output": [], "in/out": [], "return_value": {"type": "STRING", "description": "The formatted date or time value recorded.", "fields": []}}
{"title": "DLOG_FILE_TO_FTP Module", "description": "DLOG_FILE_TO_FTP is used to automatically transfer the by \n\nDLOG_STORE_FILE_CSV generated from fles to an FTP-server. The FTP_URL \n\nparameter contains the name of the FTP server and optionally the user \n\nname and password, an access path and an additional port number for the \n\ndata channel. If no Username or password is transferred, the device \n\nautomatically tries to register as \"Anonymous\". The parameter FTP_ACTIV \n\ndetermined whether the FTP server is operated in active or passive mode. \n\nIn the ACTIV mode, the FTP server tries to establish the data channel for \n\ncontrol, however these may cause problems by security software, frewall, \n\netc. because it could block the connection request. For this purpose, in the \n\nfrewall a corresponding exception rule has to be defned. In the passive \n\nmode, this problem is alleviated since the controller establishes the \n\nconnection, and can easily pass through the frewall. The control channel is \n\nalways set up on port 20, and the data channel via standard PORT21, but \n\nthis is in turn is depending whether active or passive mode is used, or \n\noptional PORT number in the FTP-URL is specifed. With the parameter \n\nFILE_DELETE can be determined whether the source fle should be deleted \n\nafter successful transfer. This works on FTP and even on the control side. \n\nIn specifying FTP directories the behavior depends on FTP server, whether \n\nthey exist in this case or are created automatically. Normally, these should \n\nbe already available. The size of fles is no limit per se, but there are \n\npractical limits: Space on PLC, FTP storage and the transmission time. With \n\ndns_ip4 the IP address of the DNS server must be specifed, if in the FTP \n\nURL a DNS name is given, alternatively, an IP address can be entered in \n\nthe FTP URL. At parameters PLC_IP4 the own IP addresses has to be \n\nsupplied. If errors occur during transmission these are passed to the \n\noutput ERROR_C and ERROR_T. As long as the transfer is running, BUSY = \n\n64 Version 1.21\n\nChapter 7. Data Logger\n\nTRUE, and after an error-free completion of the operation, DONE = TRUE. \n\nOnce a new transfer is started, DONE, ERROR_T and ERROR_C are reseted.\n\nIf parameter RETRY = 0, then the FTP transfer was repeated until it \n\ncompletes successfully. If RETRY state at a value > 0, the FTP transfer is \n\njust as often repeated in transmission failure. Then this job is simply \n\ndiscarded and the process continues with the next fle. With RETRY-TIME \n\nthe waiting time between the repetitions can be defned.\n\nThe module has integrated the IP_CONTROL and must not be externally \n\nlinked to this, as it by default would be necessary.\n\nBackground: http://de.wikipedia.org/wiki/File_Transfer_Protocol \n\nURL examples:\n\nftp://username:password@servername:portnummer/directory/\n\nftp://username:password@servername\n\nftp://username:password @ servername / directory /\n\nftp://servername\n\nftp://username:password@192.168.1.1/directory/\n\nftp://192.168.1.1\n\n65 Version 1.21\n\nChapter 7. Data Logger\n\nERROR_T:\n\nValue Properties\n\n1 Problem: DNS_CLIENT\n\nThe exact meaning of ERROR_C can be read at module DNS_CLIENT\n\n2 Problem: FTP control channel\n\nThe exact meaning of ERROR_C can be read at module IP_CONTROL\n\n3 Problem: FTP data channel\n\nThe exact meaning of ERROR_C can be read at module IP_CONTROL\n\n4 Problem: FILE_SERVER\n\nThe exact meaning of ERROR_C can be read at block FILE_SERVER\n\n5 Problem: END - TIMEOUT\n\nERROR_C contains the left WORD of the step number, and the right WORD has the re￾sponse code received by the FTP server.\n\nThe parameters must be considered first as a HEX value, divided into two WORDS, and\n\nthen be considered as a decimal value.", "type": "FUNCTION", "name": "DLOG_FILE_TO_FTP", "input": [{"name": "FTP_URL", "type": "STRING", "description": "FTP access path including optional username, password, and port number."}, {"name": "FTP_ACTIV", "type": "BOOL", "description": "Determines whether the FTP server operates in active (1) or passive (0) mode."}, {"name": "FILE_DELETE", "type": "BOOL", "description": "Specifies whether to delete the source file after successful transfer."}, {"name": "TIMEOUT", "type": "TIME", "description": "The timeout duration for the FTP connection."}, {"name": "RETRY", "type": "INT", "description": "The number of times to retry the FTP transfer in case of failure."}, {"name": "RETRY_TIME", "type": "TIME", "description": "The waiting time before each retry attempt."}, {"name": "Dns_ip4", "type": "DWORD", "description": "The IP address of the DNS server."}, {"name": "DLOG_DATA", "type": "STRUCT", "description": "The DLOG data structure that encapsulates the data to be logged.", "fields": []}], "output": [{"name": "DONE", "type": "BOOL", "description": "Indicates if the transfer completed without error."}, {"name": "BUSY", "type": "BOOL", "description": "Indicates if the transfer is currently active."}, {"name": "ERROR_C", "type": "DWORD", "description": "Error code representing the type of error encountered during transfer."}, {"name": "ERROR_T", "type": "BYTE", "description": "Indicates the specific problem encountered during the operation."}], "in/out": [], "return_value": {"type": "VOID", "description": "No return value as this function handles the FTP transfer process internally."}}
{"title": "DLOG_FILE_TO_SMTP", "description": "DLOG_FILE_TO_SMTP is used to automatically transfer the of \n\nDLOG_STORE_FILE_CSV generated fles as e-mail to an e-mail server.\n\nThe module uses internally the SMTP_CLIENT for sending.\n\nThe SERVER parameter contains the name of the SMTP server and \n\noptionally the user name and password and a port number. If you pass a \n\nuser name and password, the procedure is according to standard SMTP.\n\nSERVER: URL", "type": "FUNCTION", "name": "DLOG_FILE_TO_SMTP", "input": [{"name": "SERVER", "type": "STRING", "description": "URL of the SMTP server, option to include username, password, and port number."}, {"name": "MAIL_FROM", "type": "STRING", "description": "Return address of the email sender. Can include a display name."}, {"name": "MAILTO", "type": "STRING", "description": "Recipient addresses formatted into groups: To, Cc, Bc."}, {"name": "SUBJECT", "type": "STRING", "description": "Subject text of the email."}, {"name": "FILES", "type": "STRING", "description": "Files to be sent via email."}, {"name": "X", "type": "DLOG_DATA", "description": "DLOG data structure."}, {"name": "FILE_DELETE", "type": "BOOL", "description": "Indicates if the files should be deleted after transfer."}, {"name": "TIMEOUT", "type": "TIME", "description": "Monitoring time for the transfer."}, {"name": "DTI", "type": "DT", "description": "Current date-time when the email is sent."}, {"name": "DTI_OFFSET", "type": "INT", "description": "Time zone offset from UTC in minutes."}, {"name": "RETRY", "type": "INT", "description": "Number of repetitions for SMTP transfer on failure."}, {"name": "RETRY_TIME", "type": "TIME", "description": "Waiting period before repeating the SMTP transfer."}, {"name": "Dns_ip4", "type": "DWORD", "description": "IP4 address of the DNS server."}], "output": [{"name": "DONE", "type": "BOOL", "description": "Indicates if the transfer completed successfully without error."}, {"name": "BUSY", "type": "BOOL", "description": "Indicates if the transfer is currently active."}, {"name": "ERROR_C", "type": "DWORD", "description": "Error code if an error occurs during transfer."}, {"name": "ERROR_T", "type": "BYTE", "description": "Type of problem that occurred during transfer."}], "in/out": [], "return_value": null}
{"title": "DLOG_REAL Module", "description": "DLOG_REAL is for logging (recording) of a process value of \n\ntype REAL, and can only be used in combination with a DLOG_STORE_* \n\nmodule, as this coordinates of the data structure X to record the data. \n\nUsing parameter N defnes the number of desired decimal places. See \n\ndocumentation on the module REAL_TO_STRF. The D input determines \n\nwhich character represents the decimal point. Passed with no sign of \n\nparameter D, automatically ',' is used. \n\nAt recording formats that support a process value name, such as at \n\nDLOG_STORE_FILE_CSV a name can be provided at COLUMN\". If with DELTA \n\nparameter a value not equal 0.0 is specified, the automatic data logging is enabled \n\nvia differential monitoring. Changing the value of VALUE to + / - DELTA automatically \n\nstores a record. This feature can be applied in parallel to the central trigger on the \n\nDLOG_STORE_ * module. \n\n51 Version 1.21\n\nChapter 7. Data Logger", "type": "FUNCTION", "name": "DLOG_REAL", "input": [{"name": "X", "type": "DLOG_DATA", "description": "DLOG data structure used for storing the logging data."}, {"name": "VALUE", "type": "REAL", "description": "The process value to be logged."}, {"name": "N", "type": "INT", "description": "The number of decimal places to use when logging the process value."}, {"name": "D", "type": "STRING(1)", "description": "The character representing the decimal point."}, {"name": "COLUMN", "type": "STRING(40)", "description": "The name of the process value, used in formats that support this feature."}, {"name": "DELTA", "type": "REAL", "description": "The difference value that enables automatic data logging via differential monitoring if not equal to 0.0."}], "output": [], "in/out": [], "return_value": {"type": "VOID", "description": "Indicates that the function does not return a value."}}
{"title": "DLOG_STORE_FILE_CSV Module", "description": "DLOG_STORE_FILE_CSV is for logging (recording) of the \n\nprocess values in a CSV formatted fle. The data can be passed with the \n\nmodules DLOG_DINT, DLOG_REAL, DLOG_STRING, DLOG_DT. The \n\nparameter TRIG_M (positive pulse) is used to manually trigger (start) the \n\nstorage of process data. With Parameters TRIG_T an automatic time￾controlled release can be realized. If the current date / time value divided \n\nby the parameterized TRIG_T value with residual value is 0, then a Save is \n\nperformed. \n\nThis also ensures that the store is always performed at the same time", "type": "FUNCTION", "name": "DLOG_STORE_FILE_CSV", "input": [{"name": "X", "type": "DLOG_DATA", "description": "The DLOG data structure containing the process values to be logged."}, {"name": "ENABLE", "type": "BOOL", "description": "A boolean flag to enable or disable data recording."}, {"name": "TRIG_M", "type": "BOOL", "description": "A manual trigger that starts the storage of process data upon receiving a positive pulse."}, {"name": "TRIG_T", "type": "UDINT", "description": "An automatic trigger for cyclic storage based on time intervals."}, {"name": "FILE NAME", "type": "STRING", "description": "The name of the file (including path if necessary) where the data will be stored."}, {"name": "DTI", "type": "DT", "description": "The current date and time value to be used in data processing."}, {"name": "SEP", "type": "BYTE", "description": "The ASCII code of the delimiter used to separate recorded elements in the CSV file."}], "output": [{"name": "ERROR_C", "type": "DWORD", "description": "An error code indicating the status of the logging operation."}, {"name": "ERROR_T", "type": "BYTE", "description": "A code indicating the type of problem encountered."}], "in/out": [], "return_value": null}
{"title": "Data Logger Module", "description": "DLOG_STORE_RRD serves for logging (recording) of the \n\nprocess values in an RRD database. The data can be passed with the \n\nmodules DLOG_DINT, DLOG_REAL, DLOG_STRING, DLOG_DT. The \n\nparameter TRIG_M (positive pulse) is used to manually trigger (start) the \n\nstorage of process data. With Parameters TRIG_T an automatic time￾controlled release can be realized. If the current date / time value divided \n\nby the parameterized TRIG_T value with residual value is 0, then a Save is \n\nperformed. \n\nThis also ensures that the store is always performed at the same time", "type": "FUNCTION", "name": "DLOG_STORE_RRD", "input": [{"name": "ENABLE", "type": "BOOL", "description": "Enable data recording"}, {"name": "TRIG_M", "type": "BOOL", "description": "Manual trigger for starting data storage"}, {"name": "TRIG_T", "type": "UDINT", "description": "Automatic trigger interval for time-controlled storage"}, {"name": "URL", "type": "STRING", "description": "URL address of the server where data will be sent"}, {"name": "DTI", "type": "DT", "description": "Current date-time value for data logging"}, {"name": "SEP", "type": "BYTE", "description": "ASCII code for the separator of the recorded elements"}, {"name": "Dns_ip4", "type": "DWORD", "description": "IP address of the DNS server"}, {"name": "TIMEOUT", "type": "TIME", "description": "Time to monitor for data transfer completion"}], "output": [{"name": "DONE", "type": "BOOL", "description": "Indicates whether the data transfer completed without error"}, {"name": "ERROR_C", "type": "DWORD", "description": "Error code indicating the nature of any issue encountered"}, {"name": "ERROR_T", "type": "BYTE", "description": "Type of problem encountered during data transfer"}], "in/out": [], "return_value": {"type": null, "description": null}}
{"title": "DLOG_STRING Function Module", "description": "DLOG_STRING is for logging (recording) of a process value of type DINT, \n\nand can only be used in combination with a DLOG_STORE_* module, as this \n\ncoordinates of the data structure X to record the data. At recording formats that \n\nsupport a process value name, such as at DLOG_STORE_FILE_CSV a name can be \n\nprovided at COLUMN\".", "type": "FUNCTION", "name": "DLOG_STRING", "input": [{"name": "STR", "type": "STRING", "description": "The string representation of the process value to be logged."}, {"name": "COLUMN", "type": "STRING(40)", "description": "The name of the process value for logging purposes."}], "output": [], "in/out": [{"name": "X", "type": "DLOG_DATA", "description": "The DLOG data structure used for recording."}], "return_value": null}
{"title": "DNS Client Function", "description": "DNS_CLIENT determine from the given qualifed DOMAIN name the \n\nassociated IPv4 address eg \"www.oscat.de\" . For this purpose, a DNS \n\nquery to a DNS server for confgured DOMAIN name with is made. With \n\npositive edge of ACTIVATE the specifed DOMAIN is stored so that they no \n\nlonger must be present. If the query provide more IP addresses, so always \n\nhe highest value of the TTL (Time To Live) is used. As IP4_DNS can be used \n\nany public DNS servers. If the PLC is sitting behind a DSL router, this \n\nrouter can be used through its gateway address as a DNS server. Which \n\nultimately leads to faster even with repeated requests response times \n\nbecause they are managed in the router cache. With positive results DONE \n\n= TRUE the IP4 contains the requested IP address until the start of the \n\nnext query by positive edge of ACTIVATE. If in the DOMAIN name a valid \n\nIPv4 address is detected, no more DNS query is made and it is passed in \n\nconverted type to IPv4 and DONE is set to TRUE. ERROR gives, if an error \n\noccurs, the exact cause. \n\n89 Version 1.21\n\nChapter 9. Network and Communication\n\nError Codes:\n\nValue Source Description\n\nB3 B2 B1 B0\n\nnn nn nn xx IP_CONTROL Error from module IP_CONTROL\n\nxx xx xx 00 DNS_CLIENT No error: The request completed successfully\n\nxx xx xx 01 DNS_CLIENT Format error: The name server was unable to interpret the query. \n\nxx xx xx 02 DNS_CLIENT Server failure: The name server was unable to process this query\n\ndue to a problem with the nameserver.\n\nxx xx xx 03 DNS_CLIENT Name Error: Meaningful only for responses from an authoritative\n\nname server, this code signifies that the domain name referenced in\n\nthe query does not exist\n\nxx xx xx 04 DNS_CLIENT Not Implemented: The name server does not support the requested\n\nkind of query\n\nxx xx xx 05 DNS_CLIENT Refused: The name server refuses to perform the specified opera￾tion for policy reasons\n\nxx xx xx 06 DNS_CLIENT YXDomain: Name Exists when it should not\n\nxx xx xx 07 DNS_CLIENT YXRRSet. RR: Set Exists when it should not\n\nxx xx xx 08 DNS_CLIENT Nxrrset. RR: Set that should exist does not\n\nxx xx xx 09 DNS_CLIENT Server Not Authoritative for zone\n\nxx xx xx 0A DNS_CLIENT Name not contained in zone\n\nxx xx xx FF DNS_CLIENT No ip-address found", "type": "FUNCTION", "name": "DNS_CLIENT", "input": [{"name": "IP_C", "type": "IP_C", "description": "Parameterization for the IP control"}, {"name": "S_BUF", "type": "NETWORK_BUFFER", "description": "Buffer to transmit data"}, {"name": "R_BUF", "type": "NETWORK_BUFFER", "description": "Buffer to receive data"}, {"name": "ACTIVATE", "type": "BOOL", "description": "Query start by positive edge"}, {"name": "DOMAIN", "type": "STRING", "description": "Domain name or IP as String"}, {"name": "IP4_DNS", "type": "DWORD", "description": "IPv4 address of the DNS server"}], "output": [{"name": "IP4", "type": "DWORD", "description": "IPv4 address of the requested domain"}, {"name": "DONE", "type": "BOOL", "description": "Indicates whether the IP of the domain has been queried successfully"}, {"name": "ERROR", "type": "DWORD", "description": "Error code indicating the issue encountered during the query"}], "in/out": [], "return_value": {"type": null, "description": null}}
{"title": "Dynamic DNS Registration Module", "description": "DNS_DYN dynamic IP addresses are registered as domain names. \n\nMany Internet providers assign a dynamic IP address when dialing into the \n\nInternet. To be visible and accessible for Internet Participants, one of the \n\nways is to upgrade its current IP address via Dyn-DNS. The process is not \n\nstandardized, unfortunately, so for every Dyn-DNS provider has to be \n\ncreated a individual solution. The module can be used in conjunction with \n\nDynDNS.org and Selfhost.de. These providers ofer in addition to paid also \n\nfree DynDNS services.\n\nIf ENABLE is set to TRUE, then the module is active. Using a positive edge \n\nto UPDATE any time an update can be started. If at T_UPDATE a time is \n\nspecifed, always an update is done after that time.\n\nCaution, most DynDNS providers rates a frequent or unnecessary update \n\nas an attack, and block the account for a certain time.\n\nThe time T_UPDATE should not be set below an hour. If the parameter \n\nT_UPDATE is not connect it is assumed as an update time of 1 hour. If no \n\nupdate is needed on time, then T#0ms should be passed.\n\nThe MODE parameter allows the selection of DynDNS Provider\n\n(0 = DynDNS.org, 1 = SELFHOST.DE)\n\nThe own domain name must be passed by the hostname. For security \n\nreasons, USERNAME and PASSWORD as authorization data must be \n\nspecifed to the DynDNS provider. If the parameter IP4 is not used, so \n\nDynDNS provider automatically adopts the current registration-IP as WAN \n\nIP with which the update is performed. By specifying an IP address also an \n\nindividual IP address may be assigned.\n\nWith fawless execution the parameter DONE = TRUE, else ERROR_C and \n\nERROR_T passes the error code and error type. (See error codes).\n\nERROR_T:\n\nValue Properties\n\n93 Version 1.21\n\nChapter 9. Network and Communication\n\n1 The exact meaning of ERROR_C can be read at module DNS_CLIENT\n\n2 The exact meaning of ERROR_C can be read at module HTTP_GET\n\n3 The DynDNS provider has refused registration", "type": "FUNCTION", "name": "DNS_DYN", "input": [{"name": "ENABLE", "type": "BOOL", "description": "Release of the module to activate its functionality."}, {"name": "UPDATE", "type": "BOOL", "description": "Triggers a new DNS registration immediately."}, {"name": "T_UPDATE", "type": "TIME", "description": "Waiting time for the new DNS registration. Defaults to 1 hour if not specified."}, {"name": "MODE", "type": "BYTE", "description": "Selection of the DynDNS provider (0 = DynDNS.org, 1 = SELFHOST.DE)."}, {"name": "HOST_NAME", "type": "STRING(30)", "description": "The domain name to be registered."}, {"name": "USER_NAME", "type": "STRING(20)", "description": "The username used for registration with the DynDNS provider."}, {"name": "PASSWORD", "type": "STRING(20)", "description": "The password used for registration with the DynDNS provider."}, {"name": "IP4", "type": "DWORD", "description": "Optional parameter to specify a custom IP address. If not provided, the current WAN IP will be used."}], "output": [{"name": "BUSY", "type": "BOOL", "description": "Indicates whether the module is currently active and processing a query."}, {"name": "DONE", "type": "BOOL", "description": "Indicates whether the DNS registration succeeded."}, {"name": "ERROR_C", "type": "DWORD", "description": "Error code returned if registration fails."}, {"name": "ERROR_T", "type": "BYTE", "description": "Error type indicator."}], "in/out": [{"name": "IP_C", "type": "IP_C", "description": "Parameterization for IP configuration."}, {"name": "S_BUF", "type": "NETWORK_BUFFER", "description": "Buffer for transmitting data."}, {"name": "R_BUF", "type": "NETWORK_BUFFER", "description": "Buffer for receiving data."}], "return_value": {"type": null, "description": null}}
{"title": "DNS Reverse Client", "description": "DNS_REV_CLIENT determine from the given IP address the ofcially \n\nregistered domain name. For this purpose a reverse DNS query on the \n\nconfgured IP address with a DNS server is made. With positive edge of \n\nACTIVATE the specifed IP is stored so that they no longer must be present. \n\nIf the query result in more matches, it will always use the last record. As \n\nIP4_DNS can be used any public DNS servers. If the PLC is sitting behind a \n\nDSL router, this router can be used as a DNS server through its gateway \n\naddress. Which ultimately leads to faster even with repeated requests \n\nresponse times because they are managed in the router cache. With \n\npositive results DONE = TRUE the DOMAIN contains the ofcially \n\nregistered domain name until the start of the next query by positive edge \n\nof ACTIVATE. ERROR gives ao error, the error code. (See error codes).\n\nError Codes:\n\nValue Source Description\n\nB3 B2 B1 B0\n\nnn nn nn xx IP_CONTROL Error from module IP_CONTROL\n\nxx xx xx 00 DNS_CLIENT No error: The request completed successfully\n\nxx xx xx 01 DNS_CLIENT Format error: The name server was unable to interpret the query. \n\nxx xx xx 02 DNS_CLIENT Server failure: The name server was unable to process this query\n\ndue to a problem with the nameserver.\n\nxx xx xx 03 DNS_CLIENT Name Error: Meaningful only for responses from an authoritative\n\n91 Version 1.21\n\nChapter 9. Network and Communication\n\nname server, this code signifies that the domain name referenced in\n\nthe query does not exist\n\nxx xx xx 04 DNS_CLIENT Not Implemented: The name server does not support the requested\n\nkind of query\n\nxx xx xx 05 DNS_CLIENT Refused: The name server refuses to perform the specified opera￾tion for policy reasons\n\nxx xx xx 06 DNS_CLIENT YXDomain: Name Exists when it should not\n\nxx xx xx 07 DNS_CLIENT YXRRSet. RR: Set Exists when it should not\n\nxx xx xx 08 DNS_CLIENT Nxrrset. RR: Set that should exist does not\n\nxx xx xx 09 DNS_CLIENT Server Not Authoritative for zone\n\nxx xx xx 0A DNS_CLIENT Name not contained in zone", "type": "FUNCTION", "name": "DNS_REV_CLIENT", "input": [{"name": "IP_C", "type": "IP_C", "description": "Parameterization for the IP address"}, {"name": "S_BUF", "type": "NETWORK_BUFFER", "description": "Buffer for transmitting data"}, {"name": "R_BUF", "type": "NETWORK_BUFFER", "description": "Buffer for receiving data"}, {"name": "ACTIVATE", "type": "BOOL", "description": "Trigger to start the function on a positive edge"}, {"name": "DOMAIN", "type": "STRING", "description": "Domain name or IP address as a string"}, {"name": "IP4_DNS", "type": "DWORD", "description": "IPv4 address of the DNS server"}], "output": [{"name": "IP4", "type": "DWORD", "description": "IPv4 address of the requested domain"}, {"name": "DONE", "type": "BOOL", "description": "Indicates that the IP of the domain has been queried successfully"}, {"name": "ERROR", "type": "DWORD", "description": "Error code indicating the result of the query"}], "in/out": [], "return_value": {"type": null, "description": null}}
{"title": "ELEMENT_COUNT Function", "description": "ELEMENT_COUNT determines the number of items in a list.\n\nIf the parameter ELEMENT is an empty string 0 is passed as result. If at\n\nleast one character is in ELEMENT it is evaluated as a single element and\n\nELEMENT_COUNT = 1 is passed to output.", "type": "FUNCTION", "name": "ELEMENT_COUNT", "input": [{"name": "SEP", "type": "BYTE", "description": "Separation character of the elements"}, {"name": "ELEMENT", "type": "STRING", "description": "Input list of elements, where items are separated by the SEP character. The length of the string can vary."}], "output": [{"name": "result", "type": "INT", "description": "Number of items in the list. Returns 0 for empty input, and 1 for a single character."}], "in/out": [], "return_value": {"type": "INT", "description": "Returns the count of elements in the input list."}}
{"title": "ELEMENT_GET Function", "description": "ELEMENT_GET passes the item at the position POS from a list. The list con￾sists of strings which are separated by the separation character SEP. The\n\nfrst element of the list has the position 0", "type": "FUNCTION", "name": "ELEMENT_GET", "input": [{"name": "SEP", "type": "BYTE", "description": "The separation character of the elements."}, {"name": "POS", "type": "INT", "description": "The zero-based index of the item to retrieve."}, {"name": "ELEMENT", "type": "STRING", "description": "The input list of elements, consisting of strings separated by the separation character."}], "output": [{"name": "STRING", "type": "STRING", "description": "The output string corresponding to the element at the specified position."}], "in/out": [], "return_value": {"type": "STRING", "description": "Returns the element found at the specified position in the input list.", "fields": []}}
{"title": "File Block Access Module", "description": "FILE_BLOCK provides access to fles of any size by a data \n\nblock that is always kept in a read bufer. If the requested byte of a fle is \n\nnot stored in last block of data, automatically a matching new data block is \n\nread and the desired byte is putted out. The greater the read bufer is the \n\nless frequently a block must be read again. Optimally it is a linear access \n\nto the bytes, so that as seldom as possible, a data block must be read \n\nanew.\n\n152 Version 1.21\n\nChapter 10. File-System\n\nProcedure:\n\nThe Parameter FILENAME specifes the name of the fle to be read, and \n\nwith PT_SIZE the size of the read bufer is specifed in bytes. The value for \n\nparameter POS is the exact data position within the fle, which has to be \n\nread. The process is triggered by setting MODE to 1. Then the system \n\nautomatically checks whether the desired data byte is already in the read \n\nbufer. If not, then a new matching block of data is copied into the read \n\nbufer, and the desired data byte is passed on the parameter DATA. As \n\nlong as this operation is not fnished yet, MODE remains at 1, and only \n\nafter completion of the operation of module is reset to MODE = 0. If a \n\nspecifed data position is larger than the current length of the fle or the \n\nfle has length 0, so the output at ERROR is 255 (See ERROR codes from \n\nblock FILE_SERVER).\n\nIf the fle access is no longer needed, the user must close the fle be either \n\nby use of AUTO_CLOSE or MODE 5 (close fle) of the FILE_SERVER.", "type": "FUNCTION_BLOCK", "name": "FILE_BLOCK", "input": [{"name": "PT_SIZE", "type": "UINT", "description": "Number of bytes in the buffer"}, {"name": "FILE_NAME", "type": "STRING", "description": "Name of the file to be read"}, {"name": "POS", "type": "UDINT", "description": "Current file reading position"}], "output": [{"name": "ERROR", "type": "BYTE", "description": "Error code - See module FILE_SERVER"}, {"name": "DATA", "type": "BYTE", "description": "Byte of the requested file position"}], "in/out": [{"name": "IN_OUT_MODE", "type": "BYTE", "description": "Current mode of the operation"}, {"name": "FD", "type": "FILE_SERVER_DATA", "description": "File Interface"}, {"name": "PT", "type": "NETWORK_BUFFER", "description": "Read data"}], "return_value": null}
{"title": "File Path Split Function", "description": "FILE_PATH_SPLIT The module split a fle path into its component elements. The drive, path \n\nand fle name are extracted and stored in the data structure X. As \n\ndirectory separator \"\\\" and \"/\" will be accepted. If the passed \"File name\" is \n\nnot empty and elements can be evaluated, the module returns TRUE, \n\notherwise FALSE.", "type": "FUNCTION", "name": "FILE_PATH_SPLIT", "input": [{"name": "INPUT_FILE_NAME", "type": "STRING", "description": "The input file path as a string."}], "output": [], "in/out": [{"name": "X", "type": "FILE_PATH_DATA", "description": "A data structure that stores the extracted components of the file path."}], "return_value": {"type": "BOOL", "description": "Returns TRUE if the input file name is valid and elements can be evaluated, FALSE otherwise."}}
{"title": "FILE_SERVER Module for PLC", "description": "FILE_SERVER_DATA (fle interface)\n\nPT: NETWORK_BUFFER (read / write data)\n\nAvailable platforms and related dependencies\n\nCoDeSys:\n\nDoes the library \" SysLibFile.lib \"\n\nRuns on\n\nWAGO 750-841\n\nCoDeSys SP PLCWinNT V2.4\n\nand compatible platforms\n\n154 Version 1.21\n\nChapter 10. File-System\n\nPCWORX:\n\nNo library required\n\nRuns on all controllers with fle system from frmware >= 3.5x\n\nBECKHOFF:\n\nDevelopment Environment Target \n\nPlatform\n\nPLC libraries to include\n\nTwinCAT v2.8.0 or higher PC or CX \n\n(x86)\n\nTcSystem.Lib\n\nTwinCAT v2.10.0 Build >= 1301 or \n\nhigher\n\nCX (ARM) TcSystem.Lib\n\nThe module FILE_SERVER enables hardware and manufacturers a neutral \n\naccess to the fle system of PLC. Since at almost every hardware and \n\nsoftware platform, the accessibility to the fle system is sometimes very \n\ndiferent, it is necessary to use a uniform and simplifed functional \n\ninterface, which is reduced to the necessary functions. The module is \n\nhardware-dependent and therefore it must be available for that platform \n\nare the appropriate implementation.\n\nWIth FILE NAME the fle is determined. Depending on the platform may be \n\nslightly diferent syntax (with or without the path). With MODE parameter \n\nthe principle of access is given. At MODE 1,2 and 3 with \"OFFSET\" the \n\nposition can be specifed in the fle. In the fle system counting is always \n\nstarted with byte 0. The frst step is always to check whether this fle is \n\nalready (still) open, and if not they will open and the current fle size is \n\nobserved and passed to the \"FILE_SIZE\". When specifying a time \n\nAUTO_CLOSE > 0ms, the fle is automatically closed after each command \n\nand the expiration of the waiting time. Alternatively, using MODE = 5, the \n\nclosing of the fle is done manually. Each write command which change the \n\nsize of the fle automatically leads to a corrected \"FILE_SIZE\" entry, so it is \n\nalways visible how large the fle is right now. Once a fle is open, this is \n\nreported on FILE_OPEN = TRUE.\n\nEach write command at which the size of the fle changes automatically \n\nleads to a corrected \"FILE_SIZE\" entry, so you can always how large the \n\nfle is right now. In PT.SIZE is the actual amount of data automatically \n\ncorrected or entered.\n\nIf the MODE 1,2 or 3 called with PT.SIZE = 0, the fle is opened, the \n\nFILE_SIZE determined, but no read/write command is performed, and the \n\nfle will remain open until manually closed or AUTO_CLOSE.\n\n155 Version 1.21\n\nChapter 10. File-System\n\nIf data has to be written, the data has to be stored in PT.BUFFER and in \n\nPT.SIZE the bytes must exist. This data are written to the specifed relative \n\nofset in the fle. If a write mode is called with PT.SIZE = 0, then in turn the \n\nfle is opened (if not already open, and made no write command, and \n\nthese will remain open until a manual closing or AUTO_CLOSE is carried \n\nout.)\n\nAfter every executed command that changes the position of the virtual \n\nread / write pointer, the current position in the data structure is written in \n\nthe parameter \"OFFSET\". An automatic append function can be realized \n\nvery easy. The parameter FILE_SIZE has to be written to the OFFSET \n\nparameter after opening the fle. After that, all written bytes are appended \n\nto the end without changing the OFFSET parameter manually. The same \n\nprinciple can be applied of course when reading, the read pointer should \n\nbe positioned frst within the fle (usually starting at ofset 0).\n\nIf a command is executed and FILE NAME difers from the current FILE \n\nNAME, the old one, still open fle, is closed automatically and the new one \n\nis opened then, and continued with the normal command. This can easily \n\nperform a fying change of the fle without having to perform cumbersome \n\nand OPEN to CLOSE before.\n\nWhen you delete a fle with MODE 4 automatically a potentially \n\noutstanding fle is closed before, and then deleted in sequence.\n\nAfter a AUTO_CLOSE or manual closing by MODE 5 all data in \n\nFILE_SERVER_DATA is reseted.\n\nThe module FILE_SERVER should always be called periodically, at least as \n\nlong as not all requests are completed safely.\n\nSince some platforms perform a fle-lock (eg CoDeSys) and do not always \n\nallow an asynchronous use, FILE_SERVER should run in a separate task so \n\nthat the default application is not infuenced in the time behavior. . \n\nThe FILE_SERVER provides the following commands in \"MODE\":\n\nMODE Properties\n\n1 An existing file is opened for reading and reading data optional\n\n2 An existing file is opened for write access and optional data is written\n\n3 A file will be created for writing and data will be written optional\n\n4 Delete file\n\n5 Close file\n\nERROR: Error codes Beckhof\n\nValue trigger Description\n\n156 Version 1.21\n\nChapter 10. File-System\n\n0 No error\n\n19 SYSTEMSERVICE_FOPEN Unknown or invalid parameter\n\n28 SYSTEMSERVICE_FOPEN File not found. Invalid file name or file path\n\n38 SYSTEMSERVICE_FOPEN SYSTEMSERVICE_FOPEN\n\n51 SYSTEMSERVICE_FCLOSE unknown or invalid file handle.\n\n62 SYSTEMSERVICE_FCLOSE File was opened with the wrong method.\n\n67 SYSTEMSERVICE_FREAD unknown or invalid file handle.\n\n74 SYSTEMSERVICE_FREAD No memory for read buffer.\n\n78 SYSTEMSERVICE_FREAD File was opened with the wrong method.\n\n83 SYSTEMSERVICE_FWRITE unknown or invalid file handle\n\n94 SYSTEMSERVICE_FWRITE File was opened with the wrong method.\n\n99 SYSTEMSERVICE_FSEEK unknown or invalid file handle.\n\n110 SYSTEMSERVICE_FSEEK File was opened with the wrong method.\n\n115 SYSTEMSERVICE_FTELL unknown or invalid file handle.\n\n126 SYSTEMSERVICE_FTELL File was opened with the wrong method\n\n140 SYSTEMSERVICE_FDELETE File not found. Invalid file name or file path.\n\n255 Application Position is after the end of file\n\nERROR: Error codes PCWORX:\n\nValue trigger Description\n\n0 No error\n\n2 File_open The maximum number of files already open\n\n4 File_open The file is already open\n\n5 File_open The file is write-protected or access denied\n\n6 File_open File name not specified\n\n11 File_close Invalid file handle\n\n30 File_close File could not be closed\n\n41 FILE_READ Invalid file handle\n\n157 Version 1.21\n\nChapter 10. File-System\n\n50 FILE_READ End of file reached\n\n52 FILE_READ The number of characters to read is larger than the data buffer\n\n62 FILE_READ Data could not be read\n\n71 FILE_WRITE Invalid file handle\n\n81 FILE_WRITE There is no memory available to write the data \n\n82 FILE_WRITE The count of characters to write is larger than the data buffer\n\n93 FILE_WRITE There were no written data\n\n0 FILE_SEEK Invalid file handle\n\n113 FILE_SEEK Invalid positioning mode or the specified position is before the start of\n\nthe file\n\n124 FILE_SEEK The position could not be set\n\n131 FILE_TELL Invalid file handle\n\n142 FILE_REMOVE The maximum number of files already open\n\n143 FILE_REMOVE The file could not be found\n\n145 FILE_REMOVE The file is opened, readonly or access denied\n\n146 FILE_REMOVE File name not specified\n\n161 FILE_REMOVE File could not be deleted\n\n255 Application Position is after the end of file\n\nERROR: CoDeSys error codes:\n\nValue trigger Description\n\n0 No error\n\n1 SysFileOpen Error\n\n2 SysFileClose Error\n\n3 SysFileRead Error\n\n4 SysFileWrite Error\n\n5 SysFileSetPos Error\n\n6 SysFileGetPos Error\n\n7 SysFileDelete Error\n\n8 SysFileGetSize Error\n\n158 Version 1.21\n\nChapter 10. File-System\n\n255 Application Position is after the end of file", "type": "FUNCTION", "name": "FILE_SERVER", "input": [{"name": "FILENAME", "type": "STRING", "description": "The name of the file to be accessed. The syntax may vary by platform."}, {"name": "MODE", "type": "INT", "description": "Specifies the mode of operation: 1 for read, 2 for write, 3 for create, 4 for delete, 5 for close."}, {"name": "OFFSET", "type": "INT", "description": "Specifies the byte offset in the file to start reading or writing."}, {"name": "AUTO_CLOSE", "type": "INT", "description": "Specifies the auto close time in milliseconds. If greater than 0, the file will close automatically after each command."}, {"name": "PT", "type": "STRUCT", "description": "A structure containing buffer and size for read/write operations.", "fields": [{"name": "BUFFER", "type": "BYTE[]", "description": "The data buffer that holds data to be read from or written to the file."}, {"name": "SIZE", "type": "INT", "description": "The number of bytes in the buffer."}]}], "output": [{"name": "FILE_SIZE", "type": "INT", "description": "The current size of the file after a read/write operation."}, {"name": "FILE_OPEN", "type": "BOOL", "description": "Indicates whether the file is currently open."}, {"name": "ERROR_CODE", "type": "INT", "description": "An error code indicating the status of the file operation."}], "in/out": [], "return_value": {"type": "BOOL", "description": "Returns true if the file operation was successful, false otherwise."}}
{"title": "FTP Client Module", "description": "FTP_CLIENT is used to transfer fles from the PLC to an FTP \n\nserver and to transmitted from the FTP server to the PLC. A positive edge \n\n94 Version 1.21\n\nChapter 9. Network and Communication\n\nat ACTIVATE starts the transfer process. In FTP_DOWNLOAD the \n\ntransmission direction can be specifed. The parameter FTP_URL contains \n\nthe name of the FTP server and pass the optional user name and \n\npassword, an access path and an additional port number for the data \n\nchannel. If no username or password is passed, the module trys \n\nautomatically to register as \"Anonymous\" . The parameter FTP_ACTIV \n\ndetermines whether the FTP server is operated in active or passive mode. \n\nIn the ACTIV mode, the FTP server tries to establish the data channel for \n\ncontrol, however these may cause problems by security software, frewall, \n\netc. because these could block the connection request. For this purpose, in \n\nthe frewall a corresponding exception rule has to be defned. In the \n\npassive mode, this problem is alleviated since the controller establishes \n\nthe connection, and can easily pass through the frewall. The control \n\nchannel is always set up on port 20, and the data channel via standard \n\nPORT21, but this is in turn is depending whether active or passive mode is \n\nused, or optional PORT number in the FTP-URL is specifed. With the \n\nparameter FILE_DELETE can be determined whether the source fle should \n\nbe deleted after successful transfer. This works on FTP and even on the \n\ncontrol side. In specifying FTP directories the behavior depends on FTP \n\nserver, whether they exist in this case or are created automatically. \n\nNormally, these should be already available. The size of fles is no limit per \n\nse, but there are practical limits: Space on PLC, FTP storage and the \n\ntransmission time. With dns_ip4 the IP address of the DNS server must be \n\nspecifed, if in the FTP URL a DNS name is given, alternatively, an IP \n\naddress can be entered in the FTP URL. At parameters PLC_IP4 the own IP \n\naddresses has to be supplied. If errors occur during transmission these are \n\npassed to the output ERROR_C and ERROR_T. As long as the transfer is \n\nrunning, BUSY = TRUE, and after an error-free completion of the operation, \n\nDONE = TRUE. Once a new transfer is started, DONE, ERROR_T and \n\nERROR_C are reseted.\n\nThe module has integrated the IP_CONTROL and must not be externally \n\nlinked to this, as it by default would be necessary.\n\nBackground: http://de.wikipedia.org/wiki/File_Transfer_Protocol \n\nURL examples:\n\nftp://username:password@servername:portnummer/directory/\n\nftp://username:password@servername\n\nftp://username:password @ servername / directory /\n\nftp://servername\n\nftp://username:password@192.168.1.1/directory/\n\nftp://192.168.1.1\n\n95 Version 1.21\n\nChapter 9. Network and Communication\n\nERROR_T:\n\nValue Properties\n\n1 Problem: DNS_CLIENT\n\nThe exact meaning of ERROR_C can be read at module DNS_CLIENT\n\n2 Problem: FTP control channel\n\nThe exact meaning of ERROR_C can be read at module IP_CONTROL\n\n3 Problem: FTP data channel\n\nThe exact meaning of ERROR_C can be read at module IP_CONTROL\n\n4 Problem: FILE_SERVER\n\nThe exact meaning of ERROR_C can be read at block FILE_SERVER\n\n5 Problem: END - TIMEOUT\n\nERROR_C contains the left WORD of the step number, and the right WORD has the re￾sponse code received by the FTP server.\n\nThe parameters must be considered first as a HEX value, divided into two WORDS, and\n\nthen be considered as a decimal value.", "type": "FUNCTION", "name": "FTP_CLIENT", "input": [{"name": "ACTIVATE", "type": "BOOL", "description": "A positive edge starts the query."}, {"name": "FILE_NAME", "type": "STRING", "description": "File path and filename for the transfer."}, {"name": "FTP_URL", "type": "STRING", "description": "FTP access path including optional username, password, and port."}, {"name": "FTP_DOWNLOAD", "type": "BOOL", "description": "0 for upload, 1 for download."}, {"name": "FTP_ACTIV", "type": "BOOL", "description": "0 for passive mode, 1 for active mode."}, {"name": "FILE_DELETE", "type": "BOOL", "description": "Indicates whether to delete files after transfer."}, {"name": "TIMEOUT", "type": "TIME", "description": "Time duration for the transfer process."}, {"name": "Dns_ip4", "type": "DWORD", "description": "IP4 address of the DNS server."}], "output": [{"name": "DONE", "type": "BOOL", "description": "Indicates transfer completion without error."}, {"name": "BUSY", "type": "BOOL", "description": "Indicates the transfer is currently active."}, {"name": "ERROR_C", "type": "DWORD", "description": "Error code if an error occurred during transfer."}, {"name": "ERROR_T", "type": "BYTE", "description": "Indicates the type of the problem encountered."}], "in/out": [], "return_value": {"type": null, "description": null}}
{"title": "Get WAN IP", "description": "GET_WAN_IP determines the IP address that the Internet router on the Wide \n\nArea Network (Internet) uses. This IP address is necessary for example to \n\nto make DynDNS declarations. With a positive edge of the ACTIVATE the \n\nrequest is started. After successful completion of the query DONE = TRUE, \n\nand the parameters WAN_IP the current WAN IP address displayed. If an \n\nerror occurs during the query it is reported in ERROR_C in combination \n\nwith ERROR_T.\n\nERROR_T:\n\nValue Properties\n\n1 The exact meaning of ERROR_C can be read at module DNS_CLIENT\n\n2 The exact meaning of ERROR_C can be read at module HTTP_GET\n\n97 Version 1.21\n\nChapter 9. Network and Communication", "type": "FUNCTION", "name": "GET_WAN_IP", "input": [{"name": "IP_C", "type": "struct", "description": "Data structure for IP Control parameters.", "fields": []}, {"name": "S_BUF", "type": "struct", "description": "Data structure for the transmit network buffer.", "fields": []}, {"name": "R_BUF", "type": "struct", "description": "Data structure for the receive network buffer.", "fields": []}, {"name": "ACTIVATE", "type": "BOOL", "description": "Input to release the query."}], "output": [{"name": "WAN_IP", "type": "DWORD", "description": "Wide Area Network address."}, {"name": "DONE", "type": "BOOL", "description": "Indicates whether the query completed without errors."}, {"name": "ERROR_C", "type": "DWORD", "description": "Error code associated with the query."}, {"name": "ERROR_T", "type": "BYTE", "description": "Error type of the query."}], "in/out": [], "return_value": null}
{"title": "HTML Decode Function", "description": "HTML_DECODE converts reserved characters which are in the form\n\n&name; stored HTML code, in the original character. In addition, all coded\n\ncharacters are converted into the corresponding ASCII code. Special cha￾racters can be represented by the following string in HTML:\n\n- &#NN, where NN represents the position of the character within the cha￾racter map in decimal notation.\n\n- &#xNN, or &#XNN where NN represents the position of the character wi￾thin the character table in hexadecimal notation.\n\n&name; Special characters have names like &euro; for €.\n\nThe reserved characters in HTML are:\n\n& Is encoded as &amp;\n\n75 Version 1.21\n\nChapter 8. Converter\n\n> Is encoded as &gt;\n\n< Is encoded as &lt;\n\n\" is coded as &quot;", "type": "FUNCTION", "name": "HTML_DECODE", "input": [{"name": "String", "type": "STRING", "description": "The input string containing HTML encoded characters."}], "output": [{"name": "string_length", "type": "STRING", "description": "The decoded output string with reserved characters converted to their original form."}], "return_value": {"type": "STRING", "description": "The result of the HTML decode operation.", "fields": []}}
{"title": "HTML Encode Function", "description": "HTML_ENCODE converts in HTML reserved characters to form &Name;. If the\n\ninput M is set to TRUE also all the characters with the code 160-255 and\n\n128 are implemented in the &Name convention.\n\nCaution should be exercised in the use of character sets because they are\n\nnot the same on all systems and deviations are common in special charac￾ters. Thus, for example, not all systems the € character at position 128 in\n\nthe character map.\n\nThe reserved characters in HTML are:\n\n& Is encoded as &amp;\n\n> Is encoded as &gt;\n\n< Is encoded as &lt;\n\n\" is coded as &quot;\n\nHtml_encode converts the string '1 > than 0 'into '1 is &gt; than 0'.\n\n76 Version 1.21\n\nChapter 8. Converter", "type": "FUNCTION", "name": "HTML_ENCODE", "input": [{"name": "String", "type": "STRING", "description": "The input string to be encoded."}, {"name": "mode", "type": "BOOL", "description": "If TRUE, encodes additional characters (code 160-255 and 128) to HTML entities."}], "output": [{"name": "encoded_string", "type": "STRING", "description": "The encoded string with HTML reserved characters converted to HTML entities."}], "in/out": [], "return_value": {"type": "STRING", "description": "The result of the HTML encoding process.", "fields": []}}
{"title": "HTTP GET Function Module", "description": "HTTP_GET does at positive edge of Get a GET-command on an HTTP ser￾ver. IWith MODE the HTTP protocol version can be specifed. The reques￾ted URL (web link) must be submitted completely processed in the\n\nURL_DATA structure. The full URL should therefore be processed before the\n\nmodule call by \"STRING_TO_URL. After a successful query DONE = TRUE,\n\nand the parameters HTTP_START and HTTP_STOP point to the data area in\n\nwhich the message header data for further processing and evaluation are\n\nto be found. Normally, a message body is present, which in turn is trans-\n\n98 Version 1.21\n\nChapter 9. Network and Communication\n\nmitted via BODY_START and BODY_STOP. Also, on HTTP_STATUS is reported\n\nthe HTTP status code as a string. One of the difculties in receiving the\n\nHTTP data is the end of the data stream. This module pursued multiple\n\nstrategies. In the process of the HTTP/1.0 the end of receiving data is de￾tected by disconnection of the host. Furthermore, always the information\n\nin the header \"Content-Length\" is checked, and with this can be clearly re￾cognized, that all data is received. If none of the previous versions is true,\n\nso a simple Receive Timeout Error detectes the end of data transmission.\n\nThe only downside is, that this takes time. Sometimes, depending on the\n\ntimeout value longer than desired. Therefore it is not bad if a reasonable\n\ntimeout value is set at IP_CONTROL. ERROR gives at errors, the exact cau￾se (See module IP_CONTROL)\n\nThe following MODE can be used:\n\nMode Protocol Version Properties\n\n0 HTTP/1.0 The host terminates automatically the TCP connection, after the trans￾fer of data.\n\n1 HTTP/1.0 By applying \"Connection: Keep-Alive\", the host is instructed to use a\n\npersistent connection. The client should end of the connection after\n\nstopping activities.\n\n2 HTTP/1.1 The host uses a persistent connection and must be stopped by client.\n\n3 HTTP/1.1 By use of \"Connection: Close\" the host is instructed to stop transmissi￾on of data, the TCP connection.", "type": "FUNCTION", "name": "HTTP_GET", "input": [{"name": "URL_DATA", "type": "STRING_TO_URL", "description": "The complete URL string that has been processed into a URL structure."}, {"name": "IP_C", "type": "parameterization", "description": "Parameterization for IP configuration."}, {"name": "S_BUF", "type": "NETWORK_BUFFER", "description": "Buffer for transmitting data."}, {"name": "R_BUF", "type": "NETWORK_BUFFER", "description": "Buffer for receiving data."}, {"name": "IP4", "type": "DWORD", "description": "The IP address of the HTTP server."}, {"name": "GET", "type": "BOOL", "description": "Trigger to start the HTTP query."}, {"name": "MODE", "type": "BYTE", "description": "Determines the version of the HTTP GET query."}, {"name": "UNLOCK_BUF", "type": "BOOL", "description": "Indicates the release of the receive data buffer."}], "output": [{"name": "HTTP_STATUS", "type": "STRING", "description": "The HTTP status code returned from the server."}, {"name": "HTTP_START", "type": "UINT", "description": "The start position of the message header."}, {"name": "HTTP_STOP", "type": "UINT", "description": "The stop position of the message header."}, {"name": "BODY_START", "type": "UINT", "description": "The start position of the message body."}, {"name": "BODY_STOP", "type": "UINT", "description": "The stop position of the message body."}, {"name": "DONE", "type": "BOOL", "description": "Indicates if the task was performed without error."}, {"name": "ERROR", "type": "DWORD", "description": "Error code indicating the specific issue encountered."}], "in/out": [], "return_value": {"type": "void", "description": "This function does not return a value."}}
{"title": "INI Parser Buffer Module", "description": "INI_PARSER_BUF enables the analysis of elements of a INI fle \n\nstored in a Byte-Array . Before queries can be processed the user must fll \n\nthe byte array PT.BUFFER with the ini data, and the number of bytes has to \n\nbe stored in PT.SIZE. The search for elements always begins on the given \n\ndepended \"OFFSET\", and hence is very easy to look only at certain \n\npositions, or to repeat the search from a specifc section to browse not \n\nalways the entire byte array. At the initial search should start default to \n\nOFFSET 0 (but may not!). When querying sections and keys, there are \n\nvarious procedures. Either it is queried to a Section and evaluates all of \n\nthe following keys by individual queries, or to use in very large \n\ninitialization fle the classic enumeration (listing), which means it will be \n\nreport serially all the elements, and processed by the application.\n\nSection Search:\n\nTo determine the OFFSET of a specifc Section, STR must declare the name \n\nof the Section and the ofset can be set to a position that is located before \n\nof the searched section. Should only the nearest available section be \n\nfound, at STR an empty sting must be passed. The search query is started \n\nby RUN = 1. The search will take diferent time, depending on the \n\nstructure and size of the INI data, it takes an indefnite number of cycles \n\nuntil a positive or negative result is achieved. Once the search is fnished, \n\nthe INI_PARSER_BUF sets the parameters of RUN to 0. RESULT passes the \n\nresult of the search to output. Upon successful search the name of the \n\nsection is shown at parameters KEY. And then the OFFSET parameter \n\npoints to the end of the section line. Thus, immediately after that the key \n\nevaluation can be continued, without having to manually change the \n\nOFFSET. \n\nKey Search:\n\nBefore a Key is evaluated, the OFFSET must have a correct value, this can \n\nbe done by manual set of OFFSET or by a previously executed Section \n\nsearch. Before running the query at STR the name of the key must be are \n\npassed. If an empty string STR is handed over, the next key found is \n\nreturned. RUN = 2 means the query can be started. Once the search is \n\n162 Version 1.21\n\nChapter 10. File-System\n\nfnished, the INI_PARSER_BUF sets the parameters of RUN to 0. With \n\nRESULT the search results will be issued. When in a query the key \n\nidentifed a new Section, this is reported by RESULT = 11. Upon successful \n\nsearch the output of the parameter KEY is the name of the found key , and \n\nVALUE is the key value. And then the OFFSET parameter points to the end \n\nof the key line. Thus, immediately after the next Key evaluation be \n\ncontinued, without having to manually change the OFFSET. \n\nEnumeration - see next item:\n\nFor very large amount of data of an initialization fle to be evaluated, with \n\na enumeration (list) the user program can be build simple, and the \n\nevaluation be carried out more quickly because here no line must be used \n\nmore than once. Before the start OFFSET must have a reasonable value, \n\nthe default case to 0. With RUN = 3 the evaluation is started. Once a \n\nsection or a key is found, it is also issued immediately. In a section KEY \n\nprints the name of the Section and RESULT = 1. With a found KEY, KEY has \n\nthe key name and VALUE is the key value, and RESULT= 2.\n\nIf in a query, the end of the data array is reached, this will be reported by \n\nRESULT = 10. \n\nRUN: Feature List\n\nRUN Function\n\n0 No function to perform - and last function has finished\n\n1 Specific section or evaluate next found section \n\n2 evaluate specific Key or Key found next \n\n3 evaluate next found element (section or key) \n\nRESULT: Result - Feedback\n\nRESULT Description\n\n1 Section found\n\n2 Key found\n\n5 Current query is still running - call module further cyclical!\n\n10 Nothing found - reached the end of data\n\n163 Version 1.21\n\nChapter 10. File-System\n\n11 Key not found - reached the end of Section", "type": "FUNCTION", "name": "INI_PARSER_BUF", "input": [{"name": "RUN", "type": "BYTE", "description": "Command code for the current action. 1 for section search, 2 for key search, 3 for enumeration."}, {"name": "OFFSET", "type": "UDINT", "description": "Current file offset for the query."}, {"name": "STR", "type": "STRING(STRING_LENGTH)", "description": "Name of the section or key to search for."}, {"name": "PT", "type": "NETWORK_BUFFER", "description": "Read data buffer containing the INI file data."}], "output": [{"name": "RESULT", "type": "BYTE", "description": "The result of the query indicating success or failure."}, {"name": "KEY", "type": "STRING(STRING_LENGTH)", "description": "Name of the found section or key."}, {"name": "VALUE", "type": "STRING(STRING_LENGTH)", "description": "Value associated with the found key."}], "in/out": [], "return_value": {"type": null, "description": null}}
{"title": "INI Parser File Module", "description": "INI_PARSER_FILE enables the analysis of the elements of an \n\narbitrarily large INI fle which is read into the read data bufer block by \n\nblock for automatically processing. The name of the fle is passed in \n\nparameter \"FILENAME\". The search for elements always begins on the \n\ngiven depended \"OFFSET\", and hence is very easy to look only at certain \n\npositions, or to repeat the search from a specifc section to browse not \n\nalways the entire byte array. At the initial search should start default to \n\nOFFSET 0 (but may not!). When querying sections and keys, there are \n\nvarious procedures. Either it is queried to a Section and evaluates all of \n\nthe following keys by individual queries, or to use in very large \n\ninitialization fle the classic enumeration (listing), which means it will be \n\nreport serially all the elements, and processed by the application.\n\n164 Version 1.21\n\nChapter 10. File-System\n\nSection Search:\n\nTo determine the OFFSET of a specifc Section, STR must declare the name \n\nof the Section and the ofset can be set to a position that is located before \n\nof the searched section. Should only the nearest available section be \n\nfound, at STR an empty sting must be passed. The search query is started \n\nby RUN = 1. The search will take diferent time, depending on the \n\nstructure and size of the INI data, it takes an indefnite number of cycles \n\nuntil a positive or negative result is achieved. Once the search is fnished, \n\nthe INI_PARSER_BUF sets the parameters of RUN to 0. RESULT passes the \n\nresult of the search to output. Upon successful search the name of the \n\nsection is shown at parameters KEY. And then the OFFSET parameter \n\npoints to the end of the section line. Thus, immediately after that the key \n\nevaluation can be continued, without having to manually change the \n\nOFFSET. \n\nKey Search:\n\nBefore a Key is evaluated, the OFFSET must have a correct value, this can \n\nbe done by manual set of OFFSET or by a previously executed Section \n\nsearch. Before running the query at STR the name of the key must be are \n\npassed. If an empty string STR is handed over, the next key found is \n\nreturned. RUN = 2 means the query can be started. Once the search is \n\nfnished, it sets the parameters of RUN to 0. With RESULT the search \n\nresults will be issued. When in a query the key identifed a new Section, \n\nthis is reported by RESULT = 11. Upon successful search the output of the \n\nparameter KEY is the name of the found key , and VALUE is the key value. \n\nAnd then the OFFSET parameter points to the end of the key line. Thus, \n\nimmediately after the next Key evaluation be continued, without having to \n\nmanually change the OFFSET. \n\nEnumeration - see next item:\n\nFor very large amount of data of an initialization fle to be evaluated, with \n\na enumeration (list) the user program can be build simple, and the \n\nevaluation be carried out more quickly because here no line must be used \n\nmore than once. Before the start OFFSET must have a reasonable value, \n\nthe default case to 0. With RUN = 3 the evaluation is started. Once a \n\nsection or a key is found, it is also issued immediately. In a section KEY \n\nprints the name of the Section and RESULT = 1. With a found KEY, KEY has \n\nthe key name and VALUE is the key value, and RESULT= 2.\n\nIf in a query, the end of the data array is reached, this will be reported by \n\nRESULT = 10.\n\n165 Version 1.21\n\nChapter 10. File-System\n\nIf the fle access is no longer needed, the user must close the fle be either \n\nby use of AUTO_CLOSE or MODE 5 (close fle) of the FILE_SERVER.\n\nRUN: Feature List\n\nRUN Function\n\n0 No function to perform - and last function is complete\n\n1 Evaluate specific section or evaluate next found section \n\n2 evaluate specific Key or Key found next \n\n3 evaluate next found element (section or key) \n\nRESULT: Result - Feedback\n\nRESULT Description\n\n1 Section found\n\n2 Key found\n\n5 Current query is still running - call module further cyclical!\n\n10 Nothing found - reached the end of data\n\n11 Key not found - reached the end of Section\n\n166 Version 1.21\n\nChapter 11. Telnet-Vision\n\n 11. Telnet-Vision", "type": "FUNCTION", "name": "INI_PARSER_FILE", "input": [{"name": "FILENAME", "type": "STRING", "description": "The name of the INI file to be processed."}, {"name": "RUN", "type": "BYTE", "description": "Command code for the current action: 1 for section search, 2 for key search, 3 for enumeration."}, {"name": "OFFSET", "type": "UDINT", "description": "Current file offset for the query, indicating where to start searching within the INI file."}, {"name": "STR", "type": "STRING(STRING_LENGTH)", "description": "The string representing the name of the section or key to search for."}, {"name": "FSD", "type": "FILE_SERVER_DATA", "description": "The file interface for handling the INI file data."}, {"name": "PT", "type": "NETWORK_BUFFER", "description": "The buffer for reading data from the INI file."}], "output": [{"name": "RESULT", "type": "BYTE", "description": "The result of the search query, indicating the outcome of the operation."}, {"name": "KEY", "type": "STRING(STRING_LENGTH)", "description": "The name of the found section or key during the search."}, {"name": "VALUE", "type": "STRING(STRING_LENGTH)", "description": "The value associated with the found key."}], "in/out": [], "return_value": {"type": null, "description": null}}
{"title": "Geographic Information Retrieval from IP Address", "description": "IP2GEO (Geographic Data)\n\n99 Version 1.21\n\nChapter 9. Network and Communication\n\nINPUT ACTIVATE: BOOL (release for query)\n\nOUTPUT BUSY: BOOL (Query is active)\n\nDONE: BOOL (Query completed without errors)\n\nERROR_C: DWORD (Error code)\n\nERROR_T: BYTE (error type)\n\nThe device supplies because of the wide-area network IP address, the \n\ngeographic information of the Internet access. As the WAN IP addresses \n\nare registered worldwide, therefore can be determined the approximate \n\ngeographical position of the PLC. Should access runs through a proxy \n\nserver, so its geographic position is determined and not the PLC. Usually, \n\nbut normally it is in the nearness of the PLC, and thus the deviation is not \n\nrelevant. This results in calculated positions difer only a few miles from \n\nthe true position, and is relatively accurate.\n\nIf the parameter \"IP\" specifes no IP address, automatically the current \n\nWAN IP is used, otherwise the information of the confgured IP delivered. \n\nWith a positive edge of the ACTIVATE the request is started. As long as the \n\nquery is not complete, BUSY = TRUE is passed. After successful completion \n\nof the query DONE = TRUE, and the parameters WAN_IP the current WAN \n\nIP address displayed. If an error occurs during the query it is reported in \n\nERROR_C in combination with ERROR_T.\n\nERROR_T:\n\nValue Properties\n\n1 The exact meaning of ERROR_C can be read at module DNS_CLIENT\n\n2 The exact meaning of ERROR_C can be read at module HTTP_GET\n\nThe \"country_code is coded according to ISO 3166 country code ALPHA-2\".\n\nhttp://www.iso.org/iso/english_country_names_and_code_elements\n\nhttp://de.wikipedia.org/wiki/ISO-3166-1-Kodierliste\n\n100 Version 1.21\n\nChapter 9. Network and Communication\n\nThe \"REGION_CODE\" is coded to \"FIPS region code\". \n\nhttp://en.wikipedia.org/wiki/List_of_FIPS_region_codes", "type": "FUNCTION", "name": "IP2GEO", "input": [{"name": "IP_C", "type": "IP_C", "description": "Parameterization containing the IP address for which geographic data is requested."}, {"name": "S_BUF", "type": "NETWORK_BUFFER", "description": "Buffer for transmitting data during the query process."}, {"name": "R_BUF", "type": "NETWORK_BUFFER", "description": "Buffer for receiving data after the query is completed."}, {"name": "GEO", "type": "IP2GEO", "description": "Structure containing the geographic data returned based on the provided IP address."}, {"name": "ACTIVATE", "type": "BOOL", "description": "Flag that triggers the start of the query on a positive edge."}], "output": [{"name": "BUSY", "type": "BOOL", "description": "Indicates if the query is currently active."}, {"name": "DONE", "type": "BOOL", "description": "Indicates if the query has completed successfully without errors."}, {"name": "ERROR_C", "type": "DWORD", "description": "Error code generated if an error occurs during the query."}, {"name": "ERROR_T", "type": "BYTE", "description": "Error type that provides context about the error, refer to the DNS_CLIENT and HTTP_GET modules for exact meanings."}], "in/out": [], "return_value": {"type": "void", "description": "This function does not return a value directly. Instead, it populates the output parameters based on the query results."}}
{"title": "Subnet Check Function", "description": "IP4_CHECK checks if a network address of the NIP and the local address\n\nLIP are in the same Subnet lie. Both addresses will be frst masked with\n\nthe Subnet mask and then tested for equality. Only the bits which are in\n\nthe Subnet Mask TRUE are examined for equality. The network addresses\n\nmust correspond to the IPv4 format and presented as a DWORD. If IP ad￾dresses must be tested that are String they are to be converted to\n\nDWORD before. \n\nThe following example shows 2 IP addresses and a Subnet Mask as String\n\nare tested after appropriate conversion to DWORD there. The output is\n\nTRUE because both addresses are in the same Subnet .", "type": "FUNCTION", "name": "IP4_CHECK", "input": [{"name": "NIP", "type": "DWORD", "description": "Network IP address in DWORD format."}, {"name": "LIP", "type": "DWORD", "description": "Local IP address in DWORD format."}, {"name": "SM", "type": "DWORD", "description": "Subnet Mask in DWORD format."}], "output": [{"name": "Result", "type": "BOOL", "description": "TRUE if NIP and LIP are in the same Subnet; otherwise FALSE."}], "in/out": [], "return_value": {"type": "BOOL", "description": "Returns TRUE if the NIP and LIP are in the same subnet, otherwise returns FALSE."}}
{"title": "IP Address Decoder", "description": "IP4_DECODE decodes the in STR stored string as a IP v4 address and re￾turns it as a DWORD. A return of 0 means an invalid address or an address\n\nof '0.0.0.0 ' was evaluated. IP4 may be used for evaluating a Subnet Mask\n\nof the IP v4 format.", "type": "FUNCTION", "name": "IP4_DECODE", "input": [{"name": "STR", "type": "STRING(15)", "description": "A string that contains the IPv4 address."}], "output": [{"name": "DWORD", "type": "DWORD", "description": "The decoded IPv4 address."}], "in/out": [], "return_value": {"type": "DWORD", "description": "Returns the decoded IPv4 address as a DWORD. A return value of 0 indicates that the address is invalid or '0.0.0.0'."}}
{"title": "IP4 to String Conversion", "description": "IP4_TO_STRING converts the IP4 address stored as DWORD in a string. The\n\nformat is 'NNN.NNN.NNN.NNN'.", "type": "FUNCTION", "name": "IP4_TO_STRING", "input": [{"name": "IP4", "type": "BOOL", "description": "A string that contains the IP address in DWORD format."}], "output": [{"name": "IPAddressString", "type": "STRING", "description": "The decoded IP v4 address in string format."}], "in/out": [], "return_value": {"type": "DWORD", "description": "Decoded IP v4 address.", "fields": []}}
{"title": "IP_CONTROL Function Module", "description": "IP_CONTROL enables manufacturers and platform-neutral use of \n\nEthernet communications. In order to unite the many diferent interfaces \n\nof the PLC-companies that IP_CONTROL is used as an adapter \"wrapper\" . \n\nThis module UDP and TCP as well as active and passive connections can \n\nbe handled. As in some small controls the number of simultaneous open \n\nsockets is very limited, so this module also supports the sharing of \n\nsockets. An integrated automatic coordination of requests allows to divide \n\na socket to a number of client devices. Here is automatically recognized \n\nwhether a client uses a diferent connection parameters than its \n\npredecessor. An existing connection is automatically terminated, and \n\nestablished with the new connection parameters . The type of connection \n\ncan be set with C_MODE (see table). With C_PORT the desired port number \n\nis given, and by the C_IP the IP v4 address. With C_STATE can be \n\ndetermined whether the connection is established - closed, resp. the \n\nnegative and positive edge on change of state. C_ENABLE agent will \n\nrelease the connection (establish) or close (removed). The send and \n\nreceive data works independently of each another, which means it is also \n\npossible to send and receive asynchronous such as Telnet. In applications \n\nwhich only send data and no data receive is expected R_OBSERVE must be \n\nFALSE, so that no Timeout at receive occurs. At the start of transmit and \n\nreceive activities TIME_RESET is set by the user a to TRUE once, so that all \n\ntimeout start over with a defned start value. This is required due to the \n\nSharing functionality, because established connections remains connected \n\nand the access rights are passed here only. The parameter IP serves as a \n\npossible default IP address. To avoid repeating the same IP address \n\nparameters, a Default - IP can be used. One possible use would be to \n\nspecify the DNS server address. When the module recognizes as C_IP the \n\nIP 0.0.0.0, it automatically uses the default IP address. The same behavior \n\n102 Version 1.21\n\nChapter 9. Network and Communication\n\nis at the Port parameter. If at the port C_PORT a 0 is detected so the \n\nparameterized block port number of the module is used. The error code \n\nERROR consists of several parts (see table ERROR). With TIMEOUT the \n\noverall monitoring time can be specifed. This time value is independently \n\nused used for connection, send data and receive data. The transferred \n\nTIMEOUT value is automatically limited to 200 ms minimum. Thus, this \n\nparameter can remain free.\n\nThe data block is automatically sent if in a shared connection in the send \n\nbufer the transmit data and data length are entered. For data reveice, the \n\ndata is appended to the already existing data in the bufer. By setting SIZE \n\n= 0, the receive data pointer is reset and the next received data is then \n\nstored at position 0. \n\nThe module supports the blocking of data messages, that means the \n\nS_BUF resp. R_BUF can be arbitrarily large. Individual received data frames \n\nare collected in R_BUF in stream form. Just the same when process data \n\nare sent. The data in S_BUF is sent individually as Stream allowed block \n\nsize.\n\nApplication example: \n\n CASE state OF \n\n00: (* On Wait for release *) \n\n IF RELEASE THEN \n\n state := 10;\n\n IP_STATE: = 1; (* Sign on *) \n\n END_IF;\n\n10: (* Wait for clearance to access for connection and sending content *) \n\n IF IP_STATE = 3 THEN (* access permitted? *)\n\n (* IP set up data traffic *)\n\n IP_C.C_PORT: = 123; (* enter port number *) \n\n IP_C.C_IP = IP4; (* Enter IP *) \n\n IP_C.C_MODE:= 1; (* Mode: UDP+ACTIVE+Port+IP *) \n\n IP_C.C_ENABLE:= TRUE; (* Release connection *) \n\n IP_C.TIME_RESET: = TRUE; (Reset time monitoring * *) \n\n IP_C.R_OBSERVE: = TRUE; (* Monitor data receive *) \n\n R_BUF.SIZE:= 0; (* Reset Home length *) \n\n (* Send data register *)\n\n S_BUF.BUFFER[0] := BYTE#16#1B;\n\n (* Etc. ... *)\n\n S_BUF.SIZE: = xx; (* enter send length *) \n\n103 Version 1.21\n\nChapter 9. Network and Communication\n\n state := 30;\n\n30:\n\n IF IP_C.ERROR <> 0 THEN\n\n (* Perform error analysis *)\n\n ELSIF S_BUF.SIZE = 0 AND R_BUF.SIZE >= xxx THEN\n\n (* evaluate received data *)\n\n (* Logout - release access for other *)\n\n IP_STATE := BYTE#4;\n\n state: = 0 0; (* process end *) \n\n END_IF;\n\nEND_CASE;\n\n(* IP_FIFO call cyclic *)\n\nIP_FIFO(FIFO:=IP_C.FIFO,STATE:=IP_STATE,ID:=IP_ID);\n\nIP_C.FIFO:=IP_FIFO.FIFO;\n\nIP_STATE := IP_FIFO.STATE;\n\nIP_ID:=IP_FIFO.ID;\n\nfollowing C_MODE may be used:\n\nTYP\n\nE\n\nTCP / UDP Aktiv / Passiv Port number required IP address required\n\n0 TCP Active Yes Yes\n\n1 UDP Active Yes Yes\n\n2 TCP Passive Yes Yes (Address of the active part￾ner)\n\n3 UDP Passive Yes Yes (Address of the active part￾ner)\n\n4 TCP Passive Yes No (Any active partner will be ac￾cepted)\n\n5 UDP Passive Yes No (Any active partner will be ac￾cepted)\n\nC_STATE:\n\nValue State Message\n\n0 connection is down\n\n104 Version 1.21\n\nChapter 9. Network and Communication\n\n1 Connection has been broken down (negative edge) value exists only for one cycle, then re￾turns 0.\n\n254 Connection is established (positive edge) value exists for one cycle, then returns 255. \n\n255 Connection is established\n\n<127 query if connections is established\n\n>127 query if connection is established\n\n \n\nERROR:\n\nDWORD Message Type Description\n\nB3 B2 B1 B0\n\n00 xx xx xx Connection establish Value 00 - No errors found\n\nnn xx xx xx Connection establish Value 01-252 system-specific error\n\nFD xx xx xx Connection establish Value 253 - Connection closed by remote\n\nFF xx xx xx Connection establish value 255 - Timeout Error\n\nxx 00 xx xx Send data Value 00 - No errors found\n\nxx nn xx xx Send data Value 01-252 system-specific error\n\nxx FF xx xx Send data value 255 - Timeout Error\n\nxx xx 00 xx Receive data Value 00 - No errors found\n\nxx xx nn xx Receive data Value 01-252 system-specific error\n\nxx xx FF xx Receive data value 255 - Timeout Error\n\nxx xx FE xx Receive data Value 254 - Receive buffer is full (overflow) \n\n(Buffer size is automatically set to 0)\n\nxx xx xx nn Application- Error In IP_CONTROL always 00\n\nERROR is transferred originally from the client appli￾cation and optionally, at this point an application error\n\nis reported. This error code is entered, but only by the\n\nclient devices.\n\n System-specifc error: (PCWorx / MULTIPROG)\n\nValue State Message\n\n0x00 No error occurred.\n\n105 Version 1.21\n\nChapter 9. Network and Communication\n\n0x01 Creation of at least one task has failed.\n\n0x02 Initialization of the socket interface failed (only WinNT).\n\n0x03 Dynamic memory could not be reserved.\n\n0x04 FB can not be initialized because at start the asynchronous communication tasks, an error\n\nhas occurred.\n\n0x10 Socket initialization failed.\n\n0x11 Error at sending a message.\n\n0x12 Error when receiving a message.\n\n0x13 Unknown service code in the message header.\n\n0x21 Invalid state transition upon connection.\n\n0x30 No more free channels available.\n\n0x31 The connection was canceled.\n\n0x33 General timeout, receiver or transmitter does not answer or sender has not completed\n\ntransmission.\n\n0x34 Connection request has been negatively acknowledged.\n\n0x35 Recipient did not confirm transfer, possibly overloaded receivers (repeat transfer).\n\n0x40 Partner-string is too long (255 characters max).\n\n0x41 The specified IP address is not valid or could not be interpreted correctly.\n\n0x42 not valid port number.\n\n0x45 Unknown parameters to input \"PARTNER\".\n\n0x50 Transmission attempt on invalid connection (sender or receiver).\n\n0x53 All available connections are occupied.\n\n0x61 Neg. confirmation of the recipient. It was used an incorrect sequence number.\n\n0x62 Data type of transmitter and receiver are not equal.\n\n0x63 Receiver is at the moment not ready to receive (poss. Cause: The recipient is disabled or is\n\ncurrently in the data transfer (NDR = TRUE).\n\n0x64 Can not find a receiver module with the corresponding R_ID.\n\n0x65 Another module instance is already working on this connection.\n\n0x70 Partner control was not configured as a time server.\n\n \n\n106 Version 1.21\n\nChapter 9. Network and Communication\n\n System-specifc error: (CoDeSys)\n\n0x00 No error occurred.\n\n0x01 SysSockCreate unsuccessful\n\n0x02 SysSockBind unsuccessful\n\n0x03 SysSockListen unsuccessful\n\n \n\n System-specifc error: (Beckhof)\n\n0x00 No error occurred.\n\n0x01 SocketUdpCreate unsuccessful\n\n0x03 socket listen unsuccessful\n\n0x04 SocketAccept unsuccessful", "type": "FUNCTION", "name": "IP_CONTROL", "input": [{"name": "IP_C", "type": "IP_C", "description": "Parameterization for connection control."}, {"name": "S_BUF", "type": "NETWORK_BUFFER", "description": "Buffer for transmitting data."}, {"name": "R_BUF", "type": "NETWORK_BUFFER", "description": "Buffer for receiving data."}, {"name": "IP", "type": "DWORD", "description": "Encoded IP address as the default."}, {"name": "PORT", "type": "WORD", "description": "Port number of the IP address."}, {"name": "TIME_OUT", "type": "TIME", "description": "Monitoring time for connection, send, and receive operations."}], "output": [], "in/out": [], "return_value": {"type": "DWORD", "description": "Error code representing the status of the function execution.", "fields": [{"name": "Error Code", "type": "DWORD", "description": "Code indicating the type of error or status where 0 signifies no errors."}]}}
{"title": "Network Communication Module", "description": "IP_CONTROL2 . The maximum \n\ndata size for transmission and reception depends on the hardware \n\nplatform and is in the range of < 1500 bytes. This module can always be \n\nused when no data stream mode is needed. The primary advantage is that \n\nless bufer memory is required, and data will not be copied between \n\ninternal and external data bufer. Thus, the module is more economical \n\nwith respect to memory consumption and system load.", "type": "FUNCTION", "name": "IP_CONTROL2", "input": [{"name": "IP_C", "type": "IP_C", "description": "Parameterization data for network control."}, {"name": "S_BUF", "type": "NETWORK_BUFFER_SHORT", "description": "Buffer for transmitting data."}, {"name": "IP", "type": "DWORD", "description": "Encoded IP address as the default."}, {"name": "PORT", "type": "WORD", "description": "Port number of the IP address."}, {"name": "TIME_OUT", "type": "TIME", "description": "Monitoring time for network operations."}], "output": [{"name": "R_BUF", "type": "NETWORK_BUFFER_SHORT", "description": "Buffer for receiving data."}], "in/out": [{"name": "IP_C", "type": "IP_C", "description": "Parameterization that can be read or modified."}], "return_value": {"type": "DWORD", "description": "Indicates the status of the network operation.", "fields": []}}
{"title": "IP FIFO Management Module", "description": "IP_FIFO_DATA (IP-FIFO management data)\n\nID: BYTE (current ID assigned by IP_FIFO module)\n\nSTATE: BYTE (control commands and status messages)\n\n108 Version 1.21\n\nChapter 9. Network and Communication\n\n109 Version 1.21\n\nChapter 9. Network and Communication\n\nThis module is used in combination with IP_CONTROL for resource mana￾gement. This makes it possible that client applications request exclusive \n\naccess permissions and can also give back. By the FIFO is ensured that \n\neach participant equally often gets the resource access assigned.\n\nIn the frst call of the module automatically a new unique application ID is \n\nassigned, which one the administration in FIFO is managed. The STATE pa￾rameter is changed by the application as well as from IP_FIFO module. \n\nEach application may register by default only once in the FIFO.\n\nSTATE:\n\nValue State Message\n\n0 no action\n\n1 Privilege request\n\n2 Privilege request has been accepted in FIFO\n\n3 Privilege obtained (allowing resource access)\n\n4 Privilege remove\n\n5 Privilege was again removed from FIFO\n\nProcedure:\n\n1. application set the STATE to 1\n\n2. Access permission are required as is the STATE = 2\n\n3. if resource is free, and access rights are present, then \n\n STATE=3\n\n4. If the application has the resource resp. the access needs\n\n not anymore the application sets STATE to 4. Thereafter \n\n IP_FIFO releases the resource again and set STATE to 0.\n\n5. Process is repeated (same or other application)", "type": "FUNCTION", "name": "IP_FIFO", "input": [{"name": "IP_FIFO_DATA", "type": "struct", "description": "Management data for IP FIFO", "fields": [{"name": "ID", "type": "BYTE", "description": "Current ID assigned by IP_FIFO module"}, {"name": "STATE", "type": "BYTE", "description": "Control commands and status messages"}]}], "output": [], "in/out": [], "return_value": {"type": "struct", "description": "Return value indicating the state of the resource access", "fields": [{"name": "STATE_MESSAGE", "type": "BYTE", "description": "Message indicating the current state of the resource access"}]}}
{"title": "IRTRANS_DECODE Function Module", "description": "IRTRANS_DECODE receives the data from the module IRTRANS_SERVER\n\npresent in BUFFER, checks if a valid data package is available and deco￾des the name of the remote control and the name of the button form the\n\ndata packet. If a valid data packet has been decoded, the name of the re￾mote control is passed at the output DEV and the name of the button on\n\nthe output KEY. The output CMD signals that the new output data are pre￾sent. The ERROR output is then set when a data packet was received that\n\nis not in the correct format.\n\nThe format is defned as follows:\n\n'Name of the remote control', 'Name of the key code' $R$N\n\nA data packet consists of the name of the remote control, followed by a\n\ncomma and then the name of the key codes. The data packet is a comple￾ted by Carriage Return and a Line Feed . \n\nTo ensure that IRTRANS_DECODE works in the IRTrans confguration the\n\nCheck box BROADCAST IR RELAY must be checked and in the correspon￾ding Device database under the DEFAULT ACTION the String '%r%c\\r\\n'\n\nmust be registered. IRTRANS_DECODE evaluates just this String and deco￾des %r as the name and %c as pressed a button of the remote control.", "type": "FUNCTION", "name": "IRTRANS_DECODE", "input": [{"name": "IP_C", "type": "struct", "description": "Data structure for parameterization.", "fields": []}, {"name": "R_BUF", "type": "struct", "description": "Data structure for receiving data.", "fields": [{"name": "data", "type": "STRING", "description": "Buffer that contains the received data."}]}], "output": [{"name": "CMD", "type": "BOOL", "description": "TRUE if valid data are present at the output."}, {"name": "DEV", "type": "STRING", "description": "Name of the remote control."}, {"name": "KEY", "type": "STRING", "description": "Name of the key codes."}, {"name": "ERROR", "type": "BOOL", "description": "TRUE if an invalid data packet is present."}], "in/out": [], "return_value": null}
{"title": "IRTRANS_RCV_1 Function Module", "description": "IRTRANS_RCV_1 checkes when CMD = TRUE if the string matches the input\n\nDEV corresponds to DEV_CODE (device code) and the string at the input\n\n37 Version 1.21\n\nChapter 6. Device Driver\n\nKEY corresponds to the KEY_CODE. If the codes match and CMD = TRUE,\n\nthen the output Q for a cycle is set to TRUE.\n\nThe following example shows the application of IRTRANS_RCV_1:\n\nIn this example, the receive data bufer to IRTRANS_DECODE is passed.\n\nThe decoder determines from the valid data packets String DEV and KEY\n\nand passes them with CMD to IRTRANS_RCV_1 . \n\nIRTRANS_RCV_1 or alternatively IRTRANS_RCV_4 and IRTRANS_RCV_ checks\n\nwhether DEV and KEY match and then switches the output Q for a cycle to\n\nTRUE. in the example a DRIVER_1 is controlled which enables the remote\n\ncontrol to switch the output with each received log.\n\n If multiple Key Codes are to be evaluated alternatively the modules IR￾TRANS_RCV_4 or IRTRANS_RCV_8 can be used or more of these modules\n\ncan be used in parallel mode. \n\n38 Version 1.21\n\nChapter 6. Device Driver", "type": "FUNCTION", "name": "IRTRANS_RCV_1", "input": [{"name": "CMD", "type": "BOOL", "description": "TRUE if data for evaluating are available"}, {"name": "DEV", "type": "STRING", "description": "Name of the remote control"}, {"name": "KEY", "type": "STRING", "description": "Name of the button"}, {"name": "DEV_CODE", "type": "STRING", "description": "Device code to be decoded from the remote control name"}, {"name": "KEY_CODE", "type": "STRING", "description": "Key code to be decoded"}], "output": [{"name": "Q", "type": "BOOL", "description": "Output indicating if conditions are met (set to TRUE for a cycle)"}], "in/out": [], "return_value": null}
{"title": "IRTRANS_RCV_4 Function Module", "description": "IRTRANS_RCV_4 checkes when CMD = TRUE if the string matches the input\n\nDEV corresponds to DEV_CODE (device code) and the string at the input\n\nKEY corresponds to the KEY_CODE. If the codes match and CMD = TRUE,\n\nthen the output Q for a cycle is set to TRUE. For more information about\n\nthe function of the device are under IRTRANS_RCV_1.", "type": "FUNCTION", "name": "IRTRANS_RCV_4", "input": [{"name": "CMD", "type": "BOOL", "description": "Indicates whether data for evaluating are available (TRUE if available)."}, {"name": "DEV", "type": "STRING", "description": "The name of the remote control."}, {"name": "KEY", "type": "STRING", "description": "The name of the button."}, {"name": "DEV_CODE", "type": "STRING", "description": "Device code that corresponds to the remote control."}, {"name": "KEY_CODE_0", "type": "STRING", "description": "Key code 0 to be decoded."}, {"name": "KEY_CODE_1", "type": "STRING", "description": "Key code 1 to be decoded."}, {"name": "KEY_CODE_2", "type": "STRING", "description": "Key code 2 to be decoded."}, {"name": "KEY_CODE_3", "type": "STRING", "description": "Key code 3 to be decoded."}], "output": [{"name": "Q0", "type": "BOOL", "description": "Output signal 0 indicating if the conditions are met."}, {"name": "Q1", "type": "BOOL", "description": "Output signal 1 indicating if the conditions are met."}, {"name": "Q2", "type": "BOOL", "description": "Output signal 2 indicating if the conditions are met."}, {"name": "Q3", "type": "BOOL", "description": "Output signal 3 indicating if the conditions are met."}], "in/out": [], "return_value": {"type": "void", "description": "This function does not return a value."}}
{"title": "IRTRANS_RCV_8 Function Module", "description": "IRTRANS_RCV_8 checkes when CMD = TRUE if the string matches the input\n\nDEV corresponds to DEV_CODE (device code) and the string at the input\n\nKEY corresponds to the KEY_CODE. If the codes match and CMD = TRUE,\n\n39 Version 1.21\n\nChapter 6. Device Driver\n\nthen the output Q for a cycle is set to TRUE. For more information about\n\nthe function of the device are under IRTRANS_RCV_1.", "type": "FUNCTION", "name": "IRTRANS_RCV_8", "input": [{"name": "CMD", "type": "BOOL", "description": "TRUE if data for evaluating are available."}, {"name": "DEV", "type": "STRING", "description": "Name of the remote control."}, {"name": "KEY", "type": "STRING", "description": "Name of button."}, {"name": "DEV_CODE", "type": "STRING", "description": "To be decoded remote control name."}, {"name": "KEY_CODE_0", "type": "STRING", "description": "Key code to be decoded."}, {"name": "KEY_CODE_1", "type": "STRING", "description": "Key code to be decoded."}, {"name": "KEY_CODE_2", "type": "STRING", "description": "Key code to be decoded."}, {"name": "KEY_CODE_3", "type": "STRING", "description": "Key code to be decoded."}, {"name": "KEY_CODE_4", "type": "STRING", "description": "Key code to be decoded."}, {"name": "KEY_CODE_5", "type": "STRING", "description": "Key code to be decoded."}, {"name": "KEY_CODE_6", "type": "STRING", "description": "Key code to be decoded."}, {"name": "KEY_CODE_7", "type": "STRING", "description": "Key code to be decoded."}], "output": [{"name": "Q0", "type": "BOOL", "description": "Output signal for key code 0."}, {"name": "Q1", "type": "BOOL", "description": "Output signal for key code 1."}, {"name": "Q2", "type": "BOOL", "description": "Output signal for key code 2."}, {"name": "Q3", "type": "BOOL", "description": "Output signal for key code 3."}, {"name": "Q4", "type": "BOOL", "description": "Output signal for key code 4."}, {"name": "Q5", "type": "BOOL", "description": "Output signal for key code 5."}, {"name": "Q6", "type": "BOOL", "description": "Output signal for key code 6."}, {"name": "Q7", "type": "BOOL", "description": "Output signal for key code 7."}], "in/out": [], "return_value": {"type": null, "description": null}}
{"title": "IRTRANS Server Function Module", "description": "IRTRANS_SERVER can be used as both a receiver and a transmitter of IR￾TRANS commands. Is UDP_TCP = TRUE is a passive TCP connection, other￾wise set up a passive UDP connection. The type of operation must also be\n\nconfgured with IRTRANS device. Once a data connection is available and\n\nsending commands is allowed, S_ENABLE = TRUE. In UDP mode, after the\n\ninitial data received from IRTRANS, data can be sent, since in the passive\n\nmode, the UDP-IP parameter is initially not known. The receiving mode is\n\nindicated with R_ENABLE. If data are received they are available in R_BUF\n\nfor further processing for other modules. Send data has to be entered by\n\nthe modules in the S_BUF, so they are then sent automatically from IR-\n\n40 Version 1.21\n\nChapter 6. Device Driver\n\nTRANS_SERVER. If transmission errors occurs, they are issued with \"ER￾ROR\" (see module IP_CONTROL2). Existing errors are acknowledged auto￾matically every 5 seconds by the module.\n\nUDP server mode:\n\nIn the IRTRANS Web confguration, the IP address of the PLC is entered as\n\na broadcast address.\n\nIRTRANS Web Confguration:\n\nThe following example shows the application of IRTRANS Devices\n\n41 Version 1.21\n\nChapter 6. Device Driver", "type": "FUNCTION", "name": "IRTRANS_SERVER", "input": [{"name": "UDP_TCP", "type": "BOOL", "description": "Selects the communication mode; FALSE for UDP and TRUE for TCP."}, {"name": "IP_C", "type": "IP_CONTROL", "description": "Data structure for parameterization of the IP control settings.", "fields": [{"name": "ipAddress", "type": "STRING", "description": "IP address for the communication."}, {"name": "port", "type": "UINT", "description": "Port number for the communication."}]}, {"name": "S_BUF", "type": "NETWORK_BUFFER_SHORT", "description": "Data structure for transmitting data.", "fields": [{"name": "data", "type": "STRING", "description": "The actual data to be transmitted."}, {"name": "length", "type": "UINT", "description": "Length of the data to be sent."}]}, {"name": "R_BUF", "type": "NETWORK_BUFFER_SHORT", "description": "Data structure for receiving data.", "fields": [{"name": "data", "type": "STRING", "description": "The received data."}, {"name": "length", "type": "UINT", "description": "Length of the received data."}]}], "output": [{"name": "S_ENABLE", "type": "BOOL", "description": "Indicates whether IRTRANS data can be sent."}, {"name": "R_ENABLE", "type": "BOOL", "description": "Indicates whether IRTRANS data reception is enabled."}, {"name": "ERROR", "type": "DWORD", "description": "Error code indicating issues with the IP control settings."}], "in/out": [], "return_value": null}
{"title": "IRTrans Remote Command Sender", "description": "IRTRANS_SND_1 allows you to send a remote command to the IRTrans. If IN\n\nTRUE the specifed device and key code in setup is sent to the IRTrans\n\nwhich outputs in turn as a real remote control commands. With T_REPEAT\n\nthe repeat time for sending can be specifed . If IN remains constant to\n\nTRUE so always this key code sent repeated after the time T_REPEAT. At\n\noutput KEY in active control \"1\" is passed. KEY = 0 means that the IN is\n\nnot active.", "type": "FUNCTION", "name": "IRTRANS_SND_1", "input": [{"name": "IN", "type": "BOOL", "description": "Indicates whether to send the key code (TRUE to send key code)"}, {"name": "T_REPEAT", "type": "TIME", "description": "The time interval for re-sending the key code"}, {"name": "IP_C", "type": "struct", "description": "Data structure for parameterization", "fields": []}, {"name": "S_BUF", "type": "struct", "description": "Data structure for network buffer to transmit data", "fields": []}, {"name": "DEV_CODE", "type": "STRING", "description": "The name of the remote control to be decoded"}, {"name": "KEY_CODE", "type": "STRING", "description": "The key code to be decoded"}], "output": [{"name": "KEY", "type": "BYTE", "description": "The output of the currently active key codes. KEY = 0 means that the IN is not active."}], "in/out": [], "return_value": {"type": null, "description": null}}
{"title": "IRTRANS_SND_4 Function Module", "description": "IRTRANS_SND_4 allows users to send remote control commands to the IR￾Trans. If IN_x is TRUE the specifed device and key code in setup is sent to\n\nthe IRTrans which outputs in turn as a real remote control commands. With\n\nT_REPEAT the repeat time for sending can be specifed . If IN_0 remains\n\nconstant to TRUE so always this key code sent repeated after the time\n\nT_REPEAT. If a change to a diferent IN_x occures this code will send imme￾diately and then again delayed with T_REPEAT, if it remains a long period\n\nof time. At output KEY the currently controlled KEY will be displayed. KEY\n\n= 0 means that no IN_x is active. The values 1-3 are the IN_0 - IN_3.", "type": "FUNCTION", "name": "IRTRANS_SND_4", "input": [{"name": "IN_0", "type": "BOOL", "description": "If TRUE, sends the key code x to the IRTrans."}, {"name": "IN_1", "type": "BOOL", "description": "If TRUE, sends the key code x to the IRTrans."}, {"name": "IN_2", "type": "BOOL", "description": "If TRUE, sends the key code x to the IRTrans."}, {"name": "IN_3", "type": "BOOL", "description": "If TRUE, sends the key code x to the IRTrans."}, {"name": "T_REPEAT", "type": "TIME", "description": "Time interval to re-send the key code."}, {"name": "IP_C", "type": "struct", "description": "Data structure containing parameterization information for IP control.", "fields": []}, {"name": "S_BUF", "type": "struct", "description": "Data structure to transmit network buffer.", "fields": []}, {"name": "DEV_CODE", "type": "STRING", "description": "The name of the remote control to be decoded."}, {"name": "KEY_CODE_0", "type": "STRING", "description": "Key code to be sent when IN_0 is active."}, {"name": "KEY_CODE_1", "type": "STRING", "description": "Key code to be sent when IN_1 is active."}, {"name": "KEY_CODE_2", "type": "STRING", "description": "Key code to be sent when IN_2 is active."}, {"name": "KEY_CODE_3", "type": "STRING", "description": "Key code to be sent when IN_3 is active."}], "output": [{"name": "KEY", "type": "BYTE", "description": "Displays the currently controlled key. KEY = 0 means no IN_x is active; values 1-3 represent states of IN_0 to IN_3."}], "in/out": [], "return_value": {"type": null, "description": null}}
{"title": "IRTRANS_SND_8", "description": "IRTRANS_SND_8 allows users to send remote control commands to the IR￾Trans. If IN_x is TRUE the specifed device and key code in setup is sent to\n\nthe IRTrans which outputs in turn as a real remote control commands. With\n\nT_REPEAT the repeat time for sending can be specifed . If IN_0 remains\n\nconstant to TRUE so always this key code sent repeated after the time\n\nT_REPEAT. If a change to a diferent IN_x occures this code will send imme￾diately and then again delayed with T_REPEAT, if it remains a long period\n\nof time. At output KEY the currently controlled KEY will be displayed. KEY\n\n= 0 means that no IN_x is active. The values 1-3 are the IN_0 - IN_7.\n\n45 Version 1.21\n\nChapter 7. Data Logger\n\n 7. Data Logger", "type": "FUNCTION", "name": "IRTRANS_SND_8", "input": [{"name": "IN_0", "type": "BOOL", "description": "Input flag to send keycode x (TRUE = send keycode). This applies to IN_0 through IN_7."}, {"name": "T_REPEAT", "type": "TIME", "description": "Time interval for re-sending the key code when the respective input remains TRUE."}, {"name": "IP_C", "type": "struct IP_CONTROL", "description": "Data structure for parameterization.", "fields": []}, {"name": "S_BUF", "type": "struct NETWORK_BUFFER_SHORT", "description": "Data structure for transmitting the key code.", "fields": []}, {"name": "DEV_CODE", "type": "STRING", "description": "String representing the remote control name to be decoded."}, {"name": "KEY_CODE_0", "type": "STRING", "description": "Key code to be sent (for IN_0). This applies to KEY_CODE_0 through KEY_CODE_7."}], "output": [{"name": "KEY", "type": "BYTE", "description": "Output representing the currently active key codes. KEY = 0 means no inputs are active."}], "in/out": [], "return_value": {"type": null, "description": null}}
{"title": "IP Address Validation Function", "description": "IS_IP4 checks if the string str contains a valid IP v4 address, if not FALSE is\n\nreturned. A valid IP v4 address consists of 4 numbers from 0 - 255 and\n\nthey are separated each with one point. The address 0.0.0.0 is there clas￾sifed as wrong.\n\nIS_IP4(0.0.0.0) = FALSE\n\nIS_IP4(255.255.255.255) = TRUE\n\nIS_IP4(256.255.255.255) = FALSE\n\nIS_IP4(0.1.2.) = FALSE\n\nIS_IP4(0.1.2.3.) = FALSE\n\n78 Version 1.21\n\nChapter 8. Converter", "type": "FUNCTION", "name": "IS_IP4", "input": [{"name": "STR", "type": "STRING", "description": "The string to be tested for a valid IPv4 address."}], "output": [{"name": "BOOL", "type": "BOOL", "description": "Returns TRUE if STR contains a valid IPv4 address, otherwise returns FALSE."}], "in/out": [], "return_value": {"type": "BOOL", "description": "A boolean value indicating the validity of the IPv4 address."}}
{"title": "IP Address Validation Function", "description": "IS_URLCHR checks if the string contains only valid characters for a URL en￾coding. If the string contains reserved characters it returns FALSE, otherwi￾se TRUE.\n\nFor a URL following characters are valid:\n\n[A..Z]\n\n[a..z]\n\n[0..9]\n\n[-._~]\n\nall other characters are reserved or not allowed.", "type": "FUNCTION", "name": "IS_URLCHR", "input": [{"name": "string_to_test", "type": "STRING", "description": "The string that needs to be tested for a valid IPv4 address."}], "output": [{"name": "is_valid_ip", "type": "BOOL", "description": "Returns TRUE if the input string contains a valid IPv4 address, otherwise FALSE."}], "in/out": [], "return_value": {"type": "BOOL", "description": "The result of the validation indicating whether the input is a valid IP v4 address.", "fields": []}}
{"title": "Log Control Function Module", "description": "LOG_MSG messages (STRINGS) are stored in a ring bufer. The \n\nmessages can be provided with additional parameters such as the front \n\ncolor and back color for the output to TELNET and a flter by specifying an \n\nentry-level news. Is the level of the message larger than the default log \n\nlevel, the message is discarded. Furthermore,with Enable the logging will \n\nbe disabled in general. Thus, it is not a problem to archive many messages \n\nper PLC cycle. The message bufer can be passed to a telnet client with \n\nthe module TELNET_LOG. Details on the interface are shown in the table \n\nbelow.\n\nIf messages are applied from various module instances to the same \n\nLOG_BUFFER, then the \"LOG_CL\" data structure has to be created Global.", "type": "FUNCTION", "name": "LOG_MSG", "input": [{"name": "LOG_MSG", "type": "STRING", "description": "Messages to be stored in the log."}, {"name": "FrontColor", "type": "STRING", "description": "Color of the front text in the output to TELNET."}, {"name": "BackColor", "type": "STRING", "description": "Color of the background in the output to TELNET."}, {"name": "LogLevel", "type": "INT", "description": "Filtering log messages based on the entry-level news."}, {"name": "Enable", "type": "BOOL", "description": "If true, logging is enabled; if false, logging is disabled."}], "output": [], "in/out": [], "return_value": {"type": "BOOL", "description": "Indicates whether the log message was successfully processed.", "fields": []}}
{"title": "LOG_VIEWPORT Module", "description": "LOG_VIEWPORT\n\nThe module LOG_VIEWPORT is used to index a list of LOG_CONTROL \n\nmessages, which are currently in the virtual view. To move around within \n\nthe message list (scroll), a scroll ofset can be specifed by LV.MOVE_TO_X. \n\nA positive value scroll in direction of newer reports and a negative value \n\nin the direction of the earlier messages. The number of lines in the \n\n111 Version 1.21\n\nChapter 9. Network and Communication\n\nmessage list of the virtual view is given by LV.COUNT. The current \n\nmessages in the virtual view are stored in LV.LINE_ARRAY [x], and are \n\navailable for further processing. A change in the message list is always \n\nannounced with LV.UPDATE:= TRUE, and the user has to reset.\n\n The following LV.MOVE_TO_X values produce a special behavior.\n\n+30000 = display previous Messages (beginning of the ring bufer)\n\n+30001 = display latest messages (end of the ring bufer)\n\n+30002 = one full page in direction of recent messages.\n\n+30003 = One full page in direction of older messages", "type": "FUNCTION", "name": "LOG_VIEWPORT", "input": [{"name": "LC", "type": "LOG_CONTROL", "description": "Control data for logging messages."}, {"name": "LV", "type": "us_LOG_VIEWPORT", "description": "Viewport data structure for managing display of log messages.", "fields": [{"name": "MOVE_TO_X", "type": "INTEGER", "description": "Scroll offset to navigate through log messages."}, {"name": "COUNT", "type": "INTEGER", "description": "Total number of lines in the message list of the virtual view."}, {"name": "LINE_ARRAY", "type": "ARRAY", "description": "Array containing the current messages in the virtual view.", "fields": [{"name": "x", "type": "STRING", "description": "Individual message text."}]}, {"name": "UPDATE", "type": "BOOLEAN", "description": "Flag to indicate whether the message list has changed."}]}], "output": [], "in/out": [], "return_value": {"type": "VOID", "description": "No return value for the LOG_VIEWPORT function."}}
{"title": "MODBUS Client Function Module", "description": "MB_CLIENT The module provides access to Ethernet devices, the MODBUS TCP or \n\nMODBUS UDP supported, or MODBUS RS232/485 devices are connected \n\nvia Ethernet Modbus gateway. There commands from Classes 0,1,2 are \n\nsupported. The parameters IP_C, S_BUF, R_BUF this form the interface to \n\nthe module IP_CONTROL and used here for processing and coordination. \n\nThe desired IP address and port number (for MODBUS default is 502) must \n\nbe specifed on IP_CONTROL centrally. The DATA structure is designed as a \n\nWORD array and contains the MODBUS data for reading and writing. The \n\nsize of the WORD_ARRAY is given by DATA_SIZE. By ENABLE, the module is \n\nreleased, and by remove of the release a possibly still active query is \n\nended. For devices that support MODBUS with UDP = TRUE this mode can \n\nbe activated. The parameter UNIT_ID must only at use of Ethernet Modbus \n\nprovided. The desired function is specifed by FC (see function code table). \n\nDepending on the function, the R_xxx and W_xxx parameters has to be \n\nsupplied with data. By specifying the DELAY the repetition time can be \n\nspecifed. If not specify the time an attempt is made as often as possible \n\nto execute the command. The integrated access management \n\nautomatically guarantees to get the other module instances also to the \n\nseries. A negative command execution is reported by ERROR (see ERROR￾table). If the module actively performs a query, then BUSY = TRUE will be \n\npassed during this time.\n\nSupported function codes and parameters used:\n\n113 Version 1.21\n\nChapter 9. Network and Communication\n\n1 x Coils Read Coils x x x x\n\n2 x Input Discrete Read Discrete Inputs x x x x\n\n3 x Holding Register Read Holding Registers x x x\n\n4 x Input Register Read Input Register x x\n\n5 x Coils Write Single Coil x x x\n\n6 x Holding Register Write Single Register x x\n\n15 x Coils Write Multiple Coils x x x x\n\n16 x Holding Register Write Multiple Register x x x\n\n22 x Holding Register Mask Write Register x x\n\n23 x Holding Register Read/Write Multiple Register x x x x x x\n\nERROR:\n\nValue Source Description\n\nB3 B2 B1 B0\n\nnn nn nn xx IP_CONTROL Error from module IP_CONTROL\n\nxx xx xx 00 MB_CLIENT No Error\n\nxx xx xx 01 MB_CLIENT ILLEGAL FUNCTION:\n\nThe function code received in the query is not an allowable action\n\nfor the server (or slave). This may be because the function code is\n\nonly applicable to newer devices, and was not implemented in the\n\nunit selected. It could also indicate that the server (or slave) is in the\n\nwrong state to process a request of this type, for example because it\n\nis unconfigured and is being asked to return register values.\n\nxx xx xx 02 MB_CLIENT ILLEGAL DATA ADDRESS:\n\nThe data address received in the query is not an allowable address\n\nfor the server (or slave). More specifically, the combination of refer￾ence number and transfer length is invalid. For a controller with 100\n\n114 Version 1.21\n\nF\n\nu\n\nn\n\nctio\n\nn\n\nC\n\no\n\nd\n\ne\n\nBit A\n\nc\n\nc\n\ne\n\ns\n\ns\n\n16\n\nBit A\n\nc\n\nc\n\ne\n\ns\n\ns (R\n\ne\n\ngister)\n\nGro\n\nu\n\np\n\nF\n\nu\n\nn\n\nctio\n\nn\n\nD\n\ne\n\ns\n\ncriptio\n\nn\n\nR_A\n\nD\n\nD\n\nR\n\nR_\n\nP\n\nOIN\n\nT\n\nS\n\nR_\n\nD\n\nATA_A\n\nD\n\nR\n\nR_\n\nD\n\nATA_\n\nBIT\n\nP\n\nO\n\nS\n\nW_A\n\nD\n\nD\n\nR\n\nW_\n\nP\n\nOIN\n\nT\n\nS\n\nW_\n\nD\n\nATA_A\n\nD\n\nR\n\nW_\n\nD\n\nATA_\n\nBIT\n\nP\n\nO\n\nS\n\nChapter 9. Network and Communication\n\nregisters, the PDU addresses the first register as 0, and the last one\n\nas 99. If a request is submitted with a starting register address of 96\n\nand a quantity of registers of 4, then this request will successfully\n\noperate (address-wise at least) on registers 96, 97, 98, 99. If a re￾quest is submitted with a starting register address of 96 and a quan￾tity of registers of 5, then this request will fail with Exception Code\n\n0x02 “Illegal Data Address” since it attempts to operate on registers\n\n96, 97, 98, 99 and 100, and there is no register with address 100.\n\nxx xx xx 03 MB_CLIENT ILLEGAL DATA VALUE:\n\nA value contained in the query data field is not an allowable value\n\nfor server (or slave). This indicates a fault in the structure of the re￾mainder of a complex request, such as that the implied length is in￾correct. It specifically does NOT mean that a data item submitted for\n\nstorage in a register has a value outside the expectation of the appli￾cation program, since the MODBUS protocol is unaware of the sig￾nificance of any particular value of any particular register.\n\nxx xx xx 04 MB_CLIENT SLAVE DEVICE FAILURE:\n\nAn unrecoverable error occurred while the server (or slave) was at￾tempting to perform the requested action.\n\nxx xx xx 05 MB_CLIENT ACKNOWLEDGE:\n\nSpecialized use in conjunction with programming commands. The\n\nserver (or slave) has accepted the request and is processing it, but\n\na long duration of time will be required to do so. This response is re￾turned to prevent a timeout error from occurring in the client (or\n\nmaster). The client (or master) can next issue a Poll Program Com￾plete message to determine if processing is completed.\n\nxx xx xx 06 MB_CLIENT SLAVE DEVICE BUSY:\n\nSpecialized use in conjunction with programming commands. The\n\nserver (or slave) is engaged in processing a long–duration program\n\ncommand. The client (or master) should retransmit the message\n\nlater when the server (or slave) is free.\n\nxx xx xx 8 MB_CLIENT MEMORY PARITY ERROR:\n\nSpecialized use in conjunction with function codes 20 and\n\n21 and reference type 6, to indicate that the extended file area\n\nfailed to pass a consistency check.The server (or slave) attempted\n\nto read record file, but detected a parity error in the memory.The\n\nclient (or master) can retry the request, but service may be required\n\non the server (or slave) device.\n\nxx xx xx 0A MB_CLIENT GATEWAY PATH UNAVAILABLE:\n\nSpecialized use in conjunction with gateways, indicates that the\n\ngateway was unable to allocate an internal communication path\n\nfrom the input port to the output port for processing the request.\n\nUsually means that the gateway is misconfigured or overloaded.\n\nxx xx xx 0B MB_CLIENT GATEWAY TARGET DEVICE FAILED TO RESPOND:\n\nSpecialized use in conjunction with gateways, indicates that no re￾sponse was obtained from the target device. Usually means that the\n\n115 Version 1.21\n\nChapter 9. Network and Communication\n\ndevice is not present on the network.", "type": "FUNCTION", "name": "MB_CLIENT", "input": [{"name": "IP_C", "type": "IP_C", "description": "Parameterization for the IP control interface."}, {"name": "S_BUF", "type": "NETWORK_BUFFER_SHORT", "description": "Buffer for transmitting data."}, {"name": "R_BUF", "type": "NETWORK_BUFFER_SHORT", "description": "Buffer for receiving data."}, {"name": "DATA", "type": "ARRAY[0..255] OF WORD", "description": "Array containing MODBUS register data."}, {"name": "DATA_SIZE", "type": "INT", "description": "Number of data words in the structure MB_DATA."}, {"name": "ENABLE", "type": "BOOL", "description": "Enables or disables the module."}, {"name": "UDP", "type": "BOOL", "description": "Selects TCP (FALSE) or UDP (TRUE) mode."}, {"name": "FC", "type": "INT", "description": "Function code for the MODBUS command."}, {"name": "UNIT_ID", "type": "BYTE", "description": "Device ID for the MODBUS communication."}, {"name": "R_ADDR", "type": "INT", "description": "Read command: MODBUS data point address."}, {"name": "R_POINTS", "type": "INT", "description": "Read command: number of MODBUS data points."}, {"name": "R_DATA_ADR", "type": "INT", "description": "Read command: DATA data point address."}, {"name": "R_DATA_BITPOS", "type": "INT", "description": "Read command: DATA data point bit position."}, {"name": "W_ADDR", "type": "INT", "description": "Write command: MODBUS data point address."}, {"name": "W_POINTS", "type": "INT", "description": "Write command: number of MODBUS data points."}, {"name": "W_DATA_ADR", "type": "INT", "description": "Write command: DATA data point address."}, {"name": "W_DATA_BITPOS", "type": "INT", "description": "Write command: DATA data point bit position."}, {"name": "DELAY", "type": "TIME", "description": "Repetition time for command execution."}], "output": [{"name": "ERROR", "type": "DWORD", "description": "Error code returned from the command execution."}, {"name": "BUSY", "type": "BOOL", "description": "Indicates if the module is currently processing a command."}], "in/out": [], "return_value": {"type": "void", "description": "No return value, as this is a function that executes commands."}}
{"title": "MODBUS Ethernet Server Function Module", "description": "MB_SERVER The module provides access from external to local MODBUS data tables via \n\nEthernet. It supports commands in categories 0,1,2. The parameters IP_C, \n\nS_BUF, R_BUF this form the interface to the module IP_CONTROL and used \n\nhere for processing and coordination. The desired port number (for \n\nMODBUS default is 502) must be specifed on IP_CONTROL centrally. The IP \n\naddress is not required on IP_CONTROL, as this one operates in the \n\nPASSIVE mode. The DATA structure is designed as a WORD array and \n\ncontains the MODBUS data. DATA_SIZE specifes the size of DATA . By \n\nENABLE, the module is released, and by remove of the release a possibly \n\nstill active query is ended. For devices that support MODBUS with UDP = \n\nTRUE this mode can be activated. A negative command execution is \n\nreported by ERROR (see ERROR table).\n\nWIth entries in the data structure VMAP, virtual data areas are created, \n\nand the access to certain function codes and data regions is \n\nparameterized. Thus, it is very easy to map virtual address spaces into a \n\n116 Version 1.21\n\nChapter 9. Network and Communication\n\ncoherent Data block (DATA), or write data areas. Or provide areas, that \n\nare connected to output peripherals, with a watchdog.\n\nThe handling of the VMAP data is described in more detail in the module \n\nMB_VMAP.\n\nERROR:\n\nValue Source Description\n\nB3 B2 B1 B0\n\nnn nn nn xx IP_CONTROL Error from module IP_CONTROL\n\nxx xx xx 00 MB_SERVER NO ERROR:\n\nxx xx xx 01 MB_SERVER ILLEGAL FUNCTION:\n\nxx xx xx 02 MB_SERVER ILLEGAL DATA ADDRESS:\n\nxx xx xx 03 MB_SERVER ILLEGAL DATA VALUE:\n\nSupported function codes and parameters used:\n\n1 x Coils Read Coils\n\n2 x Input Discrete Read Discrete Inputs\n\n3 x Holding Register Read Holding Registers\n\n4 x Input Register Read Input Register\n\n5 x Coils Write Single Coil\n\n6 x Holding Register Write Single Register\n\n117 Version 1.21\n\nF\n\nu\n\nn\n\nctio\n\nn\n\nC\n\no\n\nd\n\ne\n\nBit A\n\nc\n\nc\n\ne\n\ns\n\ns\n\n16\n\nBit A\n\nc\n\nc\n\ne\n\ns\n\ns (R\n\ne\n\ngister)\n\nGro\n\nu\n\np\n\nF\n\nu\n\nn\n\nctio\n\nn\n\nD\n\ne\n\ns\n\ncriptio\n\nn\n\nChapter 9. Network and Communication\n\n15 x Coils Write Multiple Coils\n\n16 x Holding Register Write Multiple Register\n\n22 x Holding Register Mask Write Register\n\n23 x Holding Register Read/Write Multiple Register", "type": "FUNCTION", "name": "MB_SERVER", "input": [{"name": "IP_C", "type": "IP_C", "description": "Parameterization for IP control."}, {"name": "S_BUF", "type": "NETWORK_BUFFER_SHORT", "description": "Buffer for transmitting data."}, {"name": "R_BUF", "type": "NETWORK_BUFFER_SHORT", "description": "Buffer for receiving data."}, {"name": "VMAP", "type": "ARRAY", "description": "Virtual address table containing VMAP_DATA.", "fields": [{"name": "VMAP_DATA", "type": "VMAP_DATA", "description": "Data structure representing virtual mappings."}]}, {"name": "DATA", "type": "ARRAY", "description": "Array of MODBUS registers.", "fields": [{"name": "WORD", "type": "WORD", "description": "MODBUS data words."}]}, {"name": "DATA_SIZE", "type": "INT", "description": "Number of data words in DATA."}, {"name": "ENABLE", "type": "BOOL", "description": "Flag to release the module."}, {"name": "UDP", "type": "BOOL", "description": "Indicates whether to use UDP mode (TRUE for UDP)."}], "output": [{"name": "ERROR", "type": "DWORD", "description": "Error code indicating the status of command execution."}], "in/out": [], "return_value": {"type": null, "description": null}}
{"title": "Modbus Virtual Address Mapping", "description": "MB_VMAP The module allows the conversion of virtual addresses at a real address \n\nspace in the MODBUS DATA Structure. Virtual address ranges are defned \n\nin the VMAP data array. If the module is called and found that nothing in \n\nthe VMAP data is entered, automatically a block is created, allowing full \n\naccess to all the MODBUS data. In each address block also a watchdog \n\ntimer is maintained that sets each time you access this block on the timer \n\nto zero. Thus, simply by comparing the TIME_OUT value to a cutof value, \n\nat communication error (no update) can be responded.\n\nBy the parameter FC is detected the functional code and whether the \n\nregister (16 bit) or individual bits must be processed. The bit number \n\ncorresponds to the function code. This means that Bit5 = 1 in FC the \n\nfunction code 5 (Write Single Coil) enables. By V_ADR by the virtual start \n\naddress is specifed (At 16bit commands this is a register address and at \n\n118 Version 1.21\n\nChapter 9. Network and Communication\n\nbit commands an absolute bit number within a defned block.) The \n\nparameter V_CNT defnes the number of data points (unit 16-bit or bits \n\ndepending on the function code). The overall size is given by \n\nMODBUS_ARRAY SIZE (number WORDS). By using these parameters, the \n\nmodule searched the VMAP data table for a matching block of data, and \n\npasses from the correct data block P_ADR as a result. The value \n\ncorresponds to the real index for MODBUS_DATA array. At a function code \n\nwith bit access in addition the bit position within P_ADR is passed as well. \n\nA potential error occurring in the analysis is reported for the parameter \n\n\"error\" (see error table). The watchdog timer is reseted at each access to a \n\nfunction code from the group of write commands. \n\nIf no special treatment required, so in VMAP are not settings \n\nrequired, and then MODBUS_ARRAY is mapped 1:1 with the \n\naccess.\n\nERROR:\n\nValue Description\n\n0 No error\n\n1 Invalid function code\n\n2 Invalid Data Address\n\n! Note the special treatment of function code 23!\n\nThe Modbus Function Code 23 is a combined command, because it \n\nconsists of two actions. First register are written and then the register are \n\nread. Found that the write or read parameter is not allowed, so neither of \n\nthese actions is performed.\n\nTo distinguish between reading and writing by VMAP, the read command is \n\nchecked in VMAP at FC 23 as BIT23 (Read/Write Multiple registers), and the \n\nwrite command on the other hand, is tested in Bit16 (Write multiple \n\nregisters).", "type": "FUNCTION", "name": "MB_VMAP", "input": [{"name": "FC", "type": "INT", "description": "Function number that determines the operation to be performed."}, {"name": "V_ADR", "type": "INT", "description": "Virtual address range start address."}, {"name": "V_CNT", "type": "INT", "description": "Number of data points in the virtual address space."}, {"name": "SIZE", "type": "INT", "description": "Number of MODBUS registers in the DATA structure."}], "output": [{"name": "P_ADR", "type": "INT", "description": "Real address space: start address."}, {"name": "P_BIT", "type": "INT", "description": "Real address range: bit position."}, {"name": "ERROR", "type": "DWORD", "description": "Error code indicating the result of the operation."}], "in/out": [], "return_value": {"type": null, "description": null}}
{"title": "MD5 Hash Function", "description": "MD5_AUX. This module has only in\n\nconjunction with the block MD5_STREAM a useful application.\n\n79 Version 1.21\n\nChapter 8. Converter", "type": "FUNCTION", "name": "MD5_AUX", "input": [{"name": "N", "type": "INT", "description": "An integer for internal use."}, {"name": "A", "type": "DWORD", "description": "A DWORD parameter for internal use."}, {"name": "B", "type": "DWORD", "description": "A DWORD parameter for internal use."}, {"name": "C", "type": "DWORD", "description": "A DWORD parameter for internal use."}, {"name": "D", "type": "DWORD", "description": "A DWORD parameter for internal use."}, {"name": "X", "type": "DWORD", "description": "A DWORD parameter for internal use."}, {"name": "U", "type": "INT", "description": "An integer for internal use."}, {"name": "T", "type": "DWORD", "description": "A DWORD parameter for internal use."}], "output": [], "in/out": [], "return_value": {"type": "DWORD", "description": "The resulting MD5 hash value as a DWORD.", "fields": []}}
{"title": "MD5 Hash Calculation Module", "description": "MD5_STR a string of the MD5 hash can be calculated by. In the STR a\n\nstring is passed to the module, and a positive edge at input \"RUN\", the\n\ncalculation starts. DONE is immediately reset at startup, and after the pro￾cess is DONE is set to TRUE. Then, at the parameter HASH the actual cal￾culated HASH value is available. (See module MD5-STREAM).", "type": "FUNCTION", "name": "MD5_STR", "input": [{"name": "RUN", "type": "BOOL", "description": "Positive edge starts the calculation"}, {"name": "STR", "type": "STRING", "description": "Text for HASH creation"}], "output": [{"name": "DONE", "type": "BOOL", "description": "TRUE if calculations are complete"}, {"name": "MD5", "type": "ARRAY[0..15] OF BYTE", "description": "Current MD5 hash"}], "in/out": [], "return_value": null}
{"title": "MD5 Stream Calculation", "description": "MD5_STREAM allows the calculation of the MD5 ( Mes￾sage-Digest Algorithm 5 ) of a cryptographic hash function. \n\nThis can be created from any data stream a unique check value. It is vir￾tually impossible to fnd two diferent messages with the same test value,\n\nthis is referred to as collisions free. This can be used to check a confgura￾tion fle for change or manipulation.\n\nWith the hash algorithm (MD5) a hash value is generated from 128 bits in\n\nlength for any data. The maximum length of the stream is on this module\n\nis limited to 2^32 (4 gigabyte). The result is a 16 bytes hash value at pa￾rameters MD5.", "type": "FUNCTION", "name": "MD5_STREAM", "input": [{"name": "mode", "type": "INT", "description": "The mode of operation for the MD5_STREAM function. Use 1 for initialization, 2 for data block processing, and 3 for completion."}, {"name": "BUF", "type": "ARRAY[0..63] OF BYTES", "description": "The buffer containing the source data to be hashed."}, {"name": "SIZE", "type": "UDINT", "description": "The number of bytes in the data to process."}], "output": [{"name": "MD5", "type": "ARRAY[0..15] OF BYTE", "description": "The calculated MD5 hash value as a 16-byte array."}, {"name": "POS", "type": "UDINT", "description": "The start address of the requested data block."}], "in/out": [], "return_value": {"type": "void", "description": "The function does not return a value. The results are provided via output parameters."}}
{"title": "MD5 to Hex String Converter", "description": "MD5_TO_STRH converts the MD5 byte array to a hex\n\nstring.", "type": "FUNCTION", "name": "MD5_TO_STRH", "input": [{"name": "MD5", "type": "ARRAY[0..15] OF BYTE", "description": "An array representing the MD5 hash value in byte format."}], "output": [{"name": "hexString", "type": "STRING(32)", "description": "The hexadecimal string representation of the MD5 hash."}], "in/out": [], "return_value": null}
{"title": "Moon Phase Calculation", "description": "MOON_PHASE is used to calculate the moon phase pf the specified \n\ndate. At parameter XDT the current date and time is passed, and always recalculated \n\nafter delay of the time parameter \"UPDATE\". The default value for UPDATE is 1 hour \n\nand the scaling factor is 12.\n\nA moon phase takes about 29.53 days, and goes through the typical conditions of \n\nthis new moon to full moon (resp. increasing and decreasing moon). This cycle can \n\nbe scaled by SCALE to a desired value between 0 and 255.", "type": "FUNCTION", "name": "MOON_PHASE", "input": [{"name": "XDT", "type": "DT", "description": "The date and time for which the moon phase is to be calculated."}, {"name": "SCALE", "type": "BYTE", "description": "The scaling factor used to adjust the output moon phase value."}, {"name": "UPDATE", "type": "TIME", "description": "The time interval after which the moon phase is recalculated. Default value is 1 hour."}], "output": [{"name": "PHASE", "type": "BYTE", "description": "The scaled value representing the current moon phase."}], "return_value": {"type": "void", "description": "This function does not return a value; it updates the output parameter 'PHASE'."}}
{"title": "Network Version Function", "description": "NETWORK_VERSION provides if IN = FALSE the current version number as\n\nDWORD. If IN is set to TRUE then the release date of the current version as\n\na DWORD is returned.", "type": "FUNCTION", "name": "NETWORK_VERSION", "input": [{"name": "IN", "type": "BOOL", "description": "If TRUE, the function returns the release date; if FALSE, it returns the current version number."}], "output": [{"name": "Version", "type": "DWORD", "description": "The current version number or release date as a DWORD."}], "in/out": [], "return_value": {"type": "DWORD", "description": "Returns the library version number or the release date as a DWORD.", "fields": []}}
{"title": "Bidirectional Transmission of Binary Signals Using NET_VAR_BOOL8", "description": "NET_VAR_BOOL8 8 binary \n\nsignals from the master to slave and vice versa. The signals IN 1..8 are collected and \n\npassed to the other side (control) on the same module at the same position as \n\nOUT1..8 again.\n\nSimultaneously, the on the opposite side (other control) passed input data passed \n\nhere as a OUT1..8 again.\n\n200 Version 1.21\n\nChapter 12. Network Variables\n\nID parameter indicates the current identification number of the module instance. If the \n\nconfiguration of the master and the slave program is differently (incorrectly) that ID \n\nnumber is passed as a fault in the module NET_VAR_CONTROL.", "type": "FUNCTION", "name": "NET_VAR_BOOL8", "input": [{"name": "IN1", "type": "BOOL", "description": "Signal input 1"}, {"name": "IN2", "type": "BOOL", "description": "Signal input 2"}, {"name": "IN3", "type": "BOOL", "description": "Signal input 3"}, {"name": "IN4", "type": "BOOL", "description": "Signal input 4"}, {"name": "IN5", "type": "BOOL", "description": "Signal input 5"}, {"name": "IN6", "type": "BOOL", "description": "Signal input 6"}, {"name": "IN7", "type": "BOOL", "description": "Signal input 7"}, {"name": "IN8", "type": "BOOL", "description": "Signal input 8"}], "output": [{"name": "OUT1", "type": "BOOL", "description": "Signal output 1"}, {"name": "OUT2", "type": "BOOL", "description": "Signal output 2"}, {"name": "OUT3", "type": "BOOL", "description": "Signal output 3"}, {"name": "OUT4", "type": "BOOL", "description": "Signal output 4"}, {"name": "OUT5", "type": "BOOL", "description": "Signal output 5"}, {"name": "OUT6", "type": "BOOL", "description": "Signal output 6"}, {"name": "OUT7", "type": "BOOL", "description": "Signal output 7"}, {"name": "OUT8", "type": "BOOL", "description": "Signal output 8"}], "in/out": [{"name": "X", "type": "NET_VAR_DATA", "description": "NET_VAR data structure for bidirectional signal transmission"}], "return_value": {"type": "BYTE", "description": "Identification number of the module instance. It indicates faults if there's a mismatch in configuration.", "fields": [{"name": "ID", "type": "BYTE", "description": "The ID parameter for the module instance."}]}}
{"title": "NET_VAR_BUFFER Module", "description": "NET_VAR_BUFFER is used for bidirectional transmission of 64 bytes \n\nfrom the master to slave and vice versa. The data from BUF_IN be recorded and \n\npassed on the other side (other plc) on the same module at the same position as \n\nBUF_OUT.\n\nSimultaneously, the input data on the opposite side (other control) is passed here as \n\nBUF_OUT again.\n\nID parameter indicates the current identification number of the module instance. If the \n\nconfiguration of the master and the slave program is differently (incorrectly) that ID \n\nnumber is passed as a fault in the module NET_VAR_CONTROL.\n\n201 Version 1.21\n\nChapter 12. Network Variables", "type": "FUNCTION", "name": "NET_VAR_BUFFER", "input": [{"name": "X", "type": "NET_VAR_DATA", "description": "Data structure used for configuration and transmission.", "fields": []}, {"name": "BUF_IN", "type": "ARRAY [1..64] OF BYTE", "description": "Input data buffer for receiving data.", "fields": []}], "output": [{"name": "BUF_OUT", "type": "ARRAY [1..64] OF BYTE", "description": "Output data buffer for sending data.", "fields": []}, {"name": "OUTPUT ID", "type": "BYTE", "description": "Identification number of the module instance.", "fields": []}], "in/out": [], "return_value": {"type": "void", "description": "No return value as the operation is purely based on input/output data transmission.", "fields": []}}
{"title": "NET_VAR_CONTROL", "description": "NET_VAR_CONTROL coordinates the data exchange between the two \n\ncontrollers and the satellite components NET_VAR_*. With ACTIVATE = TRUE, the \n\ndata exchange will be released. The module must be invoked on both controllers, \n\nwith the parameter MASTER must be assigned once with TRUE and once must be \n\nFALSE. Thus determines which side the active connection will establish. With UDP \n\n(FALSE / TRUE) can be specified whether a UDP or TCP connection is used. The the \n\nIP address of the other side must be specified in REMOTE-IP4, and alternatively, the \n\nport address (default port is 10000). The SCAN TIME determines a data refresh \n\ninterval (default is T # 1s). WIth WATCHDOG the monitoring time is set (default is T # \n\n2s). When data exchange runs, the parameter RUN = TRUE. If the data exchange is \n\nlonger than the watchdog time not possible, RUN = FALSE and an error is passed. \n\nThe error will not be acknowledged, because the module automatically tries to \n\nrestore the data exchange. Once no more error exists, RUN = TRUE and the error \n\ncode is cleared.\n\nERROR: (regarded as a HEX value!)\n\nDWORD Message Type Description\n\n199 Version 1.21\n\nChapter 12. Network Variables\n\nB3 B2 B1 B0\n\nXX .. .. .. Connection establish Connect Error - See module IP_CONTROL\n\n.. XX .. .. Send data Transmission error - See module IP_CONTROL\n\n.. .. XX .. Receive data Receive Error - See module IP_CONTROL\n\n.. .. .. XX Configuration error ID number of the module", "type": "FUNCTION", "name": "NET_VAR_CONTROL", "input": [{"name": "ACTIVATE", "type": "BOOL", "description": "Enables the exchange of data."}, {"name": "MASTER", "type": "BOOL", "description": "Determines if this side is the master (TRUE) or slave (FALSE)."}, {"name": "UDP", "type": "BOOL", "description": "Specifies the connection type: FALSE for TCP, TRUE for UDP."}, {"name": "REMOTE_IP4", "type": "DWORD", "description": "IP4-address of the other SPS."}, {"name": "REMOTE_PORT", "type": "WORD", "description": "PORT number of the other PLC (default port is 10000)."}, {"name": "SCAN_TIME", "type": "TIME", "description": "Update time for data refresh (default is T#1s)."}, {"name": "WATCHDOG", "type": "TIME", "description": "Monitoring time (default is T#2s)."}], "output": [{"name": "RUN", "type": "BOOL", "description": "Indicates active data exchange - no error."}, {"name": "ERROR", "type": "DWORD", "description": "Error code regarding the data exchange as a HEX value."}], "in/out": [], "return_value": null}
{"title": "NET_VAR_DWORD8 Module", "description": "NET_VAR_DWORD8 is used for bidirectional transmission of eight \n\nDWORD from the master to slave and vice versa. The signals DWORD IN1..8 are \n\ncollected and passed to the other side (control) on the same module at the same \n\nposition as OUT1..8 again.\n\nSimultaneously, the on the opposite side (other control) passed input datawords \n\npassed here as a OUT1..8 again.\n\nID parameter indicates the current identification number of the module instance. If the \n\nconfiguration of the master and the slave program is differently (incorrectly) that ID \n\nnumber is passed as a fault in the module NET_VAR_CONTROL.", "type": "FUNCTION", "name": "NET_VAR_DWORD8", "input": [{"name": "X", "type": "NET_VAR_DATA", "description": "NET_VAR data structure for bidirectional data transmission"}, {"name": "IN1", "type": "DWORD", "description": "Input DWORD value 1"}, {"name": "IN2", "type": "DWORD", "description": "Input DWORD value 2"}, {"name": "IN3", "type": "DWORD", "description": "Input DWORD value 3"}, {"name": "IN4", "type": "DWORD", "description": "Input DWORD value 4"}, {"name": "IN5", "type": "DWORD", "description": "Input DWORD value 5"}, {"name": "IN6", "type": "DWORD", "description": "Input DWORD value 6"}, {"name": "IN7", "type": "DWORD", "description": "Input DWORD value 7"}, {"name": "IN8", "type": "DWORD", "description": "Input DWORD value 8"}, {"name": "ID", "type": "BYTE", "description": "Identification number of the module instance"}], "output": [{"name": "OUT1", "type": "DWORD", "description": "Output DWORD value 1 corresponding to input IN1"}, {"name": "OUT2", "type": "DWORD", "description": "Output DWORD value 2 corresponding to input IN2"}, {"name": "OUT3", "type": "DWORD", "description": "Output DWORD value 3 corresponding to input IN3"}, {"name": "OUT4", "type": "DWORD", "description": "Output DWORD value 4 corresponding to input IN4"}, {"name": "OUT5", "type": "DWORD", "description": "Output DWORD value 5 corresponding to input IN5"}, {"name": "OUT6", "type": "DWORD", "description": "Output DWORD value 6 corresponding to input IN6"}, {"name": "OUT7", "type": "DWORD", "description": "Output DWORD value 7 corresponding to input IN7"}, {"name": "OUT8", "type": "DWORD", "description": "Output DWORD value 8 corresponding to input IN8"}], "in/out": [], "return_value": {"type": "void", "description": "This function does not return a value."}}
{"title": "NET_VAR_REAL8 Function Module", "description": "NET_VAR_REAL8 is used for bidirectional transmission of eight REAL￾values from the master to slave and vice versa. The REAL values IN1..8 are \n\ncollected and passed to the other side (control) on the same module at the same \n\nposition as OUT1..8 again.\n\nSimultaneously, the on the opposite side (other control) passed input REAL values \n\nare passed here as a OUT1..8 again.\n\nID parameter indicates the current identification number of the module instance. If the \n\nconfiguration of the master and the slave program is differently (incorrectly) that ID \n\nnumber is passed as a fault in the module NET_VAR_CONTROL.", "type": "FUNCTION", "name": "NET_VAR_REAL8", "input": [{"name": "IN1", "type": "REAL", "description": "First input REAL value"}, {"name": "IN2", "type": "REAL", "description": "Second input REAL value"}, {"name": "IN3", "type": "REAL", "description": "Third input REAL value"}, {"name": "IN4", "type": "REAL", "description": "Fourth input REAL value"}, {"name": "IN5", "type": "REAL", "description": "Fifth input REAL value"}, {"name": "IN6", "type": "REAL", "description": "Sixth input REAL value"}, {"name": "IN7", "type": "REAL", "description": "Seventh input REAL value"}, {"name": "IN8", "type": "REAL", "description": "Eighth input REAL value"}], "output": [{"name": "OUT1", "type": "REAL", "description": "First output REAL value"}, {"name": "OUT2", "type": "REAL", "description": "Second output REAL value"}, {"name": "OUT3", "type": "REAL", "description": "Third output REAL value"}, {"name": "OUT4", "type": "REAL", "description": "Fourth output REAL value"}, {"name": "OUT5", "type": "REAL", "description": "Fifth output REAL value"}, {"name": "OUT6", "type": "REAL", "description": "Sixth output REAL value"}, {"name": "OUT7", "type": "REAL", "description": "Seventh output REAL value"}, {"name": "OUT8", "type": "REAL", "description": "Eighth output REAL value"}], "in/out": [{"name": "X", "type": "NET_VAR_DATA", "description": "NET_VAR data structure for bidirectional communication"}], "return_value": {"type": "BYTE", "description": "ID indicating the current identification number of the module instance"}}
{"title": "NET_VAR_STRING Function Module", "description": "NET_VAR_STRING is used for bidirectional transmission of STRING \n\nfrom the master to slave and vice versa. The STRING in the parameters IN will be \n\n203 Version 1.21\n\nChapter 12. Network Variables\n\nrecorded and passed on the other side (control) on the same module at the same \n\nposition as OUT parameter.\n\nAt the same time the input String on the opposite side of the (other control) is passed \n\nhere as a OUT value again.\n\nID parameter indicates the current identification number of the module instance. If the \n\nconfiguration of the master and the slave program is differently (incorrectly) that ID \n\nnumber is passed as a fault in the module NET_VAR_CONTROL.", "type": "FUNCTION", "name": "NET_VAR_STRING", "input": [{"name": "X", "type": "NET_VAR_DATA", "description": "A NET_VAR data structure for variable data transmission."}, {"name": "STRING", "type": "STRING", "description": "The input string that will be transmitted."}], "output": [{"name": "OUT", "type": "STRING", "description": "The output string that is received on the opposite side."}, {"name": "ID", "type": "BYTE", "description": "The current identification number of the module instance."}], "in/out": [], "return_value": {}}
{"title": "NET_VAR_X8 Function Module", "description": "NET_VAR_X8 is used for bidirectional transmission of each two REAL, \n\nDINT, UINT, DWORD values from the master to slave and vice versa. The signals \n\nIN1..8 are collected and passed to the other side (control) on the same module at the \n\nsame position as OUT1..8 again.\n\n204 Version 1.21\n\nChapter 12. Network Variables\n\nSimultaneously, the input data on the opposite side (other control) is passed here as \n\nBUF_OUT again.\n\nID parameter indicates the current identification number of the module instance. If the \n\nconfiguration of the master and the slave program is differently (incorrectly) that ID \n\nnumber is passed as a fault in the module NET_VAR_CONTROL.\n\n205 Version 1.21\n\nChapter 13. Weather Data\n\n 13. Weather Data", "type": "FUNCTION", "name": "NET_VAR_X8", "input": [{"name": "IN_REAL1", "type": "REAL", "description": "First input REAL value"}, {"name": "IN_REAL2", "type": "REAL", "description": "Second input REAL value"}, {"name": "IN_DINT1", "type": "DINT", "description": "First input DINT value"}, {"name": "IN_DINT2", "type": "DINT", "description": "Second input DINT value"}, {"name": "IN_UDINT1", "type": "DINT", "description": "First input UDINT value"}, {"name": "IN_UDINT2", "type": "DINT", "description": "Second input UDINT value"}, {"name": "IN_DWORD1", "type": "DINT", "description": "First input DWORD value"}, {"name": "IN_DWORD2", "type": "DINT", "description": "Second input DWORD value"}, {"name": "ID", "type": "BYTE", "description": "Identification number of the module instance"}], "output": [{"name": "OUT_REAL1", "type": "REAL", "description": "First output REAL value"}, {"name": "OUT_REAL2", "type": "REAL", "description": "Second output REAL value"}, {"name": "OUT_DINT1", "type": "DINT", "description": "First output DINT value"}, {"name": "OUT_DINT2", "type": "DINT", "description": "Second output DINT value"}, {"name": "OUT_UDINT1", "type": "DINT", "description": "First output UDINT value"}, {"name": "OUT_UDINT2", "type": "DINT", "description": "Second output UDINT value"}, {"name": "OUT_DWORD1", "type": "DINT", "description": "First output DWORD value"}, {"name": "OUT_DWORD2", "type": "DINT", "description": "Second output DWORD value"}], "in/out": [{"name": "X", "type": "NET_VAR_DATA", "description": "NET_VAR data structure for bidirectional data transmission"}], "return_value": {"type": null, "description": null}}
{"title": "Dynamic String Formatting", "description": "PRINT_SF a STRING can be added dynamically with a part of a string. \n\nThe position of the substring to be inserted is indicated by '~' tilde \n\ncharacter and the subsequent number defnes the parameter number. '~ \n\n1' to '~ 9' are thus processed automatically. If the insert of the substring \n\n121 Version 1.21\n\nF\n\nu\n\nn\n\nctio\n\nn\n\nD\n\ne\n\ns\n\ncriptio\n\nn\n\nF\n\nu\n\nn\n\nctio\n\nn\n\nC\n\no\n\nd\n\ne\n\nBit A\n\nc\n\nc\n\ne\n\ns\n\ns\n\n16\n\nBit A\n\nc\n\nc\n\ne\n\ns\n\ns (R\n\ne\n\ngister)\n\nR\n\ne\n\na\n\nd / Write\n\nDigital In\n\np\n\nut\n\nA\n\nn\n\nalo\n\ng In\n\np\n\nut\n\nDigital O\n\nutp\n\nut\n\nA\n\nn\n\nalo\n\ng\n\nO\n\nutp\n\nut\n\nChapter 9. Network and Communication\n\nreached the maximum number of characters, so instead of the substring \n\n'..' is inserted.\n\nVAR\n\n LITER : REAL := 545.4;\n\n FUELLZEIT : INT := 25;\n\n NAME: STRING: = 'tank content';\n\n PARA: ARRAY[1..11] OF STRING(string_length);\n\n PS: PRINT_SF;\n\nEND_VAR\n\nPARA[1]: = REAL_TO_STRING(liters); (* Parameter 1: string to convert *) \n\nPARA[2]: = INT_TO_STRING(filling time); (* Parameter 2: string to convert\n\n*) \n\nPARA[3]: = NAME; (* Parameter 3: *) \n\nPS.STR: = ' ~3: ~1 Liter, flling time: ~2 Min.' ; (* Text output-mask *) \n\nPS.PRINTF_DATA := PARA; (* Pass parameter data structure *) \n\nPS(); (* Module version *) \n\nThe string PS. STR then has the following content \n\n'Tank Capacity: 545.4 liters, filling time: 25 min'", "type": "FUNCTION", "name": "PRINT_SF", "input": [{"name": "PRINTF_DATA", "type": "ARRAY[1..11] OF STRING", "description": "An array of strings that will be used in the dynamic string formatting."}], "output": [], "in/out": [], "return_value": {"type": "STRING", "description": "The formatted string after inserting the specified parameters.", "fields": []}}
{"title": "RC4 Data Encryption Stream Module", "description": "RC4_CRYPT_STREAM uses the RC4 data encryption to process\n\nan almost arbitrarily long data stream. This standard is used for example\n\nin an SSH, HTTPS, and WEP or WPA, and is thus widely used. The algorithm\n\ncan in principle operate at up to 2048 bit key, but this is limited to the mo-\n\n82 Version 1.21\n\nChapter 8. Converter\n\ndule on a 40-character key (but it can always be adjusted to up to 250\n\ncharacters). Thus, it presents a key length of 320 bits, which are designed\n\nfor applications on a PLC more than adequate. The maximum length of the\n\nstream is on this module is limited to 2^32 (4 gigabyte). The module can\n\nbe used for encryption as well as to decrypt RC4 data. 64 bytes per cycle\n\ncan still be processed, they will be processed in serial block mode. The\n\ndata been encrypted or decrypted, remains in the module BUF for further\n\nprocessing, and must, of course, processed previously by the user before\n\neach new block of data.", "type": "FUNCTION", "name": "RC4_CRYPT_STREAM", "input": [{"name": "mode", "type": "INT", "description": "Operation mode: 1 for initialization, 2 for data block processing, 3 for completion."}, {"name": "KEY", "type": "STRING(40)", "description": "A 320-bit long secret key for the encryption/decryption process."}, {"name": "BUF", "type": "ARRAY[0..63] OF BYTES", "description": "Data block to process (maximum size of 64 bytes per cycle)."}, {"name": "SIZE", "type": "UDINT", "description": "Number of data bytes to process."}], "output": [{"name": "POS", "type": "UDINT", "description": "Start address (base 0) of the requested data block after processing."}], "in/out": [], "return_value": null}
{"title": "READ_HTTP Function Module", "description": "READ_HTTP the HTTP header information can be analyzed. The \n\nmodule searches any array of bytes on the contents of a string and then \n\nevaluates the following parameters, and returns that string as its result. \n\nThe data in the bufer are automatically converted to upper case, so all \n\nsearch string at SRC has to be too, given in capital letters. With POS it can \n\nbegin its search at any position. The frst element in the array is at position \n\nnumber 1", "type": "FUNCTION", "name": "READ_HTTP", "input": [{"name": "INPUT SIZE", "type": "UINT", "description": "The size of the buffer that contains the HTTP header."}, {"name": "POS", "type": "INT", "description": "The position in the buffer from where the search operation starts. The first element in the array is at position number 1."}, {"name": "SRC", "type": "STRING", "description": "The search string, which must be provided in uppercase to match the converted data in the buffer."}, {"name": "IN_OUT PT", "type": "POINTER", "description": "The address of the buffer containing the HTTP header and body."}], "output": [{"name": "OUTPUT VALUE", "type": "STRING", "description": "The evaluated result from the HTTP header based on the search term provided in SRC, or the default HTTP version and status code if SRC is empty."}], "in/out": [], "return_value": {"type": "STRING", "description": "Returns the value found in the HTTP header based on the search criteria. If no search term is provided, returns the HTTP version and status code.", "fields": []}}
{"title": "SHA1 Hash Calculation", "description": "SHA1_STR the SHA1 hash can be calculated in a string. In the STR a\n\nstring is passed to the module, and a positive edge at input \"RUN\", the\n\ncalculation starts. DONE is immediately reset at startup, and after the pro￾cess is DONE is set to TRUE. Then, at the parameter HASH the actual cal￾culated HASH value is available. (See module SHA1-STREAM).", "type": "FUNCTION", "name": "SHA1_STR", "input": [{"name": "RUN", "type": "BOOL", "description": "Positive edge input that starts the calculation."}, {"name": "STR", "type": "STRING", "description": "The string input for which the SHA1 hash will be created."}], "output": [{"name": "DONE", "type": "BOOL", "description": "Indicates TRUE if calculations are complete."}, {"name": "HASH", "type": "ARRAY[0..19] OF BYTE", "description": "The actual SHA1 hash value calculated from the input string."}], "in/out": [], "return_value": null}
{"title": "SHA1 Stream Function Module", "description": "SHA1_STREAM allows the calculation of standard cryptogra￾phic hash function SHA-1 (Secure Hash Algorithm).\n\n84 Version 1.21\n\nChapter 8. Converter\n\nThis can be created from any data stream a unique check value. It is vir￾tually impossible to fnd two diferent messages with the same test value,\n\nthis is referred to as collisions free. This can be used to check a confgura￾tion fle for change or manipulation.\n\nWith the secure hash algorithm (SHA1) a hash value is generated from\n\n160 bits in length for any data. The maximum length of the stream is on\n\nthis module is limited to 2^32 (4 gigabyte). The result is a 20-byte hash\n\nvalue, issued as ARRAY [0..19] OF BYTE.", "type": "FUNCTION", "name": "SHA1_STREAM", "input": [{"name": "MODE", "type": "INT", "description": "Operating mode for the module (1 = init, 2 = Data Block, 3 = Complete)"}, {"name": "BUF", "type": "ARRAY[0..63] OF BYTES", "description": "Source data buffer for current input data stream"}, {"name": "SHA1", "type": "ARRAY[0..19] OF BYTE", "description": "Current SHA1-HASH value"}, {"name": "SIZE", "type": "UDINT", "description": "Number of data bytes in BUF"}], "output": [{"name": "POS", "type": "UDINT", "description": "Start address of the requested data block"}], "in/out": [], "return_value": {"type": "void", "description": "No return value, the function operates in-place"}}
{"title": "SHA1 to Hex String Converter", "description": "SHA1_TO_STRH SHA1 byte array to a hex string.", "type": "FUNCTION", "name": "SHA1_TO_STRH", "input": [{"name": "input_md5", "type": "ARRAY[0..19] OF BYTE", "description": "An array containing the SHA1 hash in byte format."}], "output": [{"name": "output_string", "type": "STRING (40)", "description": "A hexadecimal string representation of the SHA1 byte array."}], "in/out": [], "return_value": {"type": "STRING (40)", "description": "The resulting hexadecimal string converted from the input SHA1 byte array."}}
{"title": "SMTP Client Module", "description": "SMTP_CLIENT is used to send of classic emails.\n\nFollowing features are supported:\n\nSMTP protocol\n\nExtended SMTP protocol\n\nSending the subject line, text and content\n\nIndication of email sender address (From:), including \"Display Name\"\n\nIndication of the recipient (s) (To:)\n\nIndication of carbon copy recipient (s) (Cc:)\n\nIndication of blind copy recipient (s) (bc:)\n\nSending fle (s) as an attachment\n\nAuthentication method: NO, PLAIN, LOGIN, CRAM-MD5\n\nSpecifying the port number\n\nWhen positive edge at ACTIVATE the transfer process is started. The \n\nSERVER parameter contains the name of the SMTP server and optionally \n\nthe user name and password and a port number. If you pass a user name \n\nand password, the procedure is according to standard SMTP.\n\n124 Version 1.21\n\nChapter 9. Network and Communication\n\nSERVER: URL", "type": "FUNCTION", "name": "SMTP_CLIENT", "input": [{"name": "SERVER", "type": "STRING", "description": "URL of the SMTP server, can include username, password, and port number."}, {"name": "MAIL FROM", "type": "STRING", "description": "The return address for the email."}, {"name": "MAILTO", "type": "STRING", "description": "Recipient addresses, can include To, Cc, Bc addresses separated by '#' and ';'."}, {"name": "SUBJECT", "type": "STRING", "description": "The subject text for the email."}, {"name": "FILES", "type": "STRING", "description": "List of files to be attached to the email. Multiple files separated by ';'."}, {"name": "ACTIVATE", "type": "BOOL", "description": "Positive edge starts the email transfer process."}, {"name": "TIMEOUT", "type": "TIME", "description": "Timeout duration for the transfer process."}, {"name": "DTI", "type": "DT", "description": "Current date-time value."}, {"name": "DTI_OFFSET", "type": "INT", "description": "Time zone offset from UTC in minutes."}, {"name": "Dns_ip4", "type": "DWORD", "description": "IP4 address of the DNS server."}], "output": [{"name": "DONE", "type": "BOOL", "description": "Indicates whether the email transfer completed without error."}, {"name": "BUSY", "type": "BOOL", "description": "Indicates whether the transfer is currently active."}, {"name": "ERROR_C", "type": "DWORD", "description": "Error code associated with the transfer process."}, {"name": "ERROR_T", "type": "BYTE", "description": "Problem type or identifier for the error that occurred."}], "in/out": [], "return_value": null}
{"title": "SNTP Client", "description": "SNTP_CLIENT is used to synchronize local time with an SNTP server. \n\nFor this, the Simple Network Time Protocol is used which is designed to \n\nprovide a reliable time information over networks with variable packet \n\ndelay. The SNTP is technically completely identical with NTP, which here \n\nmeans no diferences. Therefore, all known SNTP and NTP server can be \n\nused, whether it be on the local network or via the Internet. For IP4 a IP￾address of a SNTP / NTP server is specifed. A positive edge at ACTIVATE \n\nstarts the query. The elapsed time between sending and receiving of the \n\ntime is measured and a time correction is calculated. Then, the received \n\ntime will be corrected by this value. Upon successful completion DONE_P is \n\none positive edge, and the current time is passed at UDT. On XMS the \n\nassociated fractional seconds as milliseconds are passed. The values of \n\n127 Version 1.21\n\nChapter 9. Network and Communication\n\nUDT and XMS are only valid when DONE_P = TRUE, since this is a static \n\ntime value, and is only used for setting of pulse-controlled time. ERROR \n\ngives at error the exact cause (See block IP_CONTROL).", "type": "FUNCTION", "name": "SNTP_CLIENT", "input": [{"name": "IP_C", "type": "IP_C", "description": "Parameterization for IP Control."}, {"name": "S_BUF", "type": "NETWORK_BUFFER", "description": "Buffer for transmitting data."}, {"name": "R_BUF", "type": "NETWORK_BUFFER", "description": "Buffer for receiving data."}, {"name": "IP4", "type": "DWORD", "description": "IP address of the SNTP server."}, {"name": "ACTIVATE", "type": "BOOL", "description": "Starts the query when a positive edge is detected."}], "output": [{"name": "ERROR", "type": "DWORD", "description": "Error code indicating the cause of any failure."}, {"name": "DONE_P", "type": "BOOL", "description": "Positive edge indicating successful completion without error."}, {"name": "UDT", "type": "DT", "description": "Date and time output as Universal Time."}, {"name": "XMS", "type": "INT", "description": "Milliseconds of the Universal Time UDT."}], "in/out": [], "return_value": {"type": null, "description": null}}
{"title": "SNTP Server Module", "description": "SNTP_SERVER The module provides the functionality of an SNTP (NTP) server. With \n\nENABLE = TRUE the module logs in at IP_CONTROL and waits for the \n\nrelease of the resource, if it occupied by other subscribers for now. Then \n\nthe module is waiting for requests from other SNTP clients and answers it \n\nwith the current time of UDT and XMS. As long as ENABLE = TRUE, the \n\nEthernet access of this resource is permanently locked for other users \n\n(Exclusive Access - due to passive UDP mode). SNTP uses a hierarchical \n\nsystem of diferent strata. As stratum 0 is defned as the exact time \n\nstandard. The directly coupled systems, such as NTP, GPS or DCF77 time \n\nsignals are called Stratum 1.Each additional dependent unit causes an \n\nadditional time lag of 10-100ms and is designate with a higher number \n\n(Stratum 2, Stratum 3 to 255). If no STRATUM is specifed at the module, \n\nSTRATUM = 1 is used as a standard.\n\n128 Version 1.21\n\nChapter 9. Network and Communication\n\nIf an SNTP client itself has a time with a higher stratum than an SNTP \n\nserver, the time of this is sometimes rejected because it is less accurate \n\nthan their own reference. It is therefore important to specify a logically \n\ncorrect STRATUM. The module SNTP_CLIENT ignores deliberately the \n\nSTRATUM and synchronizes in each case with the SNTP server, because \n\npretty much everyone SNTP server as a more precise time than a PLC.", "type": "FUNCTION", "name": "SNTP_SERVER", "input": [{"name": "IP_C", "type": "IP_C", "description": "Parameterization for the IP address control."}, {"name": "S_BUF", "type": "NETWORK_BUFFER", "description": "Buffer used to transmit data."}, {"name": "R_BUF", "type": "NETWORK_BUFFER", "description": "Buffer used to receive data."}, {"name": "ENABLE", "type": "BOOL", "description": "Starts the SNTP server. When TRUE, the server will log in and wait for requests."}, {"name": "STRATUM", "type": "BYTE", "description": "Specifies the hierarchical level or accuracy of the SNTP server."}, {"name": "UDT", "type": "DT", "description": "Date and time input as Universal Time."}, {"name": "XMS", "type": "INT", "description": "Millisecond of the Universal Time UDT."}], "output": [], "in/out": [], "return_value": null}
{"title": "Spider Access Function Module", "description": "SPIDER_ACCESSvariables can be read wnd written from the PLC, \n\nwhich are provided by visualizations of web servers based on \"spider \n\ncontrol\" from the company iniNet integrated Solution GmbH, \n\nFor the following PLC is this web server integration available:\n\nSimatic S7 200/300/400 \n\nSAIA-Burgess PCD \n\nWago (750-841)\n\nBeckhof (CX series)\n\nPhoenix Contact (ILC Reihe)\n\nSelectron\n\nBerthel\n\nTbox\n\nBeck IPC\n\nIn the PLC program of target PLC, the desired variables must be released \n\nfor web access. Since the communication is performed via HTTP (port 80), \n\nthe data exchange is no problem, even across frewalls. Global and \n\ninstance variables can be processed.\n\nFormat of variables:\n\nAt global variables, only the regular variable names has to be given. An \n\ninstance variable must be specifed below. \n\n\"instance name. variable name\"\n\nMode: Read\n\nIf the MODE parameter is set to \"1\" and the variable name is quoted in \n\n\"NAME\", so cyclically a request to the HTTP to Web Server (PLC) is \n\nperformed and the result is displayed the \"VLAUE\" as a string. \n\n130 Version 1.21\n\nChapter 9. Network and Communication\n\nMode: Write\n\nIf the parameter MODE is set to \"2\" and at \"VALUE\" the variable value and \n\nin \"NAME\" the variable name as string, then cyclically an HTTP request to \n\nthe Web Server (PLC) is performed \n\nThe mode resp. the variable name can be changed in the cyclic mode at \n\nany time. If several variables have to be processed, thus only a many \n\nmodule instances as needed must be called.", "type": "FUNCTION", "name": "SPIDER_ACCESS", "input": [{"name": "IP_C", "type": "IP_C", "description": "Parameterization for network communication."}, {"name": "S_BUF", "type": "NETWORK_BUFFER", "description": "Buffer for transmitting data."}, {"name": "R_BUF", "type": "NETWORK_BUFFER", "description": "Buffer for receiving data."}, {"name": "VALUE", "type": "STRING", "description": "Value of the variable to be written, or the fetched value when reading."}, {"name": "NAME", "type": "STRING(40)", "description": "Variable name, which can be a global or instance variable."}, {"name": "INPUT MODE", "type": "BYTE", "description": "Operating mode: 1 for read operation, 2 for write operation."}, {"name": "ERROR", "type": "DWORD", "description": "Error code indicating the status of the operation."}], "output": [{"name": "ERROR", "type": "DWORD", "description": "Error code indicating the status of the operation."}], "in/out": [], "return_value": {"type": "void", "description": "The function does not return a value but performs a network operation."}}
{"title": "STRING_TO_URL Function", "description": "STRING_TO_URL split a URL ( Uniform Resource Locator ) into its com￾ponents and stores it in the data type URL. If in STR no path or protocoll is\n\nspecifed, so the function sets the missing values automatically with the\n\nspecifed replacement values. \n\nA URL is as follows:\n\nProtocol : / / user : Password @ domain : port / path ? query # anchor", "type": "FUNCTION", "name": "STRING_TO_URL", "input": [{"name": "STR", "type": "STRING", "description": "The input URL string that is to be split into its components."}, {"name": "DEFAULT_PROTOCOL", "type": "STRING", "description": "The replacement protocol to use if none is specified in the input URL."}, {"name": "DEFAULT_PATH", "type": "STRING", "description": "The alternate path to use if none is specified in the input URL."}], "output": [{"name": "URL", "type": "URL", "description": "The data type that holds the components of the split URL."}], "return_value": {"type": "URL", "description": "The resulting split components of the URL.", "fields": [{"name": "protocol", "type": "STRING", "description": "The protocol used in the URL."}, {"name": "user", "type": "STRING", "description": "The user name component of the URL, if specified."}, {"name": "password", "type": "STRING", "description": "The password component of the URL, if specified."}, {"name": "domain", "type": "STRING", "description": "The domain name of the URL."}, {"name": "port", "type": "INTEGER", "description": "The port number specified in the URL, if any."}, {"name": "path", "type": "STRING", "description": "The path component of the URL."}, {"name": "query", "type": "STRING", "description": "The query component of the URL, if any."}, {"name": "anchor", "type": "STRING", "description": "The anchor component of the URL, if any."}]}}
{"title": "SYSLOG Message Transmission", "description": "SYS_LOG is a standard for transmitting messages in an IP computer net￾work. The protocol is very simple - the client sends a short text message\n\nto the syslog receiver. The receiver is also called \"syslog daemon\" or \"sys￾log server\". The messages are sent using UDP port 514 or TCP port 1468\n\nand includes the message in plain text. SYSLOG is typical used for compu￾ter systems management and security surveillance. This enables the easy\n\nintegration of various log sources to a central syslog server. The server\n\nsoftware is available for all platforms, sometimes known as free / sharewa￾re. Unix or Linux systems have a syslog server already integrated.\n\nThrough a positive edge at ACTIVATE from the parameters of LDT, FACILI￾TY, SEVERITY, TAG, HOST NAME, MESSAGE a syslog message is generated\n\nand sent to the SERVER_IP4 mail address. With OPTION various properties\n\ncan still be controlled (See Table OPTION). After successfully sending\n\nDONE gets TRUE, otherwise ERROR is issued when the actual error messa￾ge (See ERROR of module IP_CONTROL).\n\nA syslog message has the following structure\n\nFACILITY,SEVERITY,TIMESTAMP,HOSTNAME,TAG,MESSAGE", "type": "FUNCTION", "name": "SYS_LOG", "input": [{"name": "IP_C", "type": "IP_C", "description": "Parameterization for the communication interface."}, {"name": "S_BUF", "type": "NETWORK_BUFFER", "description": "Buffer for transmitting data."}, {"name": "R_BUF", "type": "NETWORK_BUFFER", "description": "Buffer for receiving data."}, {"name": "ACTIVATE", "type": "BOOL", "description": "Positive edge starts the query."}, {"name": "LDT", "type": "DT", "description": "Local time for timestamping the message."}, {"name": "SERVER_IP4", "type": "DWORD", "description": "IP address of the syslog server."}, {"name": "PORT", "type": "WORD", "description": "Port number for the syslog server."}, {"name": "FACILITY", "type": "BYTE", "description": "Specifies the service or component."}, {"name": "SEVERITY", "type": "BYTE", "description": "Classification of severity for the message."}, {"name": "TAG", "type": "STRING(32)", "description": "Process name or ID associated with the syslog message."}, {"name": "HOST_NAME", "type": "STRING", "description": "Name or IP address of the sender of the message."}, {"name": "MESSAGE", "type": "STRING", "description": "The message content to be sent."}, {"name": "OPTION", "type": "BYTE", "description": "Various options to control message properties."}], "output": [{"name": "DONE", "type": "BOOL", "description": "Indicates if the query completed without errors."}, {"name": "ERROR", "type": "DWORD", "description": "Error code if the transmission fails."}], "in/out": [], "return_value": {"type": null, "description": null}}
{"title": "TELNET_LOG Function Module", "description": "TELNET_LOG is used to pass all the messages in the ring LOG_CONTROL￾bufer over TELNET. By \"ENABLE\", the module can be activated. At \n\nparameter PORT the desired port number can be defned. If the parameter \n\nis not defned the default port is 23.\n\nWith OPTION various properties can still be controlled (See Table OPTION). \n\nIf the parameter OPTION is not connected the following default is \n\nassumed:\n\nOPTION = BYTE#2#1000_1100;\n\nAs soon as a Telnet client connects this is indicated by parameter \"READY\". \n\nThen be automatically all messages are passed to TELNET. Once occurred \n\nnew reports in the course in LOG_CONTROL they are always passed \n\nautomatically. When a new connection from/to rebuilds, all messages will \n\nbe passed again. Most TELNET clients ofer the opportunity to redirect the \n\ndata stream to a fle, just to make a long-term data archiving.\n\nOPTION:\n\nBIT Function Description\n\n0 SCREEN_INIT After connecting to the TELNET console the entire screen is\n\ncleared. If the COLOR OPTION is selected, the screen\n\nBACK_COLOR will be deleted.\n\n1 AUTOWRAP In AUTOWRAP = 1, the write cursor is on reaching the end\n\nof line is automatically set to a next line. If the text output\n\nthe X,Y positions are always specifed with, it is better when\n\nAUTOWRAP = 0.\n\n2 COLOR Enables the color mode, it will apply BACK_COLOR and\n\nFRONT_COLOR to the output.\n\n3 NEW_LINE In NEW_LINE = 1 is automatically a carriage return and line\n\nfeed added to the end of the text. So the next text output\n\nstarts a new line. But this is only useful if no X_pos and\n\nY_pos be specifed.\n\n4 RESERVE\n\n5 RESERVE\n\n136 Version 1.21\n\nChapter 9. Network and Communication\n\n6 RESERVE\n\n7 NO_BUF_FLUSH Prevents the data in the bufer to be sent immediately. Only\n\nif the bufer is completely full, or this option is disabled, the\n\ndata is sent. Allows fast sending many texts in the same\n\ncycle", "type": "FUNCTION", "name": "TELNET_LOG", "input": [{"name": "IP_C", "type": "IP_C", "description": "Parameterization for IP configuration."}, {"name": "S_BUF", "type": "NETWORK_BUFFER", "description": "Buffer for transmitting data."}, {"name": "S_BUF_SIZE", "type": "UINT", "description": "Size of S_BUF."}, {"name": "ENABLE", "type": "BOOL", "description": "Toggle for activating the TELNET server."}, {"name": "OPTION", "type": "BYTE", "description": "Send options controlling various properties (default is BYTE#2#1000_1100)."}, {"name": "PORT", "type": "WORD", "description": "Desired port number for TELNET connection (default is 23 if not defined)."}], "output": [{"name": "READY", "type": "BOOL", "description": "Indicates that the TELNET client has established a connection."}], "in/out": [], "return_value": null}
{"title": "TELNET_PRINT Function Module", "description": "TELNET_PRINT The module enables easy output of text to a TELNET console. At the \n\nparameter TEXT is passed the desired string. To unlock the module for \n\ncommunication, ENABLE = 1 must be set, so that the registration takes \n\nplace at IP_CONTROL. With parameter PORT can be defned the port \n\nnumber you want, if not value is specifed the default port 23 is activated. \n\nWith BACK_COLOR and FRONT_COLOR can be defned the colors you want, \n\nif the function parameter OPTION is activated. The parameters X_pos and \n\nY_pos pass the desired coordinates of the text. If indicated in X_pos and \n\nY_pos the value \"0\", the text position is inactive, and the text are always \n\nappended at the current cursor position. The standard Telnet console \n\nallows X_pos (horizontal) from 1 to 80 and a Y_pos (Vertical) 1 to 25. The \n\nbehavior here can in turn be modifed by OPTION (Autowrap, carriage \n\nreturn, line feed, Buf_Flush etc..). If a large quantity of text will be issued, \n\nthere may be a bufering enabled, so the data are written if either the \n\nbufer is full (this is from the module induced independently) or this is \n\nsignaled by the amended OPTION parameter. By SEND = 1, the data is \n\nwritten into the bufer. The parameters may only be changed again if \n\nREADY is 1, and with DONE the data acquisition was displayed as a \n\npositive edge.\n\nOPTION:\n\nBIT Function Description\n\n0 SCREEN_INIT After connecting to the TELNET console the entire screen is\n\ncleared. If the COLOR OPTION is selected, the screen\n\nBACK_COLOR will be deleted.\n\n1 AUTOWRAP In AUTOWRAP = 1, the write cursor is on reaching the end\n\nof line is automatically set to a next line. If the text output\n\nthe X,Y positions are always specifed with, it is better when\n\nAUTOWRAP = 0.\n\n2 COLOR Enables the color mode, it will apply BACK_COLOR and\n\nFRONT_COLOR to the output.\n\n3 NEW_LINE In NEW_LINE = 1 is automatically a carriage return and line\n\nfeed added to the end of the text. So the next text output\n\nstarts a new line. But this is only useful if no X_pos and\n\nY_pos be specifed.\n\n4 RESERVE\n\n5 RESERVE\n\n6 RESERVE\n\n7 NO_BUF_FLUSH Prevents the data in the bufer to be sent immediately. Only\n\nif the bufer is completely full, or this option is disabled, the\n\ndata is sent. Allows fast sending many texts in the same\n\ncycle\n\n138 Version 1.21\n\nChapter 9. Network and Communication\n\nFRONT_COLOR:\n\nByte Color Byte Color\n\n0 Black 16 Flashing Black\n\n1 Light Red 17 Flashing Light Red\n\n2 Light Green 18 Flashing Light Green\n\n3 Yellow 19 Flashing Yellow\n\n4 Light Blue 20 Flashing Light Blue\n\n5 Pink / Light Magenta 21 Flashing Pink / Light Magenta\n\n6 Light Cyan 22 Flashing Light Cyan\n\n7 White 23 Flashing White\n\n8 Black 24 Flashing Black\n\n9 Red 25 Flashing Red\n\n10 Green 26 Flashing Green\n\n11 Brown 27 Flashing Brown\n\n12 Blue 28 Flashing Blue\n\n13 Purple / Magenta 29 Purple / Magenta\n\n14 Cyan 30 Flashing Cyan\n\n15 Gray 31 Flashing Gray\n\nBACK_COLOR:\n\nByte Color\n\n0 Black\n\n1 Red\n\n2 Green\n\n3 Brown\n\n4 Blue\n\n5 Purple / Magenta\n\n6 Cyan\n\n139 Version 1.21\n\nChapter 9. Network and Communication\n\n7 Gray", "type": "FUNCTION", "name": "TELNET_PRINT", "input": [{"name": "IP_C", "type": "IP_C", "description": "Parameterization for IP control."}, {"name": "S_BUF", "type": "NETWORK_BUFFER", "description": "Buffer for transmitting data."}, {"name": "INPUT TEXT", "type": "STRING", "description": "The string that you want to output to the TELNET console."}, {"name": "S_BUF_SIZE", "type": "UINT", "description": "Size of the buffer S_BUF."}, {"name": "ENABLE", "type": "BOOL", "description": "Enable communication; set to 1 to unlock the module."}, {"name": "SEND", "type": "BOOL", "description": "Positive edge to initiate sending of data."}, {"name": "OPTION", "type": "BYTE", "description": "Send options to configure the behavior of text output."}, {"name": "BACK_COLOR", "type": "BYTE", "description": "Background color for text output."}, {"name": "FRONT_COLOR", "type": "BYTE", "description": "Foreground color for text output."}, {"name": "X_pos", "type": "BYTE", "description": "X-coordinate of the cursor position (horizontal)."}, {"name": "Y_pos", "type": "BYTE", "description": "Y-coordinate of the cursor position (vertical)."}, {"name": "PORT", "type": "WORD", "description": "Port number for the TELNET connection; defaults to port 23 if not specified."}], "output": [{"name": "READY", "type": "BOOL", "description": "Indicates if the module is ready for operation."}, {"name": "DONE", "type": "BOOL", "description": "Positive edge indicating that the transmission is completed."}], "in/out": [], "return_value": null}
{"title": "Telnet-Vision Framework Function Module", "description": "TN_FRAMEWORK is a frame structure, which provides a \n\nfnished maturity model for TELNET-Vision .\n\nThe following tasks and functions are treated.\n\nConnection setup and breakdown with Telnet Client\n\nSend and receive data\n\nData structures for graphics functions\n\nINPUT_CONTROL elements\n\nIntelligent automatic updating of the Telnet display\n\nMenu bar display\n\nDirect access to all data structures for user program\n\n173 Version 1.21\n\nChapter 11. Telnet-Vision", "type": "FUNCTION", "name": "TN_FRAMEWORK", "input": [{"name": "Xus_TN_INPUT_CONTROL", "type": "Us_TN_INPUT_CONTROL", "description": "Input control elements to manage Telnet operations."}, {"name": "Xus_TN_SCREEN", "type": "Us_TN_SCREEN", "description": "Screen structure for displaying the Telnet interface."}, {"name": "Xus_TN_MENU", "type": "us_TN_MENU", "description": "Menu structure for user navigation and options."}, {"name": "S_BUF", "type": "NETWORK_BUFFER", "description": "Buffer for transmitting data over the network."}, {"name": "R_BUF", "type": "NETWORK_BUFFER", "description": "Buffer for receiving data from the network."}, {"name": "IP_C", "type": "IP_CONTROL", "description": "Parameters for IP configuration and control."}], "output": [], "in/out": [], "return_value": {"type": "void", "description": "No return value as this function performs operations without returning data."}}
{"title": "Input Control Management", "description": "TN_INPUT_CONTROL: us_TN_INPUT_CONTROL\n\nThe module TN_INPUT_CONTROL is used to manage the INPUT_CONTROL \n\nelements. If Xus_TN_INPUT_CONTROL.bo_Reset_Fokus = TRUE then the \n\nFOCUS is disabled on all elements and the frst item gets to the focus. \n\nUsing the cursor up / down buttons and tab, the individual elements can \n\nbe selected or changed. The current element loses focus and then the next \n\nfollowing item gets the input focus reallocated. At the focus change of the \n\nelements automatically a redraw of the respective elements is triggered. \n\nThe image/fashing cursor is always positioned at each active element and \n\nis displayed. It always automatically displays and updates the ToolTip text, \n\nas this has been confgured.\n\nIt supports the following elements.\n\nTN_INPUT_EDIT_LINE\n\nTN_INPUT_SELECT_TEXT \n\nTN_INPUT_SELECT_POPUP", "type": "FUNCTION", "name": "TN_INPUT_CONTROL", "input": [{"name": "Xus_TN_SCREEN", "type": "Us_TN_SCREEN", "description": "Screen information for the input control interface."}, {"name": "Xus_TN_INPUT_CONTROL", "type": "us_TN_INPUT_CONTROL", "description": "Control structure for managing input elements."}], "output": [], "in/out": [], "return_value": null}
{"title": "Telnet Input Line Management", "description": "TN_INPUT_EDIT_LINE is used to manage a command line. This \n\nmust be set *. in_TYPE = 1.\n\nThe item will be provided as *.in_X and *.in_Y. Every entry line can be \n\nprovided with a title text. With *.in_Title_Y_Ofset and *.in_Title_X_Ofset \n\nthe position relative to the element coordinates is expressed. The color \n\ncan be determined with *.by_Title_Attr, and the text by *.st_Title_String. If \n\na tool tip should appear at the element *. st_Input_ToolTip the text hast to \n\nbe specifed.\n\nIf the item has focus, using the keyboard cursor left / right the fashing \n\ncursor can be moved within the line. The backspace key can delete \n\nentered character. By pressing the Enter / Return key the input text is \n\nissued at *.st_Input_String and *.bo_Input_Entered ist set to TRUE. The \n\ninput fag must be reset after receive by the user. Using *.bo_Input_Hidden \n\n= TRUE the hidden input is activated, thus, all input characters \n\nrepresented with a '*'.\n\nUsing *.st_Input_Mask determines at which position and how many \n\ncharacters can be entered. At each position which a space, character can \n\nbe entered. During initialization *.st_Input_Mask must be copied once to \n\n*.st_Input_Data.\n\nIs *.bo_Input_Only_Num = TRUE only numeric keys are accepted and \n\nadopted.", "type": "FUNCTION", "name": "TN_INPUT_EDIT_LINE", "input": [{"name": "Xus_TN_SCREEN", "type": "Us_TN_SCREEN", "description": "User interface screen structure used for managing the input line."}, {"name": "Xus_TN_INPUT_CONTROL", "type": "us_TN_INPUT_CONTROL", "description": "Control structure for handling input operations and statuses."}, {"name": "in_Type", "type": "INT", "description": "Set type of the input, should be set to 1."}, {"name": "in_Y", "type": "INT", "description": "Y-coordinate position for the input line."}, {"name": "in_X", "type": "INT", "description": "X-coordinate position for the input line."}, {"name": "by_Attr_mF", "type": "BYTE", "description": "Attribute for the foreground color of the input line."}, {"name": "by_Attr_oF", "type": "BYTE", "description": "Attribute for the background color of the input line."}, {"name": "in_Cursor_Pos", "type": "INT", "description": "Current position of the cursor in the input line."}, {"name": "bo_Input_Only_Num", "type": "BOOL", "description": "Flag indicating if only numeric input is allowed."}, {"name": "bo_Input_Hidden", "type": "BOOL", "description": "Flag indicating if the input should be hidden; input characters are shown as '*' when true."}, {"name": "st_Input_Mask", "type": "STRING", "description": "Mask defining the allowed input characters and their positions."}, {"name": "st_Input_Data", "type": "STRING", "description": "Data input buffer initialized from the input mask."}, {"name": "st_Input_ToolTip", "type": "STRING", "description": "Tooltip text displayed when hovering over the input line."}, {"name": "in_Input_Option", "type": "INT", "description": "Control option for the input line."}, {"name": "in_Title_Y_Ofset", "type": "INT", "description": "Y-offset for the title relative to its position."}, {"name": "in_Title_X_Ofset", "type": "INT", "description": "X-offset for the title relative to its position."}, {"name": "by_Title_Attr", "type": "BYTE", "description": "Attribute for the title's text color."}, {"name": "st_Title_String", "type": "STRING", "description": "Text string for the title associated with the input line."}], "output": [{"name": "st_Input_String", "type": "STRING", "description": "The text input received from the user."}, {"name": "bo_Input_Entered", "type": "BOOL", "description": "Flag indicating if the input has been submitted by the user."}], "in/out": [], "return_value": null}
{"title": "Menu Bar Management Module", "description": "TN_INPUT_MENU_BAR is used to manage and view the \n\nMenu_Bar. The element is shown in *.in_X and *.in_Y. The menu items are \n\nstored as elements within verschachelte *.st_MENU_TEXT. Two diferent \n\nseparators are used. A '$' separates the diferent menu lists, and each \n\nmenu list is further divided by '#' into individual menu items. The frst \n\nmenu list is the actual menu bar, this implies the number of sub-menus, \n\nand the titles of the elements. Then all the sub-menu lists are follow and \n\nare separated by '%'. To devide individual sub-menu items from each other \n\nor providing them with a cut line, an '-' has to submitted as text menu￾element.\n\nBy pressing the Escape key, the menu bar activated and the respective \n\nsub-menu is displayed using the module TN_INPUT_MENU_POPUP. Within \n\nthe sub-menu can be navigated with up / down key. Within the sub-menu \n\ncan be navigated with up / down cursor. If a sub-menu item is confrmed \n\nby pressing Enter / Return key, then in *.in_Menu_Selected the number of \n\nthe selected menu-point is passed. The calculation of the menu item \n\nnumber is as following: Main menu index * 10 + Submenu-index. The entry \n\nin *.in_Menu_Selected needs set again to 0 after acceptance by users.\n\nThus, a maximum of 9 main menu items and each 9-Submenu items are \n\nexecutable. Means of escape key at any time the menu can be hided \n\nagain.\n\n176 Version 1.21\n\nChapter 11. Telnet-Vision\n\nActive Menu automatically backs up the background before it is drawn, \n\nand restores the background after ending.\n\nAs long as a menu is display, the user program may not make graphical \n\nchanges. This can be checked by TN_SCREEN.bo_Menue_Bar_Dialog = \n\nTRUE.", "type": "FUNCTION", "name": "TN_INPUT_MENU_BAR", "input": [{"name": "Xus_TN_SCREEN", "type": "Us_TN_SCREEN", "description": "Screen parameters for the menu bar."}, {"name": "Xus_TN_MENU", "type": "us_TN_MENU", "description": "Menu parameters that drive the menu bar functionality."}, {"name": "in_X", "type": "INT", "description": "The X position on the screen where the menu bar will be displayed."}, {"name": "in_Y", "type": "INT", "description": "The Y position on the screen where the menu bar will be displayed."}, {"name": "by_Attr_mF", "type": "BYTE", "description": "Attributes for the menu foreground color."}, {"name": "by_Attr_oF", "type": "BYTE", "description": "Attributes for the menu background color."}, {"name": "st_MENU_TEXT", "type": "STRING", "description": "The string containing the text for the menu and its sub-menus."}, {"name": "bo_Create", "type": "BOOL", "description": "Flag to indicate whether the menu bar should be created."}], "output": [{"name": "in_Menu_Selected", "type": "INT", "description": "The index of the selected menu item."}], "in/out": [], "return_value": {"type": "VOID", "description": "No return value, function operates through output parameters."}}
{"title": "TN_INPUT_MENU_POPUP Function Module", "description": "TN_INPUT_MENU_POPUP is used to manage and display the \n\nMenu_Bar Submenu and for the representation of \n\nTN_INPUT_SELECT_POPUP elements. The element is shown in *.in_X and \n\n*.in_Y. The menu items are stored as elements within *.st_Menu_Text. The \n\nindividual element are devided from each other using '#'. To devide \n\nindividual sub-menu items from each other or providing them with a cut \n\nline, an '-' has to submitted as text menu-element.\n\nWithin the sub-menu can be navigated with up / down key. If a sub-menu \n\nitem is confrmed by pressing Enter / Return key, then in \n\n*.in_Menu_Selected the number of the selected menu-point is passed.\n\nAn active Menu automatically backs up the background before it is drawn, \n\nand restores the background after ending.\n\nAs long as a menu is display, the user program may not make graphical \n\nchanges. This can be checked by TN_SCREEN.bo_Menue_Bar_Dialog = \n\nTRUE or TN_SCREEN.bo_Modal_Dialog = TRUE.\n\nThe module is primarily from TN_INPUT_MENU_BAR and \n\nTN_INPUT_SELECT_POPUP used internally, and need not be executed \n\ndirectly by the user.", "type": "FUNCTION", "name": "TN_INPUT_MENU_POPUP", "input": [{"name": "Xus_TN_SCREEN", "type": "Us_TN_SCREEN", "description": "The screen structure containing display properties and state management for the menu."}, {"name": "Xus_TN_MENU", "type": "us_TN_MENU", "description": "The menu structure containing the text and organization of menu items, divided by '#'. Each sub-menu item can be divided by '-' for visual separation."}], "output": [], "in/out": [{"name": "in_X", "type": "Integer", "description": "The X-coordinate for where the menu is displayed on the screen."}, {"name": "in_Y", "type": "Integer", "description": "The Y-coordinate for where the menu is displayed on the screen."}, {"name": "in_Menu_Selected", "type": "Integer", "description": "The number of the selected menu item after user confirmation."}], "return_value": null}
{"title": "TN_INPUT_SELECT_POPUP", "description": "TN_INPUT_SELECT_POPUP is used to manage a selection of \n\ntexts, by displaying a pop-up dialogue. This must be set *.IN_TYPE = 3.\n\nThe item will be provided as *.in_X and *.in_Y. Every entry line can be \n\nprovided with a title text. With *.in_Title_Y_Ofset and *.in_Title_X_Ofset \n\nthe position relative to the element coordinates is expressed. The color \n\ncan be determined with *.by_Title_Attr, and the text by *.st_Title_String. If \n\na tool tip should appear at the element *. st_Input_ToolTip the text hast to \n\nbe specifed.\n\nThe selection of texts will be handed over in *.st_Input_Data. The text \n\nelement should be separated from each other by the character '#'.\n\nIf the focus is on an element, using the Enter / Return key selection dialog \n\ncan be activated.\n\nWith the cursor up/down can be changed between the individual elements. \n\nIf the beginning or the end of the list will be reachted, it continues at the \n\nopposite side.\n\nThe text-element is connected by means *.st_Input_Mask, meaning that \n\nthe output text length are afected later.\n\nBy pressing the Enter / Return key is the text of the selected element is \n\npassed to *. st_Input_String and *. bo_Input_Entered = TRUE. The input \n\nfag must be reset after receive by the user.\n\nAn active selection (selection dialog) can always be canceled with the \n\nEscape key.", "type": "FUNCTION", "name": "TN_INPUT_SELECT_POPUP", "input": [{"name": "in_Type", "type": "INT", "description": "Type of the input selection dialog. Must be set to 3."}, {"name": "in_Y", "type": "INT", "description": "Vertical position of the input dialog."}, {"name": "in_X", "type": "INT", "description": "Horizontal position of the input dialog."}, {"name": "by_Attr_mF", "type": "STRING", "description": "Color attributes for the selected state, separated by '#'."}, {"name": "by_Attr_oF", "type": "STRING", "description": "Color attributes for the unselected state, separated by '#'."}, {"name": "st_Input_ToolTip", "type": "STRING", "description": "Tooltip text that appears when the element is focused."}, {"name": "in_Input_Option", "type": "INT", "description": "Option settings for the input."}, {"name": "in_Title_Y_Ofset", "type": "INT", "description": "Vertical offset for the title text position."}, {"name": "in_Title_X_Ofset", "type": "INT", "description": "Horizontal offset for the title text position."}, {"name": "by_Title_Attr", "type": "STRING", "description": "Color attributes for the title text."}, {"name": "st_Title_String", "type": "STRING", "description": "Title text displayed on the dialog."}, {"name": "st_Input_Mask", "type": "STRING", "description": "Mask that affects the output text length."}, {"name": "st_Input_Data", "type": "STRING", "description": "The text elements to be selected, separated by '#'."}], "output": [{"name": "st_Input_String", "type": "STRING", "description": "The string output of the selected element."}, {"name": "bo_Input_Entered", "type": "BOOL", "description": "Indicates whether an input has been selected (TRUE) or not (FALSE)."}], "in/out": [], "return_value": {"type": "VOID", "description": "This function does not return a value."}}
{"title": "Text Selection Management", "description": "TN_INPUT_SELECT_TEXT is used to manage a selection of \n\ntexts. This must be set *.IN_TYPE = 2.\n\n180 Version 1.21\n\nChapter 11. Telnet-Vision\n\nThe item will be provided as *.in_X and *.in_Y. Every entry line can be \n\nprovided with a title text. With *.in_Title_Y_Ofset and *.in_Title_X_Ofset \n\nthe position relative to the element coordinates is expressed. The color \n\ncan be determined with *.by_Title_Attr, and the text by *.st_Title_String. If \n\na tool tip should appear at the element *. st_Input_ToolTip the text hast to \n\nbe specifed.\n\nThe selection of texts will be handed over in *.st_Input_Data. The text \n\nelement should be separated from each other by the character '#'.\n\nIf the Element has the focus, by using the spacebar (space) can be \n\nchanged between the individual texts. The text-element is connected by \n\nmeans *.st_Input_Mask, meaning that the output text length are afected \n\nlater.\n\nBy pressing the Enter / Return key the input text is issued at \n\n*.st_Input_String and *.bo_Input_Entered ist set to TRUE. The input fag \n\nmust be reset after receive by the user.", "type": "FUNCTION", "name": "TN_INPUT_SELECT_TEXT", "input": [{"name": "Xus_TN_SCREEN", "type": "Us_TN_SCREEN", "description": "Screen interface for the text selection."}, {"name": "Xus_TN_INPUT_CONTROL", "type": "us_TN_INPUT_CONTROL", "description": "Control structure for managing input options."}, {"name": "in_Type", "type": "INT", "description": "Type of the input selection; must be set to 2."}, {"name": "in_Y", "type": "INT", "description": "Y-coordinate positioning for the input selection."}, {"name": "in_X", "type": "INT", "description": "X-coordinate positioning for the input selection."}, {"name": "by_Attr_mF", "type": "INT", "description": "Attribute value for the foreground color."}, {"name": "by_Attr_oF", "type": "INT", "description": "Attribute value for the background color."}, {"name": "st_Input_ToolTip", "type": "STRING", "description": "Tooltip text for the input element."}, {"name": "in_Input_Option", "type": "INT", "description": "Option for input selection."}, {"name": "in_Title_Y_Ofset", "type": "INT", "description": "Y-offset for the title text relative to the input element."}, {"name": "in_Title_X_Ofset", "type": "INT", "description": "X-offset for the title text relative to the input element."}, {"name": "by_Title_Attr", "type": "INT", "description": "Attribute for the title text."}, {"name": "st_Title_String", "type": "STRING", "description": "Title text to display for this input."}, {"name": "st_Input_Mask", "type": "STRING", "description": "Mask for the input string."}, {"name": "st_Input_Data", "type": "STRING", "description": "Selection of texts separated by '#'."}], "output": [{"name": "st_Input_String", "type": "STRING", "description": "Output string of the current input selection."}, {"name": "bo_Input_Entered", "type": "BOOL", "description": "Boolean indicating if the input was entered (set to TRUE when Enter/Return is pressed)."}, {"name": "st_Input_Mask", "type": "STRING", "description": "The mask affecting the output text length."}], "in/out": [], "return_value": {"type": null, "description": null}}
{"title": "Telnet Receive Function", "description": "TN_RECEIVE receives input data from the Telnet client, and \n\nevaluates the key codes.\n\nIf the key code in the range 32-126 it shall be stored as ASCII code under \n\nXus_TN_SCREEN, by_Input_ASCII_Code. In addition, \n\nXus_TN_SCREEN.bo_Input_ASCII_IsNum = TRUE if this corresponds to a \n\nnumber between 0 and 9.\n\nIf the key code is of the following extended code then this is fled under \n\nXus_TN_SCREEN,by_Input_Exten_Code.\n\nExten_code Button name\n\n65 Cursor up\n\n66 Cursor down\n\n67 Cursor RIGHT\n\n68 Cursor left\n\n72 Pos1\n\n75 End\n\n80 F1\n\n81 F2\n\n82 F3\n\n83 F4\n\n8 Backspace\n\n182 Version 1.21\n\nChapter 11. Telnet-Vision\n\n9 Tabulator\n\n13 Return (Enter)\n\n27 Escape", "type": "FUNCTION", "name": "TN_RECEIVE", "input": [{"name": "Xus_TN_SCREEN", "type": "us_TN_SCREEN", "description": "Structure to hold the result of the Telnet input processing.", "fields": [{"name": "by_Input_ASCII_Code", "type": "int", "description": "The ASCII code received from the Telnet client."}, {"name": "bo_Input_ASCII_IsNum", "type": "bool", "description": "Indicates if the received ASCII code corresponds to a numeric value (0-9)."}, {"name": "by_Input_Exten_Code", "type": "int", "description": "An extended code representing specific function keys."}]}, {"name": "R_BUF", "type": "NETWORK_BUFFER", "description": "Buffer that holds the data received from the Telnet client."}], "output": [], "in/out": [], "return_value": null}
{"title": "TN_SC_ADD_SHADOW Function Module", "description": "TN_SC_ADD_SHADOW allows you to add optical shadow to \n\nrectangular glyphs. By specifying a rectangular area by means of the \n\nparameters X1, Y1 and X2, Y2, a basic framework is defned, at which at \n\nthe right and bottom color darkened lines are drawn (shadow). The \n\nshadow coordinates X1, Y1 and X2, Y2 are always given +1 for proper \n\nprimitive. OPTION means you can choose between two shadow variations. \n\nIf OPITION = 0 then the shadow is reached by pure color adjustment \n\n(darkening of the character) . If an OPTION > 0, in the area of the shadow \n\nall the characters replaced by black flled characters.", "type": "FUNCTION", "name": "TN_SC_ADD_SHADOW", "input": [{"name": "Iin_Y1", "type": "INT", "description": "Y1 coordinate of the area"}, {"name": "Iin_X1", "type": "INT", "description": "X1 coordinate of the area"}, {"name": "Iin_Y2", "type": "INT", "description": "Y2 coordinate of the area"}, {"name": "Iin_X2", "type": "INT", "description": "X2 coordinate of the area"}, {"name": "Iin_OPTION", "type": "INT", "description": "Kind of the shadow"}], "in/out": [{"name": "Xus_TN_SCREEN", "type": "Us_TN_SCREEN", "description": "The output screen structure where shadows will be applied."}], "return_value": {"type": "VOID", "description": "This function does not return a value."}}
{"title": "Telnet-Vision Area Restore Function", "description": "TN_SC_AREA_RESTORE enables recovery of previously saved \n\nscreen area. The screen data in Xus_TN_SCREEN.bya_BACKUP [x] is \n\nrestored using the stored coordinates. This is done mainly done after the \n\ncall from the module MENU-BAR amd MENU-POPUP, to restore the modifed \n\nscreen.", "type": "FUNCTION", "name": "TN_SC_AREA_RESTORE", "input": [{"name": "Xus_TN_SCREEN", "type": "Us_TN_SCREEN", "description": "Input parameter representing the screen data containing the backup to be restored."}], "output": [], "in/out": [], "return_value": {"type": "void", "description": "No return value. The function performs restoration on the provided screen data."}}
{"title": "TN_SC_AREA_SAVE Function Module", "description": "TN_SC_AREA_SAVE allows you to save of rectangular areas of \n\nthe screen before it is modifed by other drawing operations. This is mainly \n\ndone before the call from the module BAR-MENU and MENU-POPUP , \n\nbecause these are the elements as an overlay graphic. Means X1, Y1 and \n\nX2, Y2 are given the coordinates of the secured area of the screen. The \n\ndata are saved in the data area Xus_TN_SCREEN.bya_BACKUP [x]. Here the \n\ncoordinates and the actual characters and color information is stored. The \n\nbufer can hold up half the area of the screen.\n\n185 Version 1.21\n\nChapter 11. Telnet-Vision", "type": "FUNCTION", "name": "TN_SC_AREA_SAVE", "input": [{"name": "Iin_Y1", "type": "INT", "description": "Y1 coordinate of the area"}, {"name": "Iin_X1", "type": "INT", "description": "X1 coordinate of the area"}, {"name": "Iin_Y2", "type": "INT", "description": "Y2 coordinate of the area"}, {"name": "Iin_X2", "type": "INT", "description": "X2 coordinate of the area"}], "in/out": [{"name": "Xus_TN_SCREEN", "type": "Us_TN_SCREEN", "description": "Data structure that contains information about the secured screen area including coordinates, characters, and colors."}], "output": [], "return_value": {"type": "VOID", "description": "No return value, the function operates by saving the specified screen area."}}
{"title": "TN_SC_BOX Function Module", "description": "TN_SC_BOX is used to draw a rectangular area, that is flled \n\nwith the specifed character in Iby_FILL. With parameter Iby_ATTR fll color \n\ncan be specifed. The fll area is drawn with a border that is given by \n\nIin_BORDER.\n\nBorder types:\n\n0 = no border\n\n1 = frame with a single line\n\n2 = frame double line\n\n3 = frame with spaces", "type": "FUNCTION", "name": "TN_SC_BOX", "input": [{"name": "Iin_Y1", "type": "INT", "description": "Y1 coordinate of the area"}, {"name": "Iin_X1", "type": "INT", "description": "X1 coordinate of the area"}, {"name": "Iin_Y2", "type": "INT", "description": "Y2 coordinate of the area"}, {"name": "Iin_X2", "type": "INT", "description": "X2 coordinate of the area"}, {"name": "Iby_FILL", "type": "BYTE", "description": "Fill character of the area"}, {"name": "Iby_ATTR", "type": "BYTE", "description": "Color code to fill the area"}, {"name": "Iby_BORDER", "type": "BYTE", "description": "Type of frame"}], "in/out": [{"name": "Xus_TN_SCREEN", "type": "Us_TN_SCREEN", "description": "Screen structure for displaying the drawn box"}], "return_value": null}
{"title": "TN_SC_FILL Function Module", "description": "TN_SC_FILL is used to draw a rectangular area, that is flled \n\nwith the specifed character in Iby_FILL.", "type": "FUNCTION", "name": "TN_SC_FILL", "input": [{"name": "Iin_Y1", "type": "INT", "description": "Y1 coordinate of the area"}, {"name": "Iin_X1", "type": "INT", "description": "X1 coordinate of the area"}, {"name": "Iin_Y2", "type": "INT", "description": "Y2 coordinate of the area"}, {"name": "Iin_X2", "type": "INT", "description": "X2 coordinate of the area"}, {"name": "Iby_CHAR", "type": "BYTE", "description": "Character to fill the area"}, {"name": "Iby_ATTR", "type": "BYTE", "description": "Color code to fill the area"}], "in/out": [{"name": "Xus_TN_SCREEN", "type": "Us_TN_SCREEN", "description": "In/out parameter representing the screen object to be updated with the filling"}], "return_value": null}
{"title": "Draw Line Function", "description": "TN_SC_LINE is used to draw horizontal and vertical lines. By \n\nmeans of the X1/Y1 and X2/Y2 coordinates defnes the beginning and the \n\nend of the line. The line type is passed by Iin_BORDER and the color code \n\nwith Iby_ATTR. If when drawing a line and another line of this type cut, \n\nautomatically the appropriate crossing sign is used. \n\n188 Version 1.21\n\nChapter 11. Telnet-Vision\n\nBorder types:\n\n1 = line with single line\n\n2 = line with double line\n\n> 2 = line is drawn with the specifed character in Iin_BORDER", "type": "FUNCTION", "name": "TN_SC_LINE", "input": [{"name": "Iin_Y1", "type": "INT", "description": "Y1 coordinate of the line"}, {"name": "Iin_X1", "type": "INT", "description": "X1 coordinate of the line"}, {"name": "Iin_Y2", "type": "INT", "description": "Y2 coordinate of the line"}, {"name": "Iin_X2", "type": "INT", "description": "X2 coordinate of the line"}, {"name": "Iby_ATTR", "type": "BYTE", "description": "Color code of the line"}, {"name": "Iby_BORDER", "type": "BYTE", "description": "Type of line"}], "in/out": [{"name": "Xus_TN_SCREEN", "type": "Us_TN_SCREEN", "description": "Structure for screen representation that may be modified during the drawing process", "fields": []}], "return_value": {"type": "VOID", "description": "Indicates successful execution of line drawing operation"}}
{"title": "TN_SC_READ_ATTR", "description": "TN_SC_READ_ATTR is used to read the current color of the \n\ncharacter at the specifed location X / Y.", "type": "FUNCTION", "name": "TN_SC_READ_ATTR", "input": [{"name": "Iin_Y", "type": "INT", "description": "Y coordinate"}, {"name": "Iin_X", "type": "INT", "description": "X coordinate"}], "output": [{"name": "Oby_ATTR", "type": "BYTE", "description": "Color information at position X / Y"}], "in/out": [{"name": "Xus_TN_SCREEN", "type": "Us_TN_SCREEN", "description": "Screen structure with display attributes"}], "return_value": null}
{"title": "Read Character Function Module", "description": "TN_SC_READ_CHAR is used to read the current character at \n\nthe specifed location X / Y.\n\n190 Version 1.21\n\nChapter 11. Telnet-Vision", "type": "FUNCTION", "name": "TN_SC_READ_CHAR", "input": [{"name": "Iin_Y", "type": "INT", "description": "Y coordinate"}, {"name": "Iin_X", "type": "INT", "description": "X coordinate"}], "output": [{"name": "Oby_CHAR", "type": "BYTE", "description": "Character at position X / Y"}], "in/out": [{"name": "Xus_TN_SCREEN", "type": "Us_TN_SCREEN", "description": "Screen structure containing terminal information"}], "return_value": {"type": "N/A", "description": "This function does not return a value."}}
{"title": "Convert Light Color to Dark Color", "description": "TN_SC_SHADOW_ATTR converts a light color to a dark color.", "type": "FUNCTION", "name": "TN_SC_SHADOW_ATTR", "input": [{"name": "Iby_ATTR", "type": "BYTE", "description": "Color Information representing the light color to be converted."}], "output": [], "in/out": [], "return_value": {"type": "BYTE", "description": "The resulting dark color corresponding to the input light color."}}
{"title": "TN_SC_VIEWPORT", "description": "TN_SC_VIEWPORT is used to display messages from the data \n\nstructure LOG_CONTROL within a rectangular area on the screen. The \n\ndesired messages are processed before using with Block LOG_VIEWPORT, \n\nand if necessary, with Xus_LOG_VIEWPORT.UPDATE an update is triggered. \n\nMeans Iin_X and Iin_Y defnes the upper-left corner of the window, and with \n\nIin_Width the width if of the viewing window is defned. The number of \n\nrows to be displayed is determined by Xus_LOG_VIEWPORT.COUNT. The \n\ncolor information is stored in Xus_LOG_CONTROL.MSG_OPTION [x] per \n\nmessage. It is converted to the confgured color codes from Idw_ATTR_1 \n\nand Idw_ATTR2 automatically, so the colors in the presentation can always \n\nbe adjusted individually. The messages are always automatically reduced \n\nto the width of the window or cut of.", "type": "FUNCTION", "name": "TN_SC_VIEWPORT", "input": [{"name": "Iin_Y", "type": "INT", "description": "(Y coordinate)"}, {"name": "Iin_X", "type": "INT", "description": "(X coordinate)"}, {"name": "Iin_Width", "type": "INT", "description": "(width of the window - the number of characters)"}, {"name": "Idw_ATTR_1", "type": "DWORD", "description": "(color 1,2,3 and 4)"}, {"name": "Idw_ATTR_2", "type": "DWORD", "description": "(color 5,6,7 and 8)"}, {"name": "Iti_TIME", "type": "TIME", "description": "(update time)"}], "in/out": [{"name": "Xus_LOG_VIEWPORT", "type": "LOG_VIEWPORT", "description": "Viewport for displaying log messages"}, {"name": "Xus_LOG_CONTROL", "type": "LOG_CONTROL", "description": "Control structure for log messages"}, {"name": "Xus_TN_SCREEN", "type": "us_TN_SCREEN", "description": "Screen structure for telnet vision"}], "output": [], "return_value": null}
{"title": "TN_SC_WRITE Function Module", "description": "TN_SC_WRITE passes the text Ist_STRING at the coordinates \n\nIin_Y, Iin_Y and the color of Iby_ATTR.\n\nIs specifed color code = 0, then the string is displayed without change the \n\nexisting old color information at he respective character positions.\n\n192 Version 1.21\n\nChapter 11. Telnet-Vision", "type": "FUNCTION", "name": "TN_SC_WRITE", "input": [{"name": "Iin_Y", "type": "INT", "description": "Y coordinate"}, {"name": "Iin_X", "type": "INT", "description": "X coordinate"}, {"name": "Iby_ATTR", "type": "BYTE", "description": "Color code - font color"}, {"name": "Ist_STRING", "type": "STRING", "description": "Text to be displayed"}, {"name": "Xus_TN_SCREEN", "type": "Us_TN_SCREEN", "description": "Screen structure where the text will be written"}], "output": [], "in/out": [], "return_value": null}
{"title": "TN_SC_WRITE_ATTR Function Module", "description": "TN_SC_WRITE_ATTR changes at the given coordinates Iin_Y, \n\nIin_Y the colorcode to change without changing the existing character at \n\nthat position.", "type": "FUNCTION", "name": "TN_SC_WRITE_ATTR", "input": [{"name": "Iin_Y", "type": "INT", "description": "Y coordinate where the color code will be changed."}, {"name": "Iin_X", "type": "INT", "description": "X coordinate where the color code will be changed."}, {"name": "Iby_ATTR", "type": "BYTE", "description": "Color code to apply at the specified coordinates."}], "output": [], "in/out": [{"name": "Xus_TN_SCREEN", "type": "Us_TN_SCREEN", "description": "Screen data structure that holds the current screen state."}], "return_value": {"type": "VOID", "description": "The function does not return any value."}}
{"title": "Telnet Vision Write Function", "description": "TN_SC_WRITE_C is at the given coordinates Iin_Y, Iin_Y \n\nIst_STRING the text with the color of Iby_ATTR. The text is adapted before \n\noutput on the length Iin_LENGTH, and by Iin_OPTION, the text position is \n\ndetermined.\n\nIin_OPTION\n\n0 = right fll with spaces eg 'TEST '\n\n1 = left fll with blanks eg ' TEST '\n\n2 = center and fll with blanks eg ' TEST '", "type": "FUNCTION", "name": "TN_SC_WRITE_C", "input": [{"name": "Iin_Y", "type": "INT", "description": "Y coordinate for text position"}, {"name": "Iin_X", "type": "INT", "description": "X coordinate for text position"}, {"name": "Iby_ATTR", "type": "BYTE", "description": "Color code for the text"}, {"name": "Ist_STRING", "type": "STRING", "description": "Text string to be displayed"}, {"name": "Iin_LENGTH", "type": "INT", "description": "Length to which the text will be adjusted"}, {"name": "Iin_OPTION", "type": "INT", "description": "Option for text positioning: 0 for right, 1 for left, 2 for center"}], "output": [], "in/out": [{"name": "Xus_TN_SCREEN", "type": "Us_TN_SCREEN", "description": "Screen object that may be modified by the function"}], "return_value": null}
