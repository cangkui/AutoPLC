{"title": "Special Stack", "description": "Write a function block FB that implements a special stack feature that removes the minimum value from the stack during the pop operation.\n1. Push operation: When a new element is pushed, first check if the stack is full. If the stack is full, do nothing. Otherwise, add it to the top of the stack array and update the top position.\n2. Pop operation: When performing a pop operation, first check if the stack is empty. If the stack is empty, do nothing. Otherwise, remove the minimum value from the stack and return the value of that element, while updating the top position. Status codes:\n16#0000: Execution of FB without error\n16#8A04: The stack is full\n16#8A05: The stack is empty", "type": "FUNCTION_BLOCK", "name": "StackMin", "input": [{"name": "push", "type": "Bool", "description": "Push operation, add an element to the stack if it is not full"}, {"name": "pop", "type": "Bool", "description": "Pop operation, remove the minimum value element from the stack and return its value if the stack is not empty"}, {"name": "reset", "type": "Bool", "description": "Reset operation, the top position of the stack will be reset"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error occurred; TRUE: An error occurred during the execution of FB"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "item", "type": "Int", "description": "The value used to push into the stack or to return from the stack"}, {"name": "stack", "type": "Array[0..3] of Int", "description": "The array used as the stack"}]}
{"title": "Find Maximum and Minimum Values", "description": "Write a function FC that can accept a variable-length array of integers as input and return the maximum and minimum values in the array along with their positions in the array.\n\nExample:\nAssuming the input array is array[1..5]=[5, 10, 2, 25, 1], the function should return the maximum value 25, the minimum value 1, the position of the maximum value 4, and the position of the minimum value 5.", "type": "FUNCTION", "name": "SearchMinMax_DInt", "input": [{"name": "values", "type": "Array[*] of DInt", "description": "The array to be searched"}], "output": [{"name": "minValue", "type": "DInt", "description": "The minimum value in the array"}, {"name": "minValueIndex", "type": "DInt", "description": "The position of the minimum value in the array"}, {"name": "maxValue", "type": "DInt", "description": "The maximum value in the array"}, {"name": "maxValueIndex", "type": "DInt", "description": "The position of the maximum value in the array"}]}
{"title": "Multi-Pump Switching Control System", "description": "In an industrial water supply system, there are 5 pumps, each of which can be controlled independently. The system needs to support both manual and automatic operating modes.\nBased on the value of the mode variable, switch to the corresponding operating mode.\nIn manual mode, control the start and stop of the selected pump based on the value of pumpGroup[1..5].selection.\nIn automatic mode, compare the priority of each pump, and automatically select the 3 pumps with higher priority for water supply according to the method of three in use and two on standby.", "type": "FUNCTION_BLOCK", "name": "MultiPumpCtrl", "input": [{"name": "mode", "type": "Bool", "description": "FALSE: Manual mode\nTRUE: Automatic mode"}, {"name": "start", "type": "Bool", "description": "Start button, used to start the manually selected or automatically selected pump"}, {"name": "stop", "type": "Bool", "description": "Stop button, used to stop all pumps"}], "in/out": [{"name": "pumpGroup", "type": "Array[1..5] of Struct", "description": "Pump group control structure", "fields": {"priority": {"type": "Int", "description": "Represents the priority of each pump, the higher the value, the higher the priority"}, "selection": {"type": "Bool", "description": "Whether the pump is selected in manual mode, TRUE=selected"}, "RunComd": {"type": "Bool", "description": "Pump run command, TRUE=run, FALSE=stop"}}}]}
{"title": "Calculate the Day of the Year", "description": "In some automated systems, it may be necessary to calculate the day of the year based on the current date. This can be used for tracking production cycles, maintenance schedules, or other situations that require date information.\nControl Requirements:\nThe system needs to receive date input, including year, month, and day.\nBased on the input date, calculate and output the day of the year.\nConsidering that the number of days in February may vary each year (28 days in a leap year, 29 days in a non-leap year), the system needs to be able to identify leap years and calculate accordingly.\nThe output result should be an integer representing the day of the year.\nIf the input date is invalid (such as February 30th, April 31st, etc.), the system should output an error status and error code.\nNotes:\n1. The input year (Year) must be between 1000 and 3000 (inclusive), otherwise output an error status with error=true and an error code status=16#8001. If the input month (Month) is invalid, output an error status with error=true and an error code status=16#8002. If the input day (Day) is invalid, output an error status with error=true and an error code status=16#8003.\n2. The result of the calculation is output through DayOfYear.", "type": "FUNCTION_BLOCK", "name": "FB_CalculateDayOfYear", "input": [{"name": "Year", "type": "Int", "description": "Year input"}, {"name": "Month", "type": "Int", "description": "Month input"}, {"name": "Day", "type": "Int", "description": "Day input"}], "output": [{"name": "DayOfYear", "type": "Int", "description": "Output the day of the year"}, {"name": "error", "type": "Bool", "description": "Error status indicator\nFALSE: No error occurred\nTRUE: An error occurred during execution"}, {"name": "status", "type": "Word", "description": "Status code"}]}
{"title": "Multiple Data Type Selection Sort", "description": "Write a function block FB to implement an ascending order selection sort algorithm. This function block should accept an array of variable length and data types (including Sint, Int, DInt, LInt, Real, LReal, USint, UInt, UDInt, ULint) and write the sorted results back to the original array.\nBased on the program execution results, output the corresponding error status and status code:\n16#0000: No error occurred when executing FB\n16#8A01: The queue seq is not an array type", "type": "FUNCTION_BLOCK", "name": "SelectSort", "input": [{"name": "exe", "type": "Bool", "description": "Start sorting"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error occurred\nTRUE: Error occurred while executing FB"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "seq", "type": "Variant", "description": "Array to be sorted"}]}
{"title": "Random Number", "description": "Write a function FC that generates a random integer within a specified range using the PLC's clock value.\nIf the specified range is incorrect or there is an error reading the system time, an error status and error code are output.\n\nStatus codes:\n16#0000: Execution of FC without error\n16#8200: Specified range is incorrect: minValue is greater than maxValue\n16#8600: Error reading system time", "type": "FUNCTION", "name": "RandomRange_DInt", "input": [{"name": "minValue", "type": "DInt", "description": "The minimum value of the random number range"}, {"name": "maxValue", "type": "DInt", "description": "The maximum value of the random number range"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error occurred; TRUE: An error occurred during the execution of FC"}, {"name": "status", "type": "Word", "description": "Status code"}], "return_value": [{"type": "DInt", "description": "The generated random number"}]}
{"title": "Analog Batch Processing", "description": "In industrial automation applications, analog signals usually need to be converted into specific engineering units or ranges. Write a PLC program that can batch read analog input signals and convert them to specified range. The program receives an array of analog value inputs analogValues and an array for channel settings and conversion outputs channels, with the actual total number of channels specified by the input parameter count, starting from the first element of the array. Each channel is started for conversion by enable, and the conversion is performed according to different rules based on the measuringMode. \nWhen measuringMode=0, it is a non-temperature measurement mode: \nThis mode also needs to be converted based on the polarity bipolar, when bipolar=0, it is unipolar, then the analog input value analogValues from 0 to 27648 is linearly mapped to the lower limit loLIM to the upper limit hiLIM of the output value outputFile; when bipolar=1, it is bipolar, then the analog input value analogValues from -27648 to 27648 is linearly mapped to the lower limit loLIM to the upper limit hiLIM of the output value outputFile. \nWhen measuringMode=1, it is a standard temperature measurement mode: \nIn this mode, the output value outputFile is one-tenth of the analog input value analogValues. \nWhen measuringMode=2, it is a climatic temperature measurement mode: \nIn this mode, the output value outputFile is one-hundredth of the analog input value analogValues. \nThe program also requires checking the correctness of the input parameters: \nIf measuringMode is a value other than 0, 1, 2, then retVal=16#8001, and no conversion is performed for this channel; \nIf hiLIM is less than or equal to loLIM, then retVal=16#8002, and no conversion is performed for this channel.", "type": "FUNCTION_BLOCK", "name": "AIConvert", "input": [{"name": "count", "type": "DInt", "description": "Number of channels to be converted"}], "in/out": [{"name": "analogValues", "type": "Array[*] of Int", "description": "Array of analog values for each channel input"}, {"name": "channels", "type": "Array[*] of Struct", "description": "Settings and converted output values for each channel", "fields": [{"name": "enable", "type": "Bool", "description": "Enable conversion for this channel"}, {"name": "hiLIM", "type": "Real", "description": "Upper limit"}, {"name": "loLIM", "type": "Real", "description": "Lower limit"}, {"name": "bipolar", "type": "Bool", "description": "FALSE: Unipolar\nTRUE: Bipolar"}, {"name": "measuringMode", "type": "Int", "description": "0: Non-temperature measurement\n1: Standard temperature measurement\n2: Climatic temperature measurement"}, {"name": "retVal", "type": "Word", "description": "Status information"}, {"name": "outputValue", "type": "Real", "description": "Converted output value"}]}]}
{"title": "Decompose a 16-bit binary number into four 4-bit binary numbers", "description": "In some data processing and communication applications, it is necessary to decompose a 16-bit binary number into four independent 4-bit binary numbers. For example, such decomposition operations may be required during data encoding, decoding, or data exchange with external systems.\nControl requirements:\nThe system needs to receive a 16-bit binary number InputWord as input.\nDecompose the input 16-bit binary number into four 4-bit binary numbers, corresponding to the lowest to the highest bits of the input number.\nOutput these four 4-bit binary numbers to independent variables Byte0~Byte3.\nAt the same time, calculate the average of the non-zero variables among these four variables Byte0~Byte3 and output it to average.\nFor example, if InputWord=16#1203, then Byte0=3, Byte1=0, Byte2=2, Byte3=1, and the average value average=(1+2+3)/3", "type": "FUNCTION_BLOCK", "name": "FB_SplitWordIntoBytes", "input": [{"name": "InputWord", "type": "Word", "description": "16-bit binary number input"}], "output": [{"name": "Byte0", "type": "Byte", "description": "The lowest 4-bit binary number output"}, {"name": "Byte1", "type": "Byte", "description": "The second lowest 4-bit binary number output"}, {"name": "Byte2", "type": "Byte", "description": "The second highest 4-bit binary number output"}, {"name": "Byte3", "type": "Byte", "description": "The highest 4-bit binary number output"}, {"name": "average", "type": "Real", "description": "The average of non-zero bytes among the four bytes"}]}
{"title": "Sorting", "description": "Write a function block FB that implements an optional ascending or descending sorting feature. This function block should accept a variable-length array of integers (with a maximum length of 1000 elements) and a parameter indicating the sorting direction (ascending or descending), and write the sorted results back to the original array. If the array elements exceed 1000 or are less than or equal to 1, the function block should output an error status and an error code. Status codes:\n16#0000: Execution of FB without error\n16#8200: The array has less than or equal to 1 element\n16#8201: The array has more than 1000 elements", "type": "FUNCTION_BLOCK", "name": "ShellSort_DInt", "input": [{"name": "sortDirection", "type": "Bool", "description": "When FALSE, it indicates ascending order; when TRUE, it indicates descending order"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error occurred; TRUE: An error occurred during the execution of FB"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "array", "type": "Array[*] of DInt", "description": "The array to be sorted"}]}
{"title": "Calculate Moving Average", "description": "Write a function block FB that calculates and updates a moving arithmetic mean. The moving arithmetic mean is a method of averaging over consecutive data points, where each new data point replaces the oldest data point, and then the average is recalculated.\n\n1. When cyclicExecution is TRUE, a new data value is automatically read and the moving average average is updated every scan cycle.\n2. Provide an external trigger signal trigger, which reads a new data value and updates the moving average upon each rising edge.\n3. Provide a reset function reset, which resets the moving average calculation when the reset signal is TRUE. If the window size is less than 1 or greater than 100, output an error status and status code.\n\nThe status parameter indicates the execution status of the program:\n- 16#0000: Execution successful\n- 16#8200: Window length setting error, please set a value between 1 and 100.", "type": "FUNCTION_BLOCK", "name": "FloatingAverage", "input": [{"name": "cyclicExecution", "type": "Bool", "description": "When TRUE, periodic reading is performed, and trigger has no effect"}, {"name": "trigger", "type": "Bool", "description": "External trigger signal, reads value upon each rising edge"}, {"name": "value", "type": "LReal", "description": "Newly read data value"}, {"name": "windowSize", "type": "Int", "description": "The window size for the moving average, which must be between 1 and 100"}, {"name": "reset", "type": "Bool", "description": "Reset signal, resets the moving average calculation when TRUE"}], "output": [{"name": "average", "type": "LReal", "description": "The moving average"}, {"name": "windowSizeReached", "type": "Bool", "description": "FALSE: Maximum window width not yet reached TRUE: Maximum window width has been reached"}, {"name": "error", "type": "Bool", "description": "FALSE: No error occurred TRUE: An error occurred during the execution of FB"}, {"name": "status", "type": "Word", "description": "Status code"}]}
{"title": "Automated Filling Line Control", "description": "An automated filling line responsible for cleaning, filling, capping, and packaging bottles. Each step of the production line is controlled by PLC and triggered by signals from sensors and operators.\nControl requirements:\nWhen the sensor bottleSensor detects a bottle, it triggers the start of the cleaning pump and continues to work.\nAfter cleaning is completed, the operator operates the button cleaningConfirmButton to trigger the cleaning completion signal, automatically starting the filling valve for filling.\nAfter filling is completed, the operator operates the button fillingConfirmButton to trigger the filling completion signal, automatically starting the capping machine for capping.\nAfter capping is completed, the operator operates the button cappingConfirmButton to trigger the capping completion signal, starting the packing machine for packaging.\nAfter packaging is completed, the operator operates the button packingConfirmButton to trigger the packaging completion signal, lighting up the packaging completion indicator light.\nAfter the operator picks up the packaged bottle, they press the confirmation button finishedButton to reset the indicator light and prepare for the next bottle's production cycle.", "type": "FUNCTION_BLOCK", "name": "FB_BottleProcessing", "input": [{"name": "bottleSensor", "type": "Bool", "description": "The bottle reaches the sensor, triggering a signal when a bottle is detected"}, {"name": "cleaningConfirmButton", "type": "Bool", "description": "Operator confirmation button, used to confirm the completion of the cleaning process"}, {"name": "fillingConfirmButton", "type": "Bool", "description": "Operator confirmation button, used to confirm the completion of the filling process"}, {"name": "cappingConfirmButton", "type": "Bool", "description": "Operator confirmation button, used to confirm the completion of the capping process"}, {"name": "packingConfirmButton", "type": "Bool", "description": "Operator confirmation button, used to confirm the completion of the packaging process"}, {"name": "finishedButton", "type": "Bool", "description": "Operator confirmation button, used to confirm that the bottle has been picked up"}], "output": [{"name": "Pump_Motor", "type": "Bool", "description": "Control output for the operation of the cleaning pump motor"}, {"name": "Filling_Valve", "type": "Bool", "description": "Control output for the operation of the filling valve"}, {"name": "Capping_Machine", "type": "Bool", "description": "Control output for the operation of the capping machine"}, {"name": "Packing_Machine", "type": "Bool", "description": "Control output for the operation of the packing machine"}, {"name": "Completion_Light", "type": "Bool", "description": "Indicator light for packaging completion"}]}
{"title": "Material Proportioning Process Control", "description": "Design a PLC program to control a material proportioning process that requires mixing three types of materials according to specific requirements and then delivering them to the next process through valve D. The system needs to support both manual and automatic operation modes and be able to safely stop all equipment when an emergency stop signal is triggered.\nControl requirements:\nEmergency Stop Logic: The #estop(=FALSE) signal is used for emergency stopping of all equipment.\nManual Mode: #opeMode=false, manually control the start/stop of valves A, B, C, D, and the mixing motor.\nAutomatic Mode: #opeMode=true, equipment operates automatically according to the process flow.\nImplement the emergency stop logic to ensure that all equipment stops immediately when the emergency stop signal is triggered.\nIn manual mode, manually control the start/stop of valves and the mixing motor.\nFor example, pressing the valve A start button valveAStart (triggering a rising edge) causes valve A to run (valveARun=TRUE); pressing the valve A start button valveAStart again (triggering a rising edge) stops valve A (valveARun=FALSE).\nIn automatic mode, implement the following control logic based on the process flow:\nPress the autoStart button to start the automatic process, first opening valve A.\nWhen the liquid level sensor #levelSensor reaches 50cm, close valve A and open valve B.\nWhen the liquid level sensor reaches 80cm, close valve B.\nBased on #processMode:\nIf #processMode=false, start the mixing motor; after receiving the mixing complete signal, stop the mixing motor, open valve D, and the automatic process ends.\nIf #processMode=true, open valve C; when the liquid level sensor reaches 100cm, close valve C, start the mixing motor; after receiving the mixing complete signal, stop the mixing motor, open valve D, and the automatic process ends.", "type": "FUNCTION_BLOCK", "name": "MaterialMixing", "input": [{"name": "estop", "type": "Bool", "description": "Emergency Stop Signal\nFALSE: Emergency stop triggered\nTRUE: No emergency stop triggered"}, {"name": "opeMode", "type": "Bool", "description": "Operation Mode\nFALSE: Manual Operation Mode\nTRUE: Automatic Operation Mode"}, {"name": "valveAStart", "type": "Bool", "description": "Valve A Start Button"}, {"name": "valveBStart", "type": "Bool", "description": "Valve B Start Button"}, {"name": "valveCStart", "type": "Bool", "description": "Valve C Start Button"}, {"name": "valveDStart", "type": "Bool", "description": "Valve D Start Button"}, {"name": "mixMotorStart", "type": "Bool", "description": "Mixing Motor Start Button"}, {"name": "autoStart", "type": "Bool", "description": "Automatic Start Button"}, {"name": "processMode", "type": "Bool", "description": "Process Mode"}, {"name": "levelSensor", "type": "Int", "description": "Liquid Level Sensor (unit cm)"}, {"name": "mixMotorComplete", "type": "Bool", "description": "Mixing Complete Signal"}], "output": [{"name": "valveARun", "type": "Bool", "description": "Valve A Run Command"}, {"name": "valveBRun", "type": "Bool", "description": "Valve B Run Command"}, {"name": "valveCRun", "type": "Bool", "description": "Valve C Run Command"}, {"name": "valveDRun", "type": "Bool", "description": "Valve D Run Command"}, {"name": "mixMotorRun", "type": "Bool", "description": "Mixing Motor Run Command"}]}
{"title": "Light Control Program", "description": "Write a function block FB to implement a light control feature.\nA control panel has 3 indicator lights that are controlled by 3 button switches.\n\n1. Input parameters #button1~#button3 represent the 3 button switches, and output parameters #greenLight, #redLight, #yellowLight represent the indicator lights.\n2. When #button1=0, it indicates manual mode, and the indicator lights display different states based on the operation combination of #button2 and #button3:\n   - When both #button2 and #button3 are 0, all indicator lights are off (#greenLight, #redLight, #yellowLight are all 0).\n   - When #button2 is 1 and #button3 is 0, #greenLight is on, and #redLight blinks at a frequency of 0.5Hz, i.e., off for 1 second, on for 1 second.\n   - When #button2 is 0 and #button3 is 1, #redLight is on, and #yellowLight blinks at a frequency of 1Hz, i.e., off for 1 second, on for 1 second.\n   - When both #button2 and #button3 are 1, #yellowLight is on, and #greenLight blinks at a frequency of 1Hz, i.e., off for 1 second, on for 1 second.\n3. When #button1=1, it indicates automatic mode, and the indicator lights automatically cycle through the following sequence:\n   - First, #greenLight is on for 1 second.\n   - Then #greenLight is off, #redLight is on for 1 second.\n   - Then #redLight is off, #yellowLight is on for 1 second.\n   - Then it returns to the initial state where #greenLight is on for 1 second, and the cycle repeats.", "type": "FUNCTION_BLOCK", "name": "LightsControl", "input": [{"name": "button1", "type": "Bool", "description": "Button 1"}, {"name": "button2", "type": "Bool", "description": "Button 2"}, {"name": "button3", "type": "Bool", "description": "Button 3"}], "output": [{"name": "greenLight", "type": "Bool", "description": "Green light"}, {"name": "redLight", "type": "Bool", "description": "Red light"}, {"name": "yellowLight", "type": "Bool", "description": "Yellow light"}]}
{"title": "Parking Space Management System", "description": "Design a PLC program to control the parking management system for a factory's utility cart storage. The garage has 3 rows and 5 columns, totaling 15 parking spaces, which need to implement the control of carts' entry and exit, and allocate and release parking spaces according to specific principles.\nControl requirements:\nParking space information definition: Each parking space has two states, an occupied state (Boolean type) and vehicle data (integer type, vehicle number).\nCart entry rules:\nAllocate parking spaces by using the principle of using the latter row first and then the former row, and using the latter column first and then the former column.\nWhen entering, the cart provides the vehicle number information.\nThe parking space information needs to be updated to the new occupied state and vehicle number.\nCart exit rules:\nRelease parking spaces by the principle of using the former row first and then the latter row, and the former column first and then the latter column.\nThe occupied state of the exit parking space needs to be set to unoccupied and clear the vehicle number.", "type": "FUNCTION_BLOCK", "name": "TruckGarage", "input": [{"name": "enter", "type": "Bool", "description": "Entry operation request"}, {"name": "exit", "type": "Bool", "description": "Exit operation request"}, {"name": "VehicleNumber", "type": "Int", "description": "The vehicle number to be entered"}], "output": [{"name": "truck", "type": "Struct", "description": "The vehicle information to be exited", "fields": {"row": {"type": "Int", "description": "The row position of the vehicle to be exited"}, "col": {"type": "Int", "description": "The column position of the vehicle to be exited"}, "VehicleNumber": {"type": "Int", "description": "The vehicle number to be exited"}}}], "in/out": [{"name": "garage", "type": "Array[1..3, 1..5] of Struct", "description": "Garage information", "fields": {"Occupied": {"type": "Bool", "description": "TRUE: There is a vehicle in the parking space\nFALSE: There is no vehicle in the parking space"}, "VehicleNumber": {"type": "Int", "description": "The vehicle number in the parking space"}}}]}
{"title": "Merge Bytes", "description": "Write a PLC program that receives a variable-length byte array byteArray and a variable-length double word array dwordArray. The goal of the program is to merge each byte from byteArray into dwordArray in sequence. Following the principle of merging every 4 bytes into 1 double word, if the length of byteArray is not a multiple of 4, the remainder part will not be merged. If the length of dwordArray is insufficient to store all double words, the excess part will not be merged. The program also outputs the actual number of merged double words mergeDwordNum\nFor example, byteArray=[16#11, 16#22, 16#33, 16#44], then dwordArray =[16#44332211]", "type": "FUNCTION", "name": "MergeByteArray", "input": [{"name": "byteArray", "type": "Array[*] of Byte", "description": "Byte array to be merged"}], "output": [{"name": "mergeDwordNum", "type": "DInt", "description": "Actual number of merged double words"}], "in/out": [{"name": "dwordArray", "type": "Array[*] of DWord", "description": "Merged double word array"}]}
{"title": "Extracting a substring from a character array", "description": "Write a function FC that can extract a substring from a character array based on a given start string and end string.\n\n1. The function should iterate over searchIn to find the first occurrence of textBefore, then find the subsequent occurrence of textAfter.\n2. If both textBefore and textAfter are found, the function should extract the string between these two boundaries (excluding the boundary strings themselves) and return this substring.\n3. If textBefore or textAfter does not exist in searchIn, the function should return a specific status code.\n\nThe status parameter indicates the execution status of the program:\n- 16#0000: Execution successful\n- 16#8200: The input parameter searchIn is not a character array or byte array\n\nThe return value indicates the result of the search:\n- 16#0000: Search successful, both the head and tail characters have been found\n- 16#9001: Search unsuccessful, only the start boundary was found, the end boundary was not found\n- 16#9002: Search unsuccessful, the start boundary was not found.\n\nExample:\nAssuming searchIn is \"This is a [sample] string with [multiple] boundaries.\", textBefore is \"[\", and textAfter is \"]\". The function should return \"sample\" as the extracted substring.", "type": "FUNCTION", "name": "ExtractStringFromCharArray", "input": [{"name": "textBefore", "type": "String", "description": "The start boundary of the string to be extracted"}, {"name": "textAfter", "type": "String", "description": "The end boundary of the string to be extracted"}], "output": [{"name": "extractedString", "type": "String", "description": "The extracted string"}, {"name": "status", "type": "Word", "description": "The status code, see description for details"}], "in/out": [{"name": "searchIn", "type": "Variant", "description": "The character or byte array in which to search"}], "return_value": [{"type": "Word", "description": "The status code, see description for details"}]}
{"title": "Temperature Logic Control", "description": "Write a function block FB to implement a temperature control logic. The program should include the following functions:\n1. Read the value of the temperature sensor through an analog input module.\n2. Compare the read temperature value TemperatureSensorInput with the set temperature value SetTemperature.\n3. If the actual temperature is lower than the set temperature, start the heater HeaterOutput.\n4. If the actual temperature is higher than the set temperature, turn off the heater HeaterOutput.\n5. If the heater works continuously for more than a certain period (for convenience, using 5s), it should trigger an overheating protection, automatically turn off the heater, and must wait for a certain period (for convenience, using 3s) before the overheating protection can be lifted.\n6. Provide status indication, displaying the current temperature, set temperature, heater status, and whether overheating protection is triggered.\n7. Provide temperature sensor fault judgment, if the read temperature value TemperatureSensorInput is less than 0 or greater than 100, it is considered a sensor fault, and the heater should be turned off.", "type": "FUNCTION_BLOCK", "name": "TempCtrl", "input": [{"name": "TemperatureSensorInput", "type": "Real", "description": "The input value of the temperature sensor, i.e., the actual temperature"}, {"name": "SetTemperature", "type": "Real", "description": "The set temperature value"}], "output": [{"name": "CurrentTemperature", "type": "Real", "description": "Display of the current temperature"}, {"name": "SetTempDisplay", "type": "Real", "description": "Display of the set temperature"}, {"name": "HeaterStatus", "type": "Bool", "description": "Display of the heater status"}, {"name": "OverheatProtection", "type": "Bool", "description": "Display of the overheating protection status"}], "in/out": [{"name": "HeaterOutput", "type": "Bool", "description": "The control output of the heater"}]}
{"title": "Flexible Processing Control", "description": "An automated production line consists of 5 workstations: numbered 1# to 5# from left to right. The 1# station is used for raw material loading, stations 2# to 4# are used for product processing, and the 5# station is used for finished product output and storage.\nThere is a motor in the production line, responsible for moving the product from one workstation to the next. Each workstation has a sensor (used to detect if the product has arrived).\nEach product has a different sequence and number of processing steps, specified by the process sequence 'processSequence'. The processSequence is an array type, storing the sequence numbers of the workstations, and the system automatically sends the raw materials to the corresponding workstation for processing based on the station number.\nControl requirements:\nAt the start of production, when the sensor at the 1# station (sensor1) detects the raw material, the start button at the 1# station (station1Start) is pressed. The system queries the first element of the process sequence 'processSequence', starts the conveyor to move the raw material to the corresponding workstation, and stops after delivery. Upon receiving the processing completion signal from the corresponding workstation (station2Complete to station4Complete), it continues to query the next element of the process sequence 'processSequence', determines the direction of the conveyor, and starts the conveyor (conveyorLeft, conveyorRight). This continues until the product is delivered to the 5# workstation.", "type": "FUNCTION_BLOCK", "name": "FlexibleProduction", "input": [{"name": "sensor1", "type": "Bool", "description": "Sensor at 1# station"}, {"name": "sensor2", "type": "Bool", "description": "Sensor at 2# station"}, {"name": "sensor3", "type": "Bool", "description": "Sensor at 3# station"}, {"name": "sensor4", "type": "Bool", "description": "Sensor at 4# station"}, {"name": "sensor5", "type": "Bool", "description": "Sensor at 5# station"}, {"name": "station1Start", "type": "Bool", "description": "Start button at 1# station"}, {"name": "station2Complete", "type": "Bool", "description": "Processing completion signal at 2# station"}, {"name": "station3Complete", "type": "Bool", "description": "Processing completion signal at 3# station"}, {"name": "station4Complete", "type": "Bool", "description": "Processing completion signal at 4# station"}], "output": [{"name": "conveyorLeft", "type": "Bool", "description": "Conveyor turns left"}, {"name": "conveyorRight", "type": "Bool", "description": "Conveyor turns right"}], "in/out": [{"name": "processSequence", "type": "Array[1..8] of USInt", "description": "Processing sequence"}]}
{"title": "Recipe Management System", "description": "A factory's production line needs to produce a variety of products based on different recipes. The control center of the production line requires a recipe management system that allows operators to add, delete, modify, and query recipe data.\nControl requirements:\nRecipe data should include recipe number, raw material type, raw material ratio, and production temperature.\nThe system should allow input of new recipe data and store it in the recipe database.\nThe system should allow deletion or modification of existing recipe data by recipe number.\nThe system should allow querying recipe details by recipe number and output the recipe.\nNotes:\n1. Recipes are constructed using the Struct data type, which includes recipe number (recipeID), raw material type (ingredientType), raw material ratio (ingredientRatio), and production temperature (productionTemperature). The recipe database can store up to 10 recipes, constructed with Array[1..10] of Struct, where recipe numbers must not be duplicated, and a recipe number of 0 indicates an empty slot.\n2. When a query recipe request signal (queryRecipe) is triggered, the system first compares the recipe number (recipeID) from the input recipe (recipeIn with all recipes in the recipe database recipe. If the number does not exist, an error status (error=true) and error code (status=16#8001) are output. If the number exists, the recipe is output to the recipe query result (recipeQueryResult).\n3. When an add recipe request signal (addRecipe) is triggered, the system first compares the recipe number (recipeID) from the input recipe (recipeIn) with all recipes in the recipe database (recipe). If a duplicate number exists, an error status (error=true) and error code (status=16#8002) are output. If there is no empty slot in the recipe database (recipe), an error status (error=true) and error code (status=16#8003) are output. If there are no errors, the input recipe (recipeIn) is stored in the recipe database (recipe), prioritizing the empty slot with the smallest array index.\n4. When a delete recipe request signal (deleteRecipe) is triggered, the system first compares the recipe number (recipeID) from the input recipe (recipeIn) with all recipes in the recipe database (recipe). If the number does not exist, an error status (error=true) and error code (status=16#8004) are output. If the number exists, the recipe is deleted, i.e., the recipe number (recipeID) in the recipe database (recipe) is set to 0.\n5. When a modify recipe request signal (modifyRecipe) is triggered, the system first compares the recipe number (recipeID) from the input recipe (recipeIn) with all recipes in the recipe database (recipe). If the number does not exist, an error status (error=true) and error code (status=16#8005) are output. If the number exists, the recipe is replaced with the input recipe (recipeIn).", "type": "FUNCTION_BLOCK", "name": "FB_RecipeManager", "input": [{"name": "addRecipe", "type": "Bool", "description": "Add Recipe Request Signal"}, {"name": "deleteRecipe", "type": "Bool", "description": "Delete Recipe Request Signal"}, {"name": "modifyRecipe", "type": "Bool", "description": "Modify Recipe Request Signal"}, {"name": "queryRecipe", "type": "Bool", "description": "Query Recipe Request Signal"}, {"name": "recipeIn", "type": "Struct", "description": "Input Recipe", "fields": [{"name": "recipeID", "type": "Int", "description": "Recipe Number"}, {"name": "ingredientType", "type": "Int", "description": "Raw Material Type"}, {"name": "ingredientRatio", "type": "Real", "description": "Raw Material Ratio"}, {"name": "productionTemperature", "type": "Real", "description": "Production Temperature"}]}], "output": [{"name": "recipeAdded", "type": "Bool", "description": "Recipe Added Success Indicator"}, {"name": "recipeDeleted", "type": "Bool", "description": "Recipe Deleted Success Indicator"}, {"name": "recipeModified", "type": "Bool", "description": "Recipe Modified Success Indicator"}, {"name": "recipeQueryResult", "type": "Struct", "description": "Recipe Query Result Output", "fields": [{"name": "recipeID", "type": "Int", "description": "Recipe Number"}, {"name": "ingredientType", "type": "Int", "description": "Raw Material Type"}, {"name": "ingredientRatio", "type": "Real", "description": "Raw Material Ratio"}, {"name": "productionTemperature", "type": "Real", "description": "Production Temperature"}]}, {"name": "error", "type": "Bool", "description": "Error Status Indicator\nFALSE: No Error Occurred\nTRUE: Execution Error"}, {"name": "status", "type": "Word", "description": "Status Code"}], "in/out": [{"name": "recipe", "type": "Array[1..10] of Struct", "description": "Recipe Database", "fields": [{"name": "recipeID", "type": "Int", "description": "Recipe Number"}, {"name": "ingredientType", "type": "Int", "description": "Raw Material Type"}, {"name": "ingredientRatio", "type": "Real", "description": "Raw Material Ratio"}, {"name": "productionTemperature", "type": "Real", "description": "Production Temperature"}]}]}
{"title": "Floating-point Number Interval Linearization Conversion", "description": "In some automated control systems, it may be necessary to convert a measured physical quantity (such as temperature, pressure, etc.) into another linearized or standardized value for the processing or display of control algorithms. For example, a physical quantity measured by a sensor may vary within a specific non-linear range, but the control system requires a linearized value for calculations.\nControl requirements:\nSystem needs to receive a floating-point number as input, representing the original measured value.\nBased on the size of the input value, it is converted to different linear ranges, and the linearized value after conversion is output.\nWhen the input value is between 1200 and 3600, it is converted to the range of 150 to 240.\nWhen the input value is between 3600 and 4800, it is converted to the range of 240 to 560.\nWhen the input value is between 4800 and 7000, it is converted to the range of 560 to 720.\nIf the input value is less than 1200 or greater than 7000, the converted value should be the linearized value corresponding to 1200 or 7000, and an error status error=1, status=16#8001 is output.", "type": "FUNCTION_BLOCK", "name": "FB_LinearizeValue", "input": [{"name": "InputValue", "type": "Real", "description": "Floating-point input, original measured value"}], "output": [{"name": "LinearizedValue", "type": "Real", "description": "Linearized value after conversion"}, {"name": "Error", "type": "Bool", "description": "Error status indicator\nFALSE: No error occurred\nTRUE: An error occurred during execution"}, {"name": "Status", "type": "Word", "description": "Status code"}]}
{"title": "Separate Bytes into Bits", "description": "Write a PLC program that receives a variable-length byte array byteArray and a variable-length boolean array bitArray. The goal of the program is to sequentially separate each byte in byteArray into bitArray, ensuring that all 8 bits of each byte are separated and stored. If the length of bitArray is insufficient to store all bits, only separate up to the maximum number of bits that bitArray can accommodate. The program also outputs the actual number of bytes separated splitByteNum\nFor example, if byteArray=[16#2D], then bitArray=[1,0,1,1,0,1,0,0]", "type": "FUNCTION", "name": "SplitByteArray", "input": [{"name": "byteArray", "type": "Array[*] of Byte", "description": "Byte array to be separated"}], "output": [{"name": "splitByteNum", "type": "DInt", "description": "Actual number of bytes separated"}], "in/out": [{"name": "bitArray", "type": "Array[*] of Bool", "description": "Separated boolean array"}]}
{"title": "Shift Register", "description": "Write a PLC program that receives an array of variable data types 'buffer' and performs shift operations on the array.\nIt can perform a left shift (shiftLeft=TRUE), where elements with higher index numbers move to lower index numbers.\nIt can also perform a right shift (shiftRight=TRUE), where elements with lower index numbers move to higher index numbers.\nThe length of the shift is determined by the shift range 'shiftRange'.\nEmpty positions after moving are covered with the initial value 'initialItem'.\nWhen the clear operation (clear=TRUE) is performed, all elements of the array are initialized to the initial value 'initialItem'.", "type": "FUNCTION_BLOCK", "name": "ShiftSequence", "input": [{"name": "shiftLeft", "type": "Bool", "description": "Shift left"}, {"name": "shiftRight", "type": "Bool", "description": "Shift right"}, {"name": "shiftRange", "type": "UInt", "description": "Shift range"}, {"name": "clear", "type": "Bool", "description": "Clear operation"}, {"name": "initialItem", "type": "Variant", "description": "Initial value"}], "in/out": [{"name": "buffer", "type": "Variant", "description": "Array queue to be shifted"}]}
{"title": "Convert String to IP Address and Port Number", "description": "In Siemens PLC programming, it is often necessary to receive strings containing IP addresses and port numbers from user input or external devices and parse them into integer formats for network communication.\nWrite a function FC that converts a string containing an IP address and possibly a port number into integer forms of IP address and port number. The string format should be \"xxx.xxx.xxx.xxx[:port]\", where xxx represents numbers between 0-255, and port represents a port number between 0-65535 (optional). If the string contains a port number, return it; if not, return the default port number (e.g., 0). Return the converted IP address and port number to the corresponding positions of the system data type TADDR_Param structure.\nThe function should check if the input string conforms to the \"IP_ADDRESS:PORT\" format requirement, where the IP address consists of four integers between 0 and 255 separated by dots, and the port number is an integer between 0 and 65535.\nIf the string format is correct, the function should parse it into an IP address represented by a four-byte integer array and a port number represented by an integer, and return these values.\nIf the string format is incorrect, the function should output an error status and an error code.\nStatus codes:\n16#0000: Execution of FC without error\n16#811x: IP address contains too many characters, where x indicates the lowest byte sequence number with an error, e.g., if the 2nd byte of the IP address is wrong, then x=2\n16#812x: IP address string is an empty string, x means the same as above\n16#813x: Exceeds the maximum IP address value (255), x means the same as above\n16#8150: Too many port number characters\n16#8151: Port number string is empty\n16#8152: Exceeds the maximum port number value (65535)", "type": "FUNCTION", "name": "StringToTaddr", "input": [{"name": "ipAddressString", "type": "String", "description": "The input string"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error occurred; TRUE: An error occurred during the execution of FC"}, {"name": "status", "type": "Word", "description": "Status code"}], "return_value": [{"type": "TADDR_Param", "description": "The converted IP address and port number"}]}
{"title": "Automated Warehouse Shelf Position Management System", "description": "An automated warehouse requires a system to manage the storage positions of workpieces to ensure they can be stored and retrieved efficiently. There is a shelf in the warehouse with 9 levels, numbered from 1 to 9, with each level capable of storing only one workpiece.\nControl requirements:\n1. The system needs to maintain the storage status of the shelf, recording whether each level is occupied by a workpiece.\n2. When a workpiece is stored:\n   - Query the storage status of the shelf.\n   - If there is a free position, store it in the position with the higher number first.\n   - If all positions are occupied, output an error status with error=1 and error code status16#8001.\n3. When a workpiece is retrieved:\n   - Query the storage status of the shelf.\n   - If there is a workpiece on the shelf, retrieve the workpiece from the position with the lower number first.\n   - If all positions are empty, output an error status with error=1 and error code status16#8002.\n4. The system should be able to output the current number of workpieces in stock and the number of free positions on the shelf.", "type": "FUNCTION_BLOCK", "name": "FB_WarehouseManagement", "input": [{"name": "requestIn", "type": "Bool", "description": "Storage request signal"}, {"name": "requestOut", "type": "Bool", "description": "Retrieval request signal"}], "output": [{"name": "productNum", "type": "Int", "description": "Number of workpieces in stock"}, {"name": "libFreeNum", "type": "Int", "description": "Number of free positions on the shelf"}, {"name": "error", "type": "Bool", "description": "FALSE: No error occurred\nTRUE: An error occurred during execution"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "library", "type": "Array[1..9] of Bool", "description": "Occupancy status of each level of the shelf, 1 indicates occupied, 0 indicates free"}]}
{"title": "Integration Function", "description": "Write a function block FB that implements the integration of an input signal, with start and reset functions. Integration is the cumulative summation of the input signal over time, commonly used to calculate the cumulative value of physical quantities such as flow and displacement. The start function is used to begin the integration calculation, while the reset function resets the integration value to zero.\nIf there is an error reading the system time, an error status and error code are output.\nStatus codes:\n16#0000: Execution of FB without error\n16#8600: Error reading system time", "type": "FUNCTION_BLOCK", "name": "Integration", "input": [{"name": "enable", "type": "Bool", "description": "Start signal, when this signal is TRUE, the integration calculation is enabled; if FALSE, the integration calculation will stop, and the integral output will display the last calculated value."}, {"name": "value", "type": "LReal", "description": "The input signal value to be integrated"}, {"name": "reset", "type": "Bool", "description": "Reset signal, when this signal is TRUE, the integration value is reset to zero"}], "output": [{"name": "integral", "type": "LReal", "description": "The integrated value"}, {"name": "error", "type": "Bool", "description": "FALSE: No error occurred; TRUE: An error occurred during the execution of FB"}, {"name": "status", "type": "Word", "description": "Status code"}]}
{"title": "FIFO First-In-First-Out Queue", "description": "Write a function block FB to implement the functionality of a First-In-First-Out (FIFO) circular queue, where the maximum length and data type of the queue are variable. The circular queue should support the following operations:\n\n1. Enqueue operation: Add an element to the end of the queue when the queue is not full.\n2. Dequeue operation: Remove an element from the front of the queue when the queue is not empty and return the value of that element.\n3. Check if the queue is empty: Check if there are no elements in the queue.\n4. Check if the queue is full: Check if the queue has reached its maximum capacity.\n5. Get the number of elements in the queue: Return the current number of elements in the queue.\nStatus codes:\n16#0000: Execution of FB without error\n16#8001: The queue is empty\n16#8002: The queue is full", "type": "FUNCTION_BLOCK", "name": "FIFO", "input": [{"name": "enqueue", "type": "Bool", "description": "Enqueue operation, add an element to the end of the queue when the queue is not full"}, {"name": "dequeue", "type": "Bool", "description": "Dequeue operation, remove an element from the front of the queue when the queue is not empty and return the value of that element."}, {"name": "reset", "type": "Bool", "description": "Reset operation, reset head and tail pointers, elementCount output is set to zero, and isEmpty output is set to TRUE."}, {"name": "clear", "type": "Bool", "description": "Clear operation, reset head and tail pointers, the queue will be cleared and initialized with the initial value initialItem. ElementCount output is set to zero, and isEmpty output is set to TRUE."}, {"name": "initialItem", "type": "Variant", "description": "The value used to initialize the queue"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error occurred TRUE: An error occurred during the execution of FB"}, {"name": "status", "type": "Word", "description": "Status code"}, {"name": "elementCount", "type": "DInt", "description": "The number of elements in the queue"}, {"name": "isEmpty", "type": "Bool", "description": "TRUE when the queue is empty"}], "in/out": [{"name": "item", "type": "Variant", "description": "The value used to add to the queue or return from the queue"}, {"name": "buffer", "type": "Variant", "description": "Used as an array for the queue"}], "status_codes": {"16#0000": "No error in execution of FB", "16#8001": "The queue is empty", "16#8002": "The queue is full"}}
{"title": "Mechanical Arm Control", "description": "Design a PLC program to control an automated mechanical arm that performs handling tasks on the production line. The mechanical arm has six basic actions: down, up, left, right, grip, and release. The operating modes of the mechanical arm include four types: manual, single step, single cycle, and continuous.\nControl requirements:\n1. Manual mode: Allows the operator to control each action of the mechanical arm individually through the control panel, provided it is not yet in position. For example, pressing the down button (DownButton=1), if not at the down position (DownLimitSwitch=0), then move down (MoveDown=1); if at the down position (DownLimitSwitch=1), stop moving down. Releasing the down button also stops the movement down.\n2. Single step mode: The mechanical arm automatically executes one action according to the preset program, and the operator needs to confirm after each action is completed to execute the next action.\nThe initial position of the mechanical arm is at the top left.\nWhen the start button is pressed once, the mechanical arm executes the down command MoveDown, and stops after reaching the down position.\nWhen the start button is pressed again, the mechanical arm executes the grip command ActivateGrip, and stops after gripping.\nWhen the start button is pressed again, the mechanical arm executes the up command MoveUp, and stops after reaching the up position.\nWhen the start button is pressed, the mechanical arm executes the right command MoveRight, and stops after reaching the right position.\nWhen the start button is pressed, the mechanical arm executes the down command MoveDown, and stops after reaching the down position.\nWhen the start button is pressed, the mechanical arm executes the release command ActivateRelease, and stops after releasing.\nWhen the start button is pressed again, the mechanical arm executes the up command MoveUp, and stops after reaching the up position.\nWhen the start button is pressed again, the mechanical arm executes the left command MoveLeft, and stops after reaching the left position.\nThen starts the cycle again from the beginning\n3. Single cycle mode: The mechanical arm automatically completes a full handling cycle, including all preset actions, and stops at the end of the cycle waiting for the operator's instruction.\nThe initial position of the mechanical arm is at the top left, when the start button is pressed:\nThe mechanical arm first moves down, then grips after reaching the down position, moves up after gripping, moves right after reaching the up position, moves down after reaching the right position, releases after reaching the down position, moves up after releasing, moves left after reaching the up position, and stops after reaching the left position.\n4. Continuous mode: The initial position of the mechanical arm is at the top left, when the start button is pressed, the mechanical arm continuously executes the handling cycle of the single cycle mode.\n5. The emergency stop function can stop all actions of the mechanical arm at any time.", "type": "FUNCTION_BLOCK", "name": "MechanicalArm", "input": [{"name": "ManualMode", "type": "Bool", "description": "Manual mode"}, {"name": "SingleStepMode", "type": "Bool", "description": "Single step mode"}, {"name": "SingleCycleMode", "type": "Bool", "description": "Single cycle mode"}, {"name": "ContinuousMode", "type": "Bool", "description": "Continuous mode"}, {"name": "EmergencyStop", "type": "Bool", "description": "Emergency stop signal\nFALSE: Emergency stop triggered\nTRUE: No emergency stop triggered"}, {"name": "Start", "type": "Bool", "description": "Start operation"}, {"name": "DownButton", "type": "Bool", "description": "Down button"}, {"name": "UpButton", "type": "Bool", "description": "Up button"}, {"name": "LeftButton", "type": "Bool", "description": "Left button"}, {"name": "RightButton", "type": "Bool", "description": "Right button"}, {"name": "GripButton", "type": "Bool", "description": "Grip button"}, {"name": "ReleaseButton", "type": "Bool", "description": "Release button"}, {"name": "DownLimitSwitch", "type": "Bool", "description": "Down position limit switch"}, {"name": "UpLimitSwitch", "type": "Bool", "description": "Up position limit switch"}, {"name": "LeftLimitSwitch", "type": "Bool", "description": "Left position limit switch"}, {"name": "RightLimitSwitch", "type": "Bool", "description": "Right position limit switch"}, {"name": "GripLimitSwitch", "type": "Bool", "description": "Grip position limit switch"}, {"name": "ReleaseLimitSwitch", "type": "Bool", "description": "Release position limit switch"}], "output": [{"name": "MoveDown", "type": "Bool", "description": "Down command"}, {"name": "MoveUp", "type": "Bool", "description": "Up command"}, {"name": "MoveLeft", "type": "Bool", "description": "Left command"}, {"name": "MoveRight", "type": "Bool", "description": "Right command"}, {"name": "ActivateGrip", "type": "Bool", "description": "Grip command"}, {"name": "ActivateRelease", "type": "Bool", "description": "Release command"}]}
{"title": "Console Indicator Light Sequence Control", "description": "A console is equipped with 3 indicator lights, which are green, red, and yellow. It is necessary to cyclically control the status of these lights using a control button.\nControl requirements:\nUse an input parameter 'controlButton' to represent the state of the control button, which is a pulse signal, generating a transition from 0 to 1 each time it is triggered.\nUse three output parameters 'greenLight', 'redLight', and 'yellowLight' to control the corresponding green, red, and yellow indicator lights.\nThe sequence of button triggers and the corresponding light statuses are as follows:\n1st trigger: Only the green light 'greenLight' is on.\n2nd trigger: Only the red light 'redLight' is on.\n3rd trigger: Only the yellow light 'yellowLight' is on.\n4th trigger: All three lights are on.\n5th trigger: All three lights are off.\n6th trigger and onwards: Repeat the above cycle.", "type": "FUNCTION_BLOCK", "name": "FB_ColorLightControl", "input": [{"name": "controlButton", "type": "Bool", "description": "Control button switch, pulse signal"}], "output": [{"name": "greenLight", "type": "Bool", "description": "Green indicator light"}, {"name": "redLight", "type": "Bool", "description": "Red indicator light"}, {"name": "yellowLight", "type": "Bool", "description": "Yellow indicator light"}]}
{"title": "Dual-Word Edge Detection", "description": "Write a function block FB that checks for rising and falling edges in each bit of a dual-word (DWord) input value every cycle. The function block should be able to detect and report changes, rising edges, and falling edges in the input value.", "type": "FUNCTION_BLOCK", "name": "BitEdgeDetector", "source_code": "", "input": [{"name": "value", "type": "DWord", "description": "The input value to be checked for changes and edge triggering"}], "output": [{"name": "hasChanged", "type": "Bool", "description": "True indicates that the input value has changed"}, {"name": "hasRisingEdges", "type": "Bool", "description": "True indicates that rising edges have occurred in the input value"}, {"name": "risingBits", "type": "DWord", "description": "The bit stream of rising edges, where each bit indicates whether the corresponding input bit has experienced a rising edge (1 for a rising edge, 0 for no rising edge)"}, {"name": "noOfRisingBits", "type": "USInt", "description": "The number of rising edges in the input value"}, {"name": "hasFallingEdges", "type": "Bool", "description": "True indicates that falling edges have occurred in the input value"}, {"name": "fallingBits", "type": "DWord", "description": "The bit stream of falling edges, where each bit indicates whether the corresponding input bit has experienced a falling edge (1 for a falling edge, 0 for no falling edge)"}, {"name": "noOfFallingBits", "type": "USInt", "description": "The number of falling edges in the input value"}]}
{"title": "Converting date and time of type DTL to a string", "description": "Write a function FC that can convert date and time values of type DTL to a string and output them with a custom separator. The format of the converted string should be YYYY<separator>MM<separator>DD<separator>HH:mm:ss.nnnnnnnn, where <separator> is the character specified by the function parameter. Here, HH represents hours (24-hour format), mm represents minutes, ss represents seconds, and nnnnnnnn represents nanoseconds. Note that the separator should not be applied between hours, minutes, seconds, and nanoseconds.\n\nExample:\nAssuming the input DTL date and time is 2023-09-17 12:34:56.123456789, with a custom separator of -.\nThe function should return the string \"2023-09-17 12:34:56.123456789\" as the conversion result.", "type": "FUNCTION", "name": "DTLToString_ISO", "input": [{"name": "date", "type": "DTL", "description": "Date of type DTL"}, {"name": "separator", "type": "Char", "description": "The separator between year and month, and month and day in the converted date"}], "return_value": [{"type": "String", "description": "The converted date string"}]}
{"title": "Multi-element Queue", "description": "Write a function block FB to implement the function of a first-in-first-out circular queue, which can support multiple elements for enqueue or dequeue operations, and the maximum length of the queue is variable.\nThe circular queue should be able to support the following operations:\n1. Enqueue operation (push): When there is enough space in the queue 'queue', multiple elements are added to the end of the queue. The elements to be added are specified by the starting position 'itemIndex' and the length 'itemLen' in the element array 'item'.\n2. Dequeue operation (pop): When there are enough elements in the queue 'queue', multiple elements are removed from the front of the queue, the number of elements to be removed is specified by 'itemLen', moved to 'item', starting from the position 'itemIndex'.\n3. Reset operation (reset): Clear all elements in the queue.\n4. Get queue information: Return the current number of elements and available space in the queue.", "type": "FUNCTION_BLOCK", "name": "RingQueueMultiItem", "input": [{"name": "push", "type": "Bool", "description": "Enqueue operation"}, {"name": "pop", "type": "Bool", "description": "Dequeue operation"}, {"name": "reset", "type": "Bool", "description": "Reset operation"}, {"name": "itemIndex", "type": "UDInt", "description": "Starting position of the elements to be enqueued or dequeued"}, {"name": "itemLen", "type": "UDInt", "description": "Length of the elements to be enqueued or dequeued"}], "output": [{"name": "queueUsed", "type": "DInt", "description": "Number of elements in the queue"}, {"name": "queueUnused", "type": "DInt", "description": "Remaining space in the queue"}], "in/out": [{"name": "item", "type": "Array[*] of Byte", "description": "Values to be added to the queue or returned from the queue"}, {"name": "queue", "type": "Array[*] of Byte", "description": "Array used as the queue"}]}
{"title": "Case Conversion of Characters", "description": "Write a PLC program that receives a string 'In' and performs conversion based on the 'mode' of conversion, then returns the converted string.\nIf mode=FALSE, it is the lowercase to uppercase mode, i.e., converts all lowercase characters in the string to uppercase.\nIf mode=TRUE, it is the opposite, i.e., converts all uppercase characters in the string to lowercase.\nFor example, In='ABCD1234efgh', mode=TRUE, then the returned string is 'abcd1234efgh'", "type": "FUNCTION", "name": "StringCovert", "input": [{"name": "In", "type": "String", "description": "The string to be converted"}, {"name": "mode", "type": "Bool", "description": "Conversion mode"}], "return_value": [{"type": "String", "description": "The converted string"}]}
{"title": "Recipe Management System Based on Doubly Linked List", "description": "A factory's production line needs to produce various products based on different recipes. The control center of the production line requires a recipe management system that allows operators to add recipe data.\nControl requirements:\nRecipe data should include raw material type, raw material ratio, and production temperature.\nThe system should allow the input of new recipe data and store it in the recipe database.\nNotes:\n1. Recipes are constructed using the Struct data type, which includes ingredientType, ingredientRatio, and productionTemperature. A doubly linked list is used to manage the recipe database, with each recipe having two pointers, Prev and Next. Prev points to the previous recipe position, and Next points to the next recipe position. Prev being -1 indicates the first record in the list, Next being -1 indicates the last record in the list, and if both pointers are -1, it indicates an empty record.\n2. When adding a recipe:\nIf the recipe database is an empty list, the new recipe is added to the first position of the array, and Next is set to point to the second position of the array; If the recipe database is not an empty list, the new recipe is added to the end of the list.", "type": "FUNCTION", "name": "AddRecipeLinkedList", "input": [{"name": "exe", "type": "Bool", "description": "Initiate adding recipe"}, {"name": "recipeAdded", "type": "Struct", "description": "Recipe to be added", "fields": [{"name": "ingredientType", "type": "Int", "description": "Type of raw material"}, {"name": "ingredientRatio", "type": "Real", "description": "Ratio of raw material"}, {"name": "productionTemperature", "type": "Real", "description": "Production temperature"}]}], "in/out": [{"name": "recipeList", "type": "Array[0..19] of Struct", "description": "Recipe database", "fields": [{"name": "Prev", "type": "DInt", "description": "Previous pointer, pointing to the array index of the previous recipe"}, {"name": "Next", "type": "DInt", "description": "Next pointer, pointing to the array index of the next recipe"}, {"name": "recipe", "type": "Struct", "description": "Recipe", "fields": [{"name": "ingredientType", "type": "Int", "description": "Type of raw material"}, {"name": "ingredientRatio", "type": "Real", "description": "Ratio of raw material"}, {"name": "productionTemperature", "type": "Real", "description": "Production temperature"}]}]}]}
{"title": "Batch High-Low Word Swapping", "description": "Write a PLC program that receives two variable-length arrays of double words, dataIn and dataOut. The goal of the program is to swap the high and low words of each double word in dataIn and store them sequentially in dataOut. If the lengths of the two arrays are not the same, the processing is done according to the length of the shorter array. The program also outputs the number of double words actually swapped, swapNum\nFor example, if dataIn=[16#11223344], then dataOut=[16#33441122]", "type": "FUNCTION", "name": "SwapDWord", "input": [{"name": "dataIn", "type": "Array[*] of DWord", "description": "Array of double words to be swapped"}], "output": [{"name": "swapNum", "type": "DInt", "description": "Number of double words actually swapped"}], "in/out": [{"name": "dataOut", "type": "Array[*] of DWord", "description": "Array of double words after swapping"}]}
{"title": "PLC Database Data Storage and Management System", "description": "In some automation applications, PLCs need to collect and store a large amount of data, such as sensor readings, production counts, or other process variables. This data is typically stored in the PLC's internal database or an external database system.\nControl requirements:\nThe system needs to receive a set of data dataInput, constructed as a byte array, where the first byte dataInput[0] of this set indicates the byte length of the data to be stored.\nThe data storage operation is triggered by the input storeTrigger.\nData needs to be stored in the database in sequence, with each set of data possibly having different lengths.\nWhen the remaining space in the database is not enough to store a new set of data, the system should trigger an error error.\nThe system should provide a reset function, which clears the database and resets the error through the input resetTrigger.\nThe system should be able to output the current usage and remaining space of the database.\nInstructions:\n1. When the storage signal storeTrigger is triggered, first check whether the data input length information (i.e., the first byte dataInput[0] of the array) is illegal. If it is less than or equal to 0 or greater than 5, output an error status error=true and error code status=16#8001. If the remaining space in the database is not enough to store new data, output an error status error=true and error code status=16#8002. If there are no such errors, extract the data starting from the second byte of the input array according to the length information and store it in the database. When storing, do not overwrite the original data in the database, and store it sequentially after the original data.\n2. When the reset signal resetTrigger is triggered, clear all data in the database and reset the error status error=0 and status=0.\n3. The used space and remaining space of the database are output respectively through usedSpace and remainingSpace.", "type": "FUNCTION_BLOCK", "name": "FB_DatabaseManager", "input": [{"name": "dataInput", "type": "Array[0..5] of Byte", "description": "Data input, byte array"}, {"name": "storeTrigger", "type": "Bool", "description": "Storage trigger signal"}, {"name": "resetTrigger", "type": "Bool", "description": "Reset trigger signal"}], "output": [{"name": "usedSpace", "type": "Int", "description": "Used space in the database"}, {"name": "remainingSpace", "type": "Int", "description": "Remaining space in the database"}, {"name": "error", "type": "Bool", "description": "Error status indication\nFALSE: No error occurred\nTRUE: An error occurred during execution"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "dataBase", "type": "Array[1..20] of Byte", "description": "Database, byte array"}]}
{"title": "Matrix Multiplication", "description": "Write a function to implement the multiplication of two matrices.\nThis function takes two variable-length two-dimensional floating-point arrays, matrix1 and matrix2, as input parameters.\nCalculation starts when execute=TRUE.", "type": "FUNCTION", "name": "MatrixMulti", "input": [{"name": "execute", "type": "Bool", "description": "Start calculation"}, {"name": "matrix1", "type": "Array[*, *] of Real", "description": "Input matrix 1"}, {"name": "matrix2", "type": "Array[*, *] of Real", "description": "Input matrix 2"}], "in/out": [{"name": "matrixResult", "type": "Array[*, *] of Real", "description": "Output calculation result matrix"}]}
{"title": "Matrix Addition", "description": "Write a function FC that implements the addition of two matrices.\n\nThe function accepts two two-dimensional arrays of floating-point numbers, matrix1 and matrix2, of variable lengths as input parameters. The function should check whether the two input matrices and the output matrix for the result have the same number of rows and columns. If they do not, it should return an error status and a specific error code.\n\nStatus codes:\n16#0000: Execution of FC without error\n16#8200: The lower bound of the first matrix array rows is different from the lower bound of the second matrix rows\n16#8201: The lower bound of the first matrix array rows is different from the lower bound of the result matrix rows\n16#8202: The lower bound of the first matrix array columns is different from the lower bound of the second matrix columns\n16#8203: The lower bound of the first matrix array columns is different from the lower bound of the result matrix columns\n16#8204: The upper bound of the first matrix array rows is different from the upper bound of the second matrix rows\n16#8205: The upper bound of the first matrix array rows is different from the upper bound of the result matrix rows\n16#8206: The upper bound of the first matrix array columns is different from the upper bound of the second matrix columns\n16#8207: The upper bound of the first matrix array columns is different from the upper bound of the result matrix columns", "type": "FUNCTION", "name": "MatrixAddition", "input": [{"name": "matrix1", "type": "Array[* *] of LReal", "description": "The first matrix"}, {"name": "matrix2", "type": "Array[* *] of LReal", "description": "The second matrix"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error occurred; TRUE: An error occurred during the execution of FC"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "matrixResult", "type": "Array[* *] of LReal", "description": "The matrix where the calculation result is stored"}]}
{"title": "Parity Check", "description": "Write a PLC program that receives a data of variable data type 'value', which can be of type word, Dword, or LWord. The goal of the program is to calculate the number of 1s in the binary value of the data 'value', referred to as countBitsTrue, and based on the set parity mode 'odd', return the parity check result. The program also outputs the number of 0s in the binary value of the data 'value', referred to as countBitsFalse.\n\nIf odd=FALSE, it is even parity: return the check result as TRUE when countBitsTrue is even, otherwise return the check result as FALSE.\nIf odd=TRUE, it is odd parity: return the check result as TRUE when countBitsTrue is odd, otherwise return the check result as FALSE.", "type": "FUNCTION", "name": "ParityVariant", "input": [{"name": "value", "type": "Variant", "description": "Data to be checked"}, {"name": "odd", "type": "Bool", "description": "Parity mode\nFALSE: Even Parity\nTRUE: Odd Parity"}], "output": [{"name": "countBitsFalse", "type": "USInt", "description": "Number of FALSEs in the data"}, {"name": "countBitsTrue", "type": "USInt", "description": "Number of TRUEs in the data"}], "return_value": [{"type": "Bool", "description": "Parity check result"}]}
{"title": "Automated Production Line Control", "description": "A simple automated production line consists of three workstations: Workstation A, Workstation B, and Workstation C. The product needs to go through these three stations in sequence to be considered fully completed. There is a motor in the production line that is responsible for moving the product from one workstation to the next. The sequence of the line is from Workstation A to Workstation B, and then to Workstation C. Each workstation has a sensor (used to detect if the product has arrived) and a button (used to trigger the signal that the station's processing is complete).\nControl requirements:\n1. Mode Switching: The mode switch (Mode) is used to switch between manual and automatic modes of the production line.\n2. Manual Mode: In manual mode, the forward rotation button (ForwardButton) controls the forward rotation of the motor, and the reverse rotation button (ReverseButton) controls the reverse rotation of the motor. Forward and reverse rotation operations need to be interlocked and cannot be performed simultaneously.\n3. Automatic Mode:\n   - When the product arrives at Workstation A, SensorA detects the product, and after the operator triggers the processing complete signal via ButtonA, the motor starts forward rotation to move the product to Workstation B.\n   - When the product arrives at Workstation B, SensorB detects the product, the motor stops, and after the operator triggers the processing complete signal via ButtonB, the motor starts forward rotation to move the product to Workstation C.\n   - When the product arrives at Workstation C, SensorC detects the product, the motor stops, and after the operator triggers the processing complete signal via ButtonC, the completion indicator light (CompletionLight) turns on, indicating that the product processing is complete. When the product is taken away, i.e., SensorC no longer detects the product, the completion indicator light (CompletionLight) turns off.", "type": "FUNCTION_BLOCK", "name": "FB_ProductionLineControl", "input": [{"name": "Mode", "type": "Bool", "description": "Used to switch the production line between manual and automatic modes, 0=manual mode, 1=automatic mode"}, {"name": "ForwardButton", "type": "Bool", "description": "Forward rotation button"}, {"name": "ReverseButton", "type": "Bool", "description": "Reverse rotation button"}, {"name": "SensorA", "type": "Bool", "description": "Sensor A"}, {"name": "SensorB", "type": "Bool", "description": "Sensor B"}, {"name": "SensorC", "type": "Bool", "description": "Sensor C"}, {"name": "ButtonA", "type": "Bool", "description": "Button A"}, {"name": "ButtonB", "type": "Bool", "description": "Button B"}, {"name": "ButtonC", "type": "Bool", "description": "Button C"}], "output": [{"name": "MotorForward", "type": "Bool", "description": "Motor forward rotation output"}, {"name": "MotorReverse", "type": "Bool", "description": "Motor reverse rotation output"}, {"name": "CompletionLight", "type": "Bool", "description": "Indicator light for product processing completion"}]}
{"title": "Custom String Extraction", "description": "Write a function FC that, based on a given starting string and ending string, can extract the required substring from a character array.\nDescription:\n1. The function should traverse charArray, starting from the search position startPos to find the first occurrence of textBefore, and then find the position of the subsequent appearance of textAfter.\n2. If textBefore and textAfter are found, the function should extract the string between these two boundaries (if includeBeforeAfter=FALSE, the boundary characters themselves are not included, otherwise, they are included) and return this substring retString. It should also return the position of the first character of the extracted string in the array, and the length of the extracted string.", "type": "FUNCTION", "name": "GetString", "input": [{"name": "textBefore", "type": "String", "description": "The starting boundary of the string to be extracted"}, {"name": "textAfter", "type": "String", "description": "The ending boundary of the string to be extracted"}, {"name": "includeBeforeAfter", "type": "Bool", "description": "FALSE: Exclude boundaries\nTRUE: Include boundaries"}, {"name": "startPos", "type": "DInt", "description": "The starting position from which to search in the array, 0 corresponds to the first element"}], "output": [{"name": "retString", "type": "String", "description": "The extracted string"}, {"name": "position", "type": "DInt", "description": "The position of the first character of the extracted string in the array, 0 corresponds to the first element"}, {"name": "length", "type": "Int", "description": "The length of the extracted string"}], "in/out": [{"name": "charArray", "type": "Variant", "description": "The character or byte array in which to perform the search"}]}
{"title": "Production Control", "description": "An automated production line consists of 5 workstations: material loading station, cleaning station, weighing station, firing station, and finished product station. The production line has a motor responsible for moving products from one workstation to the next, the sequence of the line is from the material loading station, cleaning station, weighing station, firing station, to the finished product station. Each workstation has a sensor (used to detect if the product has arrived).\nControl requirements:\n1. Mode Switching: The mode switch (Mode) is used to switch between manual and automatic modes of the production line. 0 = manual mode, 1 = automatic mode.\n2. Manual Mode: In manual mode, the forward rotation button (ForwardButton) controls the forward rotation of the motor, and the reverse rotation button (ReverseButton) controls the reverse rotation of the motor. Forward and reverse rotation operations need to be interlocked and cannot be performed simultaneously.\n3. Automatic Mode:\n   - When the material arrives at the material loading station, the SensorFeed detects the material, the motor starts forward rotation, and moves the material to the cleaning station.\n   - When the material arrives at the cleaning station, the SensorWash detects the material, the motor stops, and upon receiving the signal washComplete after cleaning is finished, the motor starts forward rotation, moving the material to the weighing station.\n   - When the material arrives at the weighing station, the SensorWeight detects the material, the motor stops, and upon receiving the signal after weighing is complete, the material is judged to be qualified based on the weight value. If the weight value is greater than or equal to 100 and less than or equal to 200, it is qualified, otherwise not.\n     If the material is unqualified, the rejection command kick is initiated.\n     If the material is qualified, the firing temperature is calculated based on the weight value. The calculation rule is that the weight value from 100 to 200 linearly corresponds to the temperature value from 500 to 550. The firing temperature firingTemp is output. At the same time, the motor starts forward rotation, moving the material to the firing station.\n   - When the product arrives at the firing station, the SensorFiring detects the material, the motor stops, and upon receiving the signal firingComplete after firing is finished, the motor starts forward rotation, moving the product to the finished product station.\n   - When the product arrives at the finished product station, the SensorOutput detects the product, the motor stops, and the completion light (CompletionLight) turns on, indicating that the product processing is complete. When the product is taken away, i.e., the SensorOutput does not detect the product, the completion light (CompletionLight) turns off.", "type": "FUNCTION_BLOCK", "name": "ProductionControl", "input": [{"name": "Mode", "type": "Bool", "description": "Used to switch the production line between manual and automatic modes, 0 = manual mode, 1 = automatic mode"}, {"name": "ForwardButton", "type": "Bool", "description": "Forward rotation button"}, {"name": "ReverseButton", "type": "Bool", "description": "Reverse rotation button"}, {"name": "SensorFeed", "type": "Bool", "description": "Sensor at the material loading station detecting the arrival of materials"}, {"name": "SensorWash", "type": "Bool", "description": "Sensor at the cleaning station detecting the arrival of materials"}, {"name": "SensorWeight", "type": "Bool", "description": "Sensor at the weighing station detecting the arrival of materials"}, {"name": "SensorFiring", "type": "Bool", "description": "Sensor at the firing station detecting the arrival of materials"}, {"name": "SensorOutput", "type": "Bool", "description": "Sensor at the finished product station detecting the arrival of products"}, {"name": "washComplete", "type": "Bool", "description": "Signal indicating completion of cleaning"}, {"name": "weightComplete", "type": "Bool", "description": "Signal indicating completion of weighing"}, {"name": "weight", "type": "Real", "description": "Weight value"}, {"name": "firingComplete", "type": "Bool", "description": "Signal indicating completion of firing"}], "output": [{"name": "MotorForward", "type": "Bool", "description": "Output for motor forward rotation"}, {"name": "MotorReverse", "type": "Bool", "description": "Output for motor reverse rotation"}, {"name": "kick", "type": "Bool", "description": "Rejection output"}, {"name": "CompletionLight", "type": "Bool", "description": "Indicator light for product processing completion"}, {"name": "firingTemp", "type": "Real", "description": "Firing temperature"}]}
{"title": "Generate Pulse Signal", "description": "Write a function block FB that generates a periodic signal that toggles between FALSE and TRUE. The duration of the TRUE state and the FALSE state in each cycle is determined by the given frequency and pulse pause ratio. The pulse pause ratio defines the ratio of the duration of the TRUE state to the duration of the FALSE state within each cycle.", "type": "FUNCTION_BLOCK", "name": "PulseGenerator", "input": [{"name": "frequency", "type": "Real", "description": "Clock frequency in Hz"}, {"name": "pulsePauseRatio", "type": "Real", "description": "Pulse pause ratio, which defines the ratio of the duration of the TRUE state to the duration of the FALSE state in each cycle. For example, if pulsePauseRatio is 2, the duration of the TRUE state will be twice that of the FALSE state."}], "output": [{"name": "pulse", "type": "Bool", "description": "Pulse output"}, {"name": "remainingTime", "type": "Time", "description": "Remaining time of the current state"}]}
{"title": "Alarm Handling", "description": "In industrial automation systems, monitoring the status of equipment is crucial. When equipment parameters exceed the normal range, the system needs to issue an alarm. To avoid frequent triggering of alarms due to minor fluctuations in parameters, an alarm management system with hysteresis function needs to be implemented.\nWhen Value is greater than hiLevel, trigger high alarm hiAlarm.\nWhen Value is less than hiLevel-hystWindow, exit high alarm hiAlarm.\nWhen Value is less than loLevel, trigger low alarm loAlarm.\nWhen Value is greater than loLevel+hystWindow, exit low alarm loAlarm.\nIf loLevel is greater than or equal to hiLevel, output error error=true, status=16#8001, and exit the program\nIf the hysteresis window value hystWindow is greater than or equal to the deviation range between hiLevel and loLevel, output error error=true, status=16#8002", "type": "FUNCTION_BLOCK", "name": "AlarmProcess", "input": [{"name": "Value", "type": "Real", "description": "Input value"}, {"name": "hiLevel", "type": "Real", "description": "High limit alarm value"}, {"name": "loLevel", "type": "Real", "description": "Low limit alarm value"}, {"name": "hystWindow", "type": "Real", "description": "Hysteresis window"}], "output": [{"name": "hiAlarm", "type": "Bool", "description": "High limit alarm"}, {"name": "loAlarm", "type": "Bool", "description": "Low limit alarm"}, {"name": "error", "type": "Bool", "description": "FALSE: No error occurred;\nTRUE: Error occurred during execution of FB"}, {"name": "status", "type": "Word", "description": "Status code"}]}
{"title": "Conveyor Line Control System", "description": "Design a PLC program to control a conveyor line system, which is used to transport three different specifications of workpieces to designated warehouses and classify and store them based on the workpiece number and specification information.\nControl requirements:\nThe conveyor line starts from the initial station and passes through station 1, station 2, and station 3 sequentially.\nEach station has a detection element to detect the presence of a workpiece.\nWorkpieces have specification information and a unique number, and the system needs to transport the workpieces to the corresponding station based on the specification and store them in the corresponding warehouse.\nWorkpiece specification classification:\nSmall workpieces: Warehouse 1\nMedium workpieces: Warehouse 2\nLarge workpieces: Warehouse 3\nWhen the start station sensor SensorStart detects a workpiece and the start button StartButton is pressed, the conveyor belt run command ConveyorRun=true is triggered. According to the workpiece specification PartSpec, the workpiece is transported to the corresponding station, and when the corresponding station sensor (Sensor1, Sensor2, Sensor3) detects the workpiece, the conveyor belt stops ConveyorRun=false. After the corresponding station unloading is completed (corresponding UnloadComplete1, UnloadComplete2, UnloadComplete3 are TRUE), the workpiece number PartNumber is stored in the corresponding database (WarehouseDatabase1, WarehouseDatabase2, WarehouseDatabase3).", "type": "FUNCTION_BLOCK", "name": "ConveyorSystem", "input": [{"name": "StartButton", "type": "Bool", "description": "Start Button"}, {"name": "SensorStart", "type": "Bool", "description": "Start Station Sensor"}, {"name": "Sensor1", "type": "Bool", "description": "Station 1 Sensor"}, {"name": "Sensor2", "type": "Bool", "description": "Station 2 Sensor"}, {"name": "Sensor3", "type": "Bool", "description": "Station 3 Sensor"}, {"name": "UnloadComplete1", "type": "Bool", "description": "Station 1 Unloading Complete Signal"}, {"name": "UnloadComplete2", "type": "Bool", "description": "Station 2 Unloading Complete Signal"}, {"name": "UnloadComplete3", "type": "Bool", "description": "Station 3 Unloading Complete Signal"}, {"name": "PartSpec", "type": "Int", "description": "Workpiece Specification"}, {"name": "PartNumber", "type": "Int", "description": "Workpiece Number"}], "output": [{"name": "ConveyorRun", "type": "Bool", "description": "Conveyor Belt Running"}, {"name": "WarehouseDatabase1", "type": "Array[1..10] of Int", "description": "Warehouse 1 Database"}, {"name": "WarehouseDatabase2", "type": "Array[1..10] of Int", "description": "Warehouse 2 Database"}, {"name": "WarehouseDatabase3", "type": "Array[1..10] of Int", "description": "Warehouse 3 Database"}]}
{"title": "Digital Digit Separation Display", "description": "In some automated systems, it may be necessary to separate the digits of an integer for display or further processing. For example, in some counter or production counting applications, it is necessary to separate the current count value into units, tens, hundreds, and thousands.\nControl Requirements:\nThe system needs to receive an integer input of up to four digits.\nBased on the input integer, calculate and output its units, tens, hundreds, and thousands values.\nIf the input integer has fewer than four digits, display 0 on the missing higher places.\nThe output results should be four separate integers, each representing the units, tens, hundreds, and thousands digits, respectively.\nNotes:\n1. The input integer InputNumber must be greater than or equal to 0 and less than 10000, otherwise output an error state with error=true and error code status=16#8001.\n2. After calculating the values of the units, tens, hundreds, and thousands digits, compare the non-0 values among these four digits and output the minimum value to Min; if InputNumber=0, then output Min=0.", "type": "FUNCTION_BLOCK", "name": "FB_SplitNumber", "input": [{"name": "InputNumber", "type": "Int", "description": "Four-digit integer input"}], "output": [{"name": "Thousands", "type": "Byte", "description": "Thousands digit output"}, {"name": "Hundreds", "type": "Byte", "description": "Hundreds digit output"}, {"name": "Tens", "type": "Byte", "description": "Tens digit output"}, {"name": "Ones", "type": "Byte", "description": "Units digit output"}, {"name": "Min", "type": "Byte", "description": "The minimum non-0 value among the four digits"}, {"name": "error", "type": "Bool", "description": "Error status indicator\nFALSE: No error occurred\nTRUE: An error occurred during execution"}, {"name": "status", "type": "Word", "description": "Status code"}]}
{"title": "UDInt Array Min/Max Value and Index Searcher", "name": "LGF_SearchMinMax_UDInt", "description": "## Short description ##\n\nThis function searches, in an array of the data type UDInt, for the maximum and minimum value \nand the respective index in the array.\n\n## Functional description ##\n\nAn array of any size is connected via the values input. The elements are then compared in turn. \nThe smallest and largest values, as well as their corresponding index are output to the array.\nNote If there are several identical min. or max. values, the index of the first min. or max. value is \noutput.", "type": "FUNCTION", "input": [], "output": [{"name": "minValue", "type": "UDInt", "description": "Minimum value found in the array"}, {"name": "minValueIndex", "type": "DInt", "description": "Index of the minimum found value in the array"}, {"name": "maxValue", "type": "UDInt", "description": "Maximum value found in the array"}, {"name": "maxValueIndex", "type": "DInt", "description": "Index of the maximum found value in the array"}], "in/out": [{"name": "values", "type": "Array[*] of UDInt", "description": "Array in whose fields the maximum and minimum are searched"}], "return_value": [], "status_codes": {}, "user_defined_types": []}
{"title": "Binary mask comparison", "name": "LGF_BinaryMaskCompare", "description": "## Short description ##\n\nThis function compares two binary Values source and compare by a given mask.\nBoth given values are masked (input AND mask), and the results is than compared and returned.\nCan be used for Word and Byte as well, by convert the passed parameter using for e.g. \nByte_to_DWord(...).", "type": "FUNCTION", "input": [{"name": "source", "type": "DWord", "description": "Source value to compare"}, {"name": "compare", "type": "DWord", "description": "Value to compare against"}, {"name": "mask", "type": "DWord", "description": "Mask the data - bits will pass if TRUE or block if FALSE"}], "output": [], "in/out": [], "return_value": [{"type": "Bool", "description": "Return TRUE if masked values are equal"}], "status_codes": {}, "user_defined_types": []}
{"title": "DTL to ISO 8601 Date String", "name": "LGF_DTLToString_ISO", "description": "## Short description ##\n\nThis function converts the date and time of data type DTL to the UNIX time of data type DInt. \nThe timestamp is calculated in UTC. This means that the time zone is not considered.\nOnly times after 01/01/1990 are permitted.", "type": "FUNCTION", "input": [{"name": "date", "type": "DTL", "description": "Date to convert as DTL tag"}, {"name": "separator", "type": "Char", "description": "Separator between the components of the output date."}], "output": [], "in/out": [], "return_value": [{"type": "String", "description": "Output string in accordance with the ISO 8601 format."}], "status_codes": {}, "user_defined_types": []}
{"title": "Value Min/Max Storer", "name": "LGF_StoreMinMax", "description": "## Short description ##\n\nThis function reads-in a value of a variable at each call and outputs the maximum and minimum \nvalue that has been read in since the first call.\nThe evaluation can be reset if necessary. The block supports the data type LReal.", "type": "FUNCTION_BLOCK", "input": [{"name": "value", "type": "LReal", "description": "Value to be compared with min/max"}, {"name": "reset", "type": "Bool", "description": "TRUE: The min/max history is reset and the evaluation starts over again."}], "output": [{"name": "minValue", "type": "LReal", "description": "Minimum value since first call or `reset`."}, {"name": "maxValue", "type": "LReal", "description": "Maximum values since first call or `reset`."}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": []}
{"title": "Natural number factorial calculation", "name": "LGF_GetFactorial", "description": "## Short description ##\n\nThe function calculates the faculty of a natural number (!) and returns the result.\nThe permissible value range of the input parameter naturalNumber is between 0 and 12, as 12 \nis the maximum factorial result fitting into a DInt type", "type": "FUNCTION", "input": [{"name": "naturalNumber", "type": "Int", "description": "Natural number (0..12)"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB 16#8000-16#FFFF: Error identification"}], "in/out": [], "return_value": [{"type": "DInt", "description": "Calculated factorial"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8101": "ERR_WRONG_VALUE_RANGE"}, "user_defined_types": []}
{"title": "System time, local time, and time zone setting", "name": "LGF_SetTime", "description": "## Short description ##\n\nThis block combines the functions of system time, local time, and set time zone.\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nNote The function uses internally the system function WR_LOC_T to write the local time of the CPU \nor WR_SYS_T to write the coordinated world time (UTC). Further it uses the system function \nSET_TIMEZONE to set the time zone of the PLC.\nThis block combines the functions of system time, local time, and set time zone.", "type": "FUNCTION_BLOCK", "input": [{"name": "execute", "type": "Bool", "description": "Rising edge starts action once"}, {"name": "systemTime", "type": "DTL", "description": "System time to be set in PLC"}, {"name": "isLocalTime", "type": "Bool", "description": "TRUE: `systemTime` is local time, FALSE: `systemTime` is UTC time"}, {"name": "timeZone", "type": "Int", "description": "Timezones HHMM [-1200.. -330.. 0.. 930.. 1200.. 1300]"}, {"name": "isDaylightSavingTime", "type": "Bool", "description": "Daylight saving time changeover, TRUE: activated, FALSE: deactivated"}], "output": [{"name": "done", "type": "Bool", "description": "TRUE: Commanded functionality has been completed successfully"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is active and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "FALSE: No error / TRUE: An error occurred during the execution of the FB"}, {"name": "lastSetTimeZone", "type": "String", "description": "Time zone that was set last by this block"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB / 16#8000-16#FFFF: Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED_NO_ERROR", "16#7000": "STATUS_NO_CALL", "16#7001": "STATUS_FIRST_CALL", "16#7002": "STATUS_SUBSEQUENT_CALL", "16#8201": "ERR_SET_TIME_LOCAL", "16#8202": "ERR_SET_TIME_UTC", "16#8203": "ERR_SET_TIMEZONE", "16#8600": "ERR_UNDEFINED_STATE", "16#8601": "ERR_WRONG_TIMEZONE"}, "user_defined_types": []}
{"title": "CRC-16 Calculator", "name": "LGF_CalcCRC16", "description": "## Short description ##\n\nThe CRC calculation is used for error detection at data transmission. The result of a calculation \nreturns a CRC value via the data sent. The receiver detects a faulty transmission due to the \nunequal CRC value. The function LGF_CalcCRC16 uses 16 bits as the generator polynomial \n(mask).\n\n## Functional description ##\n\nThe function calculates the CRC value from a data stream of any size. The data stream is \ncomposed of the individual elements of the array at the input/output parameter array. The start \nvalue initValue and the generator polynomial mask can be freely selected.\nThe input noOfELements can be used to specify the desired number of elements for calculation, it \napplies:\n <=(   + 1)\nNote Various online tools are available for calculating the CRC values. The function of the block \nwas tested with the following online tool, since it supports the input parameters mask\n(Polynomial) and initValue (Initial Value):\nhttp://www.sunshine2k.de/coding/javascript/crc/crc_js.html", "type": "FUNCTION", "input": [{"name": "initValue", "type": "Word", "description": "Start value for the calculation"}, {"name": "mask", "type": "Word", "description": "Generator polynomial for the calculation"}, {"name": "noOfElements", "type": "UInt", "description": "Number of elements to be used in CRC calculation"}], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "array", "type": "Array[*] of Byte", "description": "Data stream for which the CRC value will be calculated"}], "return_value": [{"type": "Word", "description": "Calculated CRC value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8400": "ERR_NO_OF_ELEMENTS"}, "user_defined_types": []}
{"title": "Random UDInt Number Generator", "name": "LGF_Random_UDInt", "description": "## Short description ##\n\nThis function generates a random value with each call.\nThe random number has the data type UDInt.\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nThe function generates random values in the range:\n0    4294967295.\nThe random value is formed from the nanoseconds of the current system time of the CPU. The \nbyte order of this value is inverted and then converted to UDInt.", "type": "FUNCTION", "input": [], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called blocks"}], "in/out": [], "return_value": [{"type": "UDInt", "description": "Random number in the UDInt range"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8600": "ERR_RD_SYS_T"}, "user_defined_types": []}
{"title": "IEC_Timer implementation", "name": "LGF_IecTimerOnOff", "description": "## Short description ##\n\nThe Block implements an IEC_Timer TON and TOF", "type": "FUNCTION_BLOCK", "input": [{"name": "in", "type": "Bool", "description": "FALSE Boolean Input value"}, {"name": "timeOnDelay", "type": "Time", "description": "T#0s Preset Time on Delay"}, {"name": "timeOffDelay", "type": "Time", "description": "T#0s Preset Time off Delay"}], "output": [{"name": "out", "type": "Bool", "description": "Delayed Input signal from input `in`"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": []}
{"title": "Value Tolerance Checker by Time", "name": "LGF_IsValueInToleranceByTime", "description": "## Short description ##\n\nChecks if a given value is within a specified tolerance in percent of a given set point.\nThe block has a configurable timing for set point change hiding, lower limit and as well for upper \nlimit violation hiding.\n\n## Functional description ##\n\nThe setpoint, lowerMinimum and upperMaximum variables define a value range.\nThe function checks whether the value is below, in or above the value range. The outputs \nbelowLowLimit, inLimits, or overHighLimit show where the value is located.\nBy the configuration it is possible to define whether the borders are given as absolute values or \nin percentage from set point.\nThe timing could be adjusted for set point changes and as well for hiding the violating of the \nlower or upper limit in case of peaks.\nFigure: Principle of operation", "type": "FUNCTION_BLOCK", "input": [{"name": "value", "type": "Real", "description": "Value to check if in range of setpoint"}, {"name": "setpoint", "type": "Real", "description": "Setpoint"}, {"name": "lowerMinimum", "type": "Real", "description": "Lower limit/tolerance of the setpoint in percent or absolut"}, {"name": "upperMaximum", "type": "Real", "description": "Upper limit/tolerance of the setpoint in percent or absolut"}, {"name": "reset", "type": "Bool", "description": "Reset Block"}, {"name": "configuration", "type": "LGF_typeIsValueInToleranceByTimeConfiguration", "description": "Module related configuration parameters"}], "output": [{"name": "overHighLimit", "type": "Bool", "description": "TRUE: if value is above high limit"}, {"name": "belowLowLimit", "type": "Bool", "description": "TRUE: if value is below low limit"}, {"name": "inLimits", "type": "Bool", "description": "TRUE: if value is in between the limits"}, {"name": "setpointChange", "type": "Bool", "description": "TRUE: when a setpoint change has been detected"}, {"name": "error", "type": "Bool", "description": "Error occured"}, {"name": "status", "type": "Word", "description": "Status of the function"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8401": "ERR_RANGE_LIMIT_VALUE_CALC", "16#8402": "ERR_SETPOINT_ABOVE_HIGH_LIMIT", "16#8403": "ERR_SETPOINT_BELOW_LOW_LIMIT"}, "user_defined_types": [{"name": "LGF_typeIsValueInToleranceByTimeConfiguration", "description": "Module related configuration parameters", "member": [{"name": "disableLimits", "type": "Bool", "default": "FALSE", "description": "TRUE: Disable the monitoring timer. Leaving the tolerance triggers immediately"}, {"name": "limitsAsAbsoluteValues", "type": "Bool", "default": "FALSE", "description": "TRUE: Limit given as absolut value / FALSE: Limits given as tolerance from setpoint"}, {"name": "toleranceAsAbsoluteValues", "type": "Bool", "default": "FALSE", "description": "TRUE: Toleranze given as absolut value / FALSE: Toleranze in percent from Setpoint"}, {"name": "upperLimitMonitoringTime", "type": "Time", "default": "T#10S", "description": "Monitoring time for the upper limit violation"}, {"name": "lowerLimitMonitoringTime", "type": "Time", "default": "T#10S", "description": "Monitoring time for the lower limit violation"}, {"name": "setpointChangeMonitoringTime", "type": "Time", "default": "T#20S", "description": "Monitoring time for setpoint changes"}]}]}
{"title": "CRC-8 Calculator", "name": "LGF_CalcCRC8", "description": "## Short description ##\n\nThe CRC calculation is used for error detection at data transmission. The result of a calculation \nreturns a CRC value via the data sent. The receiver detects a faulty transmission due to the \nunequal CRC value. The function LGF_CalcCRC8 uses 8 bits as the generator polynomial (mask).\n\n## Functional description ##\n\nThe function calculates the CRC value from a data stream of any size. The data stream is \ncomposed of the individual elements of the array at the input/output parameter array. The start \nvalue initValue and the generator polynomial mask can be freely selected.\nThe input noOfELements can be used to specify the desired number of elements for calculation, it \napplies:\n <= (   + 1)\nNote Various online tools are available for calculating the CRC values. The function of the block \nwas tested with the following online tool, since it supports the input parameters mask\n(Polynomial) and initValue (Initial Value):\nhttp://www.sunshine2k.de/coding/javascript/crc/crc_js.html", "type": "FUNCTION", "input": [{"name": "initValue", "type": "Byte", "description": "Start value for the calculation"}, {"name": "mask", "type": "Byte", "description": "Generator polynomial for the calculation"}, {"name": "noOfElements", "type": "UInt", "description": "Number of elements to be used in CRC calculation"}], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "array", "type": "Array[*] of Byte", "description": "Data stream for which the CRC value will be calculated"}], "return_value": [{"type": "Byte", "description": "Calculated CRC value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8400": "ERR_NO_OF_ELEMENTS"}, "user_defined_types": []}
{"title": "Matrix Addition", "name": "LGF_MatrixAddition", "description": "## Short description ##\n\nThis block adds two matrices of equal size of the data type ARRAY[*,*] of LREAL.\nThe individual fields of the two incoming matrices are read, added and then output in the matrix \nmatrixResult.\nNote Note that all input and output matrices must have the same low and high limits and therefore \nthe same number of columns and rows.", "type": "FUNCTION", "input": [], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "matrix1", "type": "Array[*, *] of LReal", "description": "First summand (matrix)"}, {"name": "matrix2", "type": "Array[*, *] of LReal", "description": "Second summand (matrix)"}, {"name": "matrixResult", "type": "Array[*, *] of LReal", "description": "Sum of the matrices"}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_MATR1_LOWBOUND_ROWS_MATR2_LOWBOUND_ROWS", "16#8201": "ERR_MATR1_LOWBOUND_ROWS_RESMATR_LOWBOUND_ROWS", "16#8202": "ERR_MATR1_LOWBOUND_COLUMNS_MATR2_LOWBOUND_COLUMNS", "16#8203": "ERR_MATR1_LOWBOUND_COLUMNS_RESMATR_LOWBOUND_COLUMNS", "16#8204": "ERR_MATR1_UPPBOUND_ROWS_MATR2_UPPBOUND_ROWS", "16#8205": "ERR_MATR1_UPPBOUND_ROWS_RESMATR_UPPBOUND_ROWS", "16#8206": "ERR_MATR1_UPPBOUND_COLUMNS_MATR2_UPPBOUND_COLUMNS", "16#8207": "ERR_MATR1_UPPBOUND_COLUMNS_RESMATR_UPPBOUND_COLUMNS"}, "user_defined_types": []}
{"title": "Even Parity Checker for DWord", "name": "LGF_IsParityEven", "description": "## Short description ##\n\nThe function checks whether the parity of the input variable of type DWord is even. If the \nnumber of bits that are assigned TRUE in the sequence is even, the return value is set to TRUE.", "type": "FUNCTION", "input": [{"name": "doubleWord", "type": "DWord", "description": "Variable for which the parity is to be determined."}], "output": [], "in/out": [], "return_value": [{"type": "Bool", "description": "TRUE: When the number of bits that are assigned `TRUE` is even"}], "status_codes": {"16#0000": "STATUS_NO_ERROR"}, "user_defined_types": []}
{"title": "Matrix Multiplier", "name": "LGF_MatrixMultiplication", "description": "## Short description ##\n\nThis function multiplies two matrices of the data type ARRAY[*,*] of LREAL.\nThe block multiplies two matrices of variable size. The individual elements of the two incoming \nmatrices are read, multiplied, and then output in the matrixResult matrix.\nNote Note that the number of columns in the first matrix must be equal to the number of rows in \nthe second matrix.\nThe size of the initial matrix (m * n) results from the number of rows (m) of matrix1 and the \nnumber of columns (n) of matrix2.", "type": "FUNCTION", "input": [], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "matrix1", "type": "Array[*, *] of LReal", "description": "First factor: Matrix to multiply"}, {"name": "matrix2", "type": "Array[*, *] of LReal", "description": "Second factor: Matrix to multiply"}, {"name": "matrixResult", "type": "Array[*, *] of LReal", "description": "Product: The resulting matrix"}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_MATR1_LOWBOUND_COLUMNS_MATR2_LOWBOUND_ROWS", "16#8201": "ERR_MATR1_UPPBOUND_COLUMNS_MATR2_UPPBOUND_ROWS", "16#8202": "ERR_MATR1_LOWBOUND_ROWS_RESMATR_LOWBOUND_ROWS", "16#8203": "ERR_MATR2_LOWBOUND_COLUMNS_RESMATR_LOWBOUND_COLUMNS", "16#8204": "ERR_MATR1_UPPBOUND_ROWS_RESMATR_UPPBOUND_ROWS", "16#8205": "ERR_MATR2_UPPBOUND_COLUMNS_RESMATR_UPPBOUND_COLUMNS"}, "user_defined_types": []}
{"title": "DTL to Traditional German Date String", "name": "LGF_DTLToString_DE", "description": "## Short description ##\n\nThis function converts a date of data type DTL into a character string of data type STRING in \nthe traditional format (DD MM YYYYY).\n\n## Functional description ##\n\nThe block reads a date of data type DTL and converts the individual components of the date \n(year, month, day, hour) into a character string and outputs it in traditional format (DE). The \nseparator between the components of the date is variable.", "type": "FUNCTION", "input": [{"name": "date", "type": "DTL", "description": "Date to convert as DTL tag"}, {"name": "separator", "type": "Char", "description": "Separator between the components of the output date."}], "output": [], "in/out": [], "return_value": [{"type": "String", "description": "Output string according to the traditional format."}], "status_codes": {}, "user_defined_types": []}
{"title": "String comparison operation", "name": "LGF_CompareString", "description": "## Short description ##\n\nCompares two strings and returns a number which indicates the result of the comparison.", "type": "FUNCTION", "input": [], "output": [], "in/out": [{"name": "left", "type": "String", "description": "Left / first string to compare"}, {"name": "right", "type": "String", "description": "Right / second string to compare"}], "return_value": [{"type": "SInt", "description": "Return values: left < right := -1; left > right := 1; left == right := 0"}], "status_codes": {"0": "RETURN_STRINGS_ARE_EQUAL Strings are equal", "1": "RETURN_STRING_LEFT_GREATER_THAN_RIGHT Left string is greater than right string", "-1": "RETURN_STRING_LEFT_LESS_THAN_RIGHT Left string is less than right string"}, "user_defined_types": []}
{"title": "Array element counting", "name": "LGF_CountArrayElements", "description": "## Short description ##\n\nCount the number of array elements and returns the number of elements zero based (Array[0..x] \nof Type).", "type": "FUNCTION", "input": [{"name": "array", "type": "Variant", "description": "Input array to check for number of elements"}], "output": [], "in/out": [], "return_value": [{"type": "DInt", "description": "Number of elements in array (zero based); Returning `-1` if input variable is not type `array`; Returning `-2` if input variable is type `bool`"}], "status_codes": {"-1": "RETURN_NO_ARRAY No array is present at the input `array`", "-2": "RETURN_NO_BOOL_ARRAYS_NOT_SUPPORTED Boolean arrays not supported"}, "user_defined_types": []}
{"title": "Bit reset operation in DWORD", "name": "LGF_BitReset", "description": "## Short description ##\n\nThis block resets a bit at a predefined position in a variable of the data type DWORD.\nAlternatively, Word and Byte can be used instead of DWord by converting the passed\nparameter with, for example, BYTE_TO_DWORD and the result with DWORD_TO_BYTE.", "type": "FUNCTION", "input": [{"name": "value", "type": "DWord", "description": "Tag where the bit has to be reset"}, {"name": "bitNo", "type": "USInt", "description": "Bit number to reset in \"value\" parameter"}], "output": [], "in/out": [], "return_value": [{"type": "DWord", "description": "Tag with reset bit"}], "status_codes": {}, "user_defined_types": []}
{"title": "LIFO Buffer Management", "name": "LGF_LIFO", "description": "## Short description ##\n\nLIFO (Last-In First-Out / Stack buffer memory)\nThis function stores incoming data and outputs the latest/most recent not-yet-processed data.\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nNote I computer science the stack is also based on the LIFO principle.\nWith the push input, a new item is stored from the InOut parameter item in the next free position \nin the buffer. The output elementCount is incremented by one.\nWith the pop input, the latest / most recent item is output to the InOut parameter item, and this \nfield in the buffer is replaced by the value at the parameter initialItem. The output \nelementCount is decremented by one.\nThe peek input allows the last entry in the buffer to be read out. The buffer is not changed.\nWith the reset input, the buffer is initialized and the index and counter are reset. The \nelementCount output is set to zero and the isEmpty output is set to TRUE.\nWith the clear input, the buffer is emptied and initialized with the initial value initialItem. Index \nand counter are reset. The elementCount output is set to zero and the isEmpty output is set to \nTRUE.", "type": "FUNCTION_BLOCK", "input": [{"name": "push", "type": "Bool", "description": "Push item to the buffer"}, {"name": "pop", "type": "Bool", "description": "Pop item from the buffer"}, {"name": "peek", "type": "Bool", "description": "Peek item from the buffer (buffer not changed/modified)"}, {"name": "reset", "type": "Bool", "description": "Initializing the buffer (reset the index and the counter)"}, {"name": "clear", "type": "Bool", "description": "Clearing the buffer and initialize with the initial value initialItem (Reset index and counter)."}, {"name": "initialItem", "type": "Variant", "description": "Value with which the ARRAY of the buffer is initialized (usually: 0 / default value)"}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "elementCount", "type": "DInt", "description": "Number of elements in the buffer"}, {"name": "isEmpty", "type": "Bool", "description": "Buffer is empty"}], "in/out": [{"name": "item", "type": "Variant", "description": "The entry that is either returned from the ring buffer or written into the buffer"}, {"name": "buffer", "type": "Variant", "description": "The ARRAY that is used as the ring buffer."}], "return_value": [], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#7000": "STATUS_NO_CURRENT_JOBS", "16#8001": "ERR_BUFFER_EMPTY", "16#8002": "ERR_BUFFER_FULL", "16#8200": "ERR_NO_ARRAY", "16#8201": "ERR_WRONG_TYPE_ITEM", "16#8202": "ERR_WRONG_TYPE_INITIAL_ITEM", "16#8610": "ERR_CLEAR_BUFFER", "16#8611": "ERR_RETURN_LAST_ENTRY", "16#8612": "ERR_POP_REPLACE_ITEM_BY_INIT_VALUE", "16#8613": "ERR_WRITE_ENTRY"}, "user_defined_types": []}
{"title": "GPS DMS to GPS-DD Converter", "name": "LGF_GpsToGpsDD", "description": "## Short description ##\n\nThis function converts a given GPS data type (format direction, degrees, minutes, and seconds) \ninto a GPS-DD data type (decimal degrees).\nGPS native to GPS decimal Degree.", "type": "FUNCTION", "input": [{"name": "gps", "type": "LGF_typeGPS", "description": "GPS-Data to be converted (direction, degrees, minutes, and seconds)"}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}], "in/out": [], "return_value": [{"type": "LGF_typeGPS_DD", "description": "Converted GPS-Data (decimal degrees)"}], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED_NO_ERROR", "16#8200": "ERR_LATITUDE_DIRECTION", "16#8201": "ERR_LATITUDE_VALUE", "16#8202": "ERR_LONGITUDE_DIRECTION", "16#8203": "ERR_LONGITUDE_VALUE"}, "user_defined_types": [{"name": "LGF_typeGPS", "description": "Datatype for GPS Coordinates with direction, degrees, minutes, seconds.", "member": [{"name": "latitude", "type": "LGF_typeGPS_DMS", "default": "", "description": "Datatype for GPS Coordinates in DMS and the Direction."}, {"name": "longitude", "type": "LGF_typeGPS_DMS", "default": "", "description": "Datatype for GPS Coordinates in DMS and the Direction."}]}, {"name": "LGF_typeGPS_DD", "description": "Datatype for GPS Coordinates in decimal degrees.", "member": [{"name": "latitude", "type": "Real", "default": "0.0", "description": "Degrees latitude with decimal places"}, {"name": "longitude", "type": "Real", "default": "0.0", "description": "Degrees longitude in degrees with decimal places"}]}]}
{"title": "GPS-based Sunrise and Sunset Time Determination", "name": "LGF_AstroClock", "description": "## Short description ##\n\nThis function calculates the times of sunrise and sunset based on the local time for a specific  place on Earth. The exact position is transferred in the form of geographical GPS coordinates (longitude and latitude).\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nIf processes must run automatically depending on the change between day and night, the \nfunction of an astronomical clock is required. Examples of this would be switching outdoor \nlighting on and off or opening and closing roller shutters.\nIf these processes are to be executed with a time delay i.e. a defined time before or after \nsunrise or sunset an offset is required in each case.\nNote For precise execution of the function, it must be ensured that system time and local time of \nthe SIMATIC controller are set correctly.\nBased on the system time/local time of the SIMATIC controller and the set coordinates, the \nblock calculates the times for sunrise and sunset. The offset times are added to the sunrise and \nsunset and output on the sunrise and sunset outputs. If the systems local time of the SIMATIC \ncontroller is between these values, the output isDaytime is set to the value TRUE.\nNote Since the times for sunrise and sunset change daily, it is possible that the isDaytime output \nremains permanently on TRUE or FALSE over a longer period of time:\n with correspondingly large offset values\n for a place on the other side of the Arctic Circle\nThe input of the GPS coordinate values is checked for valid values. If there are invalid values, \nan appropriate error code is output to status.\nIf there is an invalid coordinate value for a formal parameter, the outputs sunrise and sunset\nare set to the value DTL#1970-01-01-00:00:00.", "type": "FUNCTION_BLOCK", "input": [{"name": "enable", "type": "Bool", "description": "TRUE: Activates the functionality of the FB"}, {"name": "positionGps", "type": "LGF_typeGPS_DD", "description": "GPS position to calculate the time of sunrise and sunset"}, {"name": "offsetSunrise", "type": "Time", "description": "Offset to sunrise (added to sunrise time, considered at `isDaytime`, negative time allowed)"}, {"name": "positionGps", "type": "Time", "description": "Offset to sunset (added to sunset time, considered at `isDaytime`, negative time allowed)"}], "output": [{"name": "valid", "type": "Bool", "description": "TRUE: Valid set of output values available at the FB"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is active and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "FALSE: No error / TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB / 16#8000-16#FFFF: Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "actualLocalTime", "type": "DTL", "description": "Current time (local time)"}, {"name": "sunriseTime", "type": "DTL", "description": "Sunrise time (localtime)"}, {"name": "sunsetTime", "type": "DTL", "description": "Sunset time (localtime)"}, {"name": "isDaytime", "type": "Bool", "description": "TRUE: If the local time of the controller is between sunrise and sunset"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED_NO_ERROR", "16#7000": "STATUS_NO_CALL", "16#7001": "STATUS_IN_OPERATION", "16#8204": "ERR_LATITUDE_VALUE", "16#8205": "ERR_LONGITUDE_VALUE", "16#8601": "ERR_RD_SYS_T", "16#8602": "ERR_RD_LOC_T"}, "user_defined_types": [{"name": "LGF_typeGPS_DD", "description": "Datatype for GPS Coordinates in decimal degrees. For a whole GPS Data set.", "member": [{"name": "latitude", "type": "Real", "default": "0.0", "description": "Degrees latitude with decimal places (Unit: degree decimal), North = positive; South = negative) valid value range [-90.00000..90.00000] "}, {"name": "longitude", "type": "Real", "default": "0.0", "description": "Degrees longitude with decimal places (Unit: degree decimal), East = positive; West = negative) valid value range [-180.00000..180.00000] "}]}]}
{"title": "UTF-8 Byte Stream Decoder", "name": "LGF_DecodeUtf8", "description": "## Short description ##\n\nDecodes a UTF-8 encoded byte stream into a WString", "type": "FUNCTION", "input": [{"name": "byteStream", "type": "Array[*] of Byte", "description": "UTF-8 encoded byte stream"}, {"name": "startPos", "type": "DInt", "description": "Position in byte stream to start decoding from"}, {"name": "count", "type": "UInt", "description": "Number of character (not bytes) to decode; 0: byte stream is decoded until end"}], "output": [], "in/out": [{"name": "decodedString", "type": "WString", "description": "Decoded string"}], "return_value": [{"type": "Word", "description": "Status of the FC, Error identification"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#7FFD": "WARN_UNSUPPORTED_CHAR", "16#7FFE": "WARN_STREAM_EXCEEDS_MAX_LEN", "16#8201": "ERR_START_POS_OUTSIDE", "16#8202": "ERR_COUNT_EXCEEDS_BOUNDS", "16#8203": "ERR_COUNT_EXCEEDS_MAX_LEN"}, "user_defined_types": []}
{"title": "Bit set operation in DWORD", "name": "LGF_BitSet", "description": "## Short description ##\n\nThis block sets a bit at a given position in a variable of the data type DWORD.\nAlternatively, Word and Byte can be used instead of DWord by converting the passed\nparameter with, for example, BYTE_TO_DWORD and the result with DWORD_TO_BYTE.", "type": "FUNCTION", "input": [{"name": "value", "type": "DWord", "description": "Tag where the bit has to be set"}, {"name": "bitNo", "type": "USInt", "description": "Bit number to set in \"value\" parameter"}], "output": [], "in/out": [], "return_value": [{"type": "DWord", "description": "Tag with the set bit"}], "status_codes": {}, "user_defined_types": []}
{"title": "String Upper Case Converter", "name": "LGF_ToUpper", "description": "## Short description ##\n\nThis function converts the lowercase letters of a string into their capital equivalents", "type": "FUNCTION", "input": [{"name": "In", "type": "String", "description": "String input"}], "output": [], "in/out": [], "return_value": [{"type": "String", "description": "Resulting string, after the conversion"}], "status_codes": {}, "user_defined_types": []}
{"title": "Ramp Function Generator", "name": "LGF_RampCI", "description": "## Short description ##\n\nThe function generates a speed curve based on an interpolation point table. Linear interpolation \noccurs between the points within the prescribed time.\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nGlobal data\nTogether with the block, you automatically receive the PLC data type LGF_typeRampTimeTable, \nwhich is composed of the parameters outVal for the value of a base point and time for the time, \nuntil the next base point is reached. The declaration takes place in a one-dimensional array of \nthe data type LGF_typeRampTimeTable beginning with the index 0. The array is created in a global \ndata block and then passed to the module LGF_RampCI.\nPrinciple of operation\nWith this block, speed curves can be executed based on parameterized interpolation points; in \neach call cycle values are output according to a schedule, and interpolation takes place \nbetween the interpolation points.\nIn each cycle the currently approached interpolation point number stepNumber, the actual \nremaining time remainTime until reaching the interpolation point, the total time totalTime, and \nthe total remaining time until reaching the end of the speed curve remainTotalTime, are output. \nIn addition, the output actTimeTable is set if the projected speed curve is currently being output.\nThe time interval of the calling cyclic interrupt OB is determined by interconnecting the calling \ncyclic interrupt OB at the input parameter callOB.\nFigure: Interconnecting the cyclic interrupt OB\nThe following operating modes can be selected via control inputs:\n Restart\n Pre-assigning an output\n Output a speed curve\n Stop processing\n Specify processing step and processing time\n Switch-on cyclic operation+F1\n Update total time and remaining time\nRestart\nThe output outValue is reset to 0.0 with a rising edge at the input reset. With \nenDefaultOutValue = TRUE, defaultOutValue is output at outputValue. The total time and total \nremaining time are updated and output.\nPre-assigning an output\nIf the speed curve should begin with a certain output value, then enDefaultOutValue must be \nTRUE. In this case the value defaultOutValue is present on the output of the timer. The internal \nprocessing of the speed curve continues during this time. If enDefaultOutValue changes to \nFALSE again, interpolation is performed to the currently active calibration point.\nOutput a speed curve\nWith a rising edge at the input start, the speed curve is output - as long as start is TRUE or until \nthe speed curve is terminated by reaching the last interpolation point. Through a subsequent \nrising edge, the speed curve is output again. In addition, the total time is updated at each \nswitch-on.\nSwitch-on cyclic operation\nIf, in addition to the input start, the input cyclicOP is also set to TRUE, the speed curve \nautomatically returns to the start point after outputting the last interpolation point value and \nstarts a new cycle.\nThere is no interpolation between the last interpolation point value and the starting point. The \nfollowing must apply for a smooth transition: last interpolation point value = start point.\nStop speed curve\nWith hold = TRUE the value of the output variable (including time processing) is frozen. When \nresetting hold = FALSE, the program continues at the point of interruption or at a parameterized \npoint (see Defining the processing step and processing time). The processing time of the \nspeed curve is extended by the holding time T1*. (see Figure below).\nSpecify processing step and processing time\nIf the input parameter continue is set to TRUE for continuation while the speed curve is stopped \n(hold = TRUE), then after the input hold has been reset the interpolation point number \ncontStepNbr (target interpolation point) will be approached within the time contStepTime\n(interpolation). The total remaining time will be recalculated.\nUpdating total time and total remaining time\nIf values of the interpolation points are changed, the total time and the total remaining time of \nthe speed curve can change. Since calculation of totalTime and remainTotalTime can \nsignificantly increase the processing time of the function block at many interpolation points, the \ncalculation is only executed once with a rising edge on the updateTime input.", "type": "FUNCTION_BLOCK", "input": [{"name": "defaultOutValue", "type": "LReal", "description": "Value for pre-assignment of the output variable"}, {"name": "contStepNbr", "type": "Int", "description": "Number of the next interpolation point for continuing"}, {"name": "contStepTime", "type": "Time", "description": "Remaining time to continue to the interpolation point"}, {"name": "enDefaultOutValue", "type": "Bool", "description": "Assign default output value"}, {"name": "start", "type": "Bool", "description": "Run down the interpolation point table"}, {"name": "hold", "type": "Bool", "description": "Freeze/hold output at actual value"}, {"name": "continue", "type": "Bool", "description": "Continuing"}, {"name": "cyclicOP", "type": "Bool", "description": "Repeat interpolation point table cyclically"}, {"name": "updateTime", "type": "Bool", "description": "Update time values"}, {"name": "reset", "type": "Bool", "description": "Complete reset of function"}, {"name": "callOB", "type": "OB_CYCLIC", "description": "Calling wake-alarm interrupt OB"}], "output": [{"name": "outputValue", "type": "LReal", "description": "Output value"}, {"name": "actTimeTable", "type": "Bool", "description": "Interpolation point table will be edited"}, {"name": "stepNumber", "type": "Int", "description": "Current interpolation point number"}, {"name": "remainTime", "type": "Time", "description": "Remaining time until reaching the next interpolation point"}, {"name": "totalTime", "type": "Time", "description": "Total time for setpoint table"}, {"name": "remainTotalTime", "type": "Time", "description": "Total remaining time"}, {"name": "error", "type": "Bool", "description": "Error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [{"name": "setpoints", "type": "Array[*] of LGF_typeRampTimeTable", "description": "Interpolation point table."}], "return_value": [], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#7000": "STATUS_NO_CALL", "16#7001": "STATUS_FIRST_CALL", "16#7002": "STATUS_FURTHER_CALLS", "16#8200": "ERR_OB_UNAVAILABLE", "16#8201": "ERR_ARRAY_LOWER_BOUND", "16#8400": "ERR_QRY_CINT"}, "user_defined_types": [{"name": "LGF_typeRampTimeTable", "description": "Data type for setup a speed curve", "member": [{"name": "outputValue", "type": "LReal", "default": "0.0", "description": "Setpoint Value to reach by the interpolation curve"}, {"name": "time", "type": "Time", "default": "T#0s", "description": "Time until the interpolation point is reached"}]}]}
{"title": "Advanced CRC-32 Calculator", "name": "LGF_CalcCRC32Advanced", "description": "## Short description ##\n\nThe CRC calculation is used for error detection at data transmission. The result of a calculation \nreturns a CRC value via the data sent. The receiver detects a faulty transmission due to the \nunequal CRC value. The function LGF_CalcCRC32Advanced uses 32 bits as the generator \npolynomial (mask) and the parameters finalXorValue, reflectInput, and reflectResult.\n\n## Functional description ##\n\nThe function calculates the CRC value from a data stream of any size. The data stream is \ncomposed of the individual elements of the array at the input/output parameter array. The start \nvalue initValue and the generator polynomial mask can be freely selected.\nVia the Boolean input parameters reflectInput and reflectResult, you may optionally mirror \nthe bits of the input data or the CRC value. An XOR operation is also performed with the CRC \nvalue at the end and the value finalXorValue.\nThe input noOfELements can be used to specify the desired number of elements for calculation, it \napplies:\n <= (   + 1)\nNote Various online tools are available for calculating the CRC values. The function of the block \nwas tested with the following online tool, since it supports the input parameters mask\n(Polynomial) and initValue (Initial Value):\nhttp://www.sunshine2k.de/coding/javascript/crc/crc_js.html", "type": "FUNCTION", "input": [{"name": "initValue", "type": "DWord", "description": "Start value for the calculation"}, {"name": "mask", "type": "DWord", "description": "Generator polynomial for the calculation"}, {"name": "finalXorValue", "type": "DWord", "description": "Value for final XOR operation"}, {"name": "reflectInput", "type": "Bool", "description": "Mirror the bits within the input byte"}, {"name": "reflectResult", "type": "Bool", "description": "Mirror the order of the bits within the result"}, {"name": "noOfElements", "type": "UInt", "description": "Number of elements to be used in CRC calculation"}], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "array", "type": "Array[*] of Byte", "description": "Data stream for which the CRC value will be calculated"}], "return_value": [{"type": "DWord", "description": "Calculated CRC value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8400": "ERR_NO_OF_ELEMENTS"}, "user_defined_types": []}
{"title": "String to DInt Converter", "name": "LGF_StringToInt", "description": "## Short description ##\n\nThis function converts a variable of data type String into a variable of data type DInt.", "type": "FUNCTION", "input": [{"name": "value", "type": "String", "description": "String value to be converted to Double-Integer. Example: +16927"}], "output": [], "in/out": [], "return_value": [{"type": "DInt", "description": "Converted Double-Integer value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR"}, "user_defined_types": []}
{"title": "DInt to String Converter", "name": "LGF_IntToString", "description": "## Short description ##\n\nThis function converts a variable of the data type DInt into a variable of the data type String.", "type": "FUNCTION", "input": [{"name": "value", "type": "DInt", "description": "Double-Integer value to convert"}], "output": [], "in/out": [], "return_value": [{"type": "String", "description": "Converted value as string. Example: '+16927'"}], "status_codes": {}, "user_defined_types": []}
{"title": "DWORD rising edge counting", "name": "LGF_CountRisInDWord", "description": "## Short description ##\n\nThe function analyzes a variable of the type DWORD and outputs how often a 0-1 sequence \n(rising edge) occurs in the variable.\nNote LEGACY FUNCTION\nPlease update and use the FB with the same name LGF_CountRisInDWord in the future!\nThis function is no longer maintained!\n\n## Functional description ##\n\nIn a variable of the data type DWORD, the block counts the rising edges (0-1 transitions) from \nleft to right. The output countRisInDWord outputs the number of rising edges.\nSo that rising edges at the variable limit are also detected, the input value is copied to the static \nvariable statDWordPrevCycle at the end of the evaluation and evaluated in the next cycle.", "type": "FUNCTION_BLOCK", "input": [{"name": "value", "type": "DWord", "description": "Input Double word in which the rising edges are counted"}], "output": [{"name": "numberOfEdges", "type": "Int", "description": "Number of rising edges in the DWord"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": []}
{"title": "LReal Array Min/Max Value and Index Searcher", "name": "LGF_SearchMinMax_LReal", "description": "## Short description ##\n\nThis function searches, in an array of the data type LReal, for the maximum and minimum value \nand the respective index in the array.\n\n## Functional description ##\n\nAn array of any size is connected via the values input. The elements are then compared in turn. \nThe smallest and largest values, as well as their corresponding index are output to the array.\nNote If there are several identical min. or max. values, the index of the first min. or max. value is \noutput.", "type": "FUNCTION", "input": [], "output": [{"name": "minValue", "type": "LReal", "description": "Minimum value found in the array"}, {"name": "minValueIndex", "type": "DInt", "description": "Index of the minimum found value in the array"}, {"name": "maxValue", "type": "LReal", "description": "Maximum value found in the array"}, {"name": "maxValueIndex", "type": "DInt", "description": "Index of the maximum found value in the array"}], "in/out": [{"name": "values", "type": "Array[*] of LReal", "description": "Array in whose fields the maximum and minimum are searched"}], "return_value": [], "status_codes": {}, "user_defined_types": []}
{"title": "Time to String Converter", "name": "LGF_TimeToString", "description": "## Short description ##\n\nThis function converts a variable of the system data type Time into a variable of the data type \nString.", "type": "FUNCTION", "input": [{"name": "timeValue", "type": "Time", "description": "Time value to convert Example: T#1D_3H_45M_6S"}], "output": [{"name": "stringDay", "type": "String", "description": "Converted day as string"}, {"name": "stringHour", "type": "String", "description": "Converted hour as string"}, {"name": "stringMinute", "type": "String", "description": "Converted minute as string"}, {"name": "stringSecond", "type": "String", "description": "Converted second as string"}, {"name": "stringMilliSecond", "type": "String", "description": "Converted millisecond as string"}], "in/out": [], "return_value": [{"type": "String", "description": "Converted time as string. Example: 1D3H45M6S0MS"}], "status_codes": {}, "user_defined_types": []}
{"title": "Histogram Calculation Function Block for Integer Data", "name": "LGF_Histogram_DInt", "description": "## Short description ##\n\nThe histogram shows the frequency distribution of a sample by class. A class describes a value \ninterval in which the individual frequencies are added together. After specifying the number of \nclasses, the class width and the respective class center are calculated. The number of classes \nis limited to 15.\nThe distribution is represented as a rectangle around the class mean with the class width and \nthe cumulated frequency as height.\nFigure: Distribution\n\n## Functional description ##\n\nThe block sorts the transferred data and calculates the general class width using the transferred \nclass count and data range. The block then counts the values that lie within a class. In order to \ndraw a histogram, the block also calculates the necessary X and Y coordinates.\nThe elements of the passed array values are sorted in ascending order by the block. The \nLGF_Shellsort_UDInt block is used for sorting.\nThe number of classes can be specified using the following rule of thumb:\n\nFormulas\nThe block uses the following formula to calculate the class width:", "type": "FUNCTION_BLOCK", "input": [{"name": "execute", "type": "Bool", "description": "Activation of the calculation with each positive edge."}, {"name": "numberOfClasses", "type": "UInt", "description": "Number of desired classes."}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error, TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB and error identification."}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "histValues", "type": "Array[0..1, 0..#CLASSES_COUNTER_UP_LIMIT] of LReal", "description": "Outputs the calculated values in a two-dimensional array."}, {"name": "axis", "type": "Array[0..3] of LReal", "description": "Specifies the axis values."}, {"name": "classWidth", "type": "LReal", "description": "Returns the calculated class width."}], "in/out": [{"name": "values", "type": "Array[*] of DInt", "description": "The array containing the data series that is to be used for the calculation."}], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED: Execution finished without errors", "16#7000": "STATUS_NO_CALL: No call of FB. The block waits for activation.", "16#7001": "STATUS_FIRST_CALL: First call of FB after enabling", "16#8600": "ERR_SHELL_SORT: Error in command `LGF_ShellSort_DInt`.", "16#9101": "ERR_WRONG_NO_CLASSES: Incorrect number of classes."}, "user_defined_types": []}
{"title": "8-Bit to Byte Merger", "name": "LGF_MergeBitsToByte", "description": "## Short description ##\n\nThis function merge 8 Bits / 8 Boolean variables into one Byte variable.", "type": "FUNCTION", "input": [{"name": "bit7", "type": "Bool", "description": "Input Bit 7 - MSB"}, {"name": "bit6", "type": "Bool", "description": "Input Bit 6"}, {"name": "bit5", "type": "Bool", "description": "Input Bit 5"}, {"name": "bit4", "type": "Bool", "description": "Input Bit 4"}, {"name": "bit3", "type": "Bool", "description": "Input Bit 3"}, {"name": "bit2", "type": "Bool", "description": "Input Bit 2"}, {"name": "bit1", "type": "Bool", "description": "Input Bit 1"}, {"name": "bit0", "type": "Bool", "description": "Input Bit 0 - LSB"}], "output": [], "in/out": [], "return_value": [{"type": "Byte", "description": "Composite Bit sequence stored as Byte variable"}], "status_codes": {}, "user_defined_types": []}
{"title": "String Position Finder in Character Array", "name": "LGF_FindStringInCharArray", "description": "## Short description ##\n\nThe function searches for a specified String within an array of characters.\nReturning the position of the String in the Array, if the string is not found the return value is -1.", "type": "FUNCTION", "input": [{"name": "searchFor", "type": "String", "description": "Text that is searched for"}, {"name": "startPos", "type": "DInt", "description": "Position within the array to start search from (index zero based)"}], "output": [{"name": "status", "type": "Word", "description": "Status of the FB"}], "in/out": [{"name": "searchIn", "type": "Variant", "description": "Array of Character or Byte to search in"}], "return_value": [{"type": "DInt", "description": "Position (index) of the first character of the text that is searched for within the input array (index zero based). Return -1 if nothing found."}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_NO_ARRAY"}, "user_defined_types": []}
{"title": "2-Word to DWord Merger", "name": "LGF_MergeWordsToDWord", "description": "## Short description ##\n\nThis function merge 2 Word variables into one DWord variable.", "type": "FUNCTION", "input": [{"name": "word1", "type": "Word", "description": "Input Word 1 - MSB"}, {"name": "word0", "type": "Word", "description": "Input Word 0 - LSB"}], "output": [], "in/out": [], "return_value": [{"type": "DWord", "description": "Composite Word sequence stored as DWord variable"}], "status_codes": {}, "user_defined_types": []}
{"title": "Value range limit check", "name": "LGF_IsValueInLimits", "description": "## Short description ##\n\nThe function checks whether a value is within a defined value range. The value range is defined \nwith a lower and an upper limit.\n\n## Functional description ##\n\nThe variables lowLimit and highLimit define a value range.\nThe function checks whether the value is below, in or above the value range. The outputs \nbelowLowLimit, Ret_Val, or overHighLimit show where the value is located.", "type": "FUNCTION", "input": [{"name": "value", "type": "LReal", "description": "Value to be checked to determine whether it is within the defined value range"}, {"name": "lowLimit", "type": "LReal", "description": "Low limit where the value is checked against to be greater"}, {"name": "highLimit", "type": "LReal", "description": "High limit where the value is checked against to to be less"}], "output": [{"name": "overHighLimit", "type": "Bool", "description": "TRUE if the value is greater than the upper limit value"}, {"name": "belowLowLimit", "type": "Bool", "description": "TRUE, if the value is less than the lower limit value"}, {"name": "error", "type": "Bool", "description": "FALSE: No error TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB 16#8000-16#FFFF: Error identification"}], "in/out": [], "return_value": [{"type": "Bool", "description": "Return: TRUE if the value is in the value range (range of the set point)"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8401": "ERR_RANGE_HIGH_BELOW_LOW_LIMIT"}, "user_defined_types": []}
{"title": "Shell Sort for UDInt Arrays", "name": "LGF_ShellSort_UDInt", "description": "## Short description ##\n\nThis block sorts an array of type UDInt with any number of elements (max. 1000) in ascending \nor descending order and returns the sorted version of the array in the same variable.\n\n## Functional description ##\n\nThe block sorts according to the shell sort procedure. Note that the execution time of the block \ndepends significantly on how many elements the array to be sorted has. The overview below \nshows several measured values of the block depending on the number of array elements.\nAverage steps needed for execution: (  log()^2)\nTable: Execution times of the block LGF_ShellSort\nNumber of array elements S7-1212C DC/DC/DC S7-1516-3 PN/DP\n100 approx. 11-16 ms approx. 1-2 ms\n1000 approx. 185-205 ms approx. 10-12 ms\nNote The block is executed synchronously and is not split over several PLC cycles. Thus the \nexecution time has a direct effect on the PLC cycle time. Note this behavior for your project \nof the controller used and adjust the monitoring time of the controller if necessary.", "type": "FUNCTION", "input": [{"name": "sortDirection", "type": "Bool", "description": "FALSE: Sort ascending; TRUE: Sort descending"}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}], "in/out": [{"name": "array", "type": "Array[*] of UDInt", "description": "Array to be sorted"}], "return_value": [], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_NO_ARRAY", "16#8201": "ERR_TOO_MANY_ELEMENTS"}, "user_defined_types": []}
{"title": "Array Min/Max Value and Index Searcher", "name": "LGF_SearchMinMax", "description": "## Short description ##\n\nThis function searches, in an array of the data type DInt, for the maximum and minimum value \nand the respective index in the array.\nThe following data types of the array elements are supported:\nInt, DInt, UInt, UDInt, USInt, SInt, and Real.\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nAn array of any size is connected via the variableArray input. After a data type query in the \nblock, the elements are copied one after the other into a variable of the appropriate type and \ncompared. The smallest and largest values, as well as their corresponding index are output to \nthe array.\nNote The following data types of the array elements are supported:\nInt, DInt, UInt, UDInt, USInt, SInt, and Real.\nNote If there are several identical min. or max. values, the index of the first min. or max. value is \noutput.", "type": "FUNCTION", "input": [{"name": "variableArray", "type": "Variant", "description": "Array in whose fields the maximum and minimum are searched"}], "output": [{"name": "minValue", "type": "Variant", "description": "Minimum value found in the array"}, {"name": "minValueIndex", "type": "DInt", "description": "Index of the minimum found value in the array"}, {"name": "maxValue", "type": "Variant", "description": "Maximum value found in the array"}, {"name": "maxValueIndex", "type": "DInt", "description": "Index of the maximum found value in the array"}, {"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called blocks"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_NO_ARRAY", "16#8201": "ERR_WRONG_TYPE", "16#8202": "ERR_NOT_EQUAL_TYPES", "16#8203": "ERR_MOVE_BLK_VARIANT"}, "user_defined_types": []}
{"title": "Unsigned Integer Histogram Calculation Function Block", "name": "LGF_Histogram_UDInt", "description": "## Short description ##\n\nThe histogram shows the frequency distribution of a sample by class. A class describes a value \ninterval in which the individual frequencies are added together. After specifying the number of \nclasses, the class width and the respective class center are calculated. The number of classes \nis limited to 15.\nThe distribution is represented as a rectangle around the class mean with the class width and \nthe cumulated frequency as height.\nFigure: Distribution\n\n## Functional description ##\n\nThe block sorts the transferred data and calculates the general class width using the transferred \nclass count and data range. The block then counts the values that lie within a class. In order to \ndraw a histogram, the block also calculates the necessary X and Y coordinates.\nThe elements of the passed array values are sorted in ascending order by the block. The \nLGF_Shellsort_UDInt block is used for sorting.\nThe number of classes can be specified using the following rule of thumb:\n\nFormulas\nThe block uses the following formula to calculate the class width:", "type": "FUNCTION_BLOCK", "input": [{"name": "execute", "type": "Bool", "description": "Activation of the calculation with each positive edge."}, {"name": "numberOfClasses", "type": "UInt", "description": "Number of desired classes."}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error, TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB and error identification."}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "histValues", "type": "Array[0..1, 0..#CLASSES_COUNTER_UP_LIMIT] of LReal", "description": "Displays the relative frequency and class centers."}, {"name": "axis", "type": "Array[0..3] of LReal", "description": "Specifies the axis values."}, {"name": "classWidth", "type": "LReal", "description": "Returns the calculated class width."}], "in/out": [{"name": "values", "type": "Array[*] of UDInt", "description": "The array containing the data series for calculation."}], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED: Execution finished without errors", "16#7000": "STATUS_NO_CALL: No call of FB. The block waits for activation.", "16#7001": "STATUS_FIRST_CALL: First call of FB after enabling", "16#8600": "ERR_SHELL_SORT: Error in command `LGF_ShellSort_UDInt`.", "16#9101": "ERR_WRONG_NO_CLASSES: Incorrect number of classes."}, "user_defined_types": []}
{"title": "Linear Regression Calculator", "name": "LGF_RegressionLine", "description": "## Short description ##\n\nThe simplest case of a regression is the regression line. This means that the assumed \nrelationship between the input and output signal is a linear straight line.\nFigure: Regression line\n\n## Functional description ##\n\nThe block calculates the regression line with the following line equation:\n() =    + \n: Gradient of straight line\n: Intersection with y-axis\n: number of array elements", "type": "FUNCTION", "input": [], "output": [{"name": "slope", "type": "LReal", "description": "Gradient of straight line"}, {"name": "intercept", "type": "LReal", "description": "The intersection with the Y axis"}, {"name": "error", "type": "Bool", "description": "FALSE: No error TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB"}], "in/out": [{"name": "values", "type": "Array[*] of LGF_typeRegressionLine", "description": "The data points are transferred with their X- and Y-values."}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED", "16#8200": "ERR_NOT_ENOUGH_VALUES Error: Not enough Values."}, "user_defined_types": [{"name": "LGF_typeRegressionLine", "description": "UDT for transferring datapoints to LGF_RegressionLine", "member": [{"name": "x", "type": "Real", "default": "0.0", "description": "X-Axis value"}, {"name": "y", "type": "Real", "default": "0.0", "description": "Y-Axis value"}]}]}
{"title": "Matrix Transposer", "name": "LGF_MatrixTranspose", "description": "## Short description ##\n\nThis function transposes a matrix of the data type ARRAY[*,*] of LREAL.\nCondition: Input matrix (m x n) = output matrix (n x m).\nA matrix is transposed by making columns out of the rows.\nNote Note that the number of rows of the input matrix must be equal to the number of columns of \nthe output matrix. Also, the number of columns of the input matrix must be equal to the \nnumber of rows of the output matrix.", "type": "FUNCTION", "input": [], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "matrix", "type": "Array[*, *] of LReal", "description": "Matrix to be transposed"}, {"name": "matrixTranspose", "type": "Array[*, *] of LReal", "description": "Transposed matrix"}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_MATR1_LOWBOUND_ROWS_RESMATR_LOWBOUND_COLUMNS", "16#8201": "ERR_MATR1_LOWBOUND_COLUMNS_RESMATR_LOWBOUND_ROWS", "16#8202": "ERR_MATR1_UPPBOUND_ROWS_RESMATR_UPPBOUND_COLUMNS", "16#8203": "ERR_MATR1_UPPBOUND_COLUMNS_RESMATR_UPPBOUND_ROWS"}, "user_defined_types": []}
{"title": "3D distance calculation between points", "name": "LGF_CalcDistance_3D", "description": "## Short description ##\n\nThe function calculates the distance between two points in 3D space.\n\n## Functional description ##\n\nThe block calculates the distance between two points in a Cartesian coordinate system. The \ndistance is calculated with the following formula:\nresult = 2((2  1)^2 + (2  1)^2 + (2  1)^2)", "type": "FUNCTION", "input": [{"name": "x1", "type": "LReal", "description": "X coordinate point 1"}, {"name": "y1", "type": "LReal", "description": "Y coordinate point 1"}, {"name": "z1", "type": "LReal", "description": "Z coordinate point 1"}, {"name": "x2", "type": "LReal", "description": "X coordinate point 2"}, {"name": "y2", "type": "LReal", "description": "Y coordinate point 2"}, {"name": "z2", "type": "LReal", "description": "Z coordinate point 2"}], "output": [], "in/out": [], "return_value": [{"type": "LReal", "description": "Calculated distance between the Points"}], "status_codes": {}, "user_defined_types": []}
{"title": "Double word edge detection", "name": "LGF_GetBitStates", "description": "## Short description ##\n\nThis function checks a DWord for falling as well as rising edges.\nIt returns the number of edges, a DWord with the edge bits, and a boolean value if edge(s) are \npresent.", "type": "FUNCTION_BLOCK", "input": [{"name": "value", "type": "DWord", "description": "Check input value for changes and edges"}], "output": [{"name": "hasChanged", "type": "Bool", "description": "Input value has changed (compared to the previous cycle)"}, {"name": "hasRisingEdges", "type": "Bool", "description": "Input value has rising edges"}, {"name": "risingBits", "type": "DWord", "description": "Bitstream with the rising edges"}, {"name": "noOfRisingBits", "type": "USInt", "description": "Number of rising edges in the input value"}, {"name": "hasFallingEdges", "type": "Bool", "description": "Input value has falling edges"}, {"name": "fallingBits", "type": "DWord", "description": "Bitstream with the falling edges"}, {"name": "noOfFallingBits", "type": "USInt", "description": "Number of falling edges in the input value"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": []}
{"title": "Matrix Subtractor", "name": "LGF_MatrixSubtraction", "description": "## Short description ##\n\nThis function subtracts a matrix of the data type ARRAY[*,*] of LREAL from another one.\nThe individual fields of the two matrices are read, subtracted and then output in the matrix \nmatrixResult.\nNote Note that all input and output matrices must have the same number of columns and rows", "type": "FUNCTION", "input": [], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "matrix1", "type": "Array[*, *] of LReal", "description": "First matrix - minuend"}, {"name": "matrix2", "type": "Array[*, *] of LReal", "description": "Second matrix - subtrahend"}, {"name": "matrixResult", "type": "Array[*, *] of LReal", "description": "Sum of the matrices"}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_MATR1_LOWBOUND_ROWS_MATR2_LOWBOUND_ROWS", "16#8201": "ERR_MATR1_LOWBOUND_ROWS_RESMATR_LOWBOUND_ROWS", "16#8202": "ERR_MATR1_LOWBOUND_COLUMNS_MATR2_LOWBOUND_COLUMNS", "16#8203": "ERR_MATR1_LOWBOUND_COLUMNS_RESMATR_LOWBOUND_COLUMNS", "16#8204": "ERR_MATR1_UPPBOUND_ROWS_MATR2_UPPBOUND_ROWS", "16#8205": "ERR_MATR1_UPPBOUND_ROWS_RESMATR_UPPBOUND_ROWS", "16#8206": "ERR_MATR1_UPPBOUND_COLUMNS_MATR2_UPPBOUND_COLUMNS", "16#8207": "ERR_MATR1_UPPBOUND_COLUMNS_RESMATR_UPPBOUND_COLUMNS"}, "user_defined_types": []}
{"title": "FIFO Buffer Management", "name": "LGF_FIFO", "description": "## Short description ##\n\nFIFO (First-In First-Out / Queue / ring buffer memory)\nThis function stores incoming data and outputs the oldest unprocessed data.\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nNote In computer science, the queue is also based on the FIFO principle.\nWith the enqueue input, a new item is stored from the InOut parameter item in the next free \nposition in the buffer. The output elementCount is incremented by one.\nWith the dequeue input, the next element to be processed is output to the InOut parameter item, \nand this field in the buffer is replaced by the value in the parameter initialItem. The output \nelementCount decremented by one.\nWith the reset input, the buffer is initialized and the index and counter are reset. The \nelementCount output is set to zero and the isEmpty output is set to TRUE.\nWith the clear input, the buffer is emptied and initialized with the initial value initialItem. Index \nand counter are reset. The elementCount output is set to zero and the isEmpty output is set to \nTRUE.", "type": "FUNCTION_BLOCK", "input": [{"name": "enqueue", "type": "Bool", "description": "Enqueue item to the buffer"}, {"name": "dequeue", "type": "Bool", "description": "Dequeue item from the buffer and return it on `item`"}, {"name": "reset", "type": "Bool", "description": "Initializing the buffer (reset the index and the counter)"}, {"name": "clear", "type": "Bool", "description": "Clearing the buffer and initialize with the initial value `initialItem` (Reset index and counter)."}, {"name": "initialItem", "type": "Variant", "description": "Value with which the ARRAY of the buffer is initialized (usually: `0` / default value)"}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "elementCount", "type": "DInt", "description": "Number of elements in the buffer"}, {"name": "isEmpty", "type": "Bool", "description": "Buffer is empty"}], "in/out": [{"name": "item", "type": "Variant", "description": "The entry that is either returned from the ring buffer or written into the buffer"}, {"name": "buffer", "type": "Variant", "description": "The ARRAY that is used as the ring buffer."}], "return_value": [], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#7000": "STATUS_NO_CURRENT_JOBS", "16#8001": "ERR_BUFFER_EMPTY", "16#8002": "ERR_BUFFER_FULL", "16#8200": "ERR_NO_ARRAY", "16#8201": "ERR_WRONG_TYPE_ITEM", "16#8202": "ERR_WRONG_TYPE_INITIAL_ITEM", "16#8601": "ERR_INDEX_IN_ARRAY_LIMITS_1", "16#8602": "ERR_INDEX_IN_ARRAY_LIMITS_2", "16#8610": "ERR_CLEAR_BUFFER", "16#8611": "ERR_RETURN_FIRST_ENTRY", "16#8612": "ERR_REPLACE_ITEM_BY_INIT_VALUE", "16#8613": "ERR_WRITE_ENTRY"}, "user_defined_types": []}
{"title": "Boxplot Calculation for Integer Data", "name": "LGF_Boxplot_DInt", "description": "## Short description ##\n\nIf you want to get an overview of existing data, you can use a Boxplot diagram. A Boxplot shows \nyou in which area the data is located and how it is distributed over this area. A Boxplot consists \nof the following parameters:\n Minimum (smallest occurring value of the sample)\n Lower or first quartile (below this value are 25% of the sample values)\n Median or second quartile (below this value are 50% of the sample values)\n Upper or third quartile (below this value are 75% of the sample values)\n Maximum (largest occurring value of the sample)\nFigure: Boxplot\n\n## Functional description ##\n\nThe block sorts the data series and then calculates the so-called five-point summary:\nTable: Five-point summary\nCharacteristic value of the five-point summary Output parameter of the block\nMinimum (smallest occurring value of the sample) min\nLower or first quartile (below this value are 25% of \nthe sample values)\nq25\nMedian or second quartile (below this value are \n50% of the sample values)\nmedian\nUpper or third quartile (below this value are 75% of \nthe sample values)\nq75\nMaximum (largest occurring value of the sample) max\nIf outlier detection is activated, the block first calculates the limits. From these limit values, the \nvalues are recognized as outliers:\n\nThe block then calculates new values for the parameters max and min, which lie within the outlier \nlimits. The outliers are counted and output as a percentage.\nTo make it easier to judge how the data is distributed, the block also calculates the skew. The \nskewness lies between the values -1 and 1 with the following meaning:\n -1: extremely left skewed distribution\n 0: symmetrical distribution\n 1: extreme right-skew distribution\nThe elements of the passed array are sorted in ascending order by the block. The \nLGF_Shellsort_DInt block is used for sorting.\nThe parameters are calculated as follows:\nTable: Boxplot formulas Parameters Formula", "type": "FUNCTION_BLOCK", "input": [{"name": "execute", "type": "Bool", "description": "Activation of the calculation with each positive edge."}, {"name": "rangeOutlier", "type": "LReal", "description": "Outlier detection parameter."}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "outlierMax", "type": "LReal", "description": "Upper outliers in %"}, {"name": "max", "type": "DInt", "description": "Maximum Value, not an outlier."}, {"name": "q75", "type": "LReal", "description": "3rd quartile or Q75 of the data series."}, {"name": "median", "type": "LReal", "description": "2nd quartile or Median of the data series."}, {"name": "q25", "type": "LReal", "description": "1st quartile or Q25 of the data series."}, {"name": "min", "type": "DInt", "description": "Minimum Value, not an outlier."}, {"name": "outlierMin", "type": "LReal", "description": "Lower outliers in %"}, {"name": "skewness", "type": "LReal", "description": "Skewness of the data series."}], "in/out": [{"name": "values", "type": "Array[*] of DInt", "description": "The array containing the data series for calculation"}], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED", "16#7000": "STATUS_NO_CALL", "16#7001": "STATUS_FIRST_CALL", "16#8200": "ERR_NEG_ARR_BOUND", "16#8600": "ERR_SHELL_SORT", "16#9101": "ERR_RANGE_NOT_OK"}, "user_defined_types": []}
{"title": "DTL to Julian Date Converter", "name": "LGF_DTLToJulianDate", "description": "## Short description ##\n\nThis function converts the date and time of data type DTL to the Julian date and as well the \nmodified Julian Date to data type LReal (Double).\nThe timestamp is calculated based on UTC. This means that the time zone is not considered.\nOnly times after 01/01/1990 are permitted.", "type": "FUNCTION", "input": [{"name": "timeDTL", "type": "DTL", "description": "Date and time as DTL to convert to Julian Date"}], "output": [{"name": "julianDate", "type": "LReal", "description": "Converted Julian date"}, {"name": "modifiedJulianDate", "type": "LReal", "description": "Converted modified Julian date"}, {"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}], "in/out": [], "return_value": [{"type": "Void", "description": "---"}], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED_NO_ERROR", "16#8000": "ERR_DTL_INPUT_VALUE_INVALID", "16#8001": "ERR_TIME_BEFORE_1990"}, "user_defined_types": []}
{"title": "File Writing to UserFiles Folder", "name": "LGF_FileWrite", "description": "## Short description ##\n\nThis function block offers writing data as binary / serialized data stream to a file which is then \nstored on the PLC's memory card in the folder UserFiles.\n\n## Functional description ##\n\nWith the function LGF_FileWrite the data budget of a variable can be written to data in a file. For \nwriting the data it is necessary to serialize it, which the function already takes from the user.\nFor serialization an external buffer in the form of a byte array must be connected which can take \nup the data quantity, if the buffer is too small an error is output.\nThe file name must always be specified in full together with the folder name and the file \nextension in the following format: UserFiles/test.dat.\nNote The file extension (here e.g. dat) can be freely selected or omitted, it is useful for external \nprocessing to indicate the format of the file to the user.\nA file extension in the file name has no influence on the content of the file as well as its \nformatting, to provide the data in an appropriate file format is up to the user.", "type": "FUNCTION_BLOCK", "input": [{"name": "execute", "type": "Bool", "description": "Rising edge starts file write once"}, {"name": "fileName", "type": "String", "description": "Name of file including path: UserFiles/test.dat"}], "output": [{"name": "done", "type": "Bool", "description": "Commanded functionality has been completed successfully"}, {"name": "busy", "type": "Bool", "description": "FB is not finished and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}, {"name": "dataLength", "type": "DInt", "description": "Data length written to file (serialized length of data)"}], "in/out": [{"name": "bufferByteArray", "type": "Array[*] of Byte", "description": "Byte array buffer for read / write from / to file"}, {"name": "data", "type": "Variant", "description": "Data set to write into file"}], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED", "16#7000": "STATUS_NO_CALL", "16#7001": "STATUS_FIRST_CALL", "16#7002": "STATUS_SUBSEQUENT_CALL", "16#8201": "ERR_BUFFER_LOWERBOUND", "16#8202": "ERR_BUFFER_ARRAY_TO_SMALL_TO_COPY", "16#8401": "ERR_FILE_PATH", "16#8600": "ERR_UNDEFINED_STATE", "16#8601": "ERR_MOVE_BLK_VARIANT", "16#8603": "ERR_DATA_SERIALIZE", "16#8604": "ERR_FILE_WRITE_INIT", "16#8605": "ERR_FILE_WRITE"}, "user_defined_types": [{"name": "LGF_typeDiagnostics", "description": "Diagnostic structure to store and transfer diagnostic information from blocks trough the interface.", "member": [{"name": "status", "type": "Word", "default": "16#0000", "description": "Status of the Block or error identification when error occurred"}, {"name": "subfunctionStatus", "type": "Word", "default": "16#0000", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "stateNumber", "type": "DInt", "default": "0", "description": "State in the state machine of the block where the error occurred"}]}]}
{"title": "Shift Register for Datatype Variant", "name": "LGF_ShiftRegister", "description": "## Short description ##\n\nThe Function represents a shift register for any kind of Datatype (using variant).\nIt is possible to shift the elements in the array at bufferRegister to the left (index \narray[n]:=array[n+1]) or right (index array[n]:=array[n-1]).\nIt could be used for material tracking trough a machine or a process, e.g. for a rotary indexing \ntable.\nNote As this is a real shift operation, it may cause some runtime effects while using big array sizes \nto move at the input bufferRegister.\nPlease consider that a FIFO or LIFO storage, based on indexes, could be used as well for \nmost applications.", "type": "FUNCTION_BLOCK", "input": [{"name": "shiftLeft", "type": "Bool", "description": "Rising edge: Elements in the array bufferRegister shifted left."}, {"name": "shiftRight", "type": "Bool", "description": "Rising edge: Elements in the array bufferRegister shifted right."}, {"name": "shiftRange", "type": "UInt", "description": "Number of places to be shifted in the bufferRegister input array"}, {"name": "clear", "type": "Bool", "description": "Clear buffer elements in bufferRegister with initalItem"}, {"name": "fill", "type": "Bool", "description": "Overwrite buffer elements after shift operation."}, {"name": "initialItem", "type": "Variant", "description": "Value with which the array at input bufferRegister is initialized."}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [{"name": "bufferRegister", "type": "Variant", "description": "Buffer / Register memory as ARRAY, which keeps the data."}], "return_value": [], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#7000": "STATUS_NO_CURRENT_JOBS", "16#8200": "ERR_NO_ARRAY", "16#8201": "ERR_CLEARING_WITHOUT_INITIAL_ITEM", "16#8202": "ERR_FILL_WITHOUT_INITIAL_ITEM", "16#8203": "ERR_WRONG_TYPE_INITIAL_ITEM", "16#8401": "ERR_MORE_THAN_ONE_COMMAND", "16#8402": "ERR_IN_SHIFT_RANGE", "16#8610": "ERR_CLEAR_BUFFER", "16#8611": "ERR_SHIFT_BUFFER_LEFT", "16#8612": "ERR_SHIFT_BUFFER_LEFT_FILL", "16#8622": "ERR_SHIFT_BUFFER_RIGHT_FILL"}, "user_defined_types": []}
{"title": "DInt range random number generation", "name": "LGF_Random_DInt", "description": "## Short description ##\n\nThis function generates a random value with each call.\nThe random number has the data type DInt.\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nThe function generates random values in the range:\n2147483648    2147483647.\nThe random value is formed from the nanoseconds of the current system time of the CPU. The \nbyte order of this value is inverted and then converted to DInt.", "type": "FUNCTION", "input": [], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called blocks"}], "in/out": [], "return_value": [{"type": "DInt", "description": "Random number in the DInt range"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8600": "ERR_RD_SYS_T"}, "user_defined_types": []}
{"title": "DWord to 2-Word Splitter", "name": "LGF_SplitDWordToWords", "description": "## Short description ##\n\nThis function splits a DWord variable into 2 Word variables.", "type": "FUNCTION", "input": [{"name": "doubleWord", "type": "DWord", "description": "Bit sequence to be split"}], "output": [{"name": "word1", "type": "Word", "description": "Output Word 1 - MSW"}, {"name": "word0", "type": "Word", "description": "Output Word 0 - LSW"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": []}
{"title": "Advanced CRC-8 Calculator", "name": "LGF_CalcCRC8Advanced", "description": "## Short description ##\n\nThe CRC calculation is used for error detection at data transmission. The result of a calculation \nreturns a CRC value via the data sent. The receiver detects a faulty transmission due to the \nunequal CRC value. The function LGF_CalcCRC8Advanced uses 8 bits as the generator \npolynomial (mask) and the parameters finalXorValue, reflectInput, and reflectResult.\n\n## Functional description ##\n\nThe function calculates the CRC value from a data stream of any size. The data stream is \ncomposed of the individual elements of the array at the input/output parameter array. The start \nvalue initValue and the generator polynomial mask can be freely selected.\nVia the Boolean input parameters reflectInput and reflectResult, you may optionally mirror \nthe bits of the input data or the CRC value. An XOR operation is also performed with the CRC \nvalue at the end and the value finalXorValue.\nThe input noOfELements can be used to specify the desired number of elements for calculation, it \napplies:\n <= (   + 1)\nNote Various online tools are available for calculating the CRC values. The function of the block \nwas tested with the following online tool, since it supports the input parameters mask\n(Polynomial) and initValue (Initial Value):\nhttp://www.sunshine2k.de/coding/javascript/crc/crc_js.html", "type": "FUNCTION", "input": [{"name": "initValue", "type": "Byte", "description": "Start value for the calculation"}, {"name": "mask", "type": "Byte", "description": "Generator polynomial for the calculation"}, {"name": "finalXorValue", "type": "Byte", "description": "Value for final XOR operation"}, {"name": "reflectInput", "type": "Bool", "description": "Mirror the bits within the input byte"}, {"name": "reflectResult", "type": "Bool", "description": "Mirror the order of the bits within the result"}, {"name": "noOfElements", "type": "UInt", "description": "Number of elements to be used in CRC calculation"}], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "array", "type": "Array[*] of Byte", "description": "Data stream for which the CRC value will be calculated"}], "return_value": [{"type": "Byte", "description": "Calculated CRC value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8400": "ERR_NO_OF_ELEMENTS"}, "user_defined_types": []}
{"title": "Binary to Gray Code Converter", "name": "LGF_BinaryToGray", "description": "## Short description ##\n\nThis function converts a binary coded value into a Gray-coded value.", "type": "FUNCTION", "input": [{"name": "variableBinary", "type": "DWord", "description": "Binary coded value to convert to Gray code"}], "output": [], "in/out": [], "return_value": [{"type": "DWord", "description": "Gray-coded value"}], "status_codes": {}, "user_defined_types": []}
{"title": "Matrix Inverter", "name": "LGF_MatrixInverse", "description": "## Short description ##\n\nThis function inverts a square matrix of the data type ARRAY[*,*] of LREAL.\nThe square matrix of any size will be inverted according to the Shipley-Coleman method.\n = ^(1)\nNote Note that the input matrix must be square. This means that the number of rows must be \nequal to the number of columns. The output matrix must be the same size and have the \nsame array boundaries as the input matrix.", "type": "FUNCTION", "input": [], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "matrix", "type": "Array[*, *] of LReal", "description": "Square input matrix that will be inversed"}, {"name": "matrixResult", "type": "Array[*, *] of LReal", "description": "Inverted matrix"}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_NOT_SQUARE_MATRIX", "16#8201": "ERR_ALGORITHM_NOT_POSSIBLE", "16#8202": "ERR_MATR1_LOWBOUND_ROWS_RESMATR_LOWBOUND_ROWS", "16#8203": "ERR_MATR1_LOWBOUND_COLUMNS_RESMATR_LOWBOUND_COLUMNS", "16#8204": "ERR_MATR1_UPPBOUND_ROWS_RESMATR_UPPBOUND_ROWS", "16#8205": "ERR_MATR1_UPPBOUND_COLUMNS_RESMATR_UPPBOUND_COLUMNS"}, "user_defined_types": []}
{"title": "Word to 2-Byte Splitter", "name": "LGF_SplitWordToBytes", "description": "## Short description ##\n\nThis function splits a Word variable into 2 Byte variables.", "type": "FUNCTION", "input": [{"name": "word", "type": "Word", "description": "Bit sequence to be split"}], "output": [{"name": "byte1", "type": "Byte", "description": "Output Byte 1 - MSB"}, {"name": "byte0", "type": "Byte", "description": "Output Byte 0 - LSB"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": []}
{"title": "LReal numbers comparison with variable precision", "name": "LGF_CompareLRealByPrecision", "description": "## Short description ##\n\nThis function checks floating point numbers for equality, by using an approximation formula and \na fixed precision by constant 1.0E-12 (pico)\n\n## Functional description ##\n\nThe comparison of the LREAL numbers is based on an given accuracy at the parameter \nprecision. The difference between the two input values must be smaller than the precision\naccuracy value multiplied by one of the two input values.\nEquation:", "type": "FUNCTION", "input": [{"name": "valueA", "type": "LReal", "description": "First LREAL number to be compared."}, {"name": "valueB", "type": "LReal", "description": "Second LREAL number to be compared."}, {"name": "precision", "type": "LReal", "description": "Accuracy with which the two values are compared."}], "output": [], "in/out": [], "return_value": [{"type": "Bool", "description": "FALSE: not equal, TRUE: approximately the same"}], "status_codes": {}, "user_defined_types": []}
{"title": "Endianness Detection Function for Little Endian", "name": "LGF_IsLittleEndian", "description": "## Short description ##\n\nThe function detects the endianness of the executing system.", "type": "FUNCTION", "input": [], "output": [], "in/out": [], "return_value": [{"type": "Bool", "description": "TRUE if little endianness is detected"}], "status_codes": {}, "user_defined_types": []}
{"title": "Simple Smoothing Function", "name": "LGF_SimpleSmoothingFC", "description": "## Short description ##\n\nThe function calculates the linear mean value acyclically.\nThe simplest form of smoothing a sequence of measured values is to calculate the linear mean \nvalue by three points.\nThe function reads an array that is smoothed.   2 smoothed measured values can be \ncalculated from N measured values. Therefore, the output array in the index (0) and index (N) \ncontains the value 0.\n\n## Functional description ##\n\nThe function calculates the smoothed values using the following formula:\n\nThe calculated value is output or the calculated values are output at output smoothedValue.\nBased on this formula, the function cannot calculate values for the elements 0 and N.", "type": "FUNCTION", "input": [], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB"}], "in/out": [{"name": "values", "type": "Array[*] of LReal", "description": "Values that are to be included in the smoothing."}, {"name": "smoothedValues", "type": "Array[*] of LReal", "description": "The smoothed values."}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8400": "ERR_NOT_ENOUGH_VALUES Error: Not enough values.", "16#8401": "ERR_ARRAY_DIFFERENT Error: The Arraysizes are not equal."}, "user_defined_types": []}
{"title": "2D distance calculation between points", "name": "LGF_CalcDistance_2D", "description": "## Short description ##\n\nThe function calculates the distance between two points in the plane.\n\n## Functional description ##\n\nThe block calculates the distance between two points in a Cartesian coordinate system. The \ndistance is calculated with the following formula:\nresult = 2((x2  x1)^2 + (y2  y1)^2)", "type": "FUNCTION", "input": [{"name": "x1", "type": "LReal", "description": "X coordinate point 1"}, {"name": "y1", "type": "LReal", "description": "Y coordinate point 1"}, {"name": "x2", "type": "LReal", "description": "X coordinate point 2"}, {"name": "y2", "type": "LReal", "description": "Y coordinate point 2"}], "output": [], "in/out": [], "return_value": [{"type": "LReal", "description": "Calculated distance between the Points"}], "status_codes": {}, "user_defined_types": []}
{"title": "Kelvin to Celsius Converter", "name": "LGF_KelvinToCelsius", "description": "## Short description ##\n\nThis function converts a temperature value - from Kelvin to Celsius.", "type": "FUNCTION", "input": [{"name": "value", "type": "Real", "description": "Temperature to be converted in Kelvin"}], "output": [], "in/out": [], "return_value": [{"type": "Real", "description": "Converted temperature in Celsius"}], "status_codes": {}, "user_defined_types": []}
{"title": "32-Bit to DWord Merger", "name": "LGF_MergeBitsToDWord", "description": "## Short description ##\n\nThis function merge 32 Bits / 32 Boolean variables into one DWord variable.", "type": "FUNCTION", "input": [{"name": "bit31", "type": "Bool", "description": "Input Bit 31 - MSB"}, {"name": "bit30", "type": "Bool", "description": "Input Bit 30"}, {"name": "bit29", "type": "Bool", "description": "Input Bit 29"}, {"name": "bit28", "type": "Bool", "description": "Input Bit 28"}, {"name": "bit27", "type": "Bool", "description": "Input Bit 27"}, {"name": "bit26", "type": "Bool", "description": "Input Bit 26"}, {"name": "bit25", "type": "Bool", "description": "Input Bit 25"}, {"name": "bit24", "type": "Bool", "description": "Input Bit 24"}, {"name": "bit23", "type": "Bool", "description": "Input Bit 23"}, {"name": "bit22", "type": "Bool", "description": "Input Bit 22"}, {"name": "bit21", "type": "Bool", "description": "Input Bit 21"}, {"name": "bit20", "type": "Bool", "description": "Input Bit 20"}, {"name": "bit19", "type": "Bool", "description": "Input Bit 19"}, {"name": "bit18", "type": "Bool", "description": "Input Bit 18"}, {"name": "bit17", "type": "Bool", "description": "Input Bit 17"}, {"name": "bit16", "type": "Bool", "description": "Input Bit 16"}, {"name": "bit15", "type": "Bool", "description": "Input Bit 15"}, {"name": "bit14", "type": "Bool", "description": "Input Bit 14"}, {"name": "bit13", "type": "Bool", "description": "Input Bit 13"}, {"name": "bit12", "type": "Bool", "description": "Input Bit 12"}, {"name": "bit11", "type": "Bool", "description": "Input Bit 11"}, {"name": "bit10", "type": "Bool", "description": "Input Bit 10"}, {"name": "bit9", "type": "Bool", "description": "Input Bit 9"}, {"name": "bit8", "type": "Bool", "description": "Input Bit 8"}, {"name": "bit7", "type": "Bool", "description": "Input Bit 7"}, {"name": "bit6", "type": "Bool", "description": "Input Bit 6"}, {"name": "bit5", "type": "Bool", "description": "Input Bit 5"}, {"name": "bit4", "type": "Bool", "description": "Input Bit 4"}, {"name": "bit3", "type": "Bool", "description": "Input Bit 3"}, {"name": "bit2", "type": "Bool", "description": "Input Bit 2"}, {"name": "bit1", "type": "Bool", "description": "Input Bit 1"}, {"name": "bit0", "type": "Bool", "description": "Input Bit 0 - LSB"}], "output": [], "in/out": [], "return_value": [{"type": "DWord", "description": "Composite Bit sequence stored as DWord variable"}], "status_codes": {}, "user_defined_types": []}
{"title": "DInt Array Min/Max Value and Index Searcher", "name": "LGF_SearchMinMax_DInt", "description": "## Short description ##\n\nThis function searches, in an array of the data type DInt, for the maximum and minimum value \nand the respective index in the array.\n\n## Functional description ##\n\nAn array of any size is connected via the values input. The elements are then compared in turn. \nThe smallest and largest values, as well as their corresponding index are output to the array.\nNote If there are several identical min. or max. values, the index of the first min. or max. value is \noutput.", "type": "FUNCTION", "input": [], "output": [{"name": "minValue", "type": "DInt", "description": "Minimum value found in the array"}, {"name": "minValueIndex", "type": "DInt", "description": "Index of the minimum found value in the array"}, {"name": "maxValue", "type": "DInt", "description": "Maximum value found in the array"}, {"name": "maxValueIndex", "type": "DInt", "description": "Index of the maximum found value in the array"}], "in/out": [{"name": "values", "type": "Array[*] of DInt", "description": "Array in whose fields the maximum and minimum are searched"}], "return_value": [], "status_codes": {}, "user_defined_types": []}
{"title": "DTL to UNIX Time Converter", "name": "LGF_DTLToUnixTime", "description": "## Short description ##\n\nThis function converts the date and time of data type DTL to the UNIX time of data type DInt. The timestamp is calculated in UTC. This means that the time zone is not considered.\nOnly times after 01/01/1990 are permitted.", "type": "FUNCTION", "input": [{"name": "timeDTL", "type": "DTL", "description": "Date and time as DTL to convert to UNIX time"}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}], "in/out": [], "return_value": [{"type": "DInt", "description": "Converted UNIX time"}], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED_NO_ERROR", "16#8000": "ERR_TIME_BEFORE_1990", "16#8001": "ERR_DTL_INPUT_VALUE_INVALID"}, "user_defined_types": []}
{"title": "LWord Endianness Adjuster", "name": "LGF_SwapBlockLWord", "description": "## Short description ##\n\nAdjusts/ switches the endianness of multibyte data typed values.\nFor this to achieve, a loop will iterate through the array elements and swap the bytes \nintrinsically.", "type": "FUNCTION", "input": [], "output": [], "in/out": [{"name": "data", "type": "Array[*] of LWord", "description": "Contains the data values, which will be endianness adjusted"}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {}, "user_defined_types": []}
{"title": "Boxplot Calculation for Unsigned Integer Data", "name": "LGF_Boxplot_UDInt", "description": "## Short description ##\n\nIf you want to get an overview of existing data, you can use a Boxplot diagram. A Boxplot shows \nyou in which area the data is located and how it is distributed over this area. A Boxplot consists \nof the following parameters:\n Minimum (smallest occurring value of the sample)\n Lower or first quartile (below this value are 25% of the sample values)\n Median or second quartile (below this value are 50% of the sample values)\n Upper or third quartile (below this value are 75% of the sample values)\n Maximum (largest occurring value of the sample)\nFigure: Boxplot\n\n## Functional description ##\n\nThe block sorts the data series and then calculates the so-called five-point summary:\nTable: Five-point summary\nCharacteristic value of the five-point summary Output parameter of the block\nMinimum (smallest occurring value of the sample) min\nLower or first quartile (below this value are 25% of \nthe sample values)\nq25\nMedian or second quartile (below this value are \n50% of the sample values)\nmedian\nUpper or third quartile (below this value are 75% of \nthe sample values)\nq75\nMaximum (largest occurring value of the sample) max\nIf outlier detection is activated, the block first calculates the limits. From these limit values, the \nvalues are recognized as outliers:\n\nThe block then calculates new values for the parameters max and min, which lie within the outlier \nlimits. The outliers are counted and output as a percentage.\nTo make it easier to judge how the data is distributed, the block also calculates the skew. The \nskewness lies between the values -1 and 1 with the following meaning:\n -1: extremely left skewed distribution\n 0: symmetrical distribution\n 1: extreme right-skew distribution\nThe elements of the passed array are sorted in ascending order by the block. The \nLGF_Shellsort_UDInt block is used for sorting.\nThe parameters are calculated as follows:\nTable: Boxplot formulas Parameters Formula", "type": "FUNCTION_BLOCK", "input": [{"name": "execute", "type": "Bool", "description": "Activation of the calculation with each positive edge."}, {"name": "rangeOutlier", "type": "LReal", "description": "Outlier detection parameter."}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "outlierMax", "type": "LReal", "description": "Upper outliers in %"}, {"name": "max", "type": "UDInt", "description": "Maximum Value, not an outlier."}, {"name": "q75", "type": "LReal", "description": "3rd quartile or Q75 of the data series."}, {"name": "median", "type": "LReal", "description": "2nd quartile or Median of the data series."}, {"name": "q25", "type": "LReal", "description": "1st quartile or Q25 of the data series."}, {"name": "min", "type": "UDInt", "description": "Minimum Value, not an outlier."}, {"name": "outlierMin", "type": "LReal", "description": "Lower outliers in %"}, {"name": "skewness", "type": "LReal", "description": "Skewness of the data series."}], "in/out": [{"name": "values", "type": "Array[*] of UDInt", "description": "The array containing the data series for calculation"}], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED", "16#7000": "STATUS_NO_CALL", "16#7001": "STATUS_FIRST_CALL", "16#8200": "ERR_NEG_ARR_BOUND", "16#8600": "ERR_SHELL_SORT", "16#9101": "ERR_RANGE_NOT_OK"}, "user_defined_types": []}
{"title": "4-Byte to DWord Merger", "name": "LGF_MergeBytesToDWord", "description": "## Short description ##\n\nThis function merge 4 Byte variables into one DWord variable.", "type": "FUNCTION", "input": [{"name": "byte3", "type": "Byte", "description": "Input Byte 3 - MSB"}, {"name": "byte2", "type": "Byte", "description": "Input Byte 2"}, {"name": "byte1", "type": "Byte", "description": "Input Byte 1"}, {"name": "byte0", "type": "Byte", "description": "Input Byte 0 - LSB"}], "output": [], "in/out": [], "return_value": [{"type": "DWord", "description": "Composite Byte sequence stored as DWord variable"}], "status_codes": {}, "user_defined_types": []}
{"title": "Random Real Number Generator", "name": "LGF_Random_Real", "description": "## Short description ##\n\nThis function generates a random value with each call.\nThe random number has the data type Real in the range from 0.0 to 1.0.\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nThe function generates random values in the range:\n0.0    1.0.\nThe random value is formed from the nanoseconds of the current system time of the CPU. The \nbyte order of this value is inverted and then converted to a floating point.", "type": "FUNCTION", "input": [], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called blocks"}], "in/out": [], "return_value": [{"type": "Real", "description": "Random Real number between 0.0 and 1.0"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8600": "ERR_RD_SYS_T"}, "user_defined_types": []}
{"title": "DWORD falling edge counting", "name": "LGF_CountFalInDWord", "description": "## Short description ##\n\nThe function analyzes a variable of the type DWORD and outputs how often a 1-0 sequence \n(falling edge) occurs in the variable.\nNote LEGACY FUNCTION\nPlease update and use the FB with the same name LGF_CountFalInDWord in the future!\nThis function is no longer maintained!\n\n## Functional description ##\n\nIn a variable of the data type DWORD, the block counts the falling edges (1-0 transitions) from \nleft to right. The output countFalInDWord outputs the number of falling edges.\nSo that falling edges at the variable limit are also detected, the input value is copied to the static \nvariable statDWordPrevCycle at the end of the evaluation and evaluated in the next cycle.", "type": "FUNCTION_BLOCK", "input": [{"name": "value", "type": "DWord", "description": "Input Double word in which the falling edges are counted"}], "output": [{"name": "numberOfEdges", "type": "Int", "description": "Number of falling edges in the DWord"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": []}
{"title": "Linear Scaler for Input Variable", "name": "LGF_ScaleLinear", "description": "## Short description ##\n\nThis function scales an input variable (LReal) via a linear straight-line equation.\n\n## Functional description ##\n\nThe function linearly scales an input variable (e.g. an analog input value) to a specific output \nvariable (e.g. level).\nTo determine the output variable, the following linear equation is used in the function:\n =\n((2  1) / (2  1)) * (  1) + 1\nThe straight line is described by the two points, P1 and P2. You specify the points as a \nCartesian coordinate system using x and y coordinates.\nNote If the values of the parameters x1 and x2 are the same, the value of y1 is output on output y\nBy specifying yMin and yMax you can restrict the calculated value of y to a range limited at top \nand bottom. Thus, you avoid override and underride ranges.", "type": "FUNCTION", "input": [{"name": "x", "type": "LReal", "description": "Input value `x` to be scaled"}, {"name": "x1", "type": "LReal", "description": "Point 1 (P1) -`x` coordinate of the linear function"}, {"name": "y1", "type": "LReal", "description": "Point 1 (P1) -`y` coordinate of the linear function"}, {"name": "x2", "type": "LReal", "description": "Point 2 (P2) -`x` coordinate of the linear function"}, {"name": "y2", "type": "LReal", "description": "Point 2 (P2) -`y` coordinate of the linear function"}, {"name": "yMin", "type": "LReal", "description": "Lower limit value of the output"}, {"name": "yMax", "type": "LReal", "description": "High limit value of the output"}], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [], "return_value": [{"type": "LReal", "description": "Scaled output value `y`"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#6001": "WARN_Y_LIMITED_TO_YMIN", "16#6002": "WARN_Y_LIMITED_TO_YMAX", "16#8200": "ERR_LOW_LIM_OVER_UP_LIM"}, "user_defined_types": []}
{"title": "Profinet Interface Parameter Reader", "name": "LGF_ReadPnInterfaceParameter", "description": "## Short description ##\n\nThe function block provides Interface parameter like the IP Address settings, MAC Address and \nthe PN Name.\n\n## Functional description ##\n\nThe function reads the Interface settings / parameters using the system function RDREC (Read \ndata record).\nTo read the MAC and IP address of the interface provided via it's hardware ID, it is mandatory \nto read the PD_INTERFACE_DATA_REAL data record of any PROFINET compliant interface.\nNote Upon TIA Portal V17, its possible to use as well the system function CommConfig, which is in \nthe Instructions / Communication / Open user communication (Version >= V8.1) located.", "type": "FUNCTION_BLOCK", "input": [{"name": "execute", "type": "Bool", "description": "Rising edge starts action once"}, {"name": "hardwareId", "type": "HW_ANY", "description": "Hardware ID of the Interface where the parameter should be read"}], "output": [{"name": "done", "type": "Bool", "description": "Commanded functionality has been completed successfully"}, {"name": "busy", "type": "Bool", "description": "FB is not finished, new output values can be expected"}, {"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "DWord", "description": "Status of the FB and error identification"}, {"name": "address", "type": "IP_V4", "description": "IP Address from interface"}, {"name": "subnetMask", "type": "IP_V4", "description": "Subnet mask from interface"}, {"name": "standardGateway", "type": "IP_V4", "description": "Standard gateway address from interface"}, {"name": "macAddress", "type": "Array[0..5] of Byte", "description": "MAC Address from interface"}, {"name": "pnName", "type": "String", "description": "Profinet name from interface"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED: Execution finished without errors", "16#7000": "STATUS_NO_CALL: No job being currently processed", "16#7001": "STATUS_FIRST_CALL: First call after incoming new job", "16#7002": "STATUS_SUBSEQUENT_CALL: Subsequent call during active processing", "16#9000": "ERR_UNDEFINED_STATE: Due to an undefined state in state machine"}, "user_defined_types": []}
{"title": "GPS-DD to GPS Direction DMS Converter", "name": "LGF_GpsDDToGps", "description": "## Short description ##\n\nThis function converts a given GPS-DD data type (decimal degrees) into a GPS data type \n(direction, degrees, minutes, and seconds).\nGPS decimal degree to GPS native.", "type": "FUNCTION", "input": [{"name": "gps", "type": "LGF_typeGPS_DD", "description": "GPS-Data to be converted (decimal degrees)"}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}], "in/out": [], "return_value": [{"type": "LGF_typeGPS", "description": "Converted GPS-Data (direction, degrees, minutes, and seconds)"}], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED_NO_ERROR", "16#8201": "ERR_LATITUDE_VALUE", "16#8203": "ERR_LONGITUDE_VALUE"}, "user_defined_types": [{"name": "LGF_typeGPS_DD", "description": "Datatype for GPS Coordinates in decimal degrees.", "member": [{"name": "latitude", "type": "Real", "default": "0.0", "description": "Degrees latitude with decimal places"}, {"name": "longitude", "type": "Real", "default": "0.0", "description": "Degrees longitude in degrees with decimal places"}]}, {"name": "LGF_typeGPS", "description": "Datatype for GPS Coordinates with direction, degrees, minutes, seconds.", "member": [{"name": "latitude", "type": "LGF_typeGPS_DMS", "default": "---", "description": "Datatype for GPS Coordinates in DMS and the Direction."}, {"name": "longitude", "type": "LGF_typeGPS_DMS", "default": "---", "description": "Datatype for GPS Coordinates in DMS and the Direction."}]}]}
{"title": "Structured data comparison", "name": "LGF_CompareVariant", "description": "## Short description ##\n\nThe function compares two structured actual parameters (array, PLC data type) and outputs \nwhether they are of the same type and have the same values.\nCompare arrays or plc datatypes and their values up to a max lengh of 200 Bytes of the \nconnected variables. If at least one value of an element is not identical > set function result = \nfalse\nRestrictions:\nThe attached structure must not include Strings\nThe attached structure can not exceed 200 bytes, because of the internal buffer size\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nThis block compares two (structured) actual parameters and shows whether they equate to the \nsame value.\nNote The following differences cannot be detected with the comparison method (byte level):\n Variables of the data type Struct cannot be compared.\n For strings, there may be differences in the range between the actual length and the maximum \nlength.\n With REAL numbers in the structure, a disparity can also be displayed for same variables.\n Variables of the type ARRAY of BOOL cannot be checked for equality with the function, because \nthe command used, CountOfElements, also counts the filling elements (e.g. 8 is returned with an \nARRAY[0..1] of BOOL).", "type": "FUNCTION", "input": [], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error / TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB / 16#8000-16#FFFF: Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [{"name": "variableA", "type": "Variant", "description": "First comparison variable with any data type"}, {"name": "variableB", "type": "Variant", "description": "Second comparison variable with any data type"}], "return_value": [{"type": "Bool", "description": "FALSE: Values of comparison variables or PLC data types are different. TRUE: Values of the comparison variables are equal and PLC data types are identical."}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8201": "ERR_INPUT_TYPES_MUST_MATCH", "16#8202": "ERR_INPUT_TYPES_LENGTH_NOT_EQUAL", "16#8601": "ERR_SERIALIZE_VARIABLE_A", "16#8602": "ERR_SERIALIZE_VARIABLE_B"}, "user_defined_types": []}
{"title": "ISO 8601 calendar week calculation", "name": "LGF_GetCalendarWeek_ISO", "description": "## Short description ##\n\nThis function uses the specified date to calculate the calendar week and the number of days that have passed since the beginning of the year for ISO 8601 European countries.\n\n## Functional description ##\n\nCounting method for European countries in accordance with ISO 8601\n     Calendar weeks have 7 days, start on a Monday, and they are counted continuously throughout the year\n     Calendar week 1 of a year is the week that contains the first Thursday.\n     Each year has either 52 or 53 calendar weeks.\n    A year has 53 calendar weeks if the following characteristics apply:\n-    A common year begins on a Thursday and ends on a Thursday.\n-    A leap year begins either on a Wednesday and ends on a Thursday or it begins on a Thursday and ends on a Friday.\n\n\n    The 29th, 30th and 31st December can belong to the calendar week 1 of the following year.\n    The 1st, 2nd, and 3rd January can still belong to the last calendar week of the previous year.", "type": "FUNCTION", "input": [{"name": "date", "type": "DTL", "description": "Date used to calculate the calendar week and days since 1 January"}], "output": [{"name": "calendarDay", "type": "DInt", "description": "Days past since January 1st on given date"}, {"name": "error", "type": "Bool", "description": "FALSE: No error / TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB / 16#8000-16#FFFF: Error identification"}], "in/out": [], "return_value": [{"type": "DInt", "description": "Number of the calendar week."}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8201": "ERR_LIM_DATE Date out of the range"}, "user_defined_types": []}
{"title": "Random UDInt Range Number Generator", "name": "LGF_RandomRange_UDInt", "description": "## Short description ##\n\nThis function generates a random value in defined limits with each call.\nThe random number has the data type UDInt in the specified range.\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nThe block generates random values that are between the specified minValue and the maxValue. \nThis random value is output via the Ret_Val.The random value is formed from the nanoseconds of the current system time of the CPU. The \nbyte order of this value is inverted and then converted to a UDInt.", "type": "FUNCTION", "input": [{"name": "minValue", "type": "UDInt", "description": "Minimum value of the range of the random number - lower border"}, {"name": "maxValue", "type": "UDInt", "description": "Maximum value of the range of the random number - upper border"}], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called blocks"}], "in/out": [], "return_value": [{"type": "UDInt", "description": "Random UDInt number in the predefined range"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8200": "ERR_MAX_LESS_MIN", "16#8600": "ERR_RD_SYS_T"}, "user_defined_types": []}
{"title": "Function Curve Area Calculator", "name": "LGF_Integration", "description": "## Short description ##\n\nThe function approximately calculates the area under a function curve. The function curve is \ntransferred as an analog value (LReal) which varies over time. The integral value is output on \nintegral.\nThe implementation is based on the trapezoidal rule and uses [ms] as time base.\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nThe integral calculation includes the summation of those trapezoidal areas that span between \nthe last two function values on the value input and the time. The elapsed time is calculated via \nthe system time of the CPU. This trapezoidal area is identical to the product of the mean value \nof the two process values and the time interval.\nNote The calculation takes [ms] as time base. So the analoge value hase to use the same time \nbase, e.g. [volume flow/ms].\n = 1/2 * (1 + 0) * (1  0) + 1/2 * (2 + 1) *(2 1) + ...\nStart the integral calculation for the inputvalue at the parameter value:\n Set the parameter enable to the value TRUE\n Set the parameter reset to the value FALSE\nIf the parameter enable is set to the value FALSE, the integral calculation is stopped and the \noutput integral outputs the last calculated value.\nIf the parameter reset is set to the value TRUE, the output integral is reset to 0.0", "type": "FUNCTION_BLOCK", "input": [{"name": "enable", "type": "Bool", "description": "Enables integral calculation"}, {"name": "value", "type": "LReal", "description": "Analog value of the continuous function curve, based on [ms]"}, {"name": "reset", "type": "Bool", "description": "Sets the output 'integral' to '0.0'"}], "output": [{"name": "integral", "type": "LReal", "description": "Integral value"}, {"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called blocks"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED_NO_ERROR", "16#8600": "ERR_READ_SYS_TIME"}, "user_defined_types": []}
{"title": "DWord Endianness Adjuster", "name": "LGF_SwapBlockDWord", "description": "## Short description ##\n\nAdjusts/ switches the endianness of multibyte data typed values.\nFor this to achieve, a loop will iterate through the array elements and swap the bytes \nintrinsically.", "type": "FUNCTION", "input": [], "output": [], "in/out": [{"name": "data", "type": "Array[*] of DWord", "description": "Contains the data values, which will be endianness adjusted"}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {}, "user_defined_types": []}
{"title": "Kelvin to Rankine Converter", "name": "LGF_KelvinToRankine", "description": "## Short description ##\n\nThis function converts a temperature value - from Kelvin to Rankine.", "type": "FUNCTION", "input": [{"name": "value", "type": "Real", "description": "Temperature to be converted in Kelvin"}], "output": [], "in/out": [], "return_value": [{"type": "Real", "description": "Converted temperature in Rankine"}], "status_codes": {}, "user_defined_types": []}
{"title": "String to Time Converter", "name": "LGF_StringToTime", "description": "## Short description ##\n\nThe function converts a variable of the data type String into a variable of the system data type \nTime.", "type": "FUNCTION", "input": [{"name": "timeValue", "type": "String", "description": "Time to be converted as string Example: 1D3H45M6S0MS"}], "output": [], "in/out": [], "return_value": [{"type": "Time", "description": "Converted time value Example: T#1D_3H_45M_6S"}], "status_codes": {}, "user_defined_types": []}
{"title": "Pulse relay and toggle flip-flop operation", "name": "LGF_PulseRelay", "description": "## Short description ##\n\nThis block corresponds to an impulse relay or a toggle flip-flop including set and reset input.   Pulse relay, Surge relay, Toggle-Flip-Flop, Frequency divider reset is leading / prior to set or trigger\n\n## Functional description ##\n\nFigure: LGF_PulseRelay Signal diagram\n1.   Each rising edge of the input trigger changes the Boolean value of the output out.    \n2.   Each rising edge of the input set sets the Bboolean value of the output out to TRUE.    \n3.   Each rising edge of the input reset sets the Boolean value of the output out to FALSE. \n4.   If the inputs set and reset are set in the same cycle, the reset input has priority.\nThe block can also be used as a frequency divider. If the input trigger is supplied with a fixed frequency, the output out delivers half the frequency.", "type": "FUNCTION_BLOCK", "input": [{"name": "trigger", "type": "Bool", "description": "FALSE Trigger to toggle output signal (rising edge)"}, {"name": "set", "type": "Bool", "description": "FALSE Set output signal. rising edge"}, {"name": "reset", "type": "Bool", "description": "FALSE Reset signal, rising edge (prior to set)"}], "output": [{"name": "out", "type": "Bool", "description": "Ooutput signal"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": []}
{"title": "Value tolerance range check", "name": "LGF_IsValueInTolerance", "description": "## Short description ##\n\nThe function checks whether a value is within a defined value range.\nThe value range is defined with a set point, as well as a tolerance range, around the set point in \npercent (%). The function calculates the low limit and high limit of the value range.\n\n## Functional description ##\n\nThe setpoint and tolerance percentage variables define a value range.\nThe function checks whether the value is below, in or above the value range. The outputs \nbelowLowLimit, Ret_Val, or overHighLimit show where the value is located.", "type": "FUNCTION", "input": [{"name": "value", "type": "LReal", "description": "Value to be checked"}, {"name": "setpoint", "type": "LReal", "description": "Set point"}, {"name": "tolerance", "type": "LReal", "description": "Tolerance range around the set point in percent"}], "output": [{"name": "overHighLimit", "type": "Bool", "description": "TRUE if the value exceeds the upper limit"}, {"name": "belowLowLimit", "type": "Bool", "description": "TRUE if the value is below the lower limit"}, {"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [], "return_value": [{"type": "Bool", "description": "TRUE if the value is in the value range"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8401": "ERR_RANGE_LIMIT_VALUES"}, "user_defined_types": []}
{"title": "Matrix Scalar Multiplier", "name": "LGF_MatrixScalarMultiplication", "description": "## Short description ##\n\nThis function block multiplies a matrix of the data type ARRAY[*,*] of LREAL with a scalar.\nA matrix is multiplied by a scalar, thereby multiplying each matrix element by the scalar. The \nresult is output in the matrixResult matrix.\nNote Note that the input and output matrix must have the same number of columns and rows.", "type": "FUNCTION", "input": [{"name": "scalar", "type": "LReal", "description": "Scalar value where the matrix is multiplied"}], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "matrixInput", "type": "Array[*, *] of LReal", "description": "Matrix to multiply"}, {"name": "matrixResult", "type": "Array[*, *] of LReal", "description": "The result matrix of the multiplication"}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8201": "ERR_MATRICES_LOWER_BOUND_ROWS_DONT_MATCH", "16#8202": "ERR_MATRICES_UPPER_BOUND_ROWS_DONT_MATCH", "16#8203": "ERR_MATRICES_LOWER_BOUND_COLUMNS_DONT_MATCH", "16#8204": "ERR_MATRICES_UPPER_BOUND_COLUMNS_DONT_MATCH"}, "user_defined_types": []}
{"title": "LReal numbers comparison with fixed precision", "name": "LGF_CompareLReal", "description": "## Short description ##\n\nThis function checks floating point numbers for equality, by using an approximation formula and \na fixed precision by constant 1.0E-12 (pico)\n\n## Functional description ##\n\nThe comparison of the LREAL numbers is based on an fixed accuracy of 1.0E-12. The \ndifference between the two input values must be smaller than the PRECISION accuracy multiplied \nby one of the two input values.\nEquation:\nNote If your application requires a different accuracy when comparing the numbers, adapt the \nPRECISION constant in the function to your requirements.\nOr you may use the FC LGF_CompareLRealByPrecision.", "type": "FUNCTION", "input": [{"name": "valueA", "type": "LReal", "description": "First LREAL number to be compared."}, {"name": "valueB", "type": "LReal", "description": "Second LREAL number to be compared."}], "output": [], "in/out": [], "return_value": [{"type": "Bool", "description": "FALSE: not equal, TRUE: approximately the same"}], "status_codes": {}, "user_defined_types": []}
{"title": "Advanced String Extractor from Character Array", "name": "LGF_ExtractStringFromCharArrayAdv", "description": "## Short description ##\n\nThe function extracts a String specified by a text before and after from an array of characters \nwith extended options.", "type": "FUNCTION", "input": [{"name": "textBefore", "type": "String", "description": "Text in front of the characters which has to be extracted"}, {"name": "textAfter", "type": "String", "description": "Text behind the characters which has to be extracted"}, {"name": "includeBeforeAfter", "type": "Bool", "description": "TRUE: textBefore and textAfter are included in the extracted string"}, {"name": "startPos", "type": "DInt", "description": "Position within the array to start search from (index zero based)"}], "output": [{"name": "extractedString", "type": "String", "description": "Extracted string"}, {"name": "position", "type": "DInt", "description": "Position (index) within the array where text begins (index zero based)"}, {"name": "length", "type": "Int", "description": "Length of text that was extracted"}, {"name": "status", "type": "Word", "description": "Status of the FB"}], "in/out": [{"name": "searchIn", "type": "Variant", "description": "Array of Character or Byte to search in"}], "return_value": [{"type": "Word", "description": "Return value: Status of the FB"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_NO_ARRAY", "16#9001": "WARNING_ONLY_START", "16#9002": "WARNING_NOTHING_FOUND"}, "user_defined_types": []}
{"title": "Word to 16-Bit Splitter", "name": "LGF_SplitWordToBits", "description": "## Short description ##\n\nThis function splits a Word variable into 16 Boolean / 16 Bit variables.", "type": "FUNCTION", "input": [{"name": "word", "type": "Word", "description": "Bit sequence to be split"}], "output": [{"name": "bit15", "type": "Bool", "description": "Output Bit 15 - MSB"}, {"name": "bit14", "type": "Bool", "description": "Output Bit 14"}, {"name": "bit13", "type": "Bool", "description": "Output Bit 13"}, {"name": "bit12", "type": "Bool", "description": "Output Bit 12"}, {"name": "bit11", "type": "Bool", "description": "Output Bit 11"}, {"name": "bit10", "type": "Bool", "description": "Output Bit 10"}, {"name": "bit9", "type": "Bool", "description": "Output Bit 9"}, {"name": "bit8", "type": "Bool", "description": "Output Bit 8"}, {"name": "bit7", "type": "Bool", "description": "Output Bit 7"}, {"name": "bit6", "type": "Bool", "description": "Output Bit 6"}, {"name": "bit5", "type": "Bool", "description": "Output Bit 5"}, {"name": "bit4", "type": "Bool", "description": "Output Bit 4"}, {"name": "bit3", "type": "Bool", "description": "Output Bit 3"}, {"name": "bit2", "type": "Bool", "description": "Output Bit 2"}, {"name": "bit1", "type": "Bool", "description": "Output Bit 1"}, {"name": "bit0", "type": "Bool", "description": "Output Bit 0 - LSB"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": []}
{"title": "International Date String to DTL Converter", "name": "LGF_StringToDTL_ISO", "description": "## Short description ##\n\nThis function converts a character string in international format with date components into the \ndata type DTL.\n\n## Functional description ##\n\nThe block reads a date as a character string and converts it to the data type DTL. The individual \ndate components in the character string are separated according to the international format. The \nseparator between the components in the character string is irrelevant.", "type": "FUNCTION", "input": [{"name": "date", "type": "String", "description": "Date as a character string according to the format. Example: 22-01-2019 14:07:57.696417000."}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}], "in/out": [], "return_value": [{"type": "DTL", "description": "The converted date and time in the format DTL"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#7000": "STATUS_NO_JOB", "16#8201": "ERR_FORMAT_YEAR", "16#8202": "ERR_FORMAT_MONTH", "16#8203": "ERR_FORMAT_DAY", "16#8204": "ERR_FORMAT_HOUR", "16#8205": "ERR_FORMAT_MINUTE", "16#8206": "ERR_FORMAT_SECOND", "16#8207": "ERR_FORMAT_NANOSECOND"}, "user_defined_types": []}
{"title": "Endianness Detection Function", "name": "LGF_IsBigEndian", "description": "## Short description ##\n\nThe function detects the endianness of the executing system.", "type": "FUNCTION", "input": [], "output": [], "in/out": [], "return_value": [{"type": "Bool", "description": "TRUE if big endianness is detected"}], "status_codes": {}, "user_defined_types": []}
{"title": "N-th root extraction", "name": "LGF_NthRoot", "description": "## Short description ##\n\nThis function extracts the n-th root of a given value.\nThe root is defined as follows:\n =  = ^(1/)\nSTEP 7 (TIA Portal) results in the following formula:\n =  ** (1/)", "type": "FUNCTION", "input": [{"name": "value", "type": "LReal", "description": "Value from which the root should be calculated"}, {"name": "root", "type": "LReal", "description": "Exponent of root"}], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [], "return_value": [{"type": "LReal", "description": "Returns the Nth root of a value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_NEG_VAR"}, "user_defined_types": []}
{"title": "Word Endianness Adjuster", "name": "LGF_SwapBlockWord", "description": "## Short description ##\n\nAdjusts/ switches the endianness of multibyte data typed values.\nFor this to achieve, a loop will iterate through the array elements and swap the bytes \nintrinsically.", "type": "FUNCTION", "input": [], "output": [], "in/out": [{"name": "data", "type": "Array[*] of Word", "description": "Contains the data values, which will be endianness adjusted"}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {}, "user_defined_types": []}
{"title": "Shell Sort for DInt Arrays", "name": "LGF_ShellSort_DInt", "description": "## Short description ##\n\nThis block sorts an array of type DInt with any number of elements (max. 1000) in ascending or \ndescending order and returns the sorted version of the array in the same variable.\n\n## Functional description ##\n\nThe block sorts according to the shell sort procedure. Note that the execution time of the block \ndepends significantly on how many elements the array to be sorted has. The overview below \nshows several measured values of the block depending on the number of array elements.\nAverage steps needed for execution: (  log()^2)\nTable: Execution times of the block LGF_ShellSort\nNumber of array elements S7-1212C DC/DC/DC S7-1516-3 PN/DP\n100 approx. 11-16 ms approx. 1-2 ms\nNumber of array elements S7-1212C DC/DC/DC S7-1516-3 PN/DP\n1000 approx. 185-205 ms approx. 10-12 ms\nNote The block is executed synchronously and is not split over several PLC cycles. Thus the \nexecution time has a direct effect on the PLC cycle time. Note this behavior for your project \nof the controller used and adjust the monitoring time of the controller if necessary.", "type": "FUNCTION", "input": [{"name": "sortDirection", "type": "Bool", "description": "FALSE: Sort ascending; TRUE: Sort descending"}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}], "in/out": [{"name": "array", "type": "Array[*] of DInt", "description": "Array to be sorted"}], "return_value": [], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_NO_ARRAY", "16#8201": "ERR_TOO_MANY_ELEMENTS"}, "user_defined_types": []}
{"title": "Rankine to Kelvin Converter", "name": "LGF_RankineToKelvin", "description": "## Short description ##\n\nThis function converts a temperature value - from Rankine to Kelvin.", "type": "FUNCTION", "input": [{"name": "value", "type": "Real", "description": "Temperature to be converted in Rankine"}], "output": [], "in/out": [], "return_value": [{"type": "Real", "description": "Converted temperature in Kelvin"}], "status_codes": {}, "user_defined_types": []}
{"title": "Pulse Generator", "name": "LGF_Impulse", "description": "## Short description ##\n\nThis function generates pulses at a given frequency. The pulse is always present for one \n(control) cycle.\n\n## Functional description ##\n\nThe function generates pulses at the output impulse with the frequency frequency.\nThe block always begins with a pulse and sets the next pulse after the period that has elapsed.", "type": "FUNCTION_BLOCK", "input": [{"name": "frequency", "type": "Real", "description": "0.0"}], "output": [{"name": "impulse", "type": "Bool", "description": "Impulse signal output"}, {"name": "countdown", "type": "Time", "description": "Time until next pulse"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": []}
{"title": "Numeric Differentiation Function", "name": "LGF_DifferenceQuotientFC", "description": "## Short description ##\n\nThis function numerically differentiates a signal sampled equidistantly in time. For example, the \nvelocity can be calculated from a measured locus curve, or the acceleration can be calculated \nfrom the measured velocity. In order to minimize the effects of a scattering measurement signal, \nthis algorithm uses a compensating polynomial.\nThe function calculates the differentiated values acyclically.\nThe function reads an array that is differentiated.   4 smoothed measured values can be \ncalculated from N measured values. The output array contains the value 0 in the index (0,1,N-\n1,N). However, replacement values can be calculated.\n\n## Functional description ##\n\nTo calculate the difference quotient of a scattering signal, a third-degree compensation \npolynomial is first placed through the measured values. This polynomial is then differentiated. \nWith this method, even a distorted input signal can be sensibly differentiated.\nThe difference quotient is calculated with the following formula:\ny'(n)= $ \\frac {y(n-2)-8y(n-1)+8y(n+1)-y(n+2)}{12 \\cdot deltaT} $ \n: equidistant distance between two measured values (e.g. 1s).\nThe function (FC) can calculate   4 differentiated and smoothed measured values from N \nmeasured values. The output array would be assigned with 0 in the index (0,1,N-1,N). However, \nthe following formalisms can be used to calculate substitute values:\ny'(n-2)= $ \\frac {-125y(n-2)+136y(n-1)+48y(n)-88y(n+1)+29y(n+2)}{84\\cdot deltaT} $ \ny'(n-1)= $ \\frac {-38y(n-2)-2y(n-1)+24y(n)+26y(n+1)-10y(n+2)}{84\\cdot deltaT} $ \ny'(n+1)= $ \\frac {10y(n-2)-26y(n-1)-24y(n)+2y(n+1)+38y(n+2)}{84\\cdot deltaT} $ \ny'(n+2)= $ \\frac {-29y(n-2)+88y(n-1)-48y(n)-136y(n+1)+125y(n+2)}{84\\cdot deltaT} $", "type": "FUNCTION", "input": [{"name": "deltaT", "type": "LReal", "description": "Equidistant distance between two measured values. (e.g. 1s)"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB"}], "in/out": [{"name": "values", "type": "Array[*] of LReal", "description": "Values that will be included in the differentiation."}, {"name": "derivatedValues", "type": "Array[*] of LReal", "description": "The differentiated value range."}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8200": "ERR_DELTA_T Error: Delta time `deltaT` must not be zero.", "16#8400": "ERR_ARRAYS_DIFFERENT Error: The Array sizes are not equal.", "16#8401": "ERR_NOT_ENOUGH_VALUES Error: Not enough values."}, "user_defined_types": []}
{"title": "Device Activation and Deactivation State Machine", "name": "LGF_ActDeactDevice", "description": "## Short description ##\n\nLGF_ActDeactDevice implements a compact state machine to activate and monitor or deactivate \ndecentral devices.\nThe module monitors as well the device connection and error state after activation.\nIt works for PN (S7-1200 / S7-1500) and DP (S7-1500) devices.\n\n## Functional description ##\n\nThe module provides the procedure for activating and deactivating remote IO-Devices in the \nProfinet (PN, S7-1500 & S7-1200) and Profibus (DP, S7-1500) network.\nThe activation of the device (defined at hwId) is initiated by a rising edge at activate, after \ncomplete activation this is indicated at the output isActivated and deviceStateOK. After that the \nconnection status is displayed at the deviceStateOK output.\nThe connection is monitored and in case of a failure of this of more than the set monitoring time \ntimeOutStateMonitoring at the output and reported as an error. After successful recovery of the \nconnection by the system, the configured time is also waited until the error is reset to ensure \nstability.\nNote The connection status of the decentralized device can also be displayed in the TIA Portal \nproject navigation in the PLC, which is the controller, under the item Distributed I/O, if they \nare online with the engineering system.\nDeactivation of the device (defined at hwId) is initiated by a rising edge at deactivate, after \ncomplete activation this is indicated at the output isDeactivated.\nIt is possible to define the states for switching on and off, as well as the monitoring times for \nactivating and deactivating and the connection monitoring.All errors are automatically reset as soon as the faulty state is eliminated.\nThe exception to this are errors that can only be corrected by an intervention in the software, \nsuch as an incorrect or non-existent hardware ID of a non-existent decentralized IO device.", "type": "FUNCTION_BLOCK", "input": [{"name": "enable", "type": "Bool", "description": "Enable functionality of FB"}, {"name": "activate", "type": "Bool", "description": "Rising edge: Activate device given by `hwId`"}, {"name": "deactivate", "type": "Bool", "description": "Rising edge: Deactivate device given by `hwId`"}, {"name": "hwId", "type": "HW_DEVICE", "description": "Hardware ID of the device which should be activated / deactivated"}, {"name": "parameter", "type": "LGF_typeActDeactDeviceParameter", "description": "Parameter dataset for the function `LGF_ActDeactDevice`"}], "output": [{"name": "valid", "type": "Bool", "description": "TRUE: Valid set of output values available at the FB"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is not finished and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status and error identification"}, {"name": "activating", "type": "Bool", "description": "Activation of device active"}, {"name": "isActivated", "type": "Bool", "description": "Device activated"}, {"name": "deactivating", "type": "Bool", "description": "Deactivating of device active"}, {"name": "isDeactivated", "type": "Bool", "description": "Device deactivated"}, {"name": "deviceStateOK", "type": "Bool", "description": "Device is activated and connected to IO-System"}, {"name": "diagnostics", "type": "LGF_typeDiagnostics", "description": "Diagnostic structure to store and transfer diagnostic information from blocks trough the interface."}], "in/out": [], "return_value": [], "status_codes": {"16#7000": "STATUS_NO_CALL: No job being currently processed", "16#7001": "STATUS_FIRST_CALL: First call after incoming new job", "16#7002": "STATUS_SUBSEQUENT_CALL: Subsequent call during active processing", "16#8600": "ERR_UNDEFINED_STATE: Due to an undefined state in state machine", "16#8601": "ERR_LOG2GEO / ERR_GEO2LOG: Log2Geo or Geo2Log error, check diagnostics for more info", "16#8640": "ERR_DEVICE_DEACTIVATING: Error during device deactivation", "16#8641": "ERR_DEVICE_DEACTIVATING_TIME_OUT: Deactivation timeout error", "16#8660": "ERR_DEVICE_ACTIVATING: Error during device activation", "16#8661": "ERR_DEVICE_ACTIVATING_TIME_OUT: Activation timeout error", "16#8662": "ERR_READ_DEVICES_STATES_DURING_ACTIVATION: Error: Read Device states (DeviceStates) during device activation", "16#8670": "ERR_READ_DEVICES_STATES_WHILE_ACTIVE:Error: Read Device states (DeviceStates) while device active", "16#8671": "ERR_DEVICE_STATE_WHILE_ACTIVE: Device states present error and is unreachable, faulty Device or IO-System", "16#8672": "ERR_READ_ACTIVATION_STATE_WHILE_ACTIVE:Activation state (D_ACT_DP) of device is wrong", "16#8690": "ERR_DISABLING_DEACT_DEVICE: Deactivation (D_ACT_DP) of device throws an error while disabling", "16#8691": "ERR_DISABLING_WATCHDOG:Watchdog timer expired while disabling"}, "user_defined_types": [{"name": "LGF_typeActDeactDeviceParameter", "description": "UDT for configuring the behavior of the activation and deactivation process.", "member": [{"name": "timeOutActDeact", "type": "Time", "default": "T#2500ms", "description": "Time to monitor activation and deactivation commands"}, {"name": "timeOutStateMonitoring", "type": "Time", "default": "T#100ms", "description": "Time to monitor device state"}, {"name": "enableAndDeactivate", "type": "Bool", "default": "TRUE", "description": "Disable device during startup"}, {"name": "enableAndActivate", "type": "Bool", "default": "FALSE", "description": "Enable device during startup"}, {"name": "disableAndDeactivate", "type": "Bool", "default": "TRUE", "description": "Disable device during module disabling"}]}, {"name": "LGF_typeDiagnostics", "description": "UDT for diagnostic information from blocks.", "member": [{"name": "status", "type": "Word", "default": "16#0000", "description": "Status of the block or error identification"}, {"name": "subfunctionStatus", "type": "Word", "default": "16#0000", "description": "Status or return value of called blocks"}, {"name": "stateNumber", "type": "DInt", "default": "0", "description": "State in the state machine where error occurred"}]}]}
{"title": "Kelvin to Fahrenheit Converter", "name": "LGF_KelvinToFahrenheit", "description": "## Short description ##\n\nThis function converts a temperature value - from Kelvin to Fahrenheit", "type": "FUNCTION", "input": [{"name": "value", "type": "Real", "description": "Temperature to be converted in Kelvin"}], "output": [], "in/out": [], "return_value": [{"type": "Real", "description": "Converted temperature in Fahrenheit"}], "status_codes": {}, "user_defined_types": []}
{"title": "Fahrenheit to Celsius Converter", "name": "LGF_FahrenheitToCelsius", "description": "## Short description ##\n\nThis function converts a temperature value - from Fahrenheit to Celsius.", "type": "FUNCTION", "input": [{"name": "value", "type": "Real", "description": "Temperature to be converted in Fahrenheit"}], "output": [], "in/out": [], "return_value": [{"type": "Real", "description": "Converted temperature in Celsius"}], "status_codes": {}, "user_defined_types": []}
{"title": "Fahrenheit to Kelvin Converter", "name": "LGF_FahrenheitToKelvin", "description": "## Short description ##\n\nThis function converts a temperature value - from Fahrenheit to Kelvin.", "type": "FUNCTION", "input": [{"name": "value", "type": "Real", "description": "Temperature to be converted in Fahrenheit"}], "output": [], "in/out": [], "return_value": [{"type": "Real", "description": "Converted temperature in Kelvin"}], "status_codes": {}, "user_defined_types": []}
{"title": "Julian Date to DTL Time Converter", "name": "LGF_JulianTimeToDTL", "description": "## Short description ##\n\nThis function converts a given Julian Date (regular or modified) of data type LReal (Double) to a \ndate and time of data type DTL.\nThe timestamp is calculated based on UTC. This means that the time zone is not considered.\nOnly times after 01/01/1990 are permitted.", "type": "FUNCTION", "input": [{"name": "julianDate", "type": "LReal", "description": "Julian date to convert (standard or modified, depends on isModifiedDate)"}, {"name": "isModifiedDate", "type": "Bool", "description": "TRUE: julianDate is the modified Julian date FALSE: julianDate is the regular Julian date"}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}], "in/out": [], "return_value": [{"type": "DTL", "description": "Converted time (Date and time). In case of Error DTL default value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#6001": "WARN_CONVERSION_LIMIT", "16#8000": "ERR_TIME_BEFORE_1990"}, "user_defined_types": []}
{"title": "Bit toggle operation in DWORD", "name": "LGF_BitToggle", "description": "## Short description ##\n\nThis block toggles (from TRUE to FALSE and viceversa) a bit at a predefined position in a variable of the data type DWORD.\nAlternatively, Word and Byte can be used instead of DWord by converting the passed\nparameter with, for example, BYTE_TO_DWORD and the result with DWORD_TO_BYTE", "type": "FUNCTION", "input": [{"name": "value", "type": "DWord", "description": "Tag where the bit has to be toggled"}, {"name": "bitNo", "type": "USInt", "description": "Bit number to be toggled in the value parameter."}], "output": [], "in/out": [], "return_value": [{"type": "DWord", "description": "Tag with toggled bit"}], "status_codes": {}, "user_defined_types": []}
{"title": "Frequency Signal Generator", "name": "LGF_Frequency", "description": "## Short description ##\n\nThis function generates a signal that changes between the values FALSE and TRUE depending on \na defined frequency and a pulse pause ratio.\n\n## Functional description ##\n\nThe clock output is a Boolean value that toggles at the desired frequency. The pulsePauseRatio\ninput is used to set the pulse pause ratio.\nThe output countdown outputs the remaining time of the current state of clock.\nIf the desired frequency or pulse pause ratio is less than or equal to 0.0, the output clock = \nFALSE and countdown = 0s.", "type": "FUNCTION_BLOCK", "input": [{"name": "frequency", "type": "Real", "description": "0.0"}, {"name": "pulsePauseRatio", "type": "Real", "description": "1.0"}], "output": [{"name": "clock", "type": "Bool", "description": "Output changes with defined frequency."}, {"name": "countdown", "type": "Time", "description": "Remaining time of the current clock state."}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": []}
{"title": "DWord to 32-Bit Splitter", "name": "LGF_SplitDWordToBits", "description": "## Short description ##\n\nThis function splits a DWord variable into 32 Boolean / 32 Bit variables.", "type": "FUNCTION", "input": [{"name": "doubleWord", "type": "DWord", "description": "Bit sequence to be split"}], "output": [{"name": "bit31", "type": "Bool", "description": "Output Bit 31 - MSB"}, {"name": "bit30", "type": "Bool", "description": "Output Bit 30"}, {"name": "bit29", "type": "Bool", "description": "Output Bit 29"}, {"name": "bit28", "type": "Bool", "description": "Output Bit 28"}, {"name": "bit27", "type": "Bool", "description": "Output Bit 27"}, {"name": "bit26", "type": "Bool", "description": "Output Bit 26"}, {"name": "bit25", "type": "Bool", "description": "Output Bit 25"}, {"name": "bit24", "type": "Bool", "description": "Output Bit 24"}, {"name": "bit23", "type": "Bool", "description": "Output Bit 23"}, {"name": "bit22", "type": "Bool", "description": "Output Bit 22"}, {"name": "bit21", "type": "Bool", "description": "Output Bit 21"}, {"name": "bit20", "type": "Bool", "description": "Output Bit 20"}, {"name": "bit19", "type": "Bool", "description": "Output Bit 19"}, {"name": "bit18", "type": "Bool", "description": "Output Bit 18"}, {"name": "bit17", "type": "Bool", "description": "Output Bit 17"}, {"name": "bit16", "type": "Bool", "description": "Output Bit 16"}, {"name": "bit15", "type": "Bool", "description": "Output Bit 15"}, {"name": "bit14", "type": "Bool", "description": "Output Bit 14"}, {"name": "bit13", "type": "Bool", "description": "Output Bit 13"}, {"name": "bit12", "type": "Bool", "description": "Output Bit 12"}, {"name": "bit11", "type": "Bool", "description": "Output Bit 11"}, {"name": "bit10", "type": "Bool", "description": "Output Bit 10"}, {"name": "bit9", "type": "Bool", "description": "Output Bit 9"}, {"name": "bit8", "type": "Bool", "description": "Output Bit 8"}, {"name": "bit7", "type": "Bool", "description": "Output Bit 7"}, {"name": "bit6", "type": "Bool", "description": "Output Bit 6"}, {"name": "bit5", "type": "Bool", "description": "Output Bit 5"}, {"name": "bit4", "type": "Bool", "description": "Output Bit 4"}, {"name": "bit3", "type": "Bool", "description": "Output Bit 3"}, {"name": "bit2", "type": "Bool", "description": "Output Bit 2"}, {"name": "bit1", "type": "Bool", "description": "Output Bit 1"}, {"name": "bit0", "type": "Bool", "description": "Output Bit 0 - LSB"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": []}
{"title": "16-Bit to Word Merger", "name": "LGF_MergeBitsToWord", "description": "## Short description ##\n\nThis function merge 16 Bits / 16 Boolean variables into one Word variable.", "type": "FUNCTION", "input": [{"name": "bit15", "type": "Bool", "description": "Input Bit 15 - MSB"}, {"name": "bit14", "type": "Bool", "description": "Input Bit 14"}, {"name": "bit13", "type": "Bool", "description": "Input Bit 13"}, {"name": "bit12", "type": "Bool", "description": "Input Bit 12"}, {"name": "bit11", "type": "Bool", "description": "Input Bit 11"}, {"name": "bit10", "type": "Bool", "description": "Input Bit 10"}, {"name": "bit9", "type": "Bool", "description": "Input Bit 9"}, {"name": "bit8", "type": "Bool", "description": "Input Bit 8"}, {"name": "bit7", "type": "Bool", "description": "Input Bit 7"}, {"name": "bit6", "type": "Bool", "description": "Input Bit 6"}, {"name": "bit5", "type": "Bool", "description": "Input Bit 5"}, {"name": "bit4", "type": "Bool", "description": "Input Bit 4"}, {"name": "bit3", "type": "Bool", "description": "Input Bit 3"}, {"name": "bit2", "type": "Bool", "description": "Input Bit 2"}, {"name": "bit1", "type": "Bool", "description": "Input Bit 1"}, {"name": "bit0", "type": "Bool", "description": "Input Bit 0 - LSB"}], "output": [], "in/out": [], "return_value": [{"type": "Word", "description": "Composite Bit sequence stored as Word variable"}], "status_codes": {}, "user_defined_types": []}
{"title": "2-Byte to Word Merger", "name": "LGF_MergeBytesToWord", "description": "## Short description ##\n\nThis function merge 2 Byte variables into one Word variable", "type": "FUNCTION", "input": [{"name": "byte1", "type": "Byte", "description": "Input Byte 1 - MSB"}, {"name": "byte0", "type": "Byte", "description": "Input Byte 0 - LSB"}], "output": [], "in/out": [], "return_value": [{"type": "Word", "description": "Composite Byte sequence stored as Word variable"}], "status_codes": {}, "user_defined_types": []}
{"title": "Rectangle Signal Generator", "name": "LGF_RectangleCI", "description": "## Short description ##\n\nThis function generates a rectangular signal profile. For this it uses the time interval of the \ncalling Cyclic Interrupt OB.\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nThe block calculates the values for a rectangular signal profile, which is output to the output \nparameter value.\nThe amplitude, the offset in the Y-direction, the period, and the phase shift can be set at the \ninput parameters.\nThe input parameter reset resets the signal profile. At the value output parameter, the value 0 is \noutput as long as reset is set to TRUE.\nThe block must be called in a cyclic interrupt OB. The time interval of the calling cyclic interrupt \nOB is determined in the FB with the command QRY_CINT. For this, the constant name of the \ncalling cyclic interrupt OB must be interconnected at the input parameter callOB.\nThe number of calculated values of the signal profile per period duration is calculated as follows:\n =\n\n/\nNote To obtain a continuous signal profile of the curve, the time interval of the cyclic interrupt OB \nshould not be selected too large depending on the period duration.\nThe Figure below shows the signal profile of the calculated values.", "type": "FUNCTION_BLOCK", "input": [{"name": "amplitude", "type": "Real", "description": "1.0"}, {"name": "offset", "type": "Real", "description": "0.0"}, {"name": "periode", "type": "UDInt", "description": "1000"}, {"name": "phaseShift", "type": "Real", "description": "0.0"}, {"name": "callOB", "type": "OB_CYCLIC", "description": ""}, {"name": "reset", "type": "Bool", "description": "FALSE"}], "output": [{"name": "value", "type": "Real", "description": "Current value of the rectangular signal."}, {"name": "error", "type": "Bool", "description": "FALSE: No error"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB 16#8000-16#FFFF: Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8600": "ERR_OB_UNAVAILABLE", "16#8601": "ERR_QRY_CINT"}, "user_defined_types": []}
{"title": "Shell Sort for LReal Arrays", "name": "LGF_ShellSort_LReal", "description": "## Short description ##\n\nThis block sorts an array of type LReal with any number of elements (max. 1000) in ascending \nor descending order and returns the sorted version of the array in the same variable.\n\n## Functional description ##\n\nThe block sorts according to the shell sort procedure. Note that the execution time of the block \ndepends significantly on how many elements the array to be sorted has. The overview below \nshows several measured values of the block depending on the number of array elements.\nAverage steps needed for execution: (  log()^2)\nTable: Execution times of the block LGF_ShellSort\nNumber of array elements S7-1212C DC/DC/DC S7-1516-3 PN/DP\n100 approx. 11-16 ms approx. 1-2 ms\n1000 approx. 185-205 ms approx. 10-12 ms\nNote The block is executed synchronously and is not split over several PLC cycles. Thus the \nexecution time has a direct effect on the PLC cycle time. Note this behavior for your project \nof the controller used and adjust the monitoring time of the controller if necessary.", "type": "FUNCTION", "input": [{"name": "sortDirection", "type": "Bool", "description": "FALSE: Sort ascending; TRUE: Sort descending"}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}], "in/out": [{"name": "array", "type": "Array[*] of LReal", "description": "Array to be sorted"}], "return_value": [], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_NO_ARRAY", "16#8201": "ERR_TOO_MANY_ELEMENTS"}, "user_defined_types": []}
{"title": "Sinusoidal Signal Generator", "name": "LGF_SinusCI", "description": "## Short description ##\n\nThis function generates a sinusoidal signal profile. For this it uses the time interval of the calling \nCyclic Interrupt OB.\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nThe block calculates the values for a sinusoidal signal profile, which is output to the output \nparameter value.\nThe amplitude, the offset in the Y-direction, the period (in ms) and the phase shift (in ms) can \nbe set at the input parameters.\nThe input parameter reset resets the signal profile. At the value output parameter, the value 0 is \noutput as long as reset is set to TRUE.\nThe block must be called in a cyclic interrupt OB. The time interval of the calling cyclic interrupt \nOB is determined in the FB with the command QRY_CINT. For this, the constant name of the \ncalling cyclic interrupt OB must be interconnected at the input parameter callOB.\nThe number of calculated values of the signal profile per period duration is calculated as follows:\n =\n\n/\nNote To obtain a continuous signal profile of the curve, the time interval of the cyclic interrupt OB \nshould not be selected too large depending on the period duration.The Figure below shows the signal profile of the calculated values.", "type": "FUNCTION_BLOCK", "input": [{"name": "amplitude", "type": "Real", "description": "1.0"}, {"name": "offset", "type": "Real", "description": "0.0"}, {"name": "periode", "type": "UDInt", "description": "1000"}, {"name": "phaseShift", "type": "Real", "description": "0.0"}, {"name": "callOB", "type": "OB_CYCLIC", "description": ""}, {"name": "reset", "type": "Bool", "description": "FALSE"}], "output": [{"name": "value", "type": "Real", "description": "Current value of the sinusoidal signal."}, {"name": "error", "type": "Bool", "description": "FALSE: No error"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB 16#8000-16#FFFF: Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8600": "ERR_OB_UNAVAILABLE", "16#8601": "ERR_QRY_CINT"}, "user_defined_types": []}
{"title": "German public holiday detection", "name": "LGF_IsGermanHoliday", "description": "## Short description ##\n\nThe function determines whether a given date is a public holiday.\nAll public holidays in Germany are taken into account.\nHolidays that are NOT uniform nationwide can be switched on or off\n\n## Functional description ##\n\nThe block calculates the public holiday calendar of the year for a given date and displays whether the given date is a public holiday.\nOptionally, holidays that are not uniform nationwide, such as Epiphany (Three Kings), can be taken into account via the appropriate input parameters in the block.", "type": "FUNCTION", "input": [{"name": "date", "type": "DTL", "description": "Date, which has to be evaluated"}, {"name": "threeKings", "type": "Bool", "description": "Three Kings"}, {"name": "roseMonday", "type": "Bool", "description": "Rose Monday"}, {"name": "ascension", "type": "Bool", "description": "Ascension"}, {"name": "corpusChristi", "type": "Bool", "description": "Corpus Christi"}, {"name": "augsburgerFriedensfest", "type": "Bool", "description": "Augsburger Friedensfest"}, {"name": "assumptionOfMary", "type": "Bool", "description": "Assumption Of Mary"}, {"name": "reformationDay", "type": "Bool", "description": "Reformation Day"}, {"name": "allSaintDay", "type": "Bool", "description": "All Saint Day"}, {"name": "bussUndBettag", "type": "Bool", "description": "Day of Prayer and Repentance (Buss und Bettag)"}], "output": [], "in/out": [], "return_value": [{"type": "Bool", "description": "If the date at the input parameter is a public holiday - returning TRUE, otherwise returning FALSE"}], "status_codes": {}, "user_defined_types": []}
{"title": "Gray to Binary Code Converter", "name": "LGF_GrayToBinary", "description": "## Short description ##\n\nThis function converts a gray coded value into a binary coded value.", "type": "FUNCTION", "input": [{"name": "variableGray", "type": "DWord", "description": "Gray coded value to convert to binary value"}], "output": [], "in/out": [], "return_value": [{"type": "DWord", "description": "Binary value"}], "status_codes": {}, "user_defined_types": []}
{"title": "Random Real Range Number Generator", "name": "LGF_RandomRange_Real", "description": "## Short description ##\n\nThis function generates a random value in defined limits with each call.\nThe random number has the data type Real in the specified range.\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nThe block generates random values that are between the specified minValue and the maxValue. \nThis random value is output via the Ret_Val.The random value is formed from the nanoseconds of the current system time of the CPU. The byte order of this value is inverted and then converted to a floating point.", "type": "FUNCTION", "input": [{"name": "minValue", "type": "Real", "description": "Minimum value of the range of the random number - lower border"}, {"name": "maxValue", "type": "Real", "description": "Maximum value of the range of the random number - upper border"}], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called blocks"}], "in/out": [], "return_value": [{"type": "Real", "description": "Random Real number in the predefined range"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8200": "ERR_MAX_LESS_MIN", "16#8600": "ERR_RD_SYS_T"}, "user_defined_types": []}
{"title": "Boxplot Calculation for Real Data", "name": "LGF_Boxplot_LReal", "description": "## Short description ##\n\nIf you want to get an overview of existing data, you can use a Boxplot diagram. A Boxplot shows \nyou in which area the data is located and how it is distributed over this area. A Boxplot consists \nof the following parameters:\n Minimum (smallest occurring value of the sample)\n Lower or first quartile (below this value are 25% of the sample values)\n Median or second quartile (below this value are 50% of the sample values)\n Upper or third quartile (below this value are 75% of the sample values)\n Maximum (largest occurring value of the sample)\nFigure: Boxplot\n\n## Functional description ##\n\nThe block sorts the data series and then calculates the so-called five-point summary:\nTable: Five-point summary\nCharacteristic value of the five-point summary Output parameter of the block\nMinimum (smallest occurring value of the sample) min\nLower or first quartile (below this value are 25% of \nthe sample values)\nq25\nMedian or second quartile (below this value are \n50% of the sample values)\nmedian\nUpper or third quartile (below this value are 75% of \nthe sample values)\nq75\nMaximum (largest occurring value of the sample) max\nIf outlier detection is activated, the block first calculates the limits. From these limit values, the \nvalues are recognized as outliers:\n\nThe block then calculates new values for the parameters max and min, which lie within the outlier \nlimits. The outliers are counted and output as a percentage.\nTo make it easier to judge how the data is distributed, the block also calculates the skew. The \nskewness lies between the values -1 and 1 with the following meaning:\n -1: extremely left skewed distribution\n 0: symmetrical distribution\n 1: extreme right-skew distribution\nThe elements of the passed array are sorted in ascending order by the block. The \nLGF_Shellsort_LReal block is used for sorting.\nThe parameters are calculated as follows:\nTable: Boxplot formulas Parameters Formula", "type": "FUNCTION_BLOCK", "input": [{"name": "execute", "type": "Bool", "description": "Activation of the calculation with each positive edge."}, {"name": "rangeOutlier", "type": "LReal", "description": "Outlier detection parameter."}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "outlierMax", "type": "LReal", "description": "Upper outliers in %"}, {"name": "max", "type": "LReal", "description": "Maximum Value, not an outlier."}, {"name": "q75", "type": "LReal", "description": "3rd quartile or Q75 of the data series."}, {"name": "median", "type": "LReal", "description": "2nd quartile or Median of the data series."}, {"name": "q25", "type": "LReal", "description": "1st quartile or Q25 of the data series."}, {"name": "min", "type": "LReal", "description": "Minimum Value, not an outlier."}, {"name": "outlierMin", "type": "LReal", "description": "Lower outliers in %"}, {"name": "skewness", "type": "LReal", "description": "Skewness of the data series."}], "in/out": [{"name": "values", "type": "Array[*] of LReal", "description": "The array containing the data series for calculation"}], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED", "16#7000": "STATUS_NO_CALL", "16#7001": "STATUS_FIRST_CALL", "16#8200": "ERR_NEG_ARR_BOUND", "16#8600": "ERR_SHELL_SORT", "16#9101": "ERR_RANGE_NOT_OK"}, "user_defined_types": []}
{"title": "String Extractor from Character Array", "name": "LGF_ExtractStringFromCharArray", "description": "## Short description ##\n\nThe function extracts a String specified by a text before and after from an array", "type": "FUNCTION", "input": [{"name": "textBefore", "type": "String", "description": "Text in front of the characters which has to be extracted"}, {"name": "textAfter", "type": "String", "description": "Text behind the characters which has to be extracted"}], "output": [{"name": "extractedString", "type": "String", "description": "Extracted string"}, {"name": "status", "type": "Word", "description": "Status of the FB"}], "in/out": [{"name": "searchIn", "type": "Variant", "description": "Array of Character or Byte to search in"}], "return_value": [{"type": "Word", "description": "Status of the FB"}], "status_codes": {"16#0000": "STATUS_TEXT_FOUND", "16#8200": "ERR_NO_ARRAY", "16#9001": "WARNING_ONLY_START", "16#9002": "WARNING_NOTHING_FOUND"}, "user_defined_types": []}
{"title": "Odd Parity Checker for DWord", "name": "LGF_IsParityOdd", "description": "## Short description ##\n\nThe function checks whether the parity of the input variable of type DWord is odd. The return \nvalue is set to TRUE if the number of bits that are assigned TRUE in the sequence is odd.", "type": "FUNCTION", "input": [{"name": "doubleWord", "type": "DWord", "description": "Variable for which the parity is to be determined."}], "output": [], "in/out": [], "return_value": [{"type": "Bool", "description": "TRUE: When the number of bits that are assigned `TRUE` is odd"}], "status_codes": {"16#0000": "STATUS_NO_ERROR"}, "user_defined_types": []}
{"title": "Byte to 8-Bit Splitter", "name": "LGF_SplitByteToBits", "description": "## Short description ##\n\nThis function splits a Byte variable into 8 Boolean / 8 Bit variables.", "type": "FUNCTION", "input": [{"name": "byte", "type": "Byte", "description": "Bit sequence to be split"}], "output": [{"name": "bit7", "type": "Bool", "description": "Output Bit 7 - MSB"}, {"name": "bit6", "type": "Bool", "description": "Output Bit 6"}, {"name": "bit5", "type": "Bool", "description": "Output Bit 5"}, {"name": "bit4", "type": "Bool", "description": "Output Bit 4"}, {"name": "bit3", "type": "Bool", "description": "Output Bit 3"}, {"name": "bit2", "type": "Bool", "description": "Output Bit 2"}, {"name": "bit1", "type": "Bool", "description": "Output Bit 1"}, {"name": "bit0", "type": "Bool", "description": "Output Bit 0 - LSB"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": []}
{"title": "Matrix Comparator", "name": "LGF_MatrixCompare", "description": "## Short description ##\n\nThis function compares two matrices of the data type ARRAY[*,*] of LREAL of equal size.\nIf both matrices are identical, the return value of the function is set to TRUE.\nNote Note that all input matrices must have the same lower and upper limit, and, therefore, the \nsame number of columns and rows.", "type": "FUNCTION", "input": [], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "matrix1", "type": "Array[*, *] of LReal", "description": "First Matrix"}, {"name": "matrix2", "type": "Array[*, *] of LReal", "description": "Second Matrix"}], "return_value": [{"type": "Bool", "description": "TRUE: Both matrices are identical."}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_MATR1_LOWBOUND_ROWS_MATR2_LOWBOUND_ROWS", "16#8201": "ERR_MATR1_LOWBOUND_COLUMNS_MATR2_LOWBOUND_COLUMNS", "16#8202": "ERR_MATR1_UPPBOUND_ROWS_MATR2_UPPBOUND_ROWS", "16#8203": "ERR_MATR1_UPPBOUND_COLUMNS_MATR2_UPPBOUND_COLUMNS"}, "user_defined_types": []}
{"title": "Advanced Rate of Change Limiter", "name": "LGF_LimRateOfChangeAdvancedCI", "description": "## Short description ##\n\nThe function LGF_LimRateOfChangeAdvanced limits the rate of change of an input variable. Jump \nfunctions become ramp functions. In addition, the block has various operating modes.\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nFor the positive/negative value range, two rates of change in each case for the ramp (rising and \nfalling values) can be parameterized. The following operating modes can be selected via control \ninputs:\n Restart\n Pre-assigning an output\n Normal operation (automatic)\n Switch through controlled variable (manual)\n Tracking\nThe output variable can be limited through two parametrize able limits. An active limitation of the \nrate of change of a ramp, as well as an active limitation of the output variable are reported via \noutputs.\nThe time interval of the calling cyclic interrupt OB is determined by interconnecting the calling \ncyclic interrupt OB at the input parameter callOB.\nRestart\nAt restart reset = TRUE, the output outputValue is reset to 0.0.\nIf enDefaultOutValue = TRUE is set, defaultOutValue is output. All signal outputs are set to \nFALSE.\nPre-assigning an output\nIf enDefaultOutValue = TRUE is set, the value at defaultOutValue is output. When changing \nfrom TRUE to FALSE, outputValue is ramped from defaultOutValue to autoValue. When changing \nfrom FALSE to TRUE, the output outputValue immediately jumps to defaultOutValue.\nNormal operation\nThe ramps are straight lines of limitation and are based on a rate of change per second; if, for \nexample, the parameter setPosUpRateLim = 10.0 is assigned, then at a sampling time of \n1s/100ms/10ms, 10.0/1.0/0.1 will be added to outputValue at each block call, if autoValue > \noutputValue, until autoValue is reached.\nThe limitation of the rate of change can be parameterized in both positive and negative ranges \nfor the increase and decrease.\nTable: Marking of the ramps\nParameters Ramp\nsetPosUpRateLim outputValue > 0.0 and |outputValue| rising\nsetPosDownRateLim\noutputValue > 0.0 and |outputValue| falling\nsetNegUpRateLim outputValue < 0.0 and |outputValue| rising\nsetNegDownRateLim\noutputValue < 0.0 and |outputValue| falling\nIf the ramps are not parameterized (setPosUpRateLim, setPosDownRateLim, setNegUpRateLim, \nand setNegDownRateLim equal 0.0), the output remains at 0.0 and normal operation is disabled.\nTracking\nIf the input track = TRUE is set, the input variable autoValue is interconnected directly to the \noutput variable outputValue. Thus, jumps of the input variable will also be output.\nSwitch through controlled variable\nIf manOp = TRUE is set, the controlled variable manualValue is interconnected directly to the \noutput variable outputValue.\nIn this operating mode, the parameterization of the ramps or the high/low limitation of the output \nvariable, and the pre-assignment of the output, are ineffective.\nWhen changing from TRUE to FALSE, the output outputValue is ramped again after autoValue.\nAs soon as the value range between the low and high limits is reached, the high and low limits \nare reactivated.\nFigure: Ramp function sequence, operating modes", "type": "FUNCTION_BLOCK", "input": [{"name": "autoValue", "type": "LReal", "description": "Signal to be processed and limited in its rate of change"}, {"name": "manualValue", "type": "LReal", "description": "Manually controlled output value"}, {"name": "posUpRateLim", "type": "LReal", "description": "Rate of change per second for the rising ramp in the positive value range"}, {"name": "posDownRateLim", "type": "LReal", "description": "Rate of change per second for the falling ramp in the positive value range"}, {"name": "negUpRateLim", "type": "LReal", "description": "Rate of change per second for the rising ramp in the negative value range"}, {"name": "negDownRateLim", "type": "LReal", "description": "Rate of change per second for the falling ramp in the negative value range"}, {"name": "highLim", "type": "LReal", "description": "High limit value"}, {"name": "lowLim", "type": "LReal", "description": "Low limit value"}, {"name": "defaultOutValue", "type": "LReal", "description": "Value for pre-assignment of the output variable"}, {"name": "enDefaultOutValue", "type": "Bool", "description": "Assign default output value"}, {"name": "track", "type": "Bool", "description": "Follow / tracking of Input variable"}, {"name": "manOp", "type": "Bool", "description": "Manual mode on"}, {"name": "reset", "type": "Bool", "description": "Complete restart of function"}, {"name": "callOB", "type": "OB_CYCLIC", "description": "Calling wake-alarm interrupt OB"}], "output": [{"name": "outputValue", "type": "LReal", "description": "Output variable"}, {"name": "posUpRateLim", "type": "Bool", "description": "Rise limitation in positive range tripped"}, {"name": "posDownRateLim", "type": "Bool", "description": "Down rate limit in positive range reached"}, {"name": "negUpRateLim", "type": "Bool", "description": "Up rate limit in negative range reached"}, {"name": "negDownRateLim", "type": "Bool", "description": "Down rate limit in negative range reached"}, {"name": "highLim", "type": "Bool", "description": "High limit reached"}, {"name": "lowLim", "type": "Bool", "description": "Low limit reached"}, {"name": "error", "type": "Bool", "description": "Error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8200": "ERR_NEG_RATE_LIM", "16#8202": "ERR_NEG_RATE_OF_CHANGE", "16#8600": "ERR_QRY_CINT", "16#8601": "ERR_OB_UNAVAILABLE"}, "user_defined_types": [{"name": "LGF_typeNonLinSetpoints", "description": "Data type for setup a setpoint table for function", "member": [{"name": "inputValue", "type": "LReal", "default": "0.0", "description": "Input value to be interpolated"}, {"name": "outputValue", "type": "LReal", "default": "0.0", "description": "Corresponding interpolated value"}]}]}
{"title": "WString to UTF-8 Byte Stream Encoder", "name": "LGF_EncodeUtf8", "description": "## Short description ##\n\nEncodes a WString into an UTF-8 encoded byte stream.", "type": "FUNCTION", "input": [{"name": "sourceString", "type": "WString", "description": "Character that shall be converted to UTF-8"}, {"name": "startPos", "type": "DInt", "description": "Position in encoded byte stream to start insert encoded WChars (Array lower bound is added)"}], "output": [{"name": "bytesUsed", "type": "UInt", "description": "Number of Bytes converted. Ranges from 1 to 3."}], "in/out": [{"name": "encodedByteStream", "type": "Array[*] of Byte", "description": "UTF-8 conformant byte sequence."}], "return_value": [{"type": "Word", "description": "Status of the FC, Erroridentification"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8201": "ERR_START_POS_OUTSIDE", "16#8202": "ERR_COUNT_EXCEEDS_BOUNDS"}, "user_defined_types": []}
{"title": "Triangular Signal Generator", "name": "LGF_TriangleCI", "description": "## Short description ##\n\nThis function generates a triangular signal profile. For this it uses the time interval of the calling \nCyclic Interrupt OB.\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nThe block calculates the values for a triangular signal profile, which is output to the output \nparameter value.\nThe amplitude, the offset in the Y-direction, the period, and the phase shift can be set at the \ninput parameters.\nThe input parameter reset resets the signal profile. At the value output parameter, the value 0 is \noutput as long as reset is set to TRUE.\nThe block must be called in a cyclic interrupt OB. The time interval of the calling cyclic interrupt \nOB is determined in the FB with the command QRY_CINT. For this, the constant name of the \ncalling cyclic interrupt OB must be interconnected at the input parameter callOB.\nThe number of calculated values of the signal profile per period duration is calculated as follows:\n =\n\n/\nNote To obtain a continuous signal profile of the curve, the time interval of the cyclic interrupt OB \nshould not be selected too large depending on the period duration.The Figure below shows the signal profile of the calculated values.", "type": "FUNCTION_BLOCK", "input": [{"name": "amplitude", "type": "Real", "description": "1.0"}, {"name": "offset", "type": "Real", "description": "0.0"}, {"name": "periode", "type": "UDInt", "description": "1000"}, {"name": "phaseShift", "type": "Real", "description": "0.0"}, {"name": "callOB", "type": "OB_CYCLIC", "description": ""}, {"name": "reset", "type": "Bool", "description": "FALSE"}], "output": [{"name": "value", "type": "Real", "description": "Current value of the triangular signal."}, {"name": "error", "type": "Bool", "description": "FALSE: No error"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB 16#8000-16#FFFF: Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8600": "ERR_OB_UNAVAILABLE", "16#8601": "ERR_QRY_CINT"}, "user_defined_types": []}
{"title": "DWORD bit count operation", "name": "LGF_BitCount", "description": "## Short description ##\n\nThis block counts in a variable of type DWord how many bits are set (TRUE) and how many are \nnot set (FALSE) and outputs the number at the outputs.\nInstead of DWord, Word and Byte can also be used by converting the past parameter with e.g. \nBYTE_TO_DWORD and connecting the corresponding bit length of the data type at the \nparameter numberOfBits.\nByte=8, Word=16, DWord=32", "type": "FUNCTION", "input": [{"name": "value", "type": "DWord", "description": "Tag where the bit states has to be counted"}, {"name": "numberOfBits", "type": "USInt", "description": "Number of bits in input tag \"value\" (bit size of Datatype), in case of Byte=8, Word=16, DWord=32"}], "output": [{"name": "countBitsFalse", "type": "USInt", "description": "Number of bits are FALSE in input tag \"value\""}, {"name": "countBitsTrue", "type": "USInt", "description": "Number of bits are TRUE in input tag \"value\""}], "in/out": [], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {}, "user_defined_types": []}
{"title": "Advanced CRC-16 Calculator", "name": "LGF_CalcCRC16Advanced", "description": "## Short description ##\n\nThe CRC calculation is used for error detection at data transmission. The result of a calculation \nreturns a CRC value via the data sent. The receiver detects a faulty transmission due to the \nunequal CRC value. The function LGF_CalcCRC16Advanced uses 16 bits as the generator \npolynomial (mask) and the parameters finalXorValue, reflectInput, and reflectResult.\n\n## Functional description ##\n\nThe function calculates the CRC value from a data stream of any size. The data stream is \ncomposed of the individual elements of the array at the input/output parameter array. The start \nvalue initValue and the generator polynomial mask can be freely selected.\nVia the Boolean input parameters reflectInput and reflectResult, you may optionally mirror \nthe bits of the input data or the CRC value. An XOR operation is also performed with the CRC \nvalue at the end and the value finalXorValue.\nThe input noOfELements can be used to specify the desired number of elements for calculation, it \napplies:\n <= (   + 1)\nNote Various online tools are available for calculating the CRC values. The function of the block \nwas tested with the following online tool, since it supports the input parameters mask\n(Polynomial) and initValue (Initial Value):\nhttp://www.sunshine2k.de/coding/javascript/crc/crc_js.html", "type": "FUNCTION", "input": [{"name": "initValue", "type": "Word", "description": "Start value for the calculation"}, {"name": "mask", "type": "Word", "description": "Generator polynomial for the calculation"}, {"name": "finalXorValue", "type": "Word", "description": "Value for final XOR operation"}, {"name": "reflectInput", "type": "Bool", "description": "Mirror the bits within the input byte"}, {"name": "reflectResult", "type": "Bool", "description": "Mirror the order of the bits within the result"}, {"name": "noOfElements", "type": "UInt", "description": "Number of elements to be used in CRC calculation"}], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "array", "type": "Array[*] of Byte", "description": "Data stream for which the CRC value will be calculated"}], "return_value": [{"type": "Word", "description": "Calculated CRC value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8400": "ERR_NO_OF_ELEMENTS"}, "user_defined_types": []}
{"title": "TADDR_Param to String Converter", "name": "LGF_TaddrToString", "description": "## Short description ##\n\nThe system data type TADDR_Param contains address information consisting of an IPV4 address \nand the port number.\nThe LGF_TaddrToString function converts a TADDR_Param system data type variable to a String\ndata type variable.\n\n## Functional description ##\n\nThe function converts the IPV4 address with or without port number. The system data type \nTADDR_Param is a structured data type. This structure contains the variable REM_PORT_NR. If this \nvariable is 0, no port is written to the parameter Ret_Val.", "type": "FUNCTION", "input": [{"name": "ipAdressTaddr", "type": "TADDR_Param", "description": "IP-Address and Port number to convert into string"}], "output": [], "in/out": [], "return_value": [{"type": "String", "description": "IP-Address and Port number as string"}], "status_codes": {}, "user_defined_types": []}
{"title": "German Traditional Date String to DTL Converter", "name": "LGF_StringToDTL_DE", "description": "## Short description ##\n\nThis function converts a character string in the traditional format (DE) with date components into \nthe data type DTL.", "type": "FUNCTION", "input": [{"name": "date", "type": "String", "description": "Date as a character string according to the format. Example: 22-01-2019 14:07:57.696417000."}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}], "in/out": [], "return_value": [{"type": "DTL", "description": "The converted date and time in the format DTL"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#7000": "STATUS_NO_CURRENT_JOBS", "16#8201": "ERR_FORMAT_YEAR", "16#8202": "ERR_FORMAT_MONTH", "16#8203": "ERR_FORMAT_DAY", "16#8204": "ERR_FORMAT_HOUR", "16#8205": "ERR_FORMAT_MINUTE", "16#8206": "ERR_FORMAT_SECOND", "16#8207": "ERR_FORMAT_NANOSECOND"}, "user_defined_types": []}
{"title": "Moving Average Calculation Function Block", "name": "LGF_FloatingAverage", "description": "## Short description ##\n\nThis function calculates a moving arithmetic mean value from REAL values. This method can be \nused to smooth data series. The values can be read in cyclically or triggered.\n\n## Functional description ##\n\nNote The block LGF_FloatingAverage does not query the data type for the input parameter value. \nFor data types other than REAL, either an implicit conversion is performed automatically or \nan error is generated during compilation.\nYou can find further information in the Chapter Overview of Data Type Conversion in the \nOnline Help section of the TIA Portal or under:\nhttps://support.industry.siemens.com/cs/ww/en/view/109773506/100611494667\nThe block calculates the (moving) mean value based on the set window width. The window \nwidth indicates the maximum number of values read in last. After the maximum number of \nvalues has been read, the output windowSizeReached is set and each newly read value replaces \nthe oldest value (FIFO principle).\nTwo options are available for reading the values. With the input cyclicExecution, the values are \nread and calculated cyclically. With the trigger input, the values are read in and calculated with \neach pulse.", "type": "FUNCTION_BLOCK", "input": [{"name": "cyclicExecution", "type": "Bool", "description": "TRUE: cyclic operation, trigger not in use"}, {"name": "trigger", "type": "Bool", "description": "Read in `value` with every pulse at input `trigger`"}, {"name": "value", "type": "LReal", "description": "Value/s from which the moving average is to be determined."}, {"name": "windowSize", "type": "Int", "description": "Window length for sliding averaging in the range from 1..100. The standard value is 100."}, {"name": "reset", "type": "Bool", "description": "TRUE: The block is reset and the calculation starts again."}], "output": [{"name": "average", "type": "LReal", "description": "Moving / Floating average"}, {"name": "windowSizeReached", "type": "Bool", "description": "FALSE: Maximum window width not yet reached, TRUE: Maximum window width reached"}, {"name": "error", "type": "Bool", "description": "FALSE: No error, TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB and error identification."}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR: Execution finished without errors", "16#8200": "ERR_WRONG_WINDOW_SIZE: Incorrect window size/width set."}, "user_defined_types": []}
{"title": "CRC-32 Calculator", "name": "LGF_CalcCRC32", "description": "## Short description ##\n\nThe CRC calculation is used for error detection at data transmission. The result of a calculation \nreturns a CRC value via the data sent. The receiver detects a faulty transmission due to the \nunequal CRC value. The function LGF_CalcCRC32 uses 32 bits as the generator polynomial \n(mask).\n\n## Functional description ##\n\nThe function calculates the CRC value from a data stream of any size. The data stream is \ncomposed of the individual elements of the array at the input/output parameter array. The start \nvalue initValue and the generator polynomial mask can be freely selected.\nThe input noOfELements can be used to specify the desired number of elements for calculation, it \napplies:\n <= (   + 1)\nNote Various online tools are available for calculating the CRC values. The function of the block \nwas tested with the following online tool, since it supports the input parameters mask\n(Polynomial) and initValue (Initial Value):\nhttp://www.sunshine2k.de/coding/javascript/crc/crc_js.html", "type": "FUNCTION", "input": [{"name": "initValue", "type": "DWord", "description": "Start value for the calculation"}, {"name": "mask", "type": "DWord", "description": "Generator polynomial for the calculation"}, {"name": "noOfElements", "type": "UInt", "description": "Number of elements to be used in CRC calculation"}], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}], "in/out": [{"name": "array", "type": "Array[*] of Byte", "description": "Data stream for which the CRC value will be calculated"}], "return_value": [{"type": "DWord", "description": "Calculated CRC value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8400": "ERR_NO_OF_ELEMENTS"}, "user_defined_types": []}
{"title": "US calendar week calculation", "name": "LGF_GetCalendarWeek_US", "description": "## Short description ##\n\nThis function uses the specified date to calculate the calendar week and the number of days that have passed since the beginning of the year for the USA and many other countries.\n\n## Functional description ##\n\nCounting method for the USA and many other countries\n     Calendar weeks have 7 days, start on a Sunday and are counted continuously throughout the year\n     Calendar week 1 of a year is the week that contains January 1.\n     Each year has either 52 or 53 calendar weeks.\n    A year has 53 calendar weeks if the following characteristics apply:\n-    A common year begins on a Saturday and ends on a Saturday.\n-    A leap year begins either on a Saturday and ends on a Sunday or it begins on a Friday and ends on a Saturday.\n\n\n    The days after the last Saturday in December can belong to the first calendar week of the following year.", "type": "FUNCTION", "input": [{"name": "date", "type": "DTL", "description": "Date used to calculate the calendar week and days since 1 January"}], "output": [{"name": "calendarDay", "type": "DInt", "description": "Days past since January 1st on given date"}, {"name": "error", "type": "Bool", "description": "FALSE: No error / TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB / 16#8000-16#FFFF: Error identification"}], "in/out": [], "return_value": [{"type": "DInt", "description": "Number of the calendar week."}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8201": "ERR_LIM_DATE Date out of the range"}, "user_defined_types": []}
{"title": "Sawtooth Signal Generator", "name": "LGF_SawToothCI", "description": "## Short description ##\n\nThis function generates a sawtooth-shaped signal profile. For this it uses the time interval of the \ncalling Cyclic Interrupt OB.\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nThe block calculates the values for a sawtooth-shaped signal profile, which is output to the \noutput parameter value.\nThe amplitude, the offset in the Y-direction, the period, and the phase shift can be set at the \ninput parameters.\nThe input parameter reset resets the signal profile. At the value output parameter, the value 0 is \noutput as long as reset is set to TRUE.\nThe block must be called in a cyclic interrupt OB. The time interval of the calling cyclic interrupt \nOB is determined in the FB with the command QRY_CINT. For this, the constant name of the \ncalling cyclic interrupt OB must be interconnected at the input parameter callOB.\nThe number of calculated values of the signal profile per period duration is calculated as follows:\n =\n\n/\nNote To obtain a continuous signal profile of the curve, the time interval of the cyclic interrupt OB \nshould not be selected too large depending on the period duration.The Figure below shows the signal profile of the calculated values.", "type": "FUNCTION_BLOCK", "input": [{"name": "amplitude", "type": "Real", "description": "1.0"}, {"name": "offset", "type": "Real", "description": "0.0"}, {"name": "periode", "type": "UDInt", "description": "1000"}, {"name": "phaseShift", "type": "Real", "description": "0.0"}, {"name": "callOB", "type": "OB_CYCLIC", "description": ""}, {"name": "reset", "type": "Bool", "description": "FALSE"}], "output": [{"name": "value", "type": "Real", "description": "Current value of the sawtooth signal."}, {"name": "error", "type": "Bool", "description": "FALSE: No error"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB 16#8000-16#FFFF: Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8600": "ERR_OB_UNAVAILABLE", "16#8601": "ERR_QRY_CINT"}, "user_defined_types": []}
{"title": "Celsius to Kelvin Converter", "name": "LGF_CelsiusToKelvin", "description": "## Short description ##\n\nThis function converts a temperature value - from Celsius to Kelvin.", "type": "FUNCTION", "input": [{"name": "value", "type": "Real", "description": "Temperature to be converted in Celsius"}], "output": [], "in/out": [], "return_value": [{"type": "Real", "description": "Converted temperature in Kelvin"}], "status_codes": {}, "user_defined_types": []}
{"title": "DWord to 4-Byte Splitter", "name": "LGF_SplitDWordToBytes", "description": "## Short description ##\n\nThis function splits a DWord variable into 4 Byte variables.", "type": "FUNCTION", "input": [{"name": "doubleWord", "type": "DWord", "description": "Bit sequence to be split"}], "output": [{"name": "byte3", "type": "Byte", "description": "Output Byte 3 - MSB"}, {"name": "byte2", "type": "Byte", "description": "Output Byte 2"}, {"name": "byte1", "type": "Byte", "description": "Output Byte 1"}, {"name": "byte0", "type": "Byte", "description": "Output Byte 0 - LSB"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": []}
{"title": "Value set point range check", "name": "LGF_IsValueInRange", "description": "## Short description ##\n\nThe function checks whether a value is within a defined value range.\nThe value range is defined with a set point and a range around this set point. The function \ncalculates the low limit and high limit of the value range.\n\n## Functional description ##\n\nThe setpoint and range variables define a range of values.\nThe function checks whether the value is below, in or above the value range. The outputs \nbelowLowLimit, Ret_Val, or overHighLimit show where the value is located.", "type": "FUNCTION", "input": [{"name": "value", "type": "LReal", "description": "Value to be checked to determine whether it is within the defined value range"}, {"name": "setpoint", "type": "LReal", "description": "Set point"}, {"name": "range", "type": "LReal", "description": "Area where the setpoint is in range"}], "output": [{"name": "overHighLimit", "type": "Bool", "description": "TRUE if the value is greater than the upper limit value"}, {"name": "belowLowLimit", "type": "Bool", "description": "TRUE, if the value is less than the lower limit value"}, {"name": "error", "type": "Bool", "description": "FALSE: No error TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB 16#8000-16#FFFF: Error identification"}], "in/out": [], "return_value": [{"type": "Bool", "description": "Return: TRUE if the value is in the value range (range of the set point)"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8401": "ERR_RANGE_LIMIT_VALUES"}, "user_defined_types": []}
{"title": "Boolean signal edge detection", "name": "LGF_CountBooleanEdges", "description": "## Short description ##\n\nThis function evaluates a input signal for different states in a certain amount of time.\nThe states are:\n One edge and input present over the whole monitoring time\n Single edge\n Double edge\n N-Edges in between the monitoring time\nThe Output signal is present for at least on cycle after the monitoring time has expired, or as \nlong as the input trigger remains TRUE.", "type": "FUNCTION_BLOCK", "input": [{"name": "trigger", "type": "Bool", "description": "Trigger to evaluate signal"}, {"name": "monitorTime", "type": "Time", "description": "Time to monitor and count edges on `trigger` input"}], "output": [{"name": "single", "type": "Bool", "description": "Single edge until monitoring time expires"}, {"name": "double", "type": "Bool", "description": "Two edges in between the monitoring time"}, {"name": "long", "type": "Bool", "description": "Just a single edge in the monitoring time, the `trigger` input stays TRUE after the edge appears"}, {"name": "severalEdges", "type": "Bool", "description": "Numerous Edges occur within the monitoring time"}, {"name": "noOfEdges", "type": "USInt", "description": "Number of edges in between the monitoring time frame"}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": []}
{"title": "Sawtooth Signal Profile Generator", "name": "LGF_SawTooth", "description": "## Short description ##\n\nThis function generates a sawtooth-shaped signal profile. Each sawtooth consists of a defined \nnumber of steps (increments).\nNote LEGACY FUNCTION\nPlease update and use the FB with the same name LGF_CountRisInDWord in the future!\nThis function is no longer maintained\n\n## Functional description ##\n\nNote Please note that changes at the input parameters only become effective with reset.\nThe block calculates the values for a sawtooth-shaped signal profile, which is output to the \noutput parameter value. The signal begins with the start value startValue and is added with the \nvalue increment after each elapse of the time interval timeRange. The value can also be \nnegative.\nIf the variable endlessSteps is set to FALSE, the number of add operations is counted. If this \nexceeds the value numberSteps, the output parameter value is set back to the start value. A new \nsawtooth begins.\nIf the variable endlessSteps is set to TRUE, the value increment is added without interruption, \nstarting once at startValue. If the maximum positive INT value range (32767) of the output \nparameter value is exceeded, value changes to the maximum negative INT value range (-32768) and will continue to be added up.\nNote The duration of a sawtooth at endlessSteps on FALSE is calculated as follows:\nDuration = #timeRange * (#numberSteps + 1)", "type": "FUNCTION_BLOCK", "input": [{"name": "startValue", "type": "Int", "description": "0"}, {"name": "timeRange", "type": "Time", "description": "T#0s"}, {"name": "incrementRange", "type": "Int", "description": "0"}, {"name": "numberSteps", "type": "Int", "description": "0"}, {"name": "endlessSteps", "type": "Bool", "description": "FALSE"}, {"name": "reset", "type": "Bool", "description": "FALSE"}], "output": [{"name": "value", "type": "Int", "description": "Current value of the sawtooth signal."}], "in/out": [], "return_value": [], "status_codes": {}, "user_defined_types": []}
{"title": "Histogram Calculation Function Block for Real Data", "name": "LGF_Histogram_LReal", "description": "## Short description ##\n\nThe histogram shows the frequency distribution of a sample by class. A class describes a value \ninterval in which the individual frequencies are added together. After specifying the number of \nclasses, the class width and the respective class center are calculated. The number of classes \nis limited to 15.\nThe distribution is represented as a rectangle around the class mean with the class width and \nthe cumulated frequency as height.\nFigure: Distribution\n\n## Functional description ##\n\nThe block sorts the transferred data and calculates the general class width using the transferred \nclass count and data range. The block then counts the values that lie within a class. In order to \ndraw a histogram, the block also calculates the necessary X and Y coordinates.\nThe elements of the passed array values are sorted in ascending order by the block. The \nLGF_Shellsort_UDInt block is used for sorting.\nThe number of classes can be specified using the following rule of thumb:\n\nFormulas", "type": "FUNCTION_BLOCK", "input": [{"name": "execute", "type": "Bool", "description": "Activation of the calculation with each positive edge."}, {"name": "numberOfClasses", "type": "UInt", "description": "Number of desired classes."}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error, TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB and error identification."}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "histValues", "type": "Array[0..1, 0..#CLASSES_COUNTER_UP_LIMIT] of LReal", "description": "Displays the relative frequency and class centers."}, {"name": "axis", "type": "Array[0..3] of LReal", "description": "Specifies the axis values."}, {"name": "classWidth", "type": "LReal", "description": "Returns the calculated class width."}], "in/out": [{"name": "values", "type": "Array[*] of LReal", "description": "The array containing the data series for calculation."}], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED: Execution finished without errors", "16#7000": "STATUS_NO_CALL: No call of FB. The block waits for activation.", "16#7001": "STATUS_FIRST_CALL: First call of FB after enabling", "16#8600": "ERR_SHELL_SORT: Error in command `LGF_ShellSort_LReal`.", "16#9101": "ERR_WRONG_NO_CLASSES: Incorrect number of classes."}, "user_defined_types": []}
{"title": "Random DInt Range Number Generator", "name": "LGF_RandomRange_DInt", "description": "## Short description ##\n\nThis function generates a random value in defined limits with each call.\nThe random number has the data type DInt in the specified range.\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nThe block generates random values that are between the specified minValue and the maxValue. \nThis random value is output via the Ret_Val.\nThe random value is formed from the nanoseconds of the current system time of the CPU. The \nbyte order of this value is inverted and then converted to a DInt.", "type": "FUNCTION", "input": [{"name": "minValue", "type": "DInt", "description": "Minimum value of the range of the random number - lower border"}, {"name": "maxValue", "type": "DInt", "description": "Maximum value of the range of the random number - upper border"}], "output": [{"name": "error", "type": "Bool", "description": "Error flag"}, {"name": "status", "type": "Word", "description": "Status code"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called blocks"}], "in/out": [], "return_value": [{"type": "DInt", "description": "Random DInt number in the predefined range"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8200": "ERR_MAX_LESS_MIN", "16#8600": "ERR_RD_SYS_T"}, "user_defined_types": []}
{"title": "Numeric Differentiation Function Block", "name": "LGF_DifferenceQuotientFB", "description": "## Short description ##\n\nThis function numerically differentiates a signal sampled equidistantly in time. For example, the \nvelocity can be calculated from a measured locus curve, or the acceleration can be calculated \nfrom the measured velocity. In order to minimize the effects of a scattering measurement signal, \nthis algorithm uses a compensating polynomial.\nThe function block calculates the differentiated values cyclically.\nThe function block reads-in a value with each positive edge on the insert been read in, the \nblock calculates a differentiated value and outputs it.\n\n## Functional description ##\n\nTo calculate the difference quotient of a scattering signal, a third-degree compensation \npolynomial is first placed through the measured values. This polynomial is then differentiated. \nWith this method, even a distorted input signal can be sensibly differentiated.\nThe difference quotient is calculated with the following formula:\n\nThe function (FC) can calculate   4 differentiated and smoothed measured values from N \nmeasured values. The output array would be assigned with 0 in the index (0,1,N-1,N). However, \nthe following formalisms can be used to calculate substitute values:", "type": "FUNCTION_BLOCK", "input": [{"name": "enable", "type": "Bool", "description": "Activates the block."}, {"name": "insert", "type": "Bool", "description": "Accepts the value at the input `value` at positive edge and outputs a `derivatedValue` if five values have been read in."}, {"name": "value", "type": "LReal", "description": "Value that must be included in the differentiation."}, {"name": "deltaT", "type": "LReal", "description": "Equidistant distance between two measured values. (e.g. 1s)"}], "output": [{"name": "derivatedValue", "type": "LReal", "description": "The differentiated value."}, {"name": "error", "type": "Bool", "description": "FALSE: No error, TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status and error identification of the FB"}], "in/out": [], "return_value": [], "status_codes": {"16#7000": "STATUS_NO_CALL: The block waits for activation through the parameter `enable`.", "16#7001": "STATUS_FIRST_CALL: First call of FB after enabling", "16#7002": "STATUS_SUBSEQUENT_CALL: Processing is active. Subsequent call of FB.", "16#7010": "STATUS_NOT_ENOUGH_VALUES: The block requires five (5) values to calculate a differentiated value.", "16#8200": "ERR_DELTA_T: Delta time `deltaT` must not be zero."}, "user_defined_types": []}
{"title": "Cosine Signal Generator", "name": "LGF_CosinusCI", "description": "## Short description ##\n\nThis function generates a cosinusoidal signal profile. For this it uses the time interval of the \ncalling Cyclic Interrupt OB.\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nThe block calculates the values for a cosinusoidal signal profile, which is output to the output \nparameter value.\nThe amplitude, the offset in the Y-direction, the period (in ms) and the phase shift (in ms) can \nbe set at the input parameters.\nThe input parameter reset resets the signal profile. At the value output parameter, the value 0 is \noutput as long as reset is set to TRUE.\nThe block must be called in a cyclic interrupt OB. The time interval of the calling cyclic interrupt \nOB is determined in the FB with the command QRY_CINT. For this, the constant name of the \ncalling cyclic interrupt OB must be interconnected at the input parameter callOB.\nThe number of calculated values of the signal profile per period duration is calculated as follows:\n =/\nNote To obtain a continuous signal profile of the curve, the time interval of the cyclic interrupt OB \nshould not be selected too large depending on the period duration.\nThe Figure below shows the signal profile of the calculated values.", "type": "FUNCTION_BLOCK", "input": [{"name": "amplitude", "type": "Real", "description": "1.0"}, {"name": "offset", "type": "Real", "description": "0.0"}, {"name": "periode", "type": "UDInt", "description": "1000"}, {"name": "phaseShift", "type": "Real", "description": "0.0"}, {"name": "callOB", "type": "OB_CYCLIC", "description": ""}, {"name": "reset", "type": "Bool", "description": "FALSE"}], "output": [{"name": "value", "type": "Real", "description": "Current value of the cosinusoidal signal."}, {"name": "error", "type": "Bool", "description": "FALSE: No error"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB 16#8000-16#FFFF: Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8600": "ERR_OB_UNAVAILABLE", "16#8601": "ERR_QRY_CINT"}, "user_defined_types": []}
{"title": "Calendar day calculation", "name": "LGF_GetCalendarDay", "description": "## Short description ##\n\nThis function uses the specified date to calculate the number of days that have passed since the beginning of the year (1st January).\nThe function is used in the functions LGF_GetCalendarWeek_ISO and\nLGF_GetCalendarWeek_US .", "type": "FUNCTION", "input": [{"name": "date", "type": "DTL", "description": "Date for the calculation of the calendar days since 1 January."}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error / TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB / 16#8000-16#FFFF: Error identification"}], "in/out": [], "return_value": [{"type": "DInt", "description": "Days past since January 1st."}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8201": "ERR_LIM_DATE Date out of the range"}, "user_defined_types": []}
{"title": "File Reading from UserFiles Folder", "name": "LGF_FileRead", "description": "## Short description ##\n\nThis function block offers reading data as binary / serialized data stream from files stored on the \nPLC's memory card in the folder UserFiles.\n\n## Functional description ##\n\nWith the function LGF_FileRead a file can be read into the data budget of a variable at data. To \nread the data it is necessary to deserialize it, which the function already takes from the user.\nFor deserialization an external buffer in the form of a byte array must be connected which can \ntake up the amount of data, if the buffer is too small an error is output.\nThe file name must always be specified in full together with the folder name and the file \nextension in the following format: UserFiles/test.dat.", "type": "FUNCTION_BLOCK", "input": [{"name": "execute", "type": "Bool", "description": "Rising edge starts file read once"}, {"name": "dataLengthMustMatch", "type": "Bool", "description": "The length of the file data set and the dataset in the PLC have to match."}, {"name": "fileName", "type": "String", "description": "Name of file including path: `UserFiles/test.dat`"}], "output": [{"name": "done", "type": "Bool", "description": "Commanded functionality has been completed successfully"}, {"name": "busy", "type": "Bool", "description": "FB is not finished and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}, {"name": "dataLength", "type": "DInt", "description": "Data length read from file (serialized length of `data`)"}], "in/out": [{"name": "bufferByteArray", "type": "Array[*] of Byte", "description": "Byte array buffer for read / write from / to file"}, {"name": "data", "type": "Variant", "description": "Data set read from file"}], "return_value": [], "status_codes": {"16#0000": "STATUS_EXECUTION_FINISHED", "16#7000": "STATUS_NO_CALL", "16#7001": "STATUS_FIRST_CALL", "16#7002": "STATUS_SUBSEQUENT_CALL", "16#8201": "ERR_BUFFER_LOWERBOUND", "16#8202": "ERR_BUFFER_ARRAY_TO_SMALL_TO_COPY", "16#8401": "ERR_FILE_PATH", "16#8411": "ERR_FILE_SIZE_GRATER_THEN_DATA_SIZE", "16#8412": "ERR_FILE_SIZE_LESS_THEN_DATA_SIZE", "16#8600": "ERR_UNDEFINED_STATE", "16#8601": "ERR_MOVE_BLK_VARIANT", "16#8602": "ERR_DATA_SERIALIZE", "16#8603": "ERR_DATA_DESERIALIZE", "16#8604": "ERR_FILE_READ_INIT", "16#8605": "ERR_FILE_READ"}, "user_defined_types": [{"name": "LGF_typeDiagnostics", "description": "Diagnostic structure to store and transfer diagnostic information from blocks trough the interface.", "member": [{"name": "status", "type": "Word", "default": "16#0000", "description": "Status of the Block or error identification when error occurred"}, {"name": "subfunctionStatus", "type": "Word", "default": "16#0000", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "stateNumber", "type": "DInt", "default": "0", "description": "State in the state machine of the block where the error occurred"}]}]}
{"title": "Polynomial Smoothing Function", "name": "LGF_SmoothByPolynomFC", "description": "## Short description ##\n\nThis function calculates the smoothed values by polynomial acyclically.\nFor smoothing, a 3rd degree polynomial is placed through five value points. The error squares \nof the distances between polynomial and real value are minimized. The smoothed values can \nbe determined from the polynomial parameters obtained in this way.\nThe function reads an array that is smoothed.   4 smoothed measured values can be \ncalculated from N measured values. The output array contains the value 0 in the index (0,1,N-\n1,N). However, replacement values can be calculated.\n\n## Functional description ##\n\nThe 3rd degree compensation polynomial is calculated as follows:\n\n  4 smoothed measured values can thus be calculated from the N measured values. The \noutput array contains the value 0 in the index (0.1, N-1, N).\nThese missing values are calculated with the following formalisms:", "type": "FUNCTION", "input": [], "output": [{"name": "error", "type": "Bool", "description": "FALSE: No error TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB"}], "in/out": [{"name": "values", "type": "Array[*] of LReal", "description": "Values that are to be included in the smoothing."}, {"name": "smoothedValues", "type": "Array[*] of LReal", "description": "The smoothed values."}], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8400": "ERR_ARRAYS_DIFFERENT Error: The Array sizes are not equal.", "16#8401": "ERR_NOT_ENOUGH_VALUES Error: Not enough values."}, "user_defined_types": []}
{"title": "Simple Smoothing Function Block", "name": "LGF_SimpleSmoothingFB", "description": "## Short description ##\n\nThe function calculates the linear mean value cyclically.\nThe simplest form of smoothing a sequence of measured values is to calculate the linear mean \nvalue by three points.\nThe function reads-in a value with each positive edge on the insert input. As soon as three \nvalues have been read in, the block calculates a smoothed value and outputs it.\n\n## Functional description ##\n\nThe function calculates the smoothed values using the following formula:\n() = ((  1) + () + ( + 1)) / 3\nThe calculated value is output or the calculated values are output at output smoothedValue.\nBased on this formula, the function cannot calculate values for the elements 0 and N.", "type": "FUNCTION_BLOCK", "input": [{"name": "enable", "type": "Bool", "description": "Activates the block."}, {"name": "insert", "type": "Bool", "description": "Accepts the value at the input `value` at positive edge and outputs a `smoothedValue` if three values have been read in."}, {"name": "value", "type": "LReal", "description": "Value that is to be included in the smoothing."}], "output": [{"name": "smoothedValue", "type": "LReal", "description": "The smoothed value."}, {"name": "error", "type": "Bool", "description": "FALSE: No error, TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB and error identification."}], "in/out": [], "return_value": [], "status_codes": {"16#7000": "STATUS_NO_CALL: The block waits for activation through the parameter `enable`.", "16#7001": "STATUS_FIRST_CALL: First call of FB after enabling", "16#7002": "STATUS_SUBSEQUENT_CALL: Processing is active. Subsequent call of FB.", "16#7010": "STATUS_NOT_ENOUGH_VALUES: The block requires three (3) values to calculate a smoothed value."}, "user_defined_types": []}
{"title": "String to TADDR_Param Converter", "name": "LGF_StringToTaddr", "description": "## Short description ##\n\nThe system data type TADDR_Param contains address information consisting of an IPV4 address \nand the port number.\nThe LGF_StringToTaddr function converts a variable od data type String to a TADDR_Param\nsystem data type variable.\n\n## Functional description ##\n\nThe function converts the IPV4 address with or without port number from data type String to \nTADDR_Param.\nThe string must be in the following form:\n without port number: [0..255].[0..255].[0..255].[0..255]\n with port number: [0..255].[0..255].[0..255].[0..255]:[0..65535]", "type": "FUNCTION", "input": [{"name": "ipAddressString", "type": "String", "description": "IPV4 address string in the format of 192.168.1.200:55047 [Port number including colon : is optional]"}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}], "in/out": [], "return_value": [{"type": "TADDR_Param", "description": "IP-Address and Port number as TADDR_Param data type"}], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8110": "ERR_OCTET_WRONG_NUMBER_OF_CHAR", "16#8120": "ERR_OCTET_STRING_IS_EMPTY", "16#8130": "ERR_OCTET_EXCEEDS_MAX_IP_ADDRESS", "16#8150": "ERR_PORT_WRONG_NUMBER_OF_CHAR", "16#8151": "ERR_PORT_STRING_IS_EMPTY", "16#8152": "ERR_PORT_EXCEEDS_MAX_PORT"}, "user_defined_types": []}
{"title": "Bit status check operation", "name": "LGF_BitTest", "description": "## Short description ##\n\nThis block checks whether a bit is TRUE or FALSE at a given position in a variable of the data type DWORD.\nAlternatively, Word and Byte can be used instead of DWord by converting the passed\nparameter with, for example, BYTE_TO_DWORD and the result with DWORD_TO_BYTE.", "type": "FUNCTION", "input": [{"name": "value", "type": "DWord", "description": "Tag where the bit has to be tested"}, {"name": "bitNo", "type": "USInt", "description": "bit number to test in \"value\" parameter"}], "output": [], "in/out": [], "return_value": [{"type": "Bool", "description": "Value of the checked bit."}], "status_codes": {}, "user_defined_types": []}
{"title": "Arithmetic Mean and Standard Deviation Calculator", "name": "LGF_AverageAndDeviation", "description": "## Short description ##\n\nThis function calculates the arithmetic mean and the standard deviation from a series of \nnumbers.\n\n## Functional description ##\n\nAn array of any size is connected via the variableArray input. After reading-out the array \nboundaries, the arithmetic mean value and the standard deviation will be calculated from the \nvalues and both will be output.\nNote An array with too many elements can cause the cycle monitoring time to be exceeded.", "type": "FUNCTION", "input": [{"name": "variableArray", "type": "Array[*] of LReal", "description": "Sequence of numbers to calculate with"}], "output": [{"name": "arithmeticAverage", "type": "LReal", "description": "Calculated arithmetic average value"}, {"name": "standardDeviation", "type": "LReal", "description": "Calculated standard deviation"}], "in/out": [], "return_value": [{"type": "Void", "description": "Void - Function has no return value"}], "status_codes": {}, "user_defined_types": []}
{"title": "Bit assignment operation in DWORD", "name": "LGF_BitSetTo", "description": "## Short description ##\n\nThis block sets a bit to TRUE or FALSE at a predefined position in a variable of the data type DWORD.\nAlternatively, Word and Byte can be used instead of DWord by converting the passed\nparameter with, for example, BYTE_TO_DWORD and the result with DWORD_TO_BYTE.", "type": "FUNCTION", "input": [{"name": "value", "type": "DWord", "description": "Tag where the bit has to be set / reset"}, {"name": "bitNo", "type": "USInt", "description": "Bit number to set in \"value\" parameter"}, {"name": "setTo", "type": "Bool", "description": "Set bit to FALSE / TRUE"}], "output": [], "in/out": [], "return_value": [{"type": "DWord", "description": "Tag with set bit"}], "status_codes": {}, "user_defined_types": []}
{"title": "String Lower Case Converter", "name": "LGF_ToLower", "description": "## Short description ##\n\nThis function converts the capital letters of a string into their lower case equivalents.", "type": "FUNCTION", "input": [{"name": "In", "type": "String", "description": "String input"}], "output": [], "in/out": [], "return_value": [{"type": "String", "description": "Resulting string, after the conversion"}], "status_codes": {}, "user_defined_types": []}
{"title": "Single Byte CRC-8 Calculator", "name": "LGF_CalcCRC8For1Byte", "description": "## Short description ##\n\nThe CRC calculation is used for error detection at data transmission. The result of a calculation \nreturns a CRC value via the data sent (Byte). The receiver detects a faulty transmission due to \nthe unequal CRC value. The function LGF_CalcCRC8For1Byte uses 8 bits as the generator \npolynomial (mask).\n\n## Functional description ##\n\nThe function calculates the CRC value from a data byte value. The start value initValue and \nthe generator polynomial mask can be freely selected.\nNote Various online tools are available for calculating the CRC values. The function of the block \nwas tested with the following online tool, since it supports the input parameters mask\n(Polynomial) and initValue (Initial Value):\nhttp://www.sunshine2k.de/coding/javascript/crc/crc_js.html", "type": "FUNCTION", "input": [{"name": "initValue", "type": "Byte", "description": "Start value for the calculation"}, {"name": "mask", "type": "Byte", "description": "Generator polynomial for the calculation"}, {"name": "value", "type": "Byte", "description": "Data byte for which the CRC value will be calculated"}], "output": [], "in/out": [], "return_value": [{"type": "Byte", "description": "Calculated CRC value"}], "status_codes": {"16#0000": "STATUS_NO_ERROR"}, "user_defined_types": []}
{"title": "Polynomial Smoothing Function Block", "name": "LGF_SmoothByPolynomFB", "description": "## Short description ##\n\nThis function calculates the smoothed values by polynomial cyclically.\nFor smoothing, a 3rd degree polynomial is placed through five value points. The error squares \nof the distances between polynomial and real value are minimized. The smoothed values can \nbe determined from the polynomial parameters obtained in this way.\nThe function reads-in a value with each positive edge on the insert input. As soon as five \nvalues have been read in, the block calculates a smoothed value and outputs it.\n\n## Functional description ##\n\nThe 3rd degree compensation polynomial is calculated as follows:\n\n  4 smoothed measured values can thus be calculated from the N measured values. The \noutput array contains the value 0 in the index (0.1, N-1, N).\nThese missing values are calculated with the following formalisms:", "type": "FUNCTION_BLOCK", "input": [{"name": "enable", "type": "Bool", "description": "Activates the block."}, {"name": "insert", "type": "Bool", "description": "Accepts the value at the input `value` at positive edge and outputs a `smoothedValue` if five values have been read in."}, {"name": "value", "type": "LReal", "description": "Value that is to be included in the smoothing."}], "output": [{"name": "smoothedValue", "type": "LReal", "description": "The smoothed value."}, {"name": "error", "type": "Bool", "description": "FALSE: No error, TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB and error identification."}], "in/out": [], "return_value": [], "status_codes": {"16#7000": "STATUS_NO_CALL: The block waits for activation through the parameter `enable`.", "16#7001": "STATUS_FIRST_CALL: First call of FB after enabling", "16#7002": "STATUS_SUBSEQUENT_CALL: Processing is active. Subsequent call of FB.", "16#7010": "STATUS_NOT_ENOUGH_VALUES: The block requires five (5) values to calculate a smoothed value."}, "user_defined_types": []}
{"title": "Temperature Unit Converter", "name": "LGF_ConvertTemperature", "description": "## Short description ##\n\nThis function converts a temperature value from one into another unit by using an appropriate \ngiven mode parameter.", "type": "FUNCTION", "input": [{"name": "mode", "type": "Int", "description": "Conversion mode"}, {"name": "value", "type": "Real", "description": "Temperature value to be converted"}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB"}], "in/out": [], "return_value": [{"type": "Real", "description": "Converted temperature result"}], "status_codes": {"16#8200": "ERR_WRONG_MODE"}, "user_defined_types": []}
{"title": "Timer with various time switch points", "name": "LGF_TimerSwitch", "description": "## Short description ##\n\nThis block is a timer. It is possible to define daily, weekly, monthly, yearly time switch points and \ntime switch points for working days or weekend days.\nMode: Permanently off: 0, Daily: 1, Weekly: 2, Monthly: 3, Yearly: 4, Workday: 5, Weekend: 6, \nPermanently on: 10\nThe time value is always compared with the local time of the PLC, therefore the time value \nspecified at the On and Off parameters must be specified as local time.\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nNote The function uses internally the system function RD_LOC_T to read the local time of the CPU, \nfor the correct function it is therefore necessary that the local time of the CPU is set correctly.\nThe block offers various timer types, which are determined in the mode parameter:\n Permanently off (mode = 0)\n Daily timer (mode = 1)\n Weekly timer (mode = 2)\n Monthly timer (mode = 3)\n Yearly timer (mode = 4)\n Weekdays, Monday to Friday (mode = 5)\n Weekend, Saturday and Sunday (mode = 6)\n Permanently on (mode = 10)\nThe time value is always compared with the local time of the PLC, therefore the time value \nspecified at the On and Off parameters must be specified as local time.\nDepending on the mode, the following formal parameters must be interconnected:\nMode. Mode Required - formal parameters\n0 . Permanently OFF  none\n1 . Daily timer  onHour / offHour\n onMinute / offMinute\n2 . Weekly timer  onWeekday / offWeekday\n onHour / offHour\n onMinute / offMinute\n3 . Monthly timer  onDay / offDay\n onHour / offHour\n onMinute / offMinute\n4 . Yearly timer  onMonth / offMonth\n onDay / offDay\n onHour / offHour\n onMinute / offMinute\n5 . Weekdays  onHour / offHour\n onMinute / offMinute\n6 . Weekend  onHour / offHour\n onMinute / offMinute\n10 . Permanently ON  none\nIf the set start time equals the current local time of the controller, the output signal is set to \nTRUE. If the set switch-off time equals the current local time of the controller, the signal output is \nreset again.\nNote Please note that the block can be used in the Monthly timer modes (mode = 3) or yearly \ntimer (mode = 4) the block only switches if the days that you specify at the input parameters, \nonDay and offDay, actually occur in this month.", "type": "FUNCTION_BLOCK", "input": [{"name": "onMonth", "type": "USInt", "description": "Month, in which the signal shall be set."}, {"name": "onDay", "type": "USInt", "description": "Day, at which the signal shall be set."}, {"name": "onWeekday", "type": "USInt", "description": "Day of the week on which the signal will be set; Sunday: 1, Monday: 2, Tuesday: 3, ..."}, {"name": "onHour", "type": "USInt", "description": "Hour, at which the signal shall be set."}, {"name": "onMinute", "type": "USInt", "description": "Minute, at which the signal shall be set."}, {"name": "offMonth", "type": "USInt", "description": "Month, in which the signal shall be reset."}, {"name": "offDay", "type": "USInt", "description": "Day, at which the signal shall be reset."}, {"name": "offWeekday", "type": "USInt", "description": "Day of the week on which the signal will be reset; Sunday: 1, Monday: 2, Tuesday: 3, ..."}, {"name": "offHour", "type": "USInt", "description": "Hour, at which the signal shall be reset."}, {"name": "offMinute", "type": "USInt", "description": "Minute, at which the signal shall be reset."}, {"name": "mode", "type": "USInt", "description": "Specifies the mode (see Principle of operation)"}], "output": [{"name": "signal", "type": "Bool", "description": "Output signal"}, {"name": "actLocalTime", "type": "DTL", "description": "Current local time"}, {"name": "error", "type": "Bool", "description": "FALSE: No error / TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "16#0000-16#7FFF: Status of the FB / 16#8000-16#FFFF: Error identification"}, {"name": "subFunctionStatus", "type": "Word", "description": "Sub function status code"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#8200": "ERR_NO_MODE_SELECTED", "16#8600": "ERR_RD_LOC_T"}, "user_defined_types": []}
{"title": "Rate of Change Limiter", "name": "LGF_LimRateOfChangeCI", "description": "## Short description ##\n\nThis function limits the rate of change of an input variable. A jump function becomes a ramp \nfunction.\n\n## Functional description ##\n\nNote The status of called commands is output in subFunctionStatus. In this case, the output value \nin status indicates which command caused the error. In this case, refer to the TIA Portal \nOnline Help section for information on the respective commands.\nThe ramp is a limit line and refers to a rate of change per second; if, for example, setChangeRate \n= 10.0 is parameterized at a sampling time of 1s/100ms/10ms for every block call, then if value \n> delayedValue, 10.0/1.0/0.1 is added to delayedValue until value is reached.\nThe limitation of the rate of change applies to both positive and negative values for the rise and \nfall.\nThe output delayedValue can be preset or initialized.\nThe time interval of the calling cyclic interrupt OB is determined by interconnecting the calling \ncyclic interrupt OB at the input parameter callOB.\nPre-assigning an output\nIf enDefaultOutValue = TRUE is set, the value at defaultOutValue is output. When changing \nfrom TRUE to FALSE, the output delayedValue is ramped from defaultOutValue to value. When \nchanging from FALSE to TRUE, the output delayedValue immediately jumps to defaultOutValue.", "type": "FUNCTION_BLOCK", "input": [{"name": "value", "type": "LReal", "description": "Signal to be processed and limited in its rate of change"}, {"name": "setChangeRate", "type": "LReal", "description": "Rate of change of ramp function"}, {"name": "defaultOutValue", "type": "LReal", "description": "Value for pre-assignment of the output variable"}, {"name": "enDefaultOutValue", "type": "Bool", "description": "Assign default output value"}, {"name": "callOB", "type": "OB_CYCLIC", "description": "Calling wake-alarm interrupt OB"}], "output": [{"name": "delayedValue", "type": "LReal", "description": "Output variable"}, {"name": "error", "type": "Bool", "description": "Error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB"}, {"name": "subfunctionStatus", "type": "Word", "description": "Status or return value of called FB's, FC's and system blocks"}], "in/out": [], "return_value": [], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#8200": "ERR_NEG_RATE_LIM", "16#8600": "ERR_QRY_CINT", "16#8601": "ERR_OB_UNAVAILABLE"}, "user_defined_types": []}
{"title": "Standalone Data Logger with Advanced Configuration", "name": "LGF_DataLogC", "description": "## Short description ##\n\nLGF_DataLogC (C -> Compact) function integrates all the datalog system functions and can be \nused as standalone data logger.\n\n## Functional description ##\n\nThe function LGF_DataLogC combines the system functions for creating and writing data logs in \none block.\nThe procedure provides that an existing Datalog is opened on the basis of the name (name), if it \nwas not created before, this is recognized and the function creates the Datalog.\nAfterwards, depending on the parameterization, the data is written from data in an adjustable \ninterval or only on request to triggerLogEntry.\nReadMe The functionality of Datalogs can be found in the user manual:\n DataLogCreate\n DataLogOpen\n DataLogClose\n DataLogWrite\n DataLogClear\n DataLogDelete\nNOTICE The following parameters are only effective when creating a data log:\n parameter.header\n parameter.maxNumberOfEntries\n parameter.timestampFormat (S7-1200 and the S7-1500 support different formats, see the \nmanual DataLogCreate)\nNOTICE When logging data by interval (isLoggingByInterval) time variances occur, which are \ncaused by a fluctuating cycle time.\nTherefore it is recommended to call the function in a time interrupt OB besides the call in the \ncyclic program and to set the trigger for writing in this interrupt OB.\nNOTICE A data log which is deleted by the function without deleting the file cannot be created again \nas long as the file exists, it must first be deleted manually in the system.\nPlease also note the parameter parameter.deleteFile which also deletes the file next to the \ndata in case of a delete command deleteLog.", "type": "FUNCTION_BLOCK", "input": [{"name": "enable", "type": "Bool", "description": "TRUE: Enable functionality of FB"}, {"name": "name", "type": "String", "description": "Name of datalog, also used as file name"}, {"name": "triggerLogEntry", "type": "Bool", "description": "Rising edge trigger one entry in data log (only if `parameter.isLoggingByInterval` := FALSE)"}, {"name": "clearLog", "type": "Bool", "description": "Rising edge triggering clearing of datalog file"}, {"name": "deleteLog", "type": "Bool", "description": "Rising edge triggering deletion of datalog file if exist"}, {"name": "parameter", "type": "LGF_typeDataLogParameter", "description": "This UDT belongs to the Module `LGF_DataLogC` and lists all possible parameter to configure its behaviour."}], "output": [{"name": "valid", "type": "Bool", "description": "TRUE: Valid set of output values available at the FB"}, {"name": "busy", "type": "Bool", "description": "TRUE: FB is not finished and new output values can be expected"}, {"name": "error", "type": "Bool", "description": "TRUE: An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}, {"name": "writeEntryDone", "type": "Bool", "description": "TRUE: DataLog write done successfully"}, {"name": "clearLogDone", "type": "Bool", "description": "TRUE: DataLog clear done successfully"}, {"name": "deleteLogDone", "type": "Bool", "description": "TRUE: DataLog delete done successfully"}, {"name": "lastEntryReached", "type": "Bool", "description": "TRUE: Last entry of datalog reached, if `enableRingBuffer` is set, start from beginning, otherwise block ends here"}, {"name": "noOfEntries", "type": "UDInt", "description": "Number of entries in datalog"}, {"name": "diagnostics", "type": "LGF_typeDiagnostics", "description": "Diagnostic structure to store and transfer diagnostic information from blocks trough the interface."}], "in/out": [{"name": "data", "type": "Variant", "description": "Data structure to log in datalog file"}], "return_value": [], "status_codes": {"16#0000": "STATUS_FINISHED_NO_ERROR", "16#7000": "STATUS_NO_CALL", "16#7001": "STATUS_FIRST_CALL", "16#7002": "STATUS_SUBSEQUENT_CALL", "16#7010": "STATUS_MAX_ENTRIES_REACHED", "16#8401": "ERR_WRONG_COMMAND_CALL_ORDER", "16#8600": "ERR_UNDEFINED_STATE", "16#8601": "ERR_DATALOG_OPEN", "16#8602": "ERR_DATALOG_CREATE", "16#8603": "ERR_DATALOG_CLOSE", "16#8604": "ERR_DATALOG_WRITE", "16#8605": "ERR_DATALOG_DELETE"}, "user_defined_types": [{"name": "LGF_typeDataLogParameter", "description": "This UDT belongs to the Module LGF_DataLogC and lists all possible parameter to configure its behaviour.", "member": [{"name": "header", "type": "String", "default": "", "description": "Headline of datalog, string of all data fields, separated by a comma: \"field1,field2,field3,...\""}, {"name": "maxNumberOfEntries", "type": "UDInt", "default": "1000", "description": "Maximum number of entries in datalog"}, {"name": "timestampFormat", "type": "USInt", "default": "0", "description": "Timestamp format"}, {"name": "clearOnOpen", "type": "Bool", "default": "FALSE", "description": "Clear datalog during opening datalog while enabling block"}, {"name": "deleteFile", "type": "Bool", "default": "FALSE", "description": "Delete as well datalog file during datalog delete"}, {"name": "enableRingBuffer", "type": "Bool", "default": "FALSE", "description": "TRUE: Overwrite old values and start from the beginning if datalog reaches its maximum entries FALSE: Stop logging if `maxNumberOfEntries` entries reached"}, {"name": "loggingByInterval", "type": "Bool", "default": "FALSE", "description": "TRUE: Log on interval time parameter FALSE: log on \"triggerEntry\""}, {"name": "loggingInterval", "type": "Time", "default": "T#1M", "description": "Time for automatic logging interval"}]}, {"name": "LGF_typeDiagnostics", "description": "Diagnostic structure to store and transfer diagnostic information from blocks trough the interface.", "member": [{"name": "status", "type": "Word", "default": "16#0000", "description": "Status of the Block or error identification when error occurred"}, {"name": "subfunctionStatus", "type": "Word", "default": "16#0000", "description": "Status or return value of called FB's, FC's and system blocks"}, {"name": "stateNumber", "type": "DInt", "default": "0", "description": "State in the state machine of the block where the error occurred"}]}]}
{"title": "Celsius to Fahrenheit Converter", "name": "LGF_CelsiusToFahrenheit", "description": "## Short description ##\n\nThis function converts a temperature value - from Celsius to Fahrenheit.", "type": "FUNCTION", "input": [{"name": "value", "type": "Real", "description": "Temperature to be converted in Celsius"}], "output": [], "in/out": [], "return_value": [{"type": "Real", "description": "Converted temperature in Fahrenheit"}], "status_codes": {}, "user_defined_types": []}
{"title": "Non-Linear Interpolation Function", "name": "LGF_NonLinearInterpolation", "description": "## Short description ##\n\nThis function implements a characteristic curve. The characteristic curve is defined via an \ninterpolation point table with linear interpolation between the interpolation points. A prescribed \ninput value generates an output value in each cycle based on the characteristic curve from the \ninterpolation point table.\n\n## Functional description ##\n\nThe value of the output outputValue based on the following priority:\n1. As long as the input enDefaultOutValue is set, the value defined via the parameter \ndefaultOutValue will be output as output value.\n2. As long as the input reset is set, the block is reset and the output value is 0.0.\n3. If the input track is set, the output value will be output directly as input value, without \nconsideration of the characteristic curve.\n4. Based on the input value, a characteristic curve value is calculated via the linearly \ninterpolated, interpolation point table and output as an output value.\n If the input value is between two interpolation points within the interpolation point table, \nthe output value is calculated as the intersection with the connecting line between the \npreceding and following interpolation points (see Figure below).\n If the input value is before the first interpolation point (lowest value defined in the \ninterpolation point table), the output value will be calculated as the intersection of the \nline formed by the first two interpolation points of the interpolation point table.\n If the input value is after the last interpolation point (highest value defined in the \ninterpolation point table), the output value will be calculated as the intersection of the \nline formed by the last two interpolation points of the interpolation point table.\nInterpolation point table\nThe interpolation point table is implemented through a variable of the data type Array. The type \nof the array corresponds to the PLC data type LGF_typeNonLinSetpoints.\nYou can create the interpolation point table in any global data block. The size of the array \ndepends on the number of interpolation points.\nNOTICE To keep the computing time of the block as short as possible, there is no check of the \nparameterization or the data of the interpolation point table.\nWhen entering the interpolation points in the interpolation point table, the following \nparticularities must be considered. If these particularities are not taken into account, it can \nlead to a malfunction of the block.\n At least two interpolation points must be entered in the interpolation point table.\n The interpolation points in the interpolation point table must be entered in the Table in ascending \norder of the input values.", "type": "FUNCTION_BLOCK", "input": [{"name": "value", "type": "LReal", "description": "Input value for calculating the output value"}, {"name": "defaultOutValue", "type": "LReal", "description": "Value for pre-assignment of the output variable"}, {"name": "enDefaultOutValue", "type": "Bool", "description": "Assign default output value"}, {"name": "track", "type": "Bool", "description": "Follow the value of the input without using the characteristic curve"}, {"name": "reset", "type": "Bool", "description": "Reset the interpolation if the point table is changed in running operation"}], "output": [{"name": "outputValue", "type": "LReal", "description": "The calculated output value from the input value"}], "in/out": [{"name": "setpoints", "type": "Array[*] of LGF_typeNonLinSetpoints", "description": "Setpoint table for defining the characteristic curve"}], "return_value": [], "status_codes": {}, "user_defined_types": [{"name": "LGF_typeNonLinSetpoints", "description": "Data type for setup a setpoint table", "member": [{"name": "inputValue", "type": "LReal", "default": "0.0", "description": "Input value to be interpolated"}, {"name": "outputValue", "type": "LReal", "default": "0.0", "description": "Corresponding interpolated value"}]}]}
{"title": "Unix Time to DTL Time Converter", "name": "LGF_UnixTimeToDTL", "description": "## Short description ##\n\nThis function converts the Unix time of data type DInt to a date and time of data type DTL. The \ntimestamp is calculated in UTC. This means that the time zone is not considered.\nOnly times after 01/01/1990 are permitted.", "type": "FUNCTION", "input": [{"name": "timeUnix", "type": "DInt", "description": "UNIX time to convert"}], "output": [{"name": "error", "type": "Bool", "description": "An error occurred during the execution of the FB"}, {"name": "status", "type": "Word", "description": "Status of the FB, Error identification"}], "in/out": [], "return_value": [{"type": "DTL", "description": "Converted time (Date and time). In case of Error: 0 (error = true)"}], "status_codes": {"16#0000": "STATUS_NO_ERROR", "16#6001": "WARN_CONVERSION_LIMIT", "16#8000": "ERR_TIME_BEFORE_1990"}, "user_defined_types": []}
