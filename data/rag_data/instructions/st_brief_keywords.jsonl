{"instruction_name": "ABS", "description": "The IEC operator yields the absolute value of a number.", "parameters": {"Input": [{"name": "value", "type": "ANY numeric basic data type", "description": "The input number for which the absolute value is to be calculated."}], "Output": [{"name": "result", "type": "Same as input type", "description": "The absolute value of the input number."}], "InOut": []}, "how_to_use": "Use ABS to obtain the absolute value of any numeric basic data type. Assign the function result to a variable of the same type. Works with all IEC permitted numeric types.", "example_code": "i := ABS(-2);", "additional_info": "Permitted data types for input and output variables and numeric constants: any numeric basic data type.", "generated_brief": {"functional_summary": "The ABS instruction computes the absolute value of a given numeric input.", "usage_context": "It is used in control systems to ensure numeric values are non-negative regardless of their original sign."}, "generated_keywords": ["absolute value", "numeric input", "non-negative result", "IEC operator", "numeric data types"]}
{"instruction_name": "ACOS", "description": "The IEC operator yields the arccosine value of a number. The value is computed in radians.", "parameters": {"Input": [{"name": "inputValue", "type": "any numeric basic data type", "description": "Input variable representing the angle in radians."}], "Output": [{"name": "result", "type": "REAL or LREAL", "description": "Output variable that receives the arccosine value in radians."}], "InOut": []}, "how_to_use": "Use ACOS to calculate the arccosine of a numeric input value. The input can be any numeric basic data type, and the output will be a REAL or LREAL value representing the angle in radians.", "example_code": "q := ACOS(0.5);", "additional_info": "The ACOS function operates according to IEC standards and returns the value in radians.", "generated_brief": {"functional_summary": "The ACOS function calculates the arccosine of a numeric input value and returns the result in radians.", "usage_context": "It is typically used in industrial control systems to determine angle measurements or perform trigonometric calculations based on input values."}, "generated_keywords": ["arccosine calculation", "trigonometric function", "angle in radians", "numeric input processing", "IEC standard function"]}
{"instruction_name": "ADD", "description": "The IEC operator adds variables.", "parameters": {"Input": [{"name": "Operand1", "type": "Any of UXINT, XINT, XWORD, BYTE, DATE, DATE_AND_TIME, DINT, DT, DWORD, INT, LDATE, LDATE_AND_TIME, LDT, LINT, LREAL, LTIME, LTOD, LWORD, REAL, SINT, TIME, TIME_OF_DAY, TOD, UDINT, UINT, ULINT, USINT, WORD", "description": "First value to be added."}, {"name": "Operand2", "type": "Any of UXINT, XINT, XWORD, BYTE, DATE, DATE_AND_TIME, DINT, DT, DWORD, INT, LDATE, LDATE_AND_TIME, LDT, LINT, LREAL, LTIME, LTOD, LWORD, REAL, SINT, TIME, TIME_OF_DAY, TOD, UDINT, UINT, ULINT, USINT, WORD", "description": "Second value to be added."}], "Output": [{"name": "Result", "type": "Corresponding resulting type based on operand types, for example TIME + TIME = TIME, TOD + LTIME = LTOD, etc.", "description": "The sum of the input operands."}], "InOut": []}, "how_to_use": "Use ADD to sum variables of compatible types as listed. Time and date/time combinations follow specific rules for result types. The ADD operator can be extended with additional function block inputs in FBD/LD editors, observing input count limits.", "example_code": "var1 := 7 + 2 + 4 + 7;", "additional_info": "In the FBD/LD editor, ADD can be extended with additional function block inputs, but the number of these inputs is limited. Valid addition combinations for time and date/time types are explicitly defined.", "generated_brief": {"functional_summary": "The ADD instruction performs addition on two variables of compatible data types, including numeric and time/date values, producing their sum as output.", "usage_context": "It is used in PLC programs to calculate the sum of values in control logic, such as incrementing counters, timing functions, or combining measurements."}, "generated_keywords": ["addition", "sum calculation", "numeric addition", "time and date addition", "variable addition"]}
{"instruction_name": "ADR", "description": "The operator yields the 32-bit address (or the 64-bit address, if possible) of its argument. You can pass this address to manufacturer functions or assign it to a pointer in the project. ADR is an extension of the IEC 61131-3 standard and replaces the INDEXOF operator. It can be used with variable names, function names, program names, function block names, and method names.", "parameters": {"Input": [{"name": "variable_name", "type": "Any variable type", "description": "The variable or function for which the address is to be obtained."}], "Output": [{"name": "address_name", "type": "DWORD | LWORD | POINTER TO <basis data type> | XWORD", "description": "The address of the input variable, stored as a pointer or address type compatible with the system."}], "InOut": []}, "how_to_use": "Declare a variable to hold the address with an appropriate pointer or address type (DWORD, LWORD, POINTER TO <type>, or XWORD). Use the ADR operator with a variable (or function/method names) to get its memory address. When using function pointers, they can be passed to external libraries, but cannot be called from within CODESYS. Pointer variables should be updated every cycle after online changes to avoid invalid memory access. Avoid returning POINTER TO variables from functions/methods or assigning them to global variables.", "example_code": "VAR\n    piAddress1: POINTER TO INT;\n    iVar1 : INT := 5;\n\n    lwAddress2 : LWORD;\n    iVar2 : INT := 10;\n\n    xwAddress3 : _XWORD;\n    iVar3 : INT;\nEND_VAR\n\npiAddress1 := ADR(iVar1); // piAddress1 is assigned the address of iVar1\nlwAddress2 := ADR(iVar2); // works for 64 bit run time system\nxwAddress3 := ADR(iVar3); // works for 32 bit and 64 bit systems", "additional_info": "Unlike CoDeSys V2.3, ADR can be applied to functions, programs, function blocks, and methods. When using online code changes, pointer values may become invalid due to address shifts, so update pointers every cycle. Functions and methods must have specific object properties set to allow system calls for function pointers. Avoid returning pointers from functions or assigning them to global variables.", "generated_brief": {"functional_summary": "The ADR instruction returns the memory address of a given variable, function, program, function block, or method as a pointer compatible with the system's architecture.", "usage_context": "It is typically used to obtain addresses for passing pointers to manufacturer functions, interfacing with external libraries, or managing pointers within PLC applications while ensuring pointer validity during online code changes."}, "generated_keywords": ["get memory address", "pointer assignment", "variable address retrieval", "function pointer handling", "online code pointer update"]}
{"instruction_name": "AND", "description": "The IEC operator is used for the bitwise AND of bit operands. When the input bits all yield 1, the output bit also yields 1; otherwise 0.", "parameters": {"Input": [{"name": "Operand1", "type": "BOOL, BYTE, WORD, DWORD, LWORD", "description": "First bit operand for the AND operation."}, {"name": "Operand2", "type": "BOOL, BYTE, WORD, DWORD, LWORD", "description": "Second bit operand for the AND operation."}], "Output": [{"name": "Result", "type": "BOOL, BYTE, WORD, DWORD, LWORD", "description": "Result of the bitwise AND operation between the input operands."}], "InOut": []}, "how_to_use": "Use the AND operator to perform bitwise AND on operands of the same permitted bit type. The operation compares each bit of the operands and returns 1 only if both bits are 1, else returns 0.", "example_code": "var1 := 2#1001_0011 AND 2#1000_1010;", "additional_info": "Operands must be of compatible bit data types: BOOL, BYTE, WORD, DWORD, or LWORD. The operator performs bitwise AND on all bits of the input operands.", "generated_brief": {"functional_summary": "The AND instruction performs a bitwise AND operation on two bit-type operands, returning a result where each bit is set to 1 only if both corresponding input bits are 1.", "usage_context": "It is typically used in PLC programs to evaluate multiple binary conditions simultaneously or to mask specific bits within data for control logic purposes."}, "generated_keywords": ["bitwise AND", "binary masking", "logical AND operation", "bit-level comparison", "PLC bit manipulation"]}
{"instruction_name": "AND_THEN", "description": "The operator is an extension of the IEC 61131-3 standard. The AND_THEN operator is permitted only for programming in structured text with the AND operation of BOOL and BIT operands with short-circuit evaluation. When all operands yield TRUE, the result of the operands also yield TRUE; otherwise FALSE. CODESYS executes the expressions on other operands only if the first operand of the AND_THEN operator is TRUE. This can prevent problems with null pointers, for example in conditions such as IF ( <> 0 AND_THEN ptr^ = 99) THEN.... In contrast, CODESYS always evaluates all operands when using the AND IEC operator.", "parameters": {"Input": [{"name": "operands", "type": "BOOL or BIT", "description": "Operands for the AND_THEN operation, supporting short-circuit evaluation."}], "Output": [{"name": "result", "type": "BOOL or BIT", "description": "Result of the AND_THEN operation, TRUE if all operands are TRUE; otherwise FALSE."}], "InOut": []}, "how_to_use": "Use the AND_THEN operator in structured text when you want the logical AND operation with short-circuit evaluation on BOOL or BIT operands. The evaluation of later operands occurs only if the first operand is TRUE, which prevents errors like null pointer dereferencing.", "example_code": "IF (ptr <> 0 AND_THEN ptr^ = 99) THEN\n    // Your code here\nEND_IF", "additional_info": "Unlike the standard AND operator which evaluates all operands, AND_THEN evaluates operands from left to right and stops evaluation if the first operand is FALSE, thereby avoiding unnecessary or unsafe evaluations.", "generated_brief": {"functional_summary": "The AND_THEN operator performs a logical AND with short-circuit evaluation, returning TRUE only if all BOOL or BIT operands are TRUE and stopping evaluation early if any operand is FALSE.", "usage_context": "It is used in structured text programming to safely evaluate expressions where later conditions depend on earlier ones, such as avoiding null pointer errors."}, "generated_keywords": ["AND_THEN operator", "short-circuit evaluation", "logical AND BOOL BIT", "structured text programming", "null pointer safety"]}
{"instruction_name": "ATAN", "description": "The IEC operator yields the arctangent value of a number. The value is computed in radians.", "parameters": {"Input": [{"name": "value", "type": "Any numeric basic data type", "description": "Input variable representing the value whose arctangent is calculated. The value is measured in radians."}], "Output": [{"name": "result", "type": "REAL | LREAL", "description": "Output variable that holds the arctangent value in radians."}], "InOut": []}, "how_to_use": "Use the ATAN operator with a numeric input to compute its arctangent in radians. The input can be any numeric basic data type; the output will be REAL or LREAL. Typical usage involves directly assigning the result of ATAN to a variable.", "example_code": "q := ATAN(0.5);", "additional_info": "The output data type depends on the assigned variable type and can be REAL or LREAL. The operator strictly returns the angle in radians.", "generated_brief": {"functional_summary": "The ATAN instruction computes the arctangent of a numeric input value and returns the angle in radians.", "usage_context": "It is typically used in control applications where angular calculations or conversions related to trigonometric functions are required."}, "generated_keywords": ["arctangent calculation", "trigonometric function", "angle in radians", "numeric input", "IEC operator"]}
{"instruction_name": "BITADR", "description": "The operator BITADR yields the bit offset within a segment in a DWORD. It is an extension of the IEC 61131-3 standard. The offset depends on whether the \"Byte addressing\" option is selected or cleared in the target system settings. The highest value nibble (4 bits) in this DWORD defines the memory range. Marker M ranges at 16#40000000, Input I at 16#80000000, and Output Q at 16#C0000000.", "parameters": {"Input": [{"name": "xVar", "type": "BOOL", "description": "Variable reference to the bit for which the bit offset is calculated."}], "Output": [{"name": "dwBitoffset", "type": "DWORD", "description": "DWORD value representing the bit offset within the segment."}], "InOut": []}, "how_to_use": "Use BITADR by passing a BOOL variable with an absolute address to retrieve its bit offset encoded in a DWORD. Consider the target system \"Byte addressing\" option as it affects the bit offset calculation. Note that pointers to addresses may shift when applying an online change.", "example_code": "VAR\n    xVar AT %IX2.3 : BOOL;\n    dwBitoffset : DWORD;\nEND_VAR\n\ndwBitoffset := BITADR(xVar); (* If byte addressing = TRUE, result = 16#80000013; if byte addressing = FALSE, result =  16#80000023 *)", "additional_info": "The highest nibble in the result DWORD indicates the memory range for markers (M), inputs (I), and outputs (Q) with fixed hex values. Use caution when using pointers because online changes can shift address contents.", "generated_brief": {"functional_summary": "The BITADR calculates and returns the bit offset of a BOOL variable within its memory segment encoded as a DWORD, considering system-specific byte addressing settings.", "usage_context": "It is used in PLC programming when precise bit-level addressing is required for I/O, markers, or memory variables, especially in systems where bit offsets influence hardware interaction or memory mapping."}, "generated_keywords": ["bit offset calculation", "BOOL variable addressing", "DWORD bit position", "byte addressing consideration", "PLC memory segment mapping"]}
{"instruction_name": "CAL", "description": "The IEC operator is used for calling function blocks. In IL, CAL calls the instance of a function block.", "parameters": {"Input": [{"name": "input variables", "type": "Any (compatible with the function block's input parameters)", "description": "Input variables of the function block instance with assigned values"}], "Output": [], "InOut": []}, "how_to_use": "Use the CAL operator to call an instance of a function block in IL by specifying the function block instance and assigning values to its input variables in parentheses.", "example_code": "CAL Inst(Par1 := 0, Par2 := TRUE);", "additional_info": "", "generated_brief": {"functional_summary": "The CAL instruction calls an instance of a function block in IL by passing specified input parameters.", "usage_context": "It is used in industrial control programs to execute function block logic with given inputs within instruction list code."}, "generated_keywords": ["function block call", "IL instruction list", "CAL operator", "call function block instance", "input parameter assignment"]}
{"instruction_name": "COMPARE_AND_SWAP", "description": "The multicore operator is an extension of the IEC 61131-3 standard. It can be used for implementing a semaphore to guarantee exclusive access to a variable written to by different tasks. The operator gets a pointer to a XWORD variable, an old value, and a new value as its input. It compares the referenced XWORD variable with the old value, and if both are equal, writes the new value. The function returns TRUE when the new value could be written. The operation is atomic and cannot be interrupted by another task, even on multicore platforms.", "parameters": {"Input": [{"name": "Pointer to variable", "type": "POINTER TO XWORD", "description": "Pointer to the XWORD variable to be compared and swapped."}, {"name": "Old value", "type": "XWORD", "description": "The expected old value to compare with the referenced variable."}, {"name": "New value", "type": "XWORD", "description": "The new value to write if the comparison succeeds."}], "Output": [{"name": "Result", "type": "BOOL", "description": "Returns TRUE if the new value was written successfully (comparison matched), otherwise FALSE."}], "InOut": []}, "how_to_use": "Use COMPARE_AND_SWAP to implement atomic compare-and-swap operations, e.g., semaphores for exclusive access. Pass the address of a XWORD variable, an old comparison value, and a new value. The function will atomically compare the variable with the old value and update it to the new value on success. On 32-bit systems, XWORD is replaced with DWORD; on 64-bit systems, with LWORD. Use this operator to avoid race conditions in multicore or multitask environments.", "example_code": "FUNCTION ExclusiveStringWrite : BOOL\nVAR_INPUT\n        strToWrite : STRING;\n        pstrOutput : POINTER TO STRING;\nEND_VAR\nVAR_STAT\n  dwSynch : XWORD;\nEND_VAR\nVAR\n        bMutex: BOOL;\nEND_VAR\n\nbMutex:= COMPARE_AND_SWAP(ADR(dwSynch), 0, 1);\n(* compare with 0 and write 1 as atomic operation *)\nIF bMutex THEN                                       // bMutex is TRUE if write could be done\n    pstrOutput^ := strToWrite;         // Now you can write safely on the string\n    dwSynch := 0;                      // The XWORD variable must be reset.\n    ExclusiveStringWrite := TRUE;                // Writing was successful\nELSE\n    ExclusiveStringWrite := FALSE;       // Writing was not successful\nEND_IF", "additional_info": "The compiler automatically replaces XWORD with DWORD on 32-bit systems and LWORD on 64-bit systems. This atomic operation is suitable for synchronization in multicore environments to prevent inconsistent variable states due to concurrent writes.", "generated_brief": {"functional_summary": "COMPARE_AND_SWAP atomically compares the value of a variable with an expected old value and, if they match, swaps it with a new value, returning TRUE on success.", "usage_context": "It is used to implement synchronization primitives like semaphores for exclusive access in multicore or multitask PLC environments to avoid race conditions."}, "generated_keywords": ["atomic compare and swap", "semaphore synchronization", "exclusive access", "multicore variable protection", "race condition prevention"]}
{"instruction_name": "Content Operator (^)", "description": "The operator is an extension of the IEC 61131-3 standard. It allows for dereferencing a pointer by appending the operator ^ to the pointer identifier, enabling access to the content pointed to by the pointer.", "parameters": {"Input": [{"name": "Pointer", "type": "POINTER TO <DataType>", "description": "A pointer variable pointing to the memory address of the target variable."}], "Output": [{"name": "Dereferenced value", "type": "<DataType>", "description": "The value stored at the memory location pointed to by the pointer."}], "InOut": []}, "how_to_use": "Declare a pointer variable pointing to a variable's address using ADR(). To access or modify the value pointed to, append the ^ operator to the pointer variable. Care should be taken when using pointers to addresses as online changes can shift address contents.", "example_code": "pt : POINTER TO INT;\nvar_int1 : INT;\nvar_int2 : INT;\npt := ADR(var_int1);\nvar_int2 := pt^;", "additional_info": "When using pointers to addresses, applying an online change can shift the contents of addresses, which requires caution.", "generated_brief": {"functional_summary": "The Content Operator (^) dereferences a pointer to access or modify the value stored at the memory it points to.", "usage_context": "It is used in PLC programming when manipulating data indirectly through pointers to enable flexible and dynamic memory access."}, "generated_keywords": ["pointer dereferencing", "content operator", "memory access", "pointer manipulation", "indirect data access"]}
{"instruction_name": "COS", "description": "The IEC operator yields the cosine value of a number.", "parameters": {"Input": [{"name": "angle", "type": "any numeric basic data type", "description": "Input variable measuring the angle in radians."}], "Output": [{"name": "result", "type": "REAL or LREAL", "description": "Cosine value of the input angle."}], "InOut": []}, "how_to_use": "Use the COS function with an input angle in radians to obtain its cosine value. The input value must be within the range of -2^63 to +2^63. On x86 and x64 systems, if the input value is outside this range, the function returns the input value.", "example_code": "q := COS(0.5);", "additional_info": "Permitted input range is from -2^63 to +2^63. If the input value is out of range on x86 and x64 platforms, the function returns the input value instead of the cosine.", "generated_brief": {"functional_summary": "The COS function calculates the cosine of an input angle given in radians.", "usage_context": "It is typically used in PLC programs for mathematical computations involving trigonometric operations, such as in motion control or signal processing."}, "generated_keywords": ["cosine calculation", "trigonometric function", "angle in radians", "mathematical computation", "IEC operator"]}
{"instruction_name": "CURRENTTASK", "description": "The operator is an extension of the IEC 61131-3 standard. At runtime, the operator provides information about the IEC task that is currently running. It allows access to a structure with two variables: TaskIndex (zero-based index that identifies the task) and pTaskInfo (detailed information about the currently running task, which can be assigned to a POINTER TO Task_Info2 from the library CmpIecTask). The operator cannot be used in the declaration of a POU. If the current task cannot be determined, then TaskIndex is -1 and pTaskInfo is zero.", "parameters": {"Input": [], "Output": [{"name": "TaskIndex", "type": "INT", "description": "Zero-based index that identifies the currently running IEC task."}, {"name": "pTaskInfo", "type": "POINTER TO Task_Info2", "description": "Pointer to detailed information about the currently running task, from library CmpIecTask."}], "InOut": []}, "how_to_use": "Use CURRENTTASK at runtime to retrieve the current task index and detailed task info. It must not be used in the declaration of POUs, only in program code. It is supported only if the target system setting memory-layout\\max-stack-size is set to a value greater than 0.", "example_code": "//Declaration\nVAR\n        idx : INT;\n        pInfo : POINTER TO Task_Info2;\nEND_VAR\n\n//Program code\n\nidx := CURRENTTASK.TaskIndex;\npInfo := CURRENTTASK.pTaskInfo;", "additional_info": "If current task information is not available, TaskIndex returns -1 and pTaskInfo is zero. Ensure the target system enables the operator by configuring memory-layout\\max-stack-size > 0.", "generated_brief": {"functional_summary": "CURRENTTASK provides runtime information about the currently executing IEC task, including its index and detailed task data via a pointer.", "usage_context": "It is used within program code to monitor or manage task-specific behaviors and diagnostics, and requires system configuration with max-stack-size greater than zero."}, "generated_keywords": ["current IEC task", "runtime task info", "task index retrieval", "task diagnostics", "pointer to task details"]}
{"instruction_name": "DELETE", "description": "The operator releases the memory of instances that the \"NEW\" operator generated dynamically. The DELETE operator does not have a return value and the operand is set to zero after this operation. It requires the \"Use dynamic memory allocation\" option to be selected in the application build options. If the pointer references a function block, CODESYS calls the associated FB_EXIT method before setting the pointer to zero.", "parameters": {"Input": [{"name": "pointer", "type": "POINTER TO <type>", "description": "Pointer to the memory instance previously allocated dynamically with NEW. The memory will be released and the pointer set to zero."}], "Output": [], "InOut": []}, "how_to_use": "Ensure the compiler version is >= 3.3.2.0 and dynamic memory allocation is enabled. Avoid calling DELETE simultaneously from two tasks to prevent concurrency issues—use a semaphore or restrict calls to one task only. When deleting function block instances, FB_EXIT is called automatically. Use DELETE to release dynamically allocated resources to avoid memory leaks.", "example_code": "IF (bDelete) THEN\n    DELETE(pFB);\nEND_IF", "additional_info": "Simultaneous calls of DELETE from multiple tasks can cause issues; use synchronization mechanisms like SysSemEnter to prevent this. Extensive use of DELETE may cause higher jitter. Compatible compiler version and build options must be set.", "generated_brief": {"functional_summary": "The DELETE instruction releases dynamically allocated memory previously obtained with NEW and resets the associated pointer to zero, calling FB_EXIT for function blocks if applicable.", "usage_context": "It is used in PLC programs to free dynamic memory resources safely, preventing memory and ensuring proper cleanup of function block instances when they are no longer needed."}, "generated_keywords": ["dynamic memory release", "DELETE operator", "pointer reset", "function block cleanup", "memory leak prevention"]}
{"instruction_name": "DIV", "description": "The IEC operator is used to divide variables.", "parameters": {"Input": [{"name": "Operand1", "type": "BYTE, WORD, DWORD, LWORD, SINT, USINT, INT, UINT, DINT, UDINT, LINT, ULINT, REAL, LREAL, TIME", "description": "The dividend variable to be divided."}, {"name": "Operand2", "type": "BYTE, WORD, DWORD, LWORD, SINT, USINT, INT, UINT, DINT, UDINT, LINT, ULINT, REAL, LREAL, TIME", "description": "The divisor variable by which Operand1 is divided."}], "Output": [{"name": "Result", "type": "Corresponding to input types", "description": "The result of the division Operand1 / Operand2."}], "InOut": []}, "how_to_use": "Use the DIV operator to perform division between two variables of permitted data types. Be careful with division by zero as it may have different results depending on the target system. Runtime monitoring of division by zero can be done using implicit monitoring functions like CheckDivInt, CheckDivLint, CheckDivReal, and CheckDivLReal.", "example_code": "var1 := 8 / 2;", "additional_info": "Division by zero may have different results depending on the target system. It is recommended to monitor division by zero at runtime by using implicit monitoring functions CheckDivInt, CheckDivLint, CheckDivReal, and CheckDivLReal.", "generated_brief": {"functional_summary": "The DIV instruction performs division between two variables of various data types and outputs the quotient.", "usage_context": "It is used in PLC programs whenever arithmetic division of numerical or time-based variables is required, with caution to handle division by zero cases."}, "generated_keywords": ["division", "arithmetic operator", "divide variables", "handle division by zero", "numerical calculation"]}
{"instruction_name": "EQ", "description": "The IEC operator compares two operands for equality. All elementary data types are permitted as data types for the operands. If the operands are equal, then the operator yields the result TRUE; otherwise FALSE.", "parameters": {"Input": [{"name": "operand1", "type": "Elementary data types (e.g., BOOL, INT, REAL, BYTE, DATE, TIME, etc.)", "description": "First operand to be compared for equality."}, {"name": "operand2", "type": "Elementary data types (e.g., BOOL, INT, REAL, BYTE, DATE, TIME, etc.)", "description": "Second operand to be compared for equality."}], "Output": [{"name": "result", "type": "BOOL", "description": "Result of the equality comparison; TRUE if operands are equal, otherwise FALSE."}], "InOut": []}, "how_to_use": "Use the EQ operator to compare two operands of any elementary data type for equality in Structured Text. The operator returns a BOOL result reflecting if the two operands are equal. Typical use includes variable comparisons in conditional statements or assignments.", "example_code": "// Implementation\nVAR1 := 20 = 20;", "additional_info": "Elementary data types include standard IEC 61131-3 types and CODESYS-specific types such as BIT, UXINT, XINT, and XWORD.", "generated_brief": {"functional_summary": "The EQ instruction compares two operands of any elementary data type and returns TRUE if they are equal, otherwise FALSE.", "usage_context": "It is typically used in conditional statements or assignments within PLC programs to evaluate whether two variables have the same value."}, "generated_keywords": ["equality comparison", "compare operands", "boolean result", "conditional evaluation", "elementary data types"]}
{"instruction_name": "EXP", "description": "The IEC operator yields the exponential function.", "parameters": {"Input": [{"name": "input", "type": "any numeric basic data type", "description": "The input value for which the exponential function is calculated."}], "Output": [{"name": "result", "type": "REAL or LREAL", "description": "The computed exponential value of the input."}], "InOut": []}, "how_to_use": "Call the EXP function with any numeric input to obtain the exponential result as REAL or LREAL. Suitable for applications needing e^x calculations.", "example_code": "q := EXP(2);", "additional_info": "Input values must be numeric basic data types; output is restricted to REAL or LREAL types.", "generated_brief": {"functional_summary": "The EXP function calculates the exponential value e raised to the power of a given numeric input.", "usage_context": "It is used in PLC programs for mathematical computations requiring exponential calculations, such as process control or signal processing."}, "generated_keywords": ["exponential function", "math calculation", "e^x computation", "numeric input", "REAL LREAL output"]}
{"instruction_name": "EXPT", "description": "The IEC operator raises a number to a higher power and returns the power of the base raised to the exponent: power = base^exponent. The input values (parameters) are base and the exponent. The power function is undefined if the base is zero and the exponent is negative. However, the behavior depends on the platform in this case.", "parameters": {"Input": [{"name": "base", "type": "Numeric base data types (SINT, USINT, INT, UINT, DINT, UDINT, LINT, ULINT, REAL, LREAL, BYTE, WORD, DWORD, LWORD)", "description": "The base value to be raised to the power."}, {"name": "exponent", "type": "Numeric base data types (SINT, USINT, INT, UINT, DINT, UDINT, LINT, ULINT, REAL, LREAL, BYTE, WORD, DWORD, LWORD)", "description": "The exponent value to which the base is raised."}], "Output": [{"name": "power", "type": "REAL or LREAL", "description": "The result of raising the base to the power of the exponent."}], "InOut": []}, "how_to_use": "Use EXPT(base, exponent) to calculate the power of a number. Note the function is undefined if the base is zero and the exponent is negative, with behavior dependent on the platform. Permitted inputs are numeric data types; the output is a floating-point number (REAL or LREAL).", "example_code": "Var1 := EXPT(7,2);\n\n// Example with variables\nPROGRAM PLC_PRG\nVAR\n    lrPow : LREAL;\n    iBase : INT := 2;\n    iExponent : INT := 7;\nEND_VAR\n\nlrPow := EXPT(iBase, iExponent);", "additional_info": "Be aware of the undefined behavior when base=0 and exponent<0, which may vary depending on the PLC platform implementation.", "generated_brief": {"functional_summary": "The EXPT function calculates the result of raising a numeric base value to a numeric exponent power and returns the computed power as a floating-point number.", "usage_context": "It is typically used in PLC programs wherever exponential are needed, such as in mathematical computations, process control algorithms, or engineering formulas."}, "generated_keywords": ["exponentiation", "power calculation", "numeric base and exponent", "floating-point result", "mathematical function"]}
{"instruction_name": "GT", "description": "The IEC operator is used for the \"greater than\" function. Permitted data types of the operands: any basic data type. If the first operand is greater than the second operand, then the operator yields the result TRUE; otherwise FALSE.", "parameters": {"Input": [{"name": "Operand1", "type": "any basic data type", "description": "The first operand to compare."}, {"name": "Operand2", "type": "any basic data type", "description": "The second operand to compare."}], "Output": [{"name": "Result", "type": "BOOL", "description": "TRUE if Operand1 is greater than Operand2; otherwise FALSE."}], "InOut": []}, "how_to_use": "Use the GT operator to compare two operands of any basic data type. When the first operand is greater than the second, the result is TRUE; otherwise FALSE. This operator is commonly used in conditional statements and expressions.", "example_code": "VAR1 := 20 > 30;", "additional_info": "Operands must be of any basic data type supported by IEC standards; no restrictions mentioned. Result is always of type BOOL.", "generated_brief": {"functional_summary": "The GT operator compares two operands and returns TRUE if the first operand is greater than the second; otherwise, it returns FALSE.", "usage_context": "It is typically used in conditional statements within PLC programs to control logic based on comparative evaluation of values."}, "generated_keywords": ["greater than comparison", "IEC operator", "conditional evaluation", "boolean result", "basic data types"]}
{"instruction_name": "INDEXOF", "description": "The operator is an extension of the IEC 61131-3 standard.", "parameters": {"Input": [], "Output": [], "InOut": []}, "how_to_use": "Instead of the INDEXOF operator, the ADR operator is provided in CODESYS V3 for getting a pointer at the index of a POU.", "example_code": "", "additional_info": "", "generated_brief": {"functional_summary": "INDEXOF is an IEC 61131-3 extension operator intended to find the index of a specific element within a structure.", "usage_context": "It is typically used in older PLC programming environments to retrieve element positions, in CODESYS V3, the ADR operator is preferred to obtain pointers at POU indices."}, "generated_keywords": ["INDEXOF operator", "IEC 61131-3 extension", "find element index", "POU index pointer", "CODESYS V3 ADR replacement"]}
{"instruction_name": "INI", "description": "The INI operator triggers the initialization of retain variables of a function block instance used in a POU. If the second parameter is TRUE, CODESYS initializes all retain variables defined in the function block instance and then returns TRUE.", "parameters": {"Input": [{"name": "FB instance name", "type": "Function Block instance", "description": "The instance of the function block whose retain variables will be initialized."}, {"name": "boolean value", "type": "BOOL", "description": "Set to TRUE to trigger the initialization of retain variables; FALSE otherwise."}], "Output": [{"name": "result", "type": "BOOL", "description": "Returns TRUE if initialization was triggered."}], "InOut": []}, "how_to_use": "Use the INI operator by assigning its result to a BOOL variable. Pass the function block instance and a BOOL value TRUE to initialize all retain variables. Typically used in projects imported from CODESYS V2.3, as INI has been replaced by FB_Init in CODESYS V3.", "example_code": "VAR\n    fbinst : fb1;\n    b : BOOL;\nEND_VAR\n\nb := INI(fbinst, TRUE);\nivar := fbinst.retvar; (* => retvar is initialized *)", "additional_info": "The INI operator is specific to CoDeSys V2.3 and has been replaced by the FB_Init method in CODESYS V3. It remains available for compatibility with migrated projects.", "generated_brief": {"functional_summary": "The INI instruction initializes all retain variables of a specified function block instance when triggered with a TRUE boolean value and returns TRUE upon successful initialization.", "usage_context": "It is typically used in CoDeSys V2.3 projects to initialize retain variables of function blocks, especially in migrated projects where this legacy instruction is maintained for compatibility."}, "generated_keywords": ["initialize retain variables", "function block instance", "CODESYS V2.3 compatibility", "INI operator", "retain variable initialization"]}
{"instruction_name": "ISVALIDREF", "description": "The operator is an extension of the IEC 61131-3 standard. The operator is used for checking whether a reference refers to a valid value.", "parameters": {"Input": [{"name": "reference", "type": "REFERENCE", "description": "The reference to be checked if it refers to a valid value."}], "Output": [{"name": "validity", "type": "BOOL", "description": "TRUE if the reference refers to a valid value, otherwise FALSE."}], "InOut": []}, "how_to_use": "Use ISVALIDREF to verify that a reference variable points to a valid target before accessing it, preventing runtime errors due to invalid references.", "example_code": "", "additional_info": "Refer to the REFERENCE data type documentation for more details on the use and behavior of this operator.", "generated_brief": {"functional_summary": "ISVALIDREF checks whether a given reference variable points to a valid value.", "usage_context": "It is used to verify the validity of a reference before accessing it to prevent runtime errors in PLC programs."}, "generated_keywords": ["validate reference", "check reference validity", "prevent invalid reference access", "reference pointer check", "runtime error prevention"]}
{"instruction_name": "LE", "description": "The IEC operator is used for the \"less than or equal to\" function. Permitted data types of the operands: any basic data type. If the first operand is less than or equal to the second operand, then the operator yields the result TRUE; otherwise FALSE.", "parameters": {"Input": [{"name": "Operand1", "type": "ANY_BASIC", "description": "The first operand to be compared."}, {"name": "2", "type": "ANY_BASIC", "description": "The second operand to be compared."}], "Output": [{"name": "Result", "type": "BOOL", "description": "TRUE if Operand1 is less than or equal to Operand2; otherwise FALSE."}], "InOut": []}, "how_to_use": "Use the LE operator to compare two values of any basic data type. The result is a boolean indicating whether the first value is less than or equal to the second. This operator is commonly used in conditional statements and assignments.", "example_code": "Var1 := 20 <= 30;", "additional_info": "", "generated_brief": {"functional_summary": "The LE function compares two values and returns TRUE if the first operand is less than or equal to the second, otherwise FALSE.", "usage_context": "It is typically used in conditional statements and assignments to control program flow based on comparative evaluation of basic data types."}, "generated_keywords": ["less than or equal to", "comparison operator", "boolean result", "conditional evaluation", "basic data types"]}
{"instruction_name": "LIMIT", "description": "The IEC selection operator is used for limiting. LIMIT(Min, IN, Max) means OUT := MIN (MAX (IN, Min), Max). Max is the upper limit and Min is the lower limit for the result. If the IN value is above the Max upper limit, then LIMIT yields Max. If the value of IN is below the Min lower limit, then the result is Min. Permitted data types for IN and OUT: all.", "parameters": {"Input": [{"name": "Min", "type": "any (compatible with IN and OUT)", "description": "The lower limit for the result."}, {"name": "IN", "type": "any (compatible with Min and Max)", "description": "The input value to be limited."}, {"name": "Max", "type": "any (compatible with Min and IN)", "description": "The upper limit for the result."}], "Output": [{"name": "OUT", "type": "any (compatible with Min, IN, Max)", "description": "The limited output value constrained between Min and Max."}], "InOut": []}, "how_to_use": "Use LIMIT to constrain an input value between specified minimum and maximum boundaries. It is useful to ensure that a value does not exceed set limits by returning Max if the input exceeds Max, or Min if the input is below Min.", "example_code": "Var1 := LIMIT(30,90,80);", "additional_info": "", "generated_brief": {"functional_summary": "The LIMIT instruction restricts an input value to lie within specified minimum and maximum boundaries, outputting the constrained value.", "usage_context": "It is typically used in PLC programming to ensure variables or signals do not exceed defined operational limits for safety or control purposes."}, "generated_keywords": ["value limiting", "min max constraint", "input range restriction", "boundary enforcement", "signal clamping"]}
{"instruction_name": "LN", "description": "The IEC operator yields the natural logarithm of a number.", "parameters": {"Input": [{"name": "value", "type": "any numeric basic data type", "description": "The input number for which the natural logarithm is calculated."}], "Output": [{"name": "result", "type": "REAL or LREAL", "description": "The natural logarithm of the input value."}], "InOut": []}, "how_to_use": "Use LN to calculate the natural logarithm of a numeric input. The input can be any numeric type, and the output is of type REAL or LREAL. Commonly used q := LN(value);", "example_code": "q := LN(45);", "additional_info": "", "generated_brief": {"functional_summary": "The LN instruction calculates the natural logarithm of a given numeric input value.", "usage_context": "It is typically used in PLC programming for mathematical computations requiring logarithmic transformations, such as process control and data normalization."}, "generated_keywords": ["natural logarithm", "logarithmic calculation", "numeric input", "mathematical function", "PLC math instruction"]}
{"instruction_name": "LOG", "description": "The IEC operator yields the base-10 logarithm of a number. The input variable can be any numeric basic data type, but the output variable must be the data type REAL or LREAL.", "parameters": {"Input": [{"name": "InputValue", "type": "ANY_NUMERIC", "description": "Any numeric basic data type input for which the base-10 logarithm is calculated."}], "Output": [{"name": "Result", "type": "REAL or LREAL", "description": "The base-10 logarithm of the input value."}], "InOut": []}, "how_to_use": "Use the LOG operator to compute the base-10 logarithm of a numeric input. Ensure the output variable is declared as REAL or LREAL to hold the result. Typical use includes mathematical computations requiring logarithmic scales.", "example_code": "q := LOG(314.5);", "additional_info": "The input can be any numeric basic type, but the result must be stored in a REAL or LREAL variable to match the operator's output type requirements.", "generated_brief": {"functional_summary": "The LOG instruction calculates the base-10 logarithm of a numeric input value and returns the result as a REAL or LREAL type.", "usage_context": "It is commonly used in industrial automation for mathematical computations that require logarithmic scaling or data transformation."}, "generated_keywords": ["base-10 logarithm", "logarithmic calculation", "numeric input processing", "REAL output", "LREAL output"]}
{"instruction_name": "LT", "description": "The IEC operator is used for the \"less than\" function. Permitted data types of the operands: any basic data type. If the first operand is less than the second operand, then the operator yields the result TRUE; otherwise FALSE.", "parameters": {"Input": [{"name": "Operand1", "type": "any basic data type", "description": "First operand to compare."}, {"name": "Operand2", "type": "any basic data type", "description": "Second operand to compare."}], "Output": [{"name": "Result", "type": "BOOL", "description": "TRUE if Operand1 is less than Operand2; otherwise FALSE."}], "InOut": []}, "how_to_use": "Use the LT operator to compare two values of any basic data type. Commonly used in conditional expressions to determine if one value is smaller than another.", "example_code": "Var1 := 20 < 30;", "additional_info": "", "generated_brief": {"functional_summary": "The LT instruction compares two values returns TRUE if the first operand is less than the second operand; otherwise, it returns FALSE.", "usage_context": "It is typically used in conditional statements within PLC programs to control logic based on the relative magnitude of numeric or other comparable data types."}, "generated_keywords": ["less than comparison", "conditional operator", "boolean result", "numeric value comparison", "IEC operator"]}
{"instruction_name": "MAX", "description": "The IEC operator is used for the maximum function. It yields the greatest value of all inputs.", "parameters": {"Input": [{"name": "IN0, IN1, IN2, ...", "type": "all", "description": "Input values to be compared; the operator returns the greatest among these values."}], "Output": [{"name": "OUT", "type": "same as inputs", "description": "The greatest value among the inputs."}], "InOut": []}, "how_to_use": "Use the MAX operator with multiple input parameters to obtain the maximum value. Inputs can be of any permitted data type, and MAX can be nested to compare multiple values.", "example_code": "Var1 := MAX(30,90,40);\n\nVar1 := MAX(40,MAX(90,30));", "additional_info": "Permitted data types for the inputs are all IEC 61131-3 compatible types.", "generated_brief": {"functional_summary": "The MAX instruction returns the greatest value among multiple input values of any IEC 61131-3 compatible data type.", "usage_context": "It is typically used in industrial automation systems to determine the highest value from a set of sensor readings or calculated values for control or decision-making purposes."}, "generated_keywords": ["maximum value", "compare inputs", "IEC operator", "value selection", "nested MAX"]}
{"instruction_name": "MIN", "description": "The IEC operator is used for the minimum function. It yields the least value of all inputs.", "parameters": {"Input": [{"name": "IN0, IN1, IN2, ...", "type": "all", "description": "Input values for which the minimum value is to be determined. Permitted data types: all."}], "Output": [{"name": "OUT", "type": "same as input", "description": "Output variable assigned the minimum value among all inputs."}], "InOut": []}, "how_to_use": "Use the MIN operator by passing multiple input values separated by commas. The operator evaluates and returns the smallest input value. It supports nesting, allowing expressions like MIN(MIN(90,30),40).", "example_code": "Var1 := MIN(90,30,40);\n\nVar1 := MIN(MIN(90,30),40);", "additional_info": "The MIN operator supports all permitted IEC data types. It is commonly used in both Structured Text (ST) and Function Block Diagram (FBD) programming.", "generated_brief": {"functional_summary": "The MIN function returns the smallest value from multiple input values of any permitted IEC data type.", "usage_context": "It is typically used in PLC programming to determine the minimum of several values for control and decision-making processes."}, "generated_keywords": ["minimum value", "IEC operator", "multi-input comparison", "Structured Text function", "Function Block Diagram"]}
{"instruction_name": "MOD", "description": "The IEC operator is used for modulo division. The result of the function is the non-negative, integer remainder of division.", "parameters": {"Input": [{"name": "operand1", "type": "BYTE, WORD, DWORD, LWORD, SINT, USINT, INT, UINT, DINT, UDINT, LINT, or ULINT", "description": "The dividend in the modulo operation."}, {"name": "operand2", "type": "BYTE, WORD, DWORD, LWORD, SINT, USINT, INT, UINT, DINT, UDINT, LINT, or ULINT", "description": "The divisor in the modulo operation."}], "Output": [{"name": "result", "type": "Same as input operand types", "description": "The non-negative remainder of the division operand1 MOD operand2."}], "InOut": []}, "how_to_use": "Use the MOD operator between two integer operands to get the non-negative remainder of integer division. Be cautious about division by zero, as it may have different results depending on the target system.", "example_code": "var1 := 9 MOD 2;", "additional_info": "Permitted data types include BYTE, WORD, DWORD, LWORD, SINT, USINT, INT, UINT, DINT, UDINT, LINT, and ULINT. Division by zero behavior depends on the target system and may cause undefined results.", "generated_brief": {"functional_summary": "The MOD instruction calculates the non-negative remainder of division of two integer operands.", "usage_context": "It is typically used in PLC programs for operations requiring remainder calculation, such as cyclic counters or periodic event triggering."}, "generated_keywords": ["modulo operation", "integer remainder", "division remainder", "cyclic counter", "periodic event trigger"]}
{"instruction_name": "MOVE", "description": "The IEC operator is used for assigning a variable to another variable of a corresponding type. Because MOVE is available in the CFC, FBD, and LD editors, you can also use the EN/ENO functionality there for variable assignment.", "parameters": {"Input": [{"name": "ivar1", "type": "Any compatible IEC data type", "description": "Source variable whose value is to be assigned."}], "Output": [{"name": "ivar2", "type": "Matching IEC data type of the input", "description": "Destination variable which receives the value of the input variable."}], "InOut": []}, "how_to_use": "Use MOVE to assign the value of one variable to another variable of the corresponding type. In CFC, FBD, and LD editors, MOVE supports EN/ENO for conditional assignment. In Structured Text, the MOVE operator can be used directly by calling MOVE(sourceVariable), which is equivalent to direct assignment.", "example_code": "ivar2 := MOVE(ivar1);", "additional_info": "MOVE performs a simple assignment and can be conditionally executed in graphical editors using EN/ENO. The result of MOVE(ivar1) is the value of ivar1; thus ivar2 := MOVE(ivar1); is equivalent to ivar2 := ivar1;.", "generated_brief": {"functional_summary": "The MOVE instruction assigns the value of one variable to another variable of a compatible type in a PLC program.", "usage_context": "It is typically used for simple data transfers between variables and supports conditional execution in graphical programming editors such as CFC, FBD, and LD."}, "generated_keywords": ["variable assignment", "data transfer", "MOVE instruction", "conditional assignment", "PLC programming"]}
{"instruction_name": "MUL", "description": "The IEC operator is used to multiply variables.", "parameters": {"Input": [{"name": "Operand1", "type": "BYTE, WORD, DWORD, LWORD, SINT, USINT, INT, UINT, DINT, UDINT, LINT, ULINT, REAL, LREAL, TIME", "description": "First operand to be multiplied."}, {"name": "Operand2", "type": "BYTE, WORD, DWORD, LWORD, SINT, USINT, INT, UINT, DINT, UDINT, LINT, ULINT, REAL, LREAL, TIME", "description": "Second operand to be multiplied."}], "Output": [{"name": "Result", "type": "Same as input types", "description": "The result of multiplying the input operands."}], "InOut": []}, "how_to_use": "Use the MUL operator to multiply two or more compatible typed variables. In the FBD/LD editor, the MUL operator can be extended with additional inputs to multiply multiple operands together. The number of additional inputs is limited.", "example_code": "var1 := 7 * 2 * 4 * 7;", "additional_info": "Permitted data types include BYTE, WORD, DWORD, LWORD, SINT, USINT, INT, UINT, DINT, UDINT, LINT, ULINT, REAL, LREAL, and TIME. In FBD/LD, the number of additional function block inputs for multiplication is limited.", "generated_brief": {"functional_summary": "The MUL instruction multiplies two or more compatible typed variables and returns their product.", "usage_context": "It is typically used in PLC programs to perform arithmetic multiplication operations on numerical or time values within industrial automation processes."}, "generated_keywords": ["multiply variables", "arithmetic multiplication", "multiple operands multiplication", "IEC operator MUL", "numeric and time data multiplication"]}
{"instruction_name": "MUX", "description": "The IEC operator is used as a multiplexer. MUX selects the K-th value from a set of values. The first value is K=0. If K is greater than the number of other inputs (n), then CODESYS passes on the last value (INn). The compiler checks for type identity and returns any compile errors. The assignment of function block instances to interface variables is specifically not supported. For runtime optimization, CODESYS computes only the expression which precedes IN_K. However, in simulation mode, CODESYS computes all branches.", "parameters": {"Input": [{"name": "K", "type": "BYTE | WORD | DWORD | LWORD | SINT | USINT | INT | UINT | DINT | LINT | ULINT | UDINT", "description": "Index value selecting which input (IN0,...,INn) to output. Must be one of the listed integral types."}, {"name": "IN0,...,INn", "type": "any identical data type", "description": "Input values of any identical data type. The selection will be made among these values."}], "Output": [{"name": "OUT", "type": "same type as IN0,...,INn", "description": "Output value which corresponds to the K-th input from the input set."}], "InOut": []}, "how_to_use": "Use MUX to select one value from multiple inputs based on an integral index K. Ensure that K is within the range of input indexes; if K is out of range, the last input is selected. All inputs and the output must have the identical data type. CODESYS runtime optimizes evaluation by computing only the chosen input expression during runtime, while simulation mode evaluates all inputs.", "example_code": "Var1 := MUX(0,30,40,50,60,70,80);", "additional_info": "Variables must be of identical type across all inputs and output, including user-defined types. Assignment of function block instances to interface variables is not supported. For runtime performance, only the selected input expression is computed.", "generated_brief": {"functional_summary": "The MUX instruction selects and outputs the K-th input value from a set of inputs all having the same data type.", "usage_context": "It is used in PLC programming to dynamically choose one value from multiple options based on an integral index during runtime."}, "generated_keywords": ["multiplexer", "select input by index", "dynamic value selection", "identical data types", "runtime input evaluation"]}
{"instruction_name": "Enumeration Namespace", "description": "The operator is an extension of the IEC 61131-3 standard. You can use the TYPE name of an enumeration for unique access to an enumeration constant. In this way, you can use the same constant names in different enumerations. The enumeration name is prepended to the constant name with a dot ('.').", "parameters": {"Input": [{"name": "enumeration name", "type": "ENUMERATION", "description": "The TYPE name of the enumeration containing the constant."}, {"name": "constant name", "type": "ENUMERATION constant", "description": "The constant defined inside the enumeration type."}], "Output": [{"name": "enumeration constant value", "type": "ENUMERATION constant", "description": "The value of the enumeration constant accessed using the enumeration namespace operator."}], "InOut": []}, "how_to_use": "Use the syntax <enumeration_name>.<constant_name> to uniquely access a constant from an enumeration. This helps to disambiguate constants when the same constant name exists in multiple enumerations.", "example_code": "color := Colors.Blue;  // Access to component Blue in enumeration Colors\nfeeling := Feelings.Blue; // Access to component Blue in enumeration Feelings", "additional_info": "This operator extends the IEC 61131-3 standard to allow namespace-like access to enumeration constants to avoid name conflicts.", "generated_brief": {"functional_summary": "This function uniquely accesses an enumeration constant by prepending the enumeration type name to the constant name using a dot operator.", "usage_context": "It is used in PLC programming to avoid naming conflicts when the same constant names exist in different enumerations by providing namespace-like disambiguation."}, "generated_keywords": ["enumeration namespace", "unique enumeration access", "constant disambiguation", "IEC 61131-3 extension", "dot operator enumeration"]}
{"instruction_name": "Global Namespace", "description": "An instance path which begins with a dot (.) always opens a global namespace. If there is a local variable that has the same name <varname> as a global variable, then you refer to the global variable as .<varname>.", "parameters": {"Input": [{"name": "varname", "type": "Any (variable name)", "description": "Name of the variable which can be local or global. To reference the global variable, prefix with a dot."}], "Output": [], "InOut": []}, "how_to_use": "Use a dot prefix to a variable name to explicitly refer to the global variable when a local variable with the same name exists, ensuring access to the global namespace.", "example_code": "", "additional_info": "This operator is an extension to IEC 61131-3 standard to distinguish between local and global variables with the same name.", "generated_brief": {"functional_summary": "This instruction allows explicit access to global variables by prefixing the variable name with a dot when a local variable with the same name exists.", "usage_context": "It is used in PLC programming to distinguish and access global variables in situations where local variables shadow them."}, "generated_keywords": ["global variable access", "namespace resolution", "local vs global variable", "variable shadowing", "dot prefix notation"]}
{"instruction_name": "Namespace for Global Variable Lists", "description": "The operator is an extension of the IEC 61131-3 standard. You can use the name of a global variable list (GVL) as a namespace identifier for the variables that are defined in the list. This allows the use of variables with the same name in different global variable lists while still accessing specific variables uniquely by prefixing the variable name with the global variable list name and a dot.", "parameters": {"Input": [{"name": "<global variable list name>", "type": "GVL", "description": "Name of the global variable list acting as the namespace identifier."}, {"name": "<variable>", "type": "Any IEC 61131-3 compatible data type", "description": "Variable defined inside the global variable list."}], "Output": [], "InOut": []}, "how_to_use": "Prefix a variable from a global variable list with the global variable list name and a dot to access or assign values uniquely when variables with the same name exist in multiple global variable lists.", "example_code": "globlist1.varx := globlist2.varx;", "additional_info": "If a variable is declared in several global variable lists, referencing it without the prepended list name results in an error message.", "generated_brief": {"functional_summary": "This instruction uses global variable list names as namespaces to uniquely access variables with the same name defined in different global variable lists by prefixing the variable name with the list name and a dot.", "usage_context": "It is used in PLC programming to avoid naming conflicts and clearly reference variables when multiple global variable lists contain identically named variables."}, "generated_keywords": ["global variable list namespace", "variable name prefixing", "IEC 61131-3 global variables", "naming conflict resolution", "variable list scoping"]}
{"instruction_name": "Library Namespace", "description": "A library POU identifier is appended with the library namespace (as a prefix separated by a dot) for unique and qualified access to the library POU. The namespace usually matches the library name.", "parameters": {"Input": [{"name": "library namespace", "type": "STRING or valid identifier", "description": "The prefix that matches the library name or a defined namespace to qualify the POU."}, {"name": "library POU identifier", "type": "POU name (e.g., function, function block, or program identifier)", "description": "The identifier of the library POU being accessed."}], "Output": [], "InOut": []}, "how_to_use": "Use the syntax <library namespace>.<library POU identifier> to disambiguate between local and library POUs. You can set or redefine the namespace in the project information or library manager properties. This helps when a local POU has the same name as one in a library.", "example_code": "var1 := FB_A(in := 12); // Call of the project function FB_A\nvar2 := LIB_A.FB_A(in := 22); // Call of the library function FB_A", "additional_info": "Specifying an alternative namespace for a library can be done in project settings or library manager to avoid naming conflicts.", "generated_brief": {"functional_summary": "This instruction qualifies a library Program Organizational Unit (POU) with its namespace prefix to uniquely identify and access it, avoiding name conflicts with local POUs.", "usage_context": "It is used in PLC projects to disambiguate calls between local and library POUs when they share the same name by applying a namespace prefix matching the library name."}, "generated_keywords": ["library namespace", "POU qualification", "namespace prefix", "naming conflict resolution", "library POU access"]}
{"instruction_name": "# (Hashtag operator)", "description": "The hashtag operator is an extension of the IEC 61131-3 standard that forces direct access to a library POU or member when local components override library POUs with the same name, causing ambiguity.", "parameters": {"Input": [{"name": "namespace", "type": "STRING or valid identifier", "description": "The namespace (library prefix) of the POU."}, {"name": "library POU path", "type": "Valid identifier or member path", "description": "The path to the library POU or member to access directly."}], "Output": [], "InOut": []}, "how_to_use": "Use the syntax <namespace> # <library POU path> to forcibly access the library POU, bypassing local declarations with the same name. This resolves ambiguity and explicitly accesses the library component.", "example_code": "str := _3S_License.Standard#CONCAT('test1', '3444');\nstr := Standard#CONCAT('test1', '3444');\nstr := _3S_License#Standard#CONCAT('test1', '3444');\nstr := _3S_License.Standard#CONCAT('3444', '444');", "additional_info": "Use of the hashtag operator is recommended when local names shadow library names to ensure the intended library element is accessed.", "generated_brief": {"functional_summary": "The hashtag operator forces direct access to a specific library POU or member, bypassing local declarations with the same name to resolve naming ambiguities.", "usage_context": "It is used when local components override library POUs, and there is a need to explicitly reference the original library element in PLC code."}, "generated_keywords": ["hashtag operator", "library POU access", "resolve naming ambiguity", "bypass local declarations", "direct library reference"]}
{"instruction_name": "NE", "description": "The IEC operator compares two operands for inequality. All elementary data types are permitted as data types for the operands. If the operands are, then the operator yields the result TRUE; otherwise FALSE.", "parameters": {"Input": [{"name": "Operand1", "type": "Any elementary data type (e.g., BOOL, INT, REAL, etc.)", "description": "First operand to compare"}, {"name": "Operand2", "type": "Same as Operand1", "description": "Second operand to compare"}], "Output": [{"name": "Result", "type": "BOOL", "description": "Result of the inequality comparison; TRUE if operands are not equal, FALSE otherwise"}], "InOut": []}, "how_to_use": "Use the NE operator to compare two values of the same elementary data type to determine if they are unequal. It returns TRUE if the values differ, otherwise FALSE. This operator is commonly used in conditional statements and logic expressions.", "example_code": "Var1 := 40 <> 40;", "additional_info": "All elementary data types defined in IEC 61131-3 and additional CODESYS-specific data types such as BIT, UXINT, XINT, and XWORD can be used as operands for this operator.", "generated_brief": {"functional_summary": "The NE operator compares two operands of the same elementary data type and returns TRUE if they are not equal, otherwise FALSE.", "usage_context": "It is typically used in conditional statements and logic expressions to check for inequality between values in PLC programs."}, "generated_keywords": ["inequality comparison", "NE operator", "compare operands", "conditional logic", "Boolean result"]}
{"instruction_name": "NEW", "description": "The NEW operator reserves dynamic memory to instantiate function blocks, user-defined data types, or arrays of standard types. The operator returns a matching typed pointer. It generates an instance of the specified type and returns a pointer to this instance. Initialization of the instance is then called. If the type is a scalar standard data type, an optional size operand creates an array of that type and size. memory allocation fails, NEW returns 0. Use the operator within an assignment ':='; otherwise an error occurs. Requires 'Use dynamic memory allocation' option enabled in application properties. Function blocks or user-defined data types created dynamically must be marked with the {attribute 'enable_dynamic_creation'}, except for library function blocks.", "parameters": {"Input": [{"name": "type", "type": "function block | user-defined data type | standard data type", "description": "The data type to instantiate dynamically."}, {"name": "size", "type": "INT (optional)", "description": "Optional size specifying the number of elements if type is a scalar standard data type (creates an array)."}], "Output": [{"name": "pointer name", "type": "POINTER TO <type>", "description": "A typed pointer to the dynamically allocated instance or array."}], "InOut": []}, "how_to_use": "Use NEW in an assignment expression to allocate dynamic memory for a function block, user-defined data type, or an array of standard types. Ensure that the 'Use dynamic memory allocation' option is enabled. If creating instances of user-defined types or function blocks (not from a library), mark them with the pragma {attribute 'enable_dynamic_creation'}. Use DELETE to free allocated memory. Be cautious of concurrent NEW calls; synchronize with semaphores if necessary and prefer using NEW in a single task to avoid jitter.", "example_code": "PROGRAM PLC_PRG\nVAR\n    pdwScalar : POINTER TO DWORD; //Typed pointer\n    xInit : BOOL := TRUE;\n    xDelete : BOOL;\nEND_VAR\n\nIF (xInit) THEN\n    pdwScalar := NEW(DWORD, 16); // Allocates memory (16 DWORDs) and assigns to pointer\nEND_IF\nIF (xDelete) THEN\n    DELETE(pdwScalar); // Frees memory\nEND_IF\n\n{attribute 'enable_dynamic_creation'}\nFUNCTION_BLOCK FBComputeGamma\nVAR_INPUT\n    iAlpha : INT;\n    iBeta : INT;\nEND_VAR\nVAR_OUTPUT\n    iGamma : INT;\nEND_VAR\n\nPROGRAM PLC_PRG\nVAR\n    pComputeGamma : POINTER TO FBComputeGamma; // Typed pointer\n    xInit : BOOL := TRUE;\n    xDelete : BOOL;\n    iResult : INT;\nEND_VAR\n\nIF (xInit) THEN\n    pComputeGamma := NEW(FBComputeGamma); // Allocates memory\n    xInit := FALSE;\nEND_IF\npComputeGamma^.iAlpha := (pComputeGamma^.iAlpha + 1) MOD 100;\npComputeGamma^.iBeta := 10;\npComputeGamma^(); // Calls the FB\niResult := pComputeGamma^.iGamma;\nIF (xDelete) THEN\n    DELETE(pComputeGamma); // Frees memory\nEND_IF", "additional_info": "Do not execute NEW concurrently from multiple tasks without synchronization (e.g., semaphores like SysSemEnter) as it may cause higher jitter. Changing the data layout of function blocks in online mode invalidates allocated memory and prevents subsequent online logins with changes. Prefer using NEW only in one task.", "generated_brief": {"functional_summary": "The NEW operator dynamically allocates memory for function blocks, user-defined data types, or arrays of standard types and returns a typed pointer to the allocated instance.", "usage_context": "It is used in PLC programs when dynamic creation of instances is needed, typically within a single task and with dynamic memory allocation enabled, ensuring proper synchronization if accessed concurrently."}, "generated_keywords": ["dynamic memory allocation", "instantiate function block", "user-defined data types", "typed pointer return", "memory management"]}
{"instruction_name": "DELETE", "description": "The DELETE operator frees dynamic memory that was previously allocated by NEW for function blocks, user-defined data types, or arrays of standard types. It takes a typed pointer to the allocated memory and releases it.", "parameters": {"Input": [{"name": "pointer name", "type": "POINTER TO <type>", "description": "A typed pointer to the memory to free."}], "Output": [], "InOut": []}, "how_to_use": "Use DELETE to free memory allocated with NEW. Provide the typed pointer returned by NEW as the parameter. Ensure no further access to the pointer after deletion to avoid invalid memory access.", "example_code": "IF (xDelete) THEN\n    DELETE(pdwScalar); // Frees memory\nEND_IF\n\nIF (xDelete) THEN\n    DELETE(pComputeGamma); // Frees memory\nEND_IF", "additional_info": "Avoid accessing pointers after the memory has been freed with DELETE. Use synchronization methods when allocating and freeing memory with NEW and DELETE across multiple tasks.", "generated_brief": {"functional_summary": "The DELETE instruction frees dynamic memory previously allocated with NEW by taking a typed pointer and releasing the associated memory.", "usage_context": "It is used in PLC programs to properly manage dynamic memory for function blocks or data types, preventing memory leaks by releasing unused allocated memory."}, "generated_keywords": ["dynamic memory release", "free allocated memory", "pointer memory deallocation", "memory management", "delete operator"]}
{"instruction_name": "NOT", "description": "The IEC operator is used for the bitwise NOT of a bit operand. When the respective input bit yields 0, the output bit also yields 1, and the other way around.", "parameters": {"Input": [{"name": "Operand", "type": "BOOL, BYTE, WORD, DWORD, LWORD", "description": "The bit operand on which the bitwise NOT operation is performed."}], "Output": [{"name": "Result", "type": "Same as Operand (BOOL, BYTE, WORD, DWORD, LWORD)", "description": "The result of the bitwise NOT operation on the input operand."}], "InOut": []}, "how_to_use": "Use the NOT operator to invert all bits of the operand. It is applicable to all the permitted data types (BOOL, BYTE, WORD, DWORD, LWORD).", "example_code": "Var1 := NOT 2#1001_0011;", "additional_info": "Ensure that the input operand is one of the permitted data types. This operator performs bitwise inversion and does not change the operand type.", "generated_brief": {"functional_summary": "The NOT instruction performs a bitwise inversion of the input operand, flipping all bits from 0 to 1 and vice versa.", "usage_context": "It is used in PLC programs to invert boolean or multi-bit data types for control logic, signal manipulation, or status flag toggling."}, "generated_keywords": ["bitwise NOT", "invert bits", "boolean inversion", "bitwise operator", "data type inversion"]}
{"instruction_name": "OR", "description": "The IEC operator is used for the bitwise OR of bit operands. When at least one of the input bits yields 1, the output bit also yields 1; otherwise 0.", "parameters": {"Input": [{"name": "1", "type": "BOOL, BYTE, WORD, DWORD, LWORD", "description": "First bit operand for the OR operation."}, {"name": "Operand2", "type": "BOOL, BYTE, WORD, DWORD, LWORD", "description": "Second bit operand for the OR operation."}], "Output": [{"name": "Result", "type": "Same as input types", "description": "The result of the bitwise OR operation between Operand1 and Operand2."}], "InOut": []}, "how_to_use": "Use the OR operator to perform bitwise OR between two bit operands of the same permitted type. The output will have bits set to 1 wherever at least one input bit is 1.", "example_code": "Var1 := 2#1001_0011 OR 2#1000_1010;", "additional_info": "Permitted data types include BOOL, BYTE, WORD, DWORD, and LWORD.", "generated_brief": {"functional_summary": "The OR instruction performs a bitwise OR operation between two input operands, setting each output bit to 1 if at least one corresponding input bit is 1.", "usage_context": "This function is typically used in PLC programs to combine multiple bit flags or conditions for control logic or signal processing."}, "generated_keywords": ["bitwise OR", "logical OR", "bit operand", "boolean operation", "flag combination"]}
{"instruction_name": "OR_ELSE", "description": "The OR_ELSE operator is an extension of the IEC 61131-3 standard, permitted only for programming in structured text. It performs an OR operation on BOOL and BIT operands with short-circuit evaluation. When at least one operand yields TRUE, the result is TRUE; otherwise, the result is FALSE. Unlike the standard OR operator, the expressions of subsequent operands are not evaluated once an operand evaluates to TRUE.", "parameters": {"Input": [{"name": "operand1", "type": "BOOL or BIT", "description": "First operand in the OR_ELSE operation."}, {"name": "operand2", "type": "BOOL or BIT", "description": "Second operand in the OR_ELSE operation."}, {"name": "operandN", "type": "BOOL or BIT", "description": "Optional additional operands that are evaluated only if previous operands are FALSE."}], "Output": [{"name": "result", "type": "BOOL", "description": "Result of the OR_ELSE operation, TRUE if any operand is TRUE; otherwise FALSE."}], "InOut": []}, "how_to_use": "Use OR_ELSE in structured text when you need an OR operation with short-circuit evaluation, ensuring later operands are not evaluated once a TRUE operand is found. This can be used to optimize evaluation and avoid side effects in later expressions.", "example_code": "VAR\n    bEver: BOOL;\n    bX: BOOL;\n    dw: DWORD := 16#000000FF;\nEND_VAR\n\nbEver := FALSE;\nbX := dw.8 OR_ELSE dw.1 OR_ELSE (bEver := TRUE);", "additional_info": "If the standard OR operator is used instead, all operands are evaluated regardless of intermediate results. Using OR_ELSE prevents evaluation of expressions once a TRUE value is found, which can avoid unwanted side effects.", "generated_brief": {"functional_summary": "OR_ELSE performs a short-circuit logical OR on BOOL or BIT operands, returning TRUE as soon as any operand is TRUE without evaluating subsequent operands.", "usage_context": "It is used in structured text programming to optimize logical OR operations by preventing unnecessary evaluation and avoiding side effects from later operands once a TRUE condition is found."}, "generated_keywords": ["short-circuit OR", "logical OR operation", "structured text", "BOOL BIT operands", "operand evaluation optimization"]}
{"instruction_name": "POOL", "description": "The operator is an extension of the IEC 61131-3 standard. It is used to reference objects which are managed in the global POU pool (in the POUs view). The operator directly accesses objects in the POUs view.", "parameters": {"Input": [{"name": "POU", "type": "ANY", "description": "The Program Organization Unit (POU) to be referenced from the global POU pool."}], "Output": [{"name": "Referenced object", "type": "ANY", "description": "The object referenced from the global POU pool."}], "InOut": []}, "how_to_use": "The POOL operator is used to access global POU objects directly from the POUs view. Typically, you assign a variable by referencing a POU through POOL, e.g., POOL.POU(). It is useful to prevent shadowing by explicitly accessing the global POU instance.", "example_code": "PROGRAM PLC_PRG\nVAR\n        svar_pou : STRING;\nEND_VAR\n\nsvar_pou := POOL.POU();", "additional_info": "The operator is an extension beyond the standard IEC 61131-3 and should be used carefully to avoid name shadowing. See related documentation on preventing shadowing.", "generated_brief": {"functional_summary": "The POOL operator accesses and references objects stored in the global Program Organization Unit (POU) pool directly within a PLC program.", "usage_context": "It is used to explicitly access global POU instances to prevent variable shadowing and ensure clear referencing of POUs in industrial automation code."}, "generated_keywords": ["POOL operator", "global POU access", "prevent variable shadowing", "reference POU objects", "IEC 61131-3 extension"]}
{"instruction_name": "POSITION", "description": "The operator is an extension of the IEC 61131-1 standard. At runtime, the operator yields the position of a variable in the declaration part or in the implementation part of a POU. The operator has to be assigned the variables of type STRING in the declaration part or in the implementation part.", "parameters": {"Input": [], "Output": [{"name": "Result", "type": "STRING", "description": "Contains the position of the variable. In the declaration part, it returns 'Line <line number> (Decl)'. In the implementation part, it returns 'Line <line number>, Column <Column number> (Impl)'."}], "InOut": []}, "how_to_use": "Use POSITION() to get the line and column position of a variable in the declaration or implementation part of a POU. Assign the result to a STRING variable. In declaration, it returns only the line number, while in implementation it returns both line and column.", "example_code": "PROGRAM PROG1\nVAR\n        strPOS : STRING := POSITION();  //Returns the line number of this declaration\n        strlocalPOS : STRING;\nEND_VAR\n\n        strlocalPOS := POSITION();      //Returns row and column number this assignment", "additional_info": "Only assign POSITION() to STRING variables. The returned string format differs depending on whether it is used in declaration part or implementation part of the POU.", "generated_brief": {"functional_summary": "The POSITION() function returns the line and column location of a STRING variable within the declaration or implementation part of a PLC program organization unit (POU).", "usage_context": "It is typically used for debugging or documentation purposes to identify the exact position of variables within the code structure at runtime."}, "generated_keywords": ["variable position", "POU line number", "POU column number", "STRING variable location", "debugging variable position"]}
{"instruction_name": "POUNAME", "description": "The operator is an extension of the IEC 61131-1 standard. At runtime, the operator yields the name of the POU that contains the operator POUNAME. The result is of type STRING. The result of POUNAME depends where it is used: in a program, it returns the program name; in a function, the function name; in a function block, the function block name; in a method, the method name qualified with the FB name; in a Get/Set accessor of a property, the property name plus Get/Set qualified with the FB name; in a GVL, the GVL name; in a structure, the structure name; in a data structure UNION, the union name.", "parameters": {"Input": [], "Output": [{"name": "Result", "type": "STRING", "description": "The name of the POU (Program Organization Unit) that contains the operator, depending on the POU type and context."}], "InOut": []}, "how_to_use": "Use POUNAME() without parameters anywhere inside a POU to get its name as a STRING at runtime. It is useful for identification and logging purposes. The output depends on the current POU type context.", "example_code": "PROGRAM PROG1\nVAR\n    strPOU : STRING := POUNAME();  //Returns 'PROG1'\n    strlocalPOU : STRING;\nEND_VAR\n\nstrlocalPOU := POUNAME();     //Returns 'PROG1'", "additional_info": "This operator does not require any inputs. It is evaluated at runtime and returns a constant string corresponding to the current POU name. The name returned varies depending on the POU context (e.g. program, function, function block, method, property accessor, GVL, structure, union).", "generated_brief": {"functional_summary": "POUNAME() returns the name of the Program Organization Unit (POU) it is called from as a string at runtime.", "usage_context": "It is typically used within any POU to identify or log the current POU's name dynamically for debugging or tracking purposes."}, "generated_keywords": ["get current POU name", "runtime POU identification", "POUNAME operator", "dynamic POU name retrieval", "POU name logging"]}
{"instruction_name": "QUERYPOINTER", "description": "The operator is an extension of the IEC 61131-3 standard. At runtime, it converts the type of an interface reference of a function block to a pointer. It returns a BOOL result where TRUE means that CODESYS has performed the conversion successfully. For compatibility, the pointer to be converted must be an extension of the base interface \"SYSTEM.IQueryInterface\".", "parameters": {"Input": [{"name": "ITF_Source", "type": "Interface Reference or Function Block instance", "description": "The interface reference or function block instance with the required target types to be converted to a pointer."}], "Output": [{"name": "Pointer_Dest", "type": "Pointer (untyped)", "description": "Receives the pointer to the reference or instance of a function block that ITF_Source currently refers to. This pointer is untyped and can be cast to any type."}, {"name": "Return Value", "type": "BOOL", "description": "Returns TRUE if the conversion was successful; otherwise, FALSE."}], "InOut": []}, "how_to_use": "Use QUERYPOINTER to convert an interface reference or function block instance to untyped pointer at runtime, ensuring that the interface extends SYSTEM.IQueryInterface for compatibility. After conversion, cast the pointer to the desired type as needed.", "example_code": "QUERYPOINTER(<ITF_Source>, <Pointer_Dest>)", "additional_info": "Pointer_Dest is not typed and careful type casting is required by the programmer. The interface must extend SYSTEM.IQueryInterface for the conversion to succeed.", "generated_brief": {"functional_summary": "QUERYPOINTER converts an interface reference or function block instance that extends SYSTEM.IQueryInterface into an untyped pointer at runtime, returning TRUE if successful.", "usage_context": "It is used when low-level pointer manipulation or casting is needed within PLC programs that handle interface references for advanced control or interoperability."}, "generated_keywords": ["interface reference to pointer", "function block pointer conversion", "runtime pointer casting", "SYSTEM.IQueryInterface extension", "untyped pointer retrieval"]}
{"instruction_name": "ROL", "description": "The IEC operator is used for bitwise rotation of an operand to the left.", "parameters": {"Input": [{"name": "in", "type": "BYTE | WORD | DWORD | LWORD", "description": "The input operand to be rotated bitwise to the left."}, {"name": "n", "type": "ANY_INT", "description": "The number of positions to rotate the bits to the left."}], "Output": [{"name": "erg", "type": "Same as 'in' input type", "description": "The result after rotating of 'in' to the left by n positions."}], "InOut": []}, "how_to_use": "Use ROL to rotate the bits of an input operand to the left by a specified number of times. The bit shifted out of the leftmost position is reintroduced at the rightmost position. The operation considers the bit-length according to the data type of 'in'. For constant inputs, the smallest possible data type is used.", "example_code": "PROGRAM rol_st\n\nVAR\n in_byte : BYTE := 16#45;\n in_word : WORD := 6#45;\n erg_byte : BYTE;\n erg_word : WORD;\n n: BYTE := 2;\nEND_VAR\n\nerg_byte := ROL(in_byte,n); (* Result: 16#15 *)\nerg_word := ROL(in_word,n); (* Result: 16#0114 *)", "additional_info": "Note the number of bits CODESYS uses for this operation is defined by the data type of the input variable 'in'. The data type of the output variable does not influence the operation. For constant 'in' values, the smallest possible data type is assumed for the rotation.", "generated_brief": {"functional_summary": "The ROL instruction performs a bitwise left rotation on an input operand by a specified number of positions, wrapping the bits shifted out from the left back into the right side.", "usage_context": "It is typically used in PLC programs for manipulating bit patterns, such as in communication protocols, data encoding, or cyclic bit shifting operations."}, "generated_keywords": ["bitwise left rotation", "rotate bits left", "circular bit shift", "bit manipulation", "PLC bit operations"]}
{"instruction_name": "ROR", "description": "The IEC operator is used for bitwise rotation of an operand to the right.", "parameters": {"Input": [{"name": "in", "type": "BYTE | WORD | DWORD | LWORD", "description": "The input value to be rotated bitwise to the right."}, {"name": "n", "type": "BYTE", "description": "The number of bits to rotate to the right."}], "Output": [{"name": "erg", "type": "Same as inputin'", "description": "Result of the right bitwise rotation of the input value."}], "InOut": []}, "how_to_use": "Use ROR to perform bitwise right rotation of the input value by 'n' bits. The number of bits used for rotation depends on the data type of the input variable. If the input is a constant, the smallest possible data type is used. The output data type does not influence the bitwise operation.", "example_code": "PROGRAM ror_st\n\nVAR\n in_byte : BYTE := 16#45;\n in_word : WORD := 16#45;\n erg_byte : BYTE;\n erg_word : WORD;\n n: BYTE := 2;\nEND_VAR\n\nerg_byte := ROR(in_byte,n); (* Result: 16#51 *)\nerg_word := ROR(in_word,n); (* Result: 16#4011 *)", "additional_info": "The rotation uses the bit length defined by the input variable's data type. Even if 'erg' output has a different data type, the operation considers only the input 'in' data type bit width.", "generated_brief": {"functional_summary": "The ROR instruction performs a bitwise rotation of the input value to the right by a specified number of bits, preserving the input data type's bit length.", "usage_context": "It is commonly used in low-level data manipulation tasks such as cyclic bit shifts in communication protocols, signal processing, or cryptographic algorithms within PLC programs."}, "generated_keywords": ["bitwise right rotation", "cyclic bit shift", "data type bit length", "low-level data manipulation", "PLC communication protocols"]}
{"instruction_name": "SEL", "description": "The IEC operator used for bitwise selection. It returns IN0 if G is FALSE and IN1 if G is TRUE. Permitted data types are any identical data type for IN0, IN1, and OUT. The G input is BOOL. The operator ensures that variables of identical type are used in all three positions and does not support assignment of function block instances to interface variables.", "parameters": {"Input": [{"name": "G", "type": "BOOL", "description": "The selection condition. If TRUE, the output is assigned IN1; if FALSE, it is assigned IN0."}, {"name": "IN0", "type": "Any identical data type", "description": "The value assigned to output when G is FALSE."}, {"name": "IN1", "type": "Any identical data type", "description": "The value assigned to output when G is TRUE."}], "Output": [{"name": "OUT", "type": "Any identical data type", "description": "The resulting of the SEL operator."}], "InOut": []}, "how_to_use": "Use SEL to select between two values based on a BOOL condition G. Ensure IN0, IN1, and OUT are of the same data type. When G is TRUE, expressions preceding IN0 are not computed and vice versa. Note that in graphical languages, expressions at IN0 and IN1 might be computed independently under certain conditions (e.g., Box, Jump, Return, Line Branch, Edge Detection).", "example_code": "Var1 := SEL(TRUE, 3, 4); (* Result: 4 *)", "additional_info": "Type identity is strictly enforced by the compiler. Function block instances cannot be assigned to interface variables SEL.", "generated_brief": {"functional_summary": "SEL is a selection operator that outputs one of two input values based on a BOOL condition, returning IN1 if TRUE and IN0 if FALSE, with strict type matching across inputs and output.", "usage_context": "It is typically used in PLC programs to conditionally choose between two values or expressions in control logic based on a boolean condition."}, "generated_keywords": ["conditional selection", "boolean selector", "type-safe multiplexing", "bitwise selection operator", "value selection based on BOOL"]}
{"instruction_name": "SHL", "description": "The IEC operator is used for bitwise shift of an operand to the left.", "parameters": {"Input": [{"name": "in", "type": "BYTE | WORD | DWORD | LWORD", "description": "Operand which is shifted to the left"}, {"name": "n", "type": "BYTE", "description": "Number of bits to shift 'in' to the left"}], "Output": [{"name": "erg", "type": "Same as input 'in'", "description": "Result of shifting 'in' to the left by 'n' bits"}], "InOut": []}, "how_to_use": "Use SHL to perform a bitwise left shift on the operand 'in' by 'n' bits. If 'n' exceeds the data type width, behavior depends on the target system, which may pad with zeros or perform modulo based on register size. The number of bits shifted corresponds to the data type size of the input variable.", "example_code": "PROGRAM shl_st\nVAR\n  in_byte : BYTE := 16#45; (* 2#01000101 )\n  in_word : WORD := 16#0045; (* 2#0000000001000101 )\n  erg_byte : BYTE;\n  erg_word : WORD;\n  n: BYTE := 2;\nEND_VAR\n\nerg_byte := SHL(in_byte,n); (* Result is 16#14, 2#00010100 *)\nerg_word := SHL(in_word,n); (* Result is 16#0114, 2#0000000100010100 *)", "additional_info": "If 'n' exceeds the data type width, handling of the shift depends on the target system, which may pad the bits with zeros or apply modulo operations with the register size. Always consider the data type size of 'in' when using SHL.", "generated_brief": {"functional_summary": "The SHL instruction performs a bitwise left shift on the input operand by a specified number of bits, producing a shifted result of the same data type.", "usage_context": "SHL is typically used in PLC programming to manipulate individual bits for tasks such as scaling values, setting flags, or preparing data for communication protocols."}, "generated_keywords": ["bitwise left shift", "shift bits left", "data type bit manipulation", "PLC bit shifting", "operand left shift"]}
{"instruction_name": "SHR", "description": "The IEC operator is used for bitwise shift of an operand to the right.", "parameters": {"Input": [{"name": "in", "type": "BYTE | WORD | DWORD | LWORD", "description": "Operand which is shifted to the right"}, {"name": "n", "type": "BYTE", "description": "Number of bits to shift 'in' to the right"}], "Output": [{"name": "erg", "type": "Same as 'in'", "description": "Result of the right bitwise shift operation"}], "InOut": []}, "how_to_use": "Use SHR to perform bitwise right shift on integer operands of types BYTE, WORD, DWORD, or LWORD. If the number of bits to shift (n) exceeds the width of the data type, the result depends on the target system, which may pad with zeros or use modulo of the register size.", "example_code": "PROGRAM shr_st\nVAR\n in_byte : BYTE := 16#45; (* 2#01000101 *)\n in_word : WORD := 16#0045; (* 2#0000000001000101 *)\n erg_byte : BYTE;\n erg_word : WORD;\n n: BYTE := 2;\nEND_VAR\n\nerg_byte := SHR(in_byte,n); (* Result is 16#11, 2#00010001 *)\nerg_word := SHR(in_word,n); (* Result is 16#0011, 2#0000000000010001 *)", "additional_info": "If 'n' exceeds the data type width, the behavior depends on the target system. Padding can be with zeros or the shift count 'n' may be taken modulo the register size.", "generated_brief": {"functional_summary": "SHR performs a bitwise right shift on an integer operand by a specified number of bits, returning the shifted result.", "usage_context": "It is typically used in PLC programs to manipulate data at the bit level, such as extracting specific bits or efficiently dividing values by powers of two."}, "generated_keywords": ["bitwise right shift", "integer operand shift", "PLC bit manipulation", "BYTE WORD DWORD LWORD", "shift bits right"]}
{"instruction_name": "SIN", "description": "The IEC operator yields the sine value of a number.", "parameters": {"Input": [{"name": "value", "type": "Any numeric basic data type", "description": "Input variable measuring the angle in radians. Permitted range is −2^63 to +2^63."}], "Output": [{"name": "result", "type": "REAL or LREAL", "description": "The sine value of the input angle."}], "InOut": []}, "how_to_use": "Use the SIN operator with an input angle in radians. Common numeric types are accepted. Note that on x86 and x64 systems, if the input is outside the permitted range (−2^63 to +2^63), the function returns the input value instead of a sine value.", "example_code": "q := SIN(0.5);", "additional_info": "Permitted input data types include any numeric basic data type. Output data types can be REAL or LREAL. Be aware of input range limitations on certain architectures (x86 and x64).", "generated_brief": {"functional_summary": "The SIN instruction calculates the sine of an input angle given in radians and returns the result as a real number.", "usage_context": "It is typically used in PLC programming for applications involving trigonometric calculations such as motion control, signal processing, or mathematical modeling."}, "generated_keywords": ["sine calculation", "trigonometric function", "angle in radians", "numeric input", "real output"]}
{"instruction_name": "SIZEOF", "description": "The operator determines the number of bytes which are needed in the passed variable or data type. An unsigned value is always returned. The type of the return value is adapted to that of the passed operand (variable or data type).", "parameters": {"Input": [{"name": "variable name or data type name", "type": "ANY or TYPE", "description": "The variable or data type for which the size in bytes is determined."}], "Output": [{"name": "return value", "type": "USINT, UINT, UDINT, or ULINT", "description": "The size in bytes of the passed variable or data type. The exact return type depends on the size: USINT if less than 256, UINT if less than 65536, UDINT if less than 4294967296, otherwise ULINT."}], "InOut": []}, "how_to_use": "Use SIZEOF to determine the memory size in bytes of variables or data types. Be aware that in compiler version 3.5.16.0 and higher, the XSIZEOF operator should be used instead.", "example_code": "PROGRAM PLC_PRG\nVAR\n\taData_1 : ARRAY[0..4] OF INT;\n\tiReturnValue : INT;\nEND_VAR\n\niReturnValue := SIZEOF(aData_1);  (* iReturnValue := USINT#10; *)", "additional_info": "The operator is an extension of the IEC 61131-3 standard and returns an unsigned value. The return type is implicitly adapted to the operand size. For newer compiler versions (>= 3.5.16.0), use XSIZEOF instead.", "generated_brief": {"functional_summary": "SIZEOF returns the memory size in bytes required by a given variable or data type as an unsigned integer with a type adapted to the operand size.", "usage_context": "It is used in PLC programs to determine the exact byte size of variables or data types for memory management or data handling purposes, though newer compilers use XSIZEOF instead."}, "generated_keywords": ["determine memory size", "variable size in bytes", "data type size", "unsigned size return", "PLC memory management"]}
{"instruction_name": "SQRT", "description": "The IEC operator yields the square root of a number.", "parameters": {"Input": [{"name": "InputValue", "type": "any numeric basic data type", "description": "The number for which the square root is calculated."}], "Output": [{"name": "Result", "type": "REAL or LREAL", "description": "The square root of the input number."}], "InOut": []}, "how_to_use": "Use the SQRT operator to compute the square root of any numeric input. The output will be of type REAL or LREAL. Typical use involves assigning the result to a variable.", "example_code": "q := SQRT(16);", "additional_info": "", "generated_brief": {"functional_summary": "The SQRT instruction calculates the square root of a given numeric input value.", "usage_context": "This function is typically used in industrial control systems when mathematical computations involving square roots are required for process calculations or control logic."}, "generated_keywords": ["square root calculation", "numeric input", "mathematical operator", "real number output", "industrial control math"]}
{"instruction_name": "SUB", "description": "The IEC operator subtracts variables.", "parameters": {"Input": [{"name": "Operand1", "type": "BYTE, WORD, DWORD, LWORD, SINT, USINT, INT, UINT, DINT, UDINT, LINT, ULINT, REAL, LREAL, TIME, LTIME, TIME_OF_DAY (TOD), LTIME_OF_DAY (LTOD), DATE, LDATE, DATE_AND_TIME (DT), LDATE_AND_TIME (DT)", "description": "The minuend - the variable from which another variable is to be subtracted."}, {"name": "Operand2", "type": "BYTE, WORD, DWORD, LWORD, SINT, USINT, INT, UINT, DINT, UDINT, LINT, ULINT, REAL, LREAL, TIME, LTIME, TIME_OF_DAY (TOD), LTIME_OF_DAY (LTOD), DATE, LDATE, DATE_AND_TIME (DT), LDATE_AND_TIME (DT)", "description": "The subtrahend - the variable to subtract from the minuend."}], "Output": [{"name": "Result", "type": "BYTE, WORD, DWORD, LWORD, SINT, USINT, INT, UINT, DINT, UDINT, LINT, ULINT, REAL, LREAL, TIME, LTIME, TIME_OF_DAY (TOD), LTIME_OF_DAY (LTOD), DATE, LDATE, DATE_AND_TIME (DT), LDATE_AND_TIME (DT)", "description": "The result of subtracting Operand2 from Operand1, with type depending on the operands used."}], "InOut": []}, "how_to_use": "Use the SUB operator to subtract one variable from another. Pay attention to the data types, especially for time and date types, as there are specific valid combinations. Negative TIME and LTIME values are undefined and should be avoided.", "example_code": "var1 := 7 - 2;", "additional_info": "Valid type combinations include but are not limited to: TIME - TIME = TIME, LTIME - LTIME = LTIME, DATE - DATE = TIME, TOD - TOD = TIME, DT - DT = TIME, etc. Negative TIME or LTIME values are undefined.", "generated_brief": {"functional_summary": "The SUB instruction subtracts one variable (Operand2) from another variable (Operand1) across various data types, including numeric, time, and date types.", "usage_context": "It is typically used in PLC programs to perform arithmetic subtraction in control processes, especially when calculating differences in values like time intervals or numeric measurements."}, "generated_keywords": ["subtraction", "arithmetic operation", "time and date calculation", "variable difference", "numeric subtraction"]}
{"instruction_name": "TAN", "description": "The IEC operator yields the tangent value of a number.", "parameters": {"Input": [{"name": "angle", "type": "ANY numeric basic data type", "description": "Input variable representing the angle in radians for which the tangent is to be calculated."}], "Output": [{"name": "result", "type": "REAL or LREAL", "description": "Output variable holding the tangent value of the input angle."}], "InOut": []}, "how_to_use": "Provide an angle in radians as input of any numeric basic data type to the TAN operator. The result will be returned as a REAL or LREAL. Typical usage involves assigning the output of TAN directly to a REAL or LREAL variable.", "example_code": "q := TAN(0.5);", "additional_info": "", "generated_brief": {"functional_summary": "The TAN instruction calculates the tangent of an input angle given in radians and returns the result as a REAL or LREAL value.", "usage_context": "It is typically used in industrial control systems where trigonometric calculations are required, such as motion control or angle-based computations."}, "generated_keywords": ["tangent calculation", "trigonometric function", "angle in radians", "real output", "motion control"]}
{"instruction_name": "TEST_AND_SET", "description": "The multicore operator is an extension of the IEC 61131-3 standard. The operator can be used for implementing a semaphore, for example to guarantee exclusive access to a variable written to by different tasks. TEST_AND_SET gets a type DWORD variable as its input. Write access to this variable must be possible. The variable is set to 1 and the previous value is returned as the result. The operation is atomic, which means that it cannot be interrupted by another task. This also applies to multicore platforms.", "parameters": {"Input": [{"name": "dw", "type": "DWORD", "description": "Variable to set to 1 atomically and whose previous value is returned."}], "Output": [{"name": "result", "type": "DWORD", "description": "Previous value of the input variable before setting it to 1, returned as the function result."}], "InOut": []}, "how_to_use": "Use TEST_AND_SET on a DWORD variable that requires exclusive access handling in multi-task or multicore environments. Assign the result to a DWORD variable and check if the old value was 0 before entering a critical section. Reset the DWORD variable to 0 after completing the exclusive access. This operator ensures atomicity for synchronization primitives like semaphores.", "example_code": "FUNCTION ExclusiveStringWrite : BOOL\nVAR_INPUT\n        strToWrite : STRING;\n        pstrOutput : POINTER TO STRING;\nEND_VAR\nVAR_STAT\n        dwSynch : DWORD;\nEND_VAR\nVAR\n        dwOldValue: DWORD;\nEND_VAR\n\ndwOldValue := TEST_AND_SET(dwSynch);  // Write the 1 and read the old value at the same time\nIF dwOldValue = 0 THEN                          // 0 means: no other task is currently writing\n   pstrOutput^ := strToWrite;         // Now you can write safely on the string\n   dwSynch := 0;                        // The DWORD must be reset\n   ExclusiveStringWrite := TRUE;          // Writing was successful\nELSE\n   ExclusiveStringWrite := FALSE;        // Writing was not successful\nEND_IF", "additional_info": "The input DWORD variable must allow write access. The operation is atomic on multicore platforms. Use this operator to avoid inconsistent data access in concurrent writing scenarios. After the critical section, reset the DWORD to 0 to release the lock.", "generated_brief": {"functional_summary": "TEST_AND_SET atomically sets a DWORD variable to 1 and returns its previous value to enable atomic test-and-set operations.", "usage_context": "It is used to implement synchronization mechanisms like semaphores to guarantee exclusive access to shared variables in multi-task or multicore PLC environments."}, "generated_keywords": ["atomic test and set", "exclusive access", "synchronization", "semaphore implementation", "multicore synchronization"]}
{"instruction_name": "TRY, CATCH, FINALLY, ENDTRY", "description": "These operators are extended from the IEC 61131-3 standard and they are used for specific exception handling in IEC code. When a statement in the TRY operator throws an exception, the application does not stop. Instead, it executes the statements below CATCH and therefore starts the exception handling. Then it executes the instructions below FINALLY. The exception handling ends with ENDTRY. Then the application executes the next statements. An IEC variable for an exception has the data type System.ExceptionCode.", "parameters": {"Input": [{"name": "exec", "type": "System.ExceptionCode", "description": "The exception code variable passed to the CATCH operator to handle the exception."}], "Output": [], "InOut": []}, "how_to_use": "Use the TRY block to encapsulate code that may generate exceptions. Follow it with a CATCH block that handles exceptions, using a variable of type System.ExceptionCode to receive exception information. Then use FINALLY to execute cleanup or final statements regardless of whether an exception occurred. Close the structure with ENDTRY. This enables structured exception handling where the program does not stop on exceptions but proceeds with handling.", "example_code": "FUNCTION Tester : UDINT\nVAR_INPUT\n        count : UDINT;\nEND_VAR\nVAR_OUTPUT\n        strExceptionText : STRING;\nEND_VAR\nVAR\n        exc : SYSTEM.ExceptionCode;\nEND_VAR\n\nTRY\nTester := tryFun(count := count, testcase := g_testcase);\nCATCH(exc)\nHandleException(exc, strExceptionText => strExceptionText);\nFINALLY\nGVL.g_count := GVL.g_count + 2;\nENDTRY", "additional_info": "The exception variable used in CATCH must be of data type System.ExceptionCode. The exception handling does not stop the program; after handling, execution resumes after ENDTRY. The datatype System.ExceptionCode enumerates various exception codes that can be encountered.", "generated_brief": {"functional_summary": "These instructions provide structured exception handling in IEC 61131-3 code by allowing the program to catch and handle runtime errors without stopping execution.", "usage_context": "They are used in PLC programs to manage and respond to exceptions safely, ensuring the application continues running and executes cleanup code after errors occur."}, "generated_keywords": ["exception handling", "TRY CATCH FINALLY", "structured error management", "System.ExceptionCode", "IEC 61131-3"]}
{"instruction_name": "XADD", "description": "The multicore operator is an extension of the IEC 61131-3 standard. It can be used for implementing an atomic counter. When called, it gets a pointer to a DINT variable as the first summand and a DINT value as the second summand. XADD returns the old value of the first summand and in the same step adds the second summand to the first summand. This ensures atomic increment operations in concurrent tasks.", "parameters": {"Input": [{"name": "pVariable", "type": "POINTER TO DINT", "description": "Pointer to the variable of type DINT which will be incremented atomically."}, {"name": "value", "type": "DINT", "description": "The value of type DINT to be added atomically to the variable."}], "Output": [{"name": "oldValue", "type": "DINT", "description": "The old value of the variable before adding the input value."}], "InOut": []}, "how_to_use": "Use XADD when multiple tasks need to increment a shared integer variable atomically to avoid race conditions. Pass the address of the variable and the increment value. The function returns the old value before incrementing, which can be used as a unique index or counter. Common use cases include unique indexing in arrays when accessed concurrently.", "example_code": "FUNCTION WriteToNextArrayPosition : BOOL\nVAR_EXTERNAL\n        g_diIndex : DINT;  // Index and array are globally defined and used by multiple tasks\n        g_boolArray : ARRAY [0..1000] OF BOOL;\nEND_VAR\nVAR_INPUT\n        bToWrite : BOOL;\nEND_VAR\nVAR\n        diIndex : DWORDnEND_VAR\n\ndiIndex := XADD(ADR(g_diIndex), 1);       // Returns a unique index\nWriteToNextArrayPosition := FALSE;\nIF (diIndex >= 0 AND diIndex <= 1000) THEN\n        g_boolArray[diIndex] := bToWrite;         //Writes to unique index\n        WriteToNextArrayPosition := TRUE;         // TRUE: Array was not full yet\nEND_IF", "additional_info": "This operator is particularly useful in multicore and multitasking environments to ensure atomic operations on shared integer variables. Normal addition is not atomic, so XADD prevents race conditions that may lead to incorrect counter values. Ensure the variable referenced is of type DINT and properly aligned. It is an extension and may not be supported on all platforms or targets.", "generated_brief": {"functional_summary": "XADD atomically adds a specified value to a DINT variable and returns its old value to ensure thread-safe increment operations.", "usage_context": "It is used in multicore or multitasking environments to avoid race conditions when multiple tasks concurrently update a shared integer variable, such as generating unique indexes."}, "generated_keywords": ["atomic increment", "multicore synchronization", "thread-safe counter", "concurrent variable update", "unique index generation"]}
{"instruction_name": "XOR", "description": "The IEC operator is used for the bitwise XOR of bit operands. When only one of the two input bits yields 1, the output bit also yields 1. When both inputs yield 1 or 0, then the output yields 0.", "parameters": {"Input": [{"name": "Operand1", "type": "BOOL, BYTE, WORD, DWORD, LWORD", "description": "The first bit operand for the XOR operation."}, {"name": "Operand2", "type": "BOOL, BYTE, WORD, DWORD, LWORD", "description": "The second bit operand for the XOR operation."}], "Output": [{"name": "Result", "type": "BOOL, BYTE, WORD, DWORD, LWORD", "description": "The result of the XOR operation on the input bit operands."}], "InOut": []}, "how_to_use": "Use the XOR operator to perform a bitwise exclusive OR operation between two bit operands. For more than two inputs in extended form, the inputs are compared in pairs and then the corresponding results are combined, which may not always match user expectations.", "example_code": "var1 := 2#1001_0011 XOR 2#1000_1010;", "additional_info": "Permitted data types for the XOR operator include BOOL, BYTE,, DWORD, and LWORD. Note that the extended form with more than two inputs compares inputs pairwise according to the IEC standard.", "generated_brief": {"functional_summary": "The XOR instruction performs a bitwise exclusive OR operation between two bit operands, outputting 1 only when exactly one input bit is 1.", "usage_context": "It is typically used in industrial control systems for logic operations where toggling or difference detection between binary signals is required."}, "generated_keywords": ["bitwise XOR", "exclusive OR operation", "binary logic operation", "IEC operator", "bit operand comparison"]}
{"instruction_name": "XSIZEOF", "description": "The operator XSIZEOF determines the number of bytes which are needed in the passed variable or data type. It always returns an unsigned value whose type is ULINT on 64-bit platforms and UDINT on all other platforms. For portability across platforms, the return value can be declared with the UXINT data type.", "parameters": {"Input": [{"name": "variable", "type": "Any IEC 61131-3 compatible data type or data variable", "description": "The variable or data type for which the memory size in bytes is determined."}], "Output": [{"name": "return value", "type": "ULINT (on 64-bit platforms) or UDINT (on other platforms)", "description": "The number of bytes required by the passed variable or data type."}], "InOut": []}, "how_to_use": "Assign the XSIZEOF operator to a variable declared typically as UXINT for cross-platform compatibility. Pass the variable or data type whose size in bytes is to be determined. Use XSIZEOF instead of SIZEOF if platform independence is desired since XSIZEOF adapts its return value type to the platform.", "example_code": "PROGRAM PLC_PRG\nVAR\n    uxiReturnValue : UXINT;  (* Data type on 64-bit platforms: ULINT *)\n    aData_1 : ARRAY[0..4] OF INT; \nEND_VAR\n\nuxiReturnValue := XSIZEOF(aData_1);\n(* uxiReturnValue = 10 *)", "additional_info": "XSIZEOF is recommended over SIZEOF when assigning the result to UXINT variables because it avoids problems related to data type mismatches across different platforms.", "generated_brief": {"functional_summary": "XSIZEOF returns the number of bytes required to store a given variable or data type, adapting its return type for platform compatibility.", "usage_context": "It is used when determining memory size in a platform-independent manner, especially when assigning the result to a UXINT variable to avoid data type mismatches across different systems."}, "generated_keywords": ["memory size determination", "platform independent size", "XSIZEOF operator", "variable byte size", "cross-platform data size"]}
{"instruction_name": "ASIN", "description": "The IEC operator yields the arcsine value of a number.", "parameters": {"Input": [{"name": "VALUE", "type": "any numeric basic data type", "description": "The input value for which the arcsine is calculated."}], "Output": [{"name": "Result", "type": "REAL or LREAL", "description": "The arcsine of the input value."}], "InOut": []}, "how_to_use": "Use ASIN to compute the arcsine of a numeric input. The input can be any numeric basic data type, and the resulting output is in REAL or LREAL. Typically assigned to a REAL or LREAL variable.", "example_code": "q := ASIN(0.5);", "additional_info": "", "generated_brief": {"functional_summary": "The ASIN instruction calculates the arcsine (inverse sine) of a numeric input value and returns the result as a REAL or LREAL.", "usage_context": "It is typically used in PLC programs when determining the angle corresponding to a sine value in applications such as trigonometric calculations, motion control, or signal processing."}, "generated_keywords": ["arcsine calculation", "inverse sine", "trigonometric function", "angle computation", "numeric input processing"]}
{"instruction_name": "GE", "description": "The IEC operator is used for the \"greater than or equal to\" function. Permitted data types of the operands: any basic data type. If the first operand is greater than or equal to the second operand, then the operator yields the result TRUE; otherwise FALSE.", "parameters": {"Input": [{"name": "Operand1", "type": "Any basic data type", "description": "The first operand to compare."}, {"name": "Operand2", "type": "Any basic data type", "description": "The second operand to compare."}], "Output": [{"name": "Result", "type": "BOOL", "description": "TRUE if Operand1 is greater than or equal to Operand2; otherwise FALSE."}], "InOut": []}, "how_to_use": "Use the GE operator between two operands to check if the first is greater than or equal to the second. The operator supports any basic data type for comparison. The output is a BOOL indicating the comparison result.", "example_code": "VAR1 := 60 >= 40;", "additional_info": "", "generated_brief": {"functional_summary": "The GE instruction compares two operands and returns TRUE if the first operand is greater than or equal to the second, otherwise FALSE.", "usage_context": "It is typically used in PLC programming to control logic flow based on numerical or data value comparisons."}, "generated_keywords": ["greater than or equal to", "comparison operator", "boolean result", "PLC logic control", "data type agnostic"]}
{"instruction_name": "QUERYINTERFACE", "description": "The operator is an extension of the IEC 61131-3 standard. At runtime, the operator executes a type conversion of an interface reference into another type. The operator returns a BOOL result. TRUE means that CODESYS has performed the conversion successfully. The requirement for the explicit conversion is that both the ITF_Source and ITF_Dest are derived from Interface System.IQueryInterface. This interface is implicitly available and does not require a library.", "parameters": {"Input": [{"name": "ITF_Source", "type": "Interface reference or FB interface", "description": "The source interface reference or function block interface to be converted."}, {"name": "ITF_Dest", "type": "Interface reference", "description": "The target interface reference with the required target type."}], "Output": [{"name": "Result", "type": "BOOL", "description": "Returns TRUE if the conversion of ITF_Source to ITF_Dest was performed successfully by CODESYS, otherwise FALSE."}], "InOut": []}, "how_to_use": "Use QUERYINTERFACE to safely attempt to convert an interface reference to another interface type at runtime. Both interfaces must derive from System.IQueryInterface. Check the BOOL result to confirm if the conversion succeeded before using the converted interface reference.", "example_code": "INTERFACE ItfBase EXTENDS System.IQueryInterface\nMETHOD mbase : BOOL\nEND_METHOD\n\nINTERFACE ItfDerived1 EXTENDS ItfBase\nMETHOD mderived1 : BOOL\nEND_METHOD\n\nINTERFACE ItfDerived2 EXTENDS ItfBase\nMETHOD mderived2 : BOOL\nEND_METHOD\n\nFUNCTION_BLOCK FB1 IMPLEMENTS ItfDerived1\nMETHOD mbase : BOOL\n    mbase := TRUE;\nEND_METHOD\nMETHOD mderived1 : BOOL\n    mderived1 := TRUE;\nEND_METHOD\nEND_FUNCTION_BLOCK\n\nFUNCTION_BLOCK FB2 IMPLEMENTS ItfDerived2\nMETHOD mbase : BOOL\n    mbase := FALSE;\nEND_METHOD\nMETHOD mderived2 : BOOL\n    mderived2 := TRUE;\nEND_METHOD\nEND_FUNCTION_BLOCK\n\nPROGRAMM POU\nVAR\n    inst1 : FB1;\n    inst2 : FB2;\n    itfbase1 : ItfBase := inst1;\n    itfbase2 : ItfBase := inst2;\n    itfderived1 : ItfDerived1 := 0;\n    itfderived2 : ItfDerived2 := 0;\n    xResult1, xResult2, xResult3, xResult4: BOOL;\nEND_VAR\n\n\nxResult1 := QUERYINTERFACE(itfbase1, itfderived1); // xResult = TRUE, itfderived1 <> 0\n                                                     // references the instance inst1\nxResult2 := QUERYINTERFACE(itfbase1, itfderived2); // xResult = FALSE, itfderived2 = 0\nxResult3 := QUERYINTERFACE(itfbase2, itfderived1); // xResult = FALSE, itfderived1 = 0\nxResult4 := QUERYINTERFACE(itfbase2, itfderived2); // xResult = TRUE, itfderived2 <> 0\n                                                     // references the instance inst2", "additional_info": "The operator only works if both interfaces implement or extend System.IQueryInterface, which is implicitly available and does not require adding a library. The returned BOOL must be checked before using the converted interface reference to avoid invalid references.", "generated_brief": {"functional_summary": "QUERYINTERFACE attempts to safely convert a source interface reference to a target interface type at runtime, returning TRUE if successful.", "usage_context": "It is used in IEC 61131-3 compliant PLC programs when dynamic interface type conversion is needed between interfaces derived from System.IQuery."}, "generated_keywords": ["interface type conversion", "runtime interface casting", "IEC 61131-3 interface", "System.IQueryInterface", "boolean conversion result"]}
{"instruction_name": "VARINFO", "description": "The operator yields information about a variable. You can save the information as data structure in a variable of data type SYSTEM.VAR_INFO.", "parameters": {"Input": [{"name": "variable name", "type": "ANY", "description": "The variable to obtain information about."}], "Output": [{"name": "info variable", "type": "SYSTEM.VAR_INFO", "description": "Variable to store the information about the input variable."}], "InOut": []}, "how_to_use": "Declare a variable of type SYSTEM.VAR_INFO to hold the variable information. Use the VARINFO operator with the target variable as input and assign the result to the SYSTEM.VAR_INFO variable. This allows inspection of variable metadata such as address, memory area, type, size, and comments.", "example_code": "FUNCTION_BLOCK FB_Velocity\nVAR_INPUT\n        rVelocity: REAL := 1.2;\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n        infoVelocity: SYSTEM.VAR_INFO; //Info of Velocity\nEND_VAR\n\ninfoVelocity := VARINFO(rVelocity); // Gets the info of Velocity locally\n\nPROGRAM PLC_PRG\nVAR\n        iCounter : INT := 0; // Counts the calls\n        infoCounter : SYSTEM.VAR_INFO; //Info of Counter\n        arrA : ARRAY [1..2, 1..2, 1..2] OF INT := [0, 1, 2, 3, 4, 5, 6, 7]; // Stores the A data\n        infoA : SYSTEM.VAR_INFO; //Info of A\n        fbVel : FB_Velocity;\nEND_VAR\n\niCounter := iCounter + 1;\ninfoCounter := VARINFO(iCounter);\ninfoA := VARINFO(arrA);\nfbVel();", "additional_info": "The VARINFO operator is an extension of the IEC 61131-3 standard. The resulting SYSTEM.VAR_INFO structure provides detailed attributes such as ByteAddress, ByteOffset, Area, BitNr, BitSize, BitAddress, TypeClass, TypeName, NumElements (for arrays), BaseTypeClass (for arrays), ElemBitSize (for arrays), MemoryArea, Symbol (variable name), and Comment (variable declaration comment). The interpretation of addresses and offsets depends on whether the variable is global, local to functions or function blocks, and device-specific memory areas.", "generated_brief": {"functional_summary": "The VARINFO instruction retrieves detailed metadata about a given variable and stores it in a SYSTEM.VAR_INFO data structure.", "usage_context": "It is used when inspecting variable attributes such as memory address, type, size, or comments is required for diagnostics, debugging, or dynamic program analysis in PLC automation."}, "generated_keywords": ["variable metadata", "variable information retrieval", "SYSTEM.VAR_INFO", "memory address inspection", "PLC variable attributes"]}
{"instruction_name": "SysTimeGetMs", "description": "Returns a system timer tick value in milliseconds as a UDINT. This value represents a point in time with millisecond resolution and can be used to measure durations.", "parameters": {"Input": [], "Output": [], "InOut": []}, "how_to_use": "Use SysTimeGetMs when you need to track elapsed time in milliseconds. It is suitable for coarse timing applications like measuring delays or durations of operations.", "example_code": "VAR\n    tStart, tEnd, tDelta : TIME;\nEND_VAR\n\ntStart := TO_TIME(SysTimeGetMs());\n(* lengthy operation *)\ntEnd := TO_TIME(SysTimeGetMs());\ntDelta := tEnd - tStart;", "additional_info": "The return value is a UDINT that wraps around every ~49 days. For higher resolution or longer uptime ranges, use SysTimeGetUs or SysTimeGetNs instead.", "generated_brief": {"functional_summary": "SysTimeGetMs returns the current system timer value in milliseconds as a UDINT for time measurement purposes.", "usage_context": "It is used to measure elapsed time or durations in millisecond resolution, suitable for coarse timing tasks in industrial automation."}, "generated_keywords": ["system timer milliseconds", "elapsed time measurement", "coarse timing", "UDINT timer value", "duration tracking"]}
{"instruction_name": "SysTimeRtcGet", "description": "Returns the current date and time in seconds since January 1, 1970 (UTC), stored as a UDINT. Useful for obtaining system time in a compact representation.", "parameters": {"Input": [{"name": "Result", "type": "RTS_IEC_RESULT", "description": "Status code output indicating success or failure of the operation."}], "Output": [], "InOut": []}, "how_to_use": "Use SysTimeRtcGet when you need to log or compare absolute timestamps in seconds. Combine with TO_DT, TO_TOD, or TO_DATE to convert to human-readable formats.", "example_code": "VAR\n    udiUTC_DateAndTime : UDINT;\n    Result : RTS_IEC_RESULT;\nEND_VAR\n\naudiUTC_DateAndTime := TO_UDINT(SysTimeRtcGet(Result));", "additional_info": "SysTimeRtcGet provides a 32-bit timestamp which may overflow in 2106. For high-resolution or future-safe applications, prefer SysTimeRtcHighResGet.", "generated_brief": {"functional_summary": "SysTimeRtcGet returns the current system date and time as a 32-bit unsigned integer representing seconds elapsed since January 1, 0 (UTC).", "usage_context": "It is typically used to obtain absolute timestamps for logging or time comparison purposes in industrial control applications."}, "generated_keywords": ["get system time", "UTC timestamp", "current date and time", "time logging", "32-bit time representation"]}
{"instruction_name": "RS", "description": "FUNCTION_BLOCK RS realizes a bistable reset-dominant latch.", "parameters": {"Input": [{"name": "SET", "type": "BOOL", "description": "Rising edge: Set Q1 to TRUE"}, {"name": "RESET1", "type": "BOOL", "description": "Rising edge: Reset Q1 to FALSE (dominant)"}], "Output": [{"name": "Q1", "type": "BOOL", "description": "Output value"}], "InOut": []}, "how_to_use": "Instantiate the RS function block and call it with SET and RESET1 inputs. On a rising edge of SET, Q1 is set to TRUE. On a rising edge of RESET1, Q1 is reset to FALSE with reset being dominant over set.", "example_code": "RSInst : RS ;\n\nRSInst(SET:= VarBOOL1 , RESET1:=VarBOOL2 );\nVarBOOL3 := RSInst.Q1 ;", "additional_info": "", "generated_brief": {"functional_summary": "The RS function block implements a reset-dominant bistable latch that sets the output Q1 to TRUE on a SET rising edge and resets it to FALSE on a RESET1 rising edge.", "usage_context": "It is typically used in PLC programs to maintain or control a boolean state based on set and reset input signals where reset action has priority."}, "generated_keywords": ["reset dominant latch", "bistable flip-flop", "set reset function block", "boolean state control", "rising edge trigger"]}
{"instruction_name": "SR", "description": "FUNCTION_BLOCK SR realizes a bistable set-dominat latch.", "parameters": {"Input": [{"name": "SET1", "type": "BOOL", "description": "Rising edge: Set Q1 to TRUE (dominant)"}, {"name": "RESET", "type": "BOOL", "description": "Rising edge: Reset Q1 to FALSE"}], "Output": [{"name": "Q1", "type": "BOOL", "description": "Output value"}], "InOut": []}, "how_to_use": "Instantiate the SR function block, then call it with SET1 and RESET boolean inputs. Q1 outputs the latched state which is set dominant, meaning SET has priority over RESET on simultaneous rising edges.", "example_code": "SRInst : SR;\n\nSRInst(SET1:= VarBOOL1 , RESET:=VarBOOL2 );\nVarBOOL3 := SRInst.Q1 ;", "additional_info": "", "generated_brief": {"functional_summary": "The SR function block implements a bistable set-dominant latch that sets or resets its output Q1 based on rising edges of the input signals SET1 and RESET.", "usage_context": "This function is typically used in PLC programs to maintain a stable output state that prioritizes set commands over reset commands in industrial control applications."}, "generated_keywords": ["set-dominant latch", "bistable function block", "rising edge trigger", "PLC output control", "latched boolean output"]}
{"instruction_name": "CTD", "description": "FUNCTION_BLOCK CTD decrements a given value.", "parameters": {"Input": [{"name": "CD", "type": "BOOL", "description": "Rising edge: Decrementing CV by one"}, {"name": "LOAD", "type": "BOOL", "description": "TRUE: Set CV to the start value PV"}, {"name": "PV", "type": "WORD", "description": "Start value for decrementing"}], "Output": [{"name": "Q", "type": "BOOL", "description": "TRUE if CV = 0"}, {"name": "CV", "type": "WORD", "description": "Current counter value"}], "InOut": []}, "how_to_use": "Instantiate the CTD function block, provide CD to decrement CV on rising edge, LOAD to initialize CV with PV, and monitor Q to detect when CV reaches zero.", "example_code": "CTDInst : CTD ;\n\nCTDInst(CD:= VarBOOL1, LOAD:=VarBOOL2 , PV:= VarWORD1);\nVarBOOL3 := CTDInst.Q ;\nVarWORD2 := CTDInst.CV;", "additional_info": "", "generated_brief": {"functional_summary": "The CTD function block decrements a counter value by one on each rising edge of the CD input and signals when the counter reaches zero.", "usage_context": "It is typically used in industrial control systems for countdown operations, such as timing events or tracking remaining quantities until zero is reached."}, "generated_keywords": ["countdown counter", "decrement on rising edge", "initialize counter", "zero detection", "industrial timing"]}
{"instruction_name": "CTUD", "description": "FUNCTION_BLOCK CTUD. Increments and decrements a given value.", "parameters": {"Input": [{"name": "CU", "type": "BOOL", "description": "Rising edge: Incrementing CV by one"}, {"name": "CD", "type": "BOOL", "description": "Rising edge: Decrementing CV by one"}, {"name": "RESET", "type": "BOOL", "description": "TRUE: Reset CV to 0"}, {"name": "LOAD", "type": "BOOL", "description": "TRUE: Set CV to the start value PV"}, {"name": "PV", "type": "WORD", "description": "Start value for decrementing / upper limit for incrementing"}], "Output": [{"name": "QU", "type": "BOOL", "description": "TRUE if CV >= PV"}, {"name": "QD", "type": "BOOL", "description": "TRUE if CV = 0"}, {"name": "CV", "type": "WORD", "description": "Current counter value"}], "InOut": []}, "how_to_use": "Instantiate the CTUD function block and call it by assigning the appropriate BOOL inputs for increment (CU), decrement (CD), reset, and load. Use PV to set the start/limit value. Monitor QU and QD outputs to detect upper and lower limits. The CV output holds the current counter value.", "example_code": "CTUDInst : CTUD ;\n\nCTUDInst(CU := VarBOOL1, CD := VarBOOL2, RESET := VarBOOL3, LOAD := VarBOOL4, PV := VarWORD1);\n\nVarBOOL5 := CTUDInst.QU;\nVarBOOL6 := CTUDInst.QD;\nVarWORD2 := CTUDInst.CV;", "additional_info": "Note that the datatype WORD for PV and CV is used in CODESYS but does not match the IEC standard which defines INT for PV. Use caution when interfacing with systems expecting IEC standard types.", "generated_brief": {"functional_summary": "The CTUD function block increments or decrements a counter value based on input signals, with options to reset or load a preset start value and outputs indicating upper and lower counter limits.", "usage_context": "It is typically used in industrial automation to track counts up or down within defined limits, such as monitoring production quantities or controlling repetitive processes."}, "generated_keywords": ["up-down counter", "increment decrement", "reset counter", "preset load", "limit detection"]}
{"instruction_name": "DELETE", "description": "Deletes a number of characters from a string. DELETE(STR, LEN, POS) means: Delete LEN characters from STR, beginning with the character in the POS position. POS = 0 or POS = 1 both the first character. Note that the implementation is not correct for POS=0, as LEN is internally reduced by one. It is recommended to use POS values starting from 1 as per IEC 61131-3.", "parameters": {"Input": [{"name": "STR", "type": "STRING(255)", "description": "String to be modified"}, {"name": "LEN", "type": "INT", "description": "Length of the partial string to be deleted, number of characters"}, {"name": "POS", "type": "INT", "description": "Position in STR after which the deletion starts. Counted from left, starting with 1"}], "Output": [], "InOut": [{"name": "DELETE", "type": "STRING(255)", "description": "String remaining after deletion"}]}, "how_to_use": "Call DELETE with the string to modify, the number of characters to delete, and the starting position (counted from 1). Avoid using POS=0 to prevent unexpected behavior.", "example_code": "VarSTRING1 := DELETE('SUXYSI', 2, 3);  // Result is 'SUSI'", "additional_info": "The current implementation reduces LEN by one internally if POS=0 is used, which is not standard compliant. Use POS starting at 1 per IEC 61131-3 recommendations.", "generated_brief": {"functional_summary": "The DELETE instruction removes a specified number of characters from a given string starting at a defined position counted from one.", "usage_context": "It is typically used in PLC programs to manipulate and modify string data by deleting undesired portions according to IEC 61131-3 standards."}, "generated_keywords": ["string deletion", "remove characters", "substring manipulation", "position-based delete", "IEC 61131-3 string operation"]}
{"instruction_name": "FIND", "description": "Searches for the position of a partial string within a string. FIND(STR1, STR2) means: Find the position of the first character where STR2 appears in STR1 for the first time. If STR2 is not found in STR1, then OUT:=0.", "parameters": {"Input": [{"name": "STR1", "type": "STRING(255)", "description": "String within which STR2 is searched"}, {"name": "STR2", "type": "STRING(255)", "description": "String whose position is searched in STR1"}], "Output": [], "InOut": [{"name": "FIND", "type": "INT", "description": "Character position of the first occurance of STR2 in STR1. If no occurance is found, result is 0"}]}, "how_to_use": "Use FIND to locate the starting position of a substring (STR2) within another string (STR1). The function returns the position of the first character of STR2 in STR1; returns0 if not found.", "example_code": "arINT1 := FIND('abcdef','de');", "additional_info": "", "generated_brief": {"functional_summary": "FIND locates the starting position of a specified substring within another string and returns its character index or 0 if not found.", "usage_context": "Use FIND when you need to identify the presence and position of a substring inside a main string for string parsing or validation in PLC programs."}, "generated_keywords": ["string search", "substring position", "find substring", "string parsing", "substring index"]}
{"instruction_name": "INSERT", "description": "Inserts a string into another string at a specific position. INSERT (STR1, STR2, POS) means: Insert STR2 into STR1 after position POS.", "parameters": {"Input": [{"name": "STR1", "type": "STRING(255)", "description": "String into which STR2 is inserted"}, {"name": "STR2", "type": "STRING(255)", "description": "String to be inserted into STR1"}, {"name": "POS", "type": "INT", "description": "Insert position. If POS is > 255 OR < 0, the result equals STR1. 0: Inserts before the first character. 1: Inserts after the first character."}], "Output": [], "InOut": [{"name": "INSERT", "type": "STRING(255)", "description": "Resulting string"}]}, "how_to_use": "Use the INSERT function to insert STR2 into STR1 at the specified position POS. Note that if POS is out of range (>255 or <0), the original string STR1 is returned unchanged. Position 0 inserts before the first character, and position 1 inserts after the first character.", "example_code": "VarSTRING1 := INSERT('SUSI', 'XY', 2); // result is 'SUXYSI'", "additional_info": "", "generated_brief": {"functional_summary": "The INSERT function inserts one string (STR2) into another string (STR1) at a specified position (POS) within the first string.", "usage_context": "It is typically used in PLC programs to dynamically modify or compose strings by inserting substrings at precise locations for purposes like formatting or data manipulation."}, "generated_keywords": ["string insertion", "substring position", "string manipulation", "dynamic string editing", "insert substring"]}
{"instruction_name": "LEFT", "description": "Returns a specific number of characters of a string, starting from left.", "parameters": {"Input": [{"name": "STR", "type": "STRING(255)", "description": "String to be analyzed"}, {"name": "SIZE", "type": "INT", "description": "Number of characters"}], "Output": [], "InOut": [{"name": "LEFT", "type": "STRING(255)", "description": "Resulting string"}]}, "how_to_use": "Use the LEFT function by providing a string and the desired number of characters to extract starting from the left. It returns a substring of the specified length. The SIZE parameter should not exceed the string length.", "example_code": "VarSTRING1 := LEFT('SUSI', 3);    (* result is 'SUS' *)", "additional_info": "", "generated_brief": {"functional_summary": "The LEFT function extracts a specified number of characters from the beginning of a given string.", "usage_context": "It is typically used in PLC programs to parse or manipulate string data where only the initial portion of the string is needed."}, "generated_keywords": ["string extraction", "left substring", "character slicing", "string manipulation", "substring from left"]}
{"instruction_name": "MID", "description": "Returns a specific number of characters of a string, starting from a specific position", "parameters": {"Input": [{"name": "STR", "type": "STRING(255)", "description": "String to be analyzed"}, {"name": "LEN", "type": "INT", "description": "Number of characters, counted from the left"}, {"name": "POS", "type": "INT", "description": "Start position for the partial string"}], "Output": [], "InOut": [{"name": "MID", "type": "STRING(255)", "description": "Partial string of STR"}]}, "how_to_use": "Use MID to retrieve LEN characters from the input string STR, starting at position POS. The function returns a substring of STR beginning at POS with length LEN. are counted from the first character as 1.", "example_code": "VarSTRING1 := MID('SUSI',2,2);  (* result is 'US' *)", "additional_info": "", "generated_brief": {"functional_summary": "The MID function extracts a substring of specified length LEN from a given string STR, starting at position POS.", "usage_context": "It is used in PLC programming to isolate specific sections of text data for processing or analysis within industrial control systems."}, "generated_keywords": ["string extraction", "substring function", "character positioning", "text manipulation", "partial string retrieval"]}
{"instruction_name": "TO", "description": "Implements a timer with a turn-off delay", "parameters": {"Input": [{"name": "IN", "type": "BOOL", "description": "Falling edge: starts delay counter; Rising edge: resets delay counter"}, {"name": "PT", "type": "TIME", "description": "Time for the delay counter [ms]"}], "Output": [{"name": "Q", "type": "BOOL", "description": "TRUE if IN is TRUE; FALSE if IN is FALSE and delay time PT elapsed"}, {"name": "ET", "type": "TIME", "description": "Elapsed time since falling edge at IN"}], "InOut": []}, "how_to_use": "Declare an instance of the TOF function block and assign the IN and PT inputs. The Q output indicates the timer status and ET provides elapsed time since the falling edge of IN.", "example_code": "(* Example declaration *)\nTOFInst : TOF ;\n\n(* Example in ST *)\nTOFInst(IN := VarBOOL1, PT:= T#5s);\nVarBOOL2 := TOFInst.Q;", "additional_info": "", "generated_brief": {"functional_summary": "The TO instruction implements a timer that delays turning off an output signal after the input signal falls, maintaining the output as TRUE for a specified delay time.", "usage_context": "It is typically used in industrial control systems to ensure outputs remain active for a set duration after an input signal is deactivated, such as in motor or valve control applications requiring delayed shutoff."}, "generated_keywords": ["turn-off delay timer", "falling edge trigger", "output signal hold", "elapsed time measurement", "delay counter"]}
{"instruction_name": "TP", "description": "FUNCTION_BLOCK TP implements a pulse timer that starts on a rising edge of the input signal and produces a pulse of a specified duration.", "parameters": {"Input": [{"name": "IN", "type": "BOOL", "description": "Rising edge starts the pulse timer and sets Q to TRUE"}, {"name": "PT", "type": "TIME", "description": "Length of the pulse (high-signal)"}], "Output": [{"name": "Q", "type": "BOOL", "description": "Pulse signal, set to TRUE for PT milliseconds if EN has a rising edge"}, {"name": "ET", "type": "TIME", "description": "Elapsed time since pulse timer started. It will then remain constant after PT is reached."}], "InOut": []}, "how_to_use": "Declare an instance of the TP function block, then call it by assigning the input variables IN and PT. Monitor the output Q for the pulse signal and ET for elapsed time since timer started.", "example_code": "TPInst : TP ;\n\nTPInst(IN := VarBOOL1, PT:= T#5s);\nVarBOOL2 := TPInst.Q;", "additional_info": "", "generated_brief": {"functional_summary": "The TP function block generates a fixed-duration pulse on its output Q in response to a rising edge on the input IN.", "usage_context": "It is typically used in industrial control systems to create timed pulse signals triggered by events or conditions."}, "generated_keywords": ["pulse timer", "rising edge trigger", "fixed duration pulse", "time delay output", "industrial control timing"]}
{"instruction_name": "TON", "description": "Implements a timer with a turn-on delay", "parameters": {"Input": [{"name": "IN", "type": "BOOL", "description": "Rising edge: starts delay counter; Falling edge: resets delay counter"}, {"name": "PT", "type": "TIME", "description": "Time for the delay counter [ms]"}], "Output": [{"name": "Q", "type": "BOOL", "description": "FALSE if IN is FALSE; TRUE if IN is TRUE and delay time PT elapsed"}, {"name": "ET", "type": "TIME", "description": "Elapsed time since rising edge at IN"}], "InOut": []}, "how_to_use": "Create an instance of the TON function block and call it with input IN and preset time PT. The output Q indicates when the delay time has elapsed since IN was set TRUE. The ET output provides the elapsed time during the timing.", "example_code": "TONInst : TON ;\nTONInst(IN := VarBOOL1, PT:= T#5s);\nVarBOOL2 := TONInst.Q;", "additional_info": "", "generated_brief": {"functional_summary": "The TON instruction implements a timer that outputs a TRUE signal only after its input remains TRUE continuously for a specified preset delay time.", "usage_context": "It is typically used in automation to introduce controlled time delays before activating processes or outputs in response to changing input conditions."}, "generated_keywords": ["turn-on delay timer", "rising edge trigger", "preset time delay", "elapsed time output", "timer function block"]}
{"instruction_name": "F_TRIG", "description": "FUNCTION_BLOCK F_TRIG detects a falling edge of a boolean signal.", "parameters": {"Input": [{"name": "CLK", "type": "BOOL", "description": "Boolean signal to be checked"}], "Output": [{"name": "Q", "type": "BOOL", "description": "TRUE: Falling edge detected"}], "InOut": []}, "how_to_use": "Declare an instance of the F_TRIG function block. Assign a boolean signal to the CLK input. The output Q will be TRUE when a falling edge is detected on CLK.", "example_code": "FTRIGInst : F_TRIG ;\n\nFTRIGInst(CLK := VarBOOL1);\nVarBOOL2 := FTRIGInst.Q;", "additional_info": "", "generated_brief": {"functional_summary": "F_TRIG is a function block that detects the falling edge of a boolean input signal and outputs TRUE at that instant.", "usage_context": "It is typically used in PLC programs to trigger actions or events precisely when a boolean signal transitions from TRUE to FALSE."}, "generated_keywords": ["falling edge detection", "boolean signal", "function block", "edge triggered output", "PLC signal transition"]}
{"instruction_name": "R_TRIG", "description": "FUNCTION_BLOCK R_TRIG. Detects a rising edge of a boolean signal.", "parameters": {"Input": [{"name": "CLK", "type": "BOOL", "description": "Boolean signal to be checked"}], "Output": [{"name": "Q", "type": "BOOL", "description": "TRUE: Rising edge detected"}], "InOut": []}, "how_to_use": "Declare an instance of R_TRIG function block. Call the instance with the boolean input signal assigned to CLK. The output Q will be TRUE only when a rising edge is detected on CLK.", "example_code": "RTRIGInst : R_TRIG ;\n\nRTRIGInst(CLK := VarBOOL1);\nVarBOOL2 := RTRIGInst.Q;", "additional_info": "", "generated_brief": {"functional_summary": "R_TRIG detects the rising edge of a boolean input signal, outputting TRUE only at the moment the signal transitions from FALSE to TRUE.", "usage_context": "It is typically used in PLC programs to trigger actions precisely at the instant a boolean condition becomes true, such as starting timers or counters on signal changes."}, "generated_keywords": ["rising edge detection", "boolean signal trigger", "pulse on signal transition", "edge-triggered output", "PLC input signal monitoring"]}
{"instruction_name": "CTU", "description": "FUNCTION_BLOCK CTU increments a given value.", "parameters": {"Input": [{"name": "CU", "type": "BOOL", "description": "Rising edge: Incrementing CV by one"}, {"name": "RESET", "type": "BOOL", "description": "TRUE: Reset CV to 0"}, {"name": "PV", "type": "WORD", "description": "Upper limit for incrementing"}], "Output": [{"name": "Q", "type": "BOOL", "description": "TRUE if CV >= PV"}, {"name": "CV", "type": "WORD", "description": "Current counter value"}], "InOut": []}, "how_to_use": "Declare an instance of the CTU function block, then call it by passing CU, RESET, and PV as inputs. Use outputs Q and CV for status and count value respectively.", "example_code": "CTUInst : CTU ;\n\nCTUInst(CU:= VarBOOL1, RESET:=VarBOOL2 , PV:= VarWORD1);\nVarBOOL3 := CTUInst.Q ;\nVarWORD2 := CTUInst.CV;", "additional_info": "", "generated_brief": {"functional_summary": "The CTU function block increments a counter value on a rising edge input until it reaches a preset upper limit, with the ability to reset the count to zero.", "usage_context": "It is typically used in industrial automation to count events or objects and signal when the count reaches a predefined threshold."}, "generated_keywords": ["counter increment", "rising edge trigger", "preset limit", "reset counter", "event counting"]}
{"instruction_name": "CONCAT", "description": "Concatenates two strings.", "parameters": {"Input": [{"name": "STR1", "type": "STRING(255)", "description": "String 1 to be concatenated, max. 255 characters"}, {"name": "STR2", "type": "STRING(255)", "description": "String 2 to be concatenated, max. 255 characters"}], "Output": [], "InOut": [{"name": "CONCAT", "type": "STRING(255)", "description": "Concatenated string, max. 255 characters. If the result doesn’t fit into these 255 bytes, it will be silently truncated. No error is produced."}]}, "how_to_use": "Use CONCAT to join two strings into a single string up to 255 characters. Be aware that if the total length exceeds 255 characters, the result will be truncated without error.", "example_code": "VarSTRING1 : STRING ;\n\n(* Example in ST , result is 'SUSIWILLI' *)\nVarSTRING1 := CONCAT ('SUSI','WILLI');", "additional_info": "The concatenated string has a maximum length of 255 characters. No error is thrown on overflow; excess characters are truncated silently.", "generated_brief": {"functional_summary": "The CONCAT instruction joins two input strings into a single string up to 255 characters in length, truncating any excess without error.", "usage_context": "It is typically used in PLC programs when combining multiple string values for display, messaging, or data manipulation within industrial control applications."}, "generated_keywords": ["string concatenation", "combine strings", "truncate overflow", "PLC string manipulation", "join two strings"]}
{"instruction_name": "REPLACE", "description": "Replaces a specific number of characters of a string by another string.", "parameters": {"Input": [{"name": "STR1", "type": "STRING(255)", "description": "String of which a part is replaced."}, {"name": "STR2", "type": "STRING(255)", "description": "String which replaces a part of STR1."}, {"name": "L", "type": "INT", "description": "Number of characters to replace, counting from left."}, {"name": "P", "type": "INT", "description": "Start position of the characters to be replaced. P = 1 or P = 0 both address the first character."}], "Output": [{"name": "REPLACE", "type": "STRING(255)", "description": "Resulting string after replacement."}], "InOut": []}, "how_to_use": "Use REPLACE to overwrite L characters of STR1 starting at position P with STR2. Note that P=0 or P=1 both refer to the first character, but the implementation for P=0 reduces L by one internally. It is recommended to use P values starting at 1 according to IEC 61131-3 standards.", "example_code": "VarSTRING1 := REPLACE('SUXYSI','K',2,2); (* Result: 'SKYSI' *)", "additional_info": "The current implementation has an incompatibility when P=0: the length parameter L is internally reduced by one. For compatibility reasons, this cannot be changed. Adhering to the IEC 61131-3 convention starting P at 1 is best practice.", "generated_brief": {"functional_summary": "The REPLACE instruction substitutes a specified number of characters in a string starting at a given position with another string.", "usage_context": "It is typically used in PLC programs to modify or update parts of text data dynamically according to control logic requirements."}, "generated_keywords": ["string replacement", "substring overwrite", "character substitution", "text manipulation", "PLC string functions"]}
{"instruction_name": "RIGHT", "description": "Returns a specific number of characters of a string, starting from right. RIGHT (STR, SIZE) means: Return the first SIZE characters from the right in string STR.", "parameters": {"Input": [{"name": "STR", "type": "STRING(255)", "description": "String to be analyzed"}, {"name": "SIZE", "type": "INT", "description": "Number of characters"}], "Output": [], "InOut": [{"name": "RIGHT", "type": "STRING(255)", "description": "Resulting string"}]}, "how_to_use": "Use the RIGHT function to extract a substring composed of the last SIZE characters from the input string STR. The function returns a string of length up to SIZE starting from the right end of STR.", "example_code": "VarSTRING1 := RIGHT ('SUSI',3);", "additional_info": "", "generated_brief": {"functional_summary": "The RIGHT function extracts a specified number of characters from the end of a given string.", "usage_context": "It is typically used in PLC programming to retrieve trailing substrings such as file extensions, codes, or identifiers from input strings."}, "generated_keywords": ["string extraction", "substring from right", "get trailing characters", "string manipulation", "PLC string function"]}
{"instruction_name": "RTC", "description": "FUNCTION_BLOCK RTC calculates the elapsed time since a given start time. It can be used as an operation hour counter when PDT is set to DT#1970-01-01-00-00:00 or is not connected. It can also return the current date and time by adjusting FB to the current local time, setting PDT to the current local time on the rising edge of EN. Note: This counter will overflow on 7th February, 2106.", "parameters": {"Input": [{"name": "EN", "type": "BOOL", "description": "Rising edge sets CDT to PDT and starts increasing CDT; falling edge resets CDT to DT#1970-01-01-00:00:00."}, {"": "PDT", "type": "DT", "description": "Preset date and time."}], "Output": [{"name": "Q", "type": "BOOL", "description": "TRUE as long as CDT is counting."}, {"name": "CDT", "type": "DT", "description": "Date and time elapsed since PDT."}], "InOut": []}, "how_to_use": "Use RTC by configuring the EN input to detect edges: on rising edge, CDT starts from PDT and counts upwards; on falling edge, CDT resets to DT#1970-01-01-00:00:00. Set PDT to the desired start time or use the default to count operation hours.", "example_code": "RTC(EN:=VarBOOL1, PDT:=DT#2006-03-30-14:00:00, Q=>VarBOOL2, CDT=>VarTimeCur);", "additional_info": "The RTC counter will overflow on 7th February, 2106. When used as an hour counter, set PDT to the epoch start date DT#1970-01-01-00-00:00 or leave unconnected.", "generated_brief": {"functional_summary": "The RTC function block calculates the elapsed time since a specified start date and time or returns the current date and time based on input control signals.", "usage_context": "It is typically used for tracking operation hours or time elapsed in industrial automation by setting a preset start time and controlling the timer with enable signals."}, "generated_keywords": ["elapsed time calculation", "real-time clock", "operation hour counter", "preset start time", "enable edge detection"]}
{"instruction_name": "LEN", "description": "Returns the number of characters of a string", "parameters": {"Input": [{"name": "STR", "type": "STRING(255)", "description": "String to be analyzed"}], "Output": [{"name": "LEN", "type": "INT", "description": "Length of string STR"}], "InOut": []}, "how_to_use": "Call LEN with a STRING input to obtain its length as an INT. No initialization required.", "example_code": "VarINT1 := LEN('SUSI');", "additional_info": "", "generated_brief": {"functional_summary": "The LEN instruction returns the number of characters contained in a given string input.", "usage_context": "It is typically used to determine string length for validation, parsing, or manipulating text data within PLC programs."}, "generated_keywords": ["string length", "character count", "string", "length calculation", "text processing"]}
