{"instruction_name": "ResolveSymbols", "description": "The asynchronous instruction \"ResolveSymbols\" creates references to the respective tags in the PLC program by resolving symbolic tag names entered during runtime. These references are typed pointers used to address the tags.", "parameters": {"Input": [{"name": "nameList", "type": "Array of WSTRING", "description": "An array containing the symbolic tag names that you wish to resolve."}], "Output": [{"name": "referenceList", "type": "Array of ResolvedSymbol (SDT)", "description": "An array where the references to the resolved tags are saved. Each entry corresponds to a symbolic tag name from nameList."}], "InOut": []}, "how_to_use": "Specify an array of tag names in 'nameList'. 'referenceList' must have the same limits as 'nameList' to receive the resolved references. Use this instruction asynchronously to create typed pointers to tags for later access.", "example_code": "VAR\n  tagNames : ARRAY[0..1] OF WSTRING := ['Tag1', 'Tag2'];\n  references : ARRAY[0..1] OF ResolvedSymbol;\nEND_VAR\n\nResolveSymbols(nameList := tagNames, referenceList => references);", "additional_info": "Available for S7-1500 CPUs with firmware V3.0 or higher. Tags must have the attribute 'Accessible from HMI/OPC UA/Web API' or 'Writable from HMI/OPC UA/Web API'.", "generated_brief": {"functional_summary": "The ResolveSymbols instruction asynchronously converts an array of symbolic tag names into typed references that point to the corresponding tags in the PLC program at runtime.", "usage_context": "This function is typically used when dynamic access to PLC tags is required during operation, such as for HMI or OPC UA interfaces needing runtime tag references."}, "generated_keywords": ["asynchronous tag resolution", "symbolic tag name referencing", "runtime tag pointers", "dynamic PLC tag access", "typed tag references"]}
{"instruction_name": "MoveResolvedSymbolsToBuffer", "description": "A synchronous instruction used to read the values of tags referenced by ResolvedSymbol structures and write these values into a target buffer.", "parameters": {"Input": [{"name": "src", "type": "Array of ResolvedSymbol (SDT)", "description": "Array containing references to resolved tags to be read."}], "Output": [{"name": "dst", "type": "Array of BYTE", "description": "Target buffer where read tag values are written."}], "InOut": []}, "how_to_use": "Use after resolving symbolic tag names with 'ResolveSymbols'. Pass the array of references to 'src' and provide a BYTE array in 'dst' to receive the tag values. This reads tag values dynamically during runtime.", "example_code": "VAR\n  references : ARRAY[0..1] OF ResolvedSymbol;  // previously obtained\n  buffer : ARRAY[0..15] OF BYTE;\nEND_VAR\n\nMoveResolvedSymbolsToBuffer(src := references, dst => buffer);", "additional_info": "This instruction provides dynamic read access to tags during runtime using resolved references. Applicable under the same constraints as 'ResolveSymbols'.", "generated_brief": {"functional_summary": "Moves the current values of tags referenced by ResolvedSymbol structures into a specified byte buffer synchronously.", "usage_context": "Used after resolving symbolic tag names to dynamically read and store tag values during runtime for further processing or communication."}, "generated_keywords": ["read resolved symbols", "move tag values to buffer", "dynamic tag value reading", "runtime data access", "synchronous symbol reading"]}
{"instruction_name": "S_PEXT", "description": "The 'Assign extended pulse timer parameters and start' instruction starts a programmed timer when a positive signal edge is detected at the S parameter. The timer runs for the programmed time (TV) even if the signal state at the S parameter changes to '0'. As long as the timer runs, parameter Q returns the signal state '1'. When the timer has expired, parameter Q is reset to '0'. If the signal state at the S parameter changes from '0' to '1' while the timer is running, the timer is restarted with the time programmed in the TV parameter.", "parameters": {"Input": [{"name": "T_NO", "type": "TIMER, INT", "description": "The timer that is started. The number of timers depends on the CPU."}, {"name": "S", "type": "BOOL", "description": "Start input"}, {"name": "TV", "type": "S5TIME, WORD", "description": "Preset time value"}, {"name": "R", "type": "BOOL", "description": "Reset input"}], "Output": [{"name": "Q", "type": "BOOL", "description": "Status of the timer"}, {"name": "BI", "type": "WORD", "description": "Current dual-coded timer value"}], "InOut": []}, "how_to_use": "To use this instruction, assign the timer number (T_NO) and connect the start (S), time value (TV), and resetR) parameters. Monitor the output (Q) for the timer's status and (BI) for the current time value.", "example_code": "\"Tag_Result\" := S_PEXT(T_NO := \"Timer_1\", S := \"Tag_1\", TV := \"Tag_Number\", R := \"Tag_Reset\", Q => \"Tag_Status\", BI => \"Tag_Value\");", "additional_info": "In the time cell, the operating system reduces the time value in an interval specified by the time base by one unit until the value equals '0'. The decrementation is performed asynchronously to the user program.", "generated_brief": {"functional_summary": "The S_PEXT instruction triggers and manages an extended pulse timer that starts on a positive edge of the input signal and maintains its output for a preset time even if the input signal goes low, restarting if triggered again during timing.", "usage_context": "It is typically used in industrial control systems to reliably time pulse durations for processes requiring precise timing triggered by signal edges."}, "generated_keywords": ["extended pulse timer", "positive edge trigger", "preset timer duration", "timer restart on input", "industrial timing control"]}
{"instruction_name": "S_OFFDT", "description": "The 'Assign off-delay timer parameters and start' instruction starts a programmed timer when a negative signal edge is detected at the S parameter. The timer runs for the programmed time (TV). As long as the timer is running or parameter S returns signal state '1', then parameter Q has signal state '1'. If the timer expires and the signal state is '0' then parameter Q is reset to signal state '0'. If the signal state at parameter S changes from '0' to '1' while the timer is running, the timer is stopped. The timer is only restarted after a falling signal edge is detected at parameter S.", "parameters": {"Input": [{"name": "T_NO", "type": "TIMER, INT", "description": "The timer that is started. The number of timers depends on the CPU."}, {"name": "S", "type": "BOOL", "description": "Start input."}, {"name": "TV", "type": "S5TIME, WORD", "description": "Preset time value."}, {"name": "R", "type": "BOOL", "description": "Reset input."}], "Output": [{"name": "Q", "type": "BOOL", "description": "Status of the timer."}, {"name": "BI", "type": "WORD", "description": "Current dual-coded timer value."}], "InOut": []}, "how_to_use": "To use this instruction, specify the timer number, start input, preset time value, and reset signal. Monitor the output status and current timer value as per your application requirements.", "example_code": "\"Tag_Result\" := S_OFFDT(T_NO := \"Timer_1\",\n                                S := \"Tag_1\",\n                                TV := \"Tag_Number\",\n                                R := \"Tag_Reset\",\n                                Q => \"Tag_Status\",\n                                BI => \"Tag_Value\");", "additional_info": "The operating system reduces the time value in an interval specified by the time base until the value equals '0'. The resulting timer may thus be up to one time interval shorter than the desired time base.", "generated_brief": {"functional_summary": "The S_OFFDT instruction starts an off-delay timer on a falling edge of the input signal, keeping the output active during the timer duration or while the input is high, and stops or resets the timer based on signal changes or reset input.", "usage_context": "It is typically used in industrial automation to delay turning off outputs after an input signal transitions from high to low, such as in motor control or safety interlock timing applications."}, "generated_keywords": ["off-delay timer", "negative edge trigger", "timer reset", "signal state monitoring", "preset time delay"]}
{"instruction_name": "S_ODT", "description": "The \"Assign on-delay timer parameters and start\" instruction starts a programmed timer as on-delay when a positive signal edge is detected at the S parameter. The timer runs for the programmed time (TV) as long as the signal state of the S parameter is \"1\". If the timer expires correctly and parameter S still has signal state \"1\" then parameter Q returns signal state \"1\". If the signal state at the S parameter changes from \"1\" to \"0\" while the timer is running, the timer is stopped. In this case, output Q is reset to signal state \"0\". Internally, the time is made up of a time value and a time base and is programmed in the TV parameter. When the instruction starts, the programmed time value counts down to zero. The time base specifies the time increment by which the time value changes. The current time value is provided at the parameter BI. If the time is running and the signal state at input R changes from \"0\" to \"1\" then the current time value and the time base are also set to zero. In this case, the signal state at parameter Q is \"0\". The timer is reset if the signal state at the R parameter is \"1\", even if the timer is not running and the result of logic operation (RLO) at the S parameter is \"1\". The instruction data is updated with each access. It is therefore possible that the query of the data at the start of the cycle returns different values from those at the end of the cycle.", "parameters": {"Input": [{"name": "T_NO", "type": "TIMER, INT", "description": "The timer that is started. The number of timers depends on the CPU."}, {"name": "S", "type": "BOOL", "description": "Start input"}, {"name": "TV", "type": "S5TIME, WORD", "description": "Preset time value"}, {"name": "R", "type": "BOOL", "description": "Reset input"}], "Output": [{"name": "Q", "type": "BOOL", "description": "Status of the timer"}, {"name": "BI", "type": "WORD", "description": "Current dual-coded timer value"}, {"name": "Function value", "type": "S5TIME", "description": "Current timer value"}], "InOut": []}, "how_to_use": "Use this instruction to start an on-delay timer when a positive edge occurs at input S. The timer runs as long as S remains TRUE. If input R becomes TRUE, the timer is reset immediately regardless of S. The outputs Q and BI provide the timer status and current time respectively. Be aware that the timer value decrements asynchronously, so actual timing may be up to one time base interval shorter than programmed.", "example_code": "\"Tag_Result\" := S_ODT(T_NO := \"Timer_1\",\n                      S := \"Tag_1\",\n                      TV := \"Tag_Number\",\n                      R := \"Tag_Reset\",\n                      Q => \"Tag_Status\",\n                      BI => \"Tag_Value\");", "additional_info": "The time cell internally reduces the time value asynchronously by one unit per time base interval until zero, which means timer durations may be slightly shorter than the programmed time. The instruction updates its data with each access cycle, so data queried at the start and end of a cycle may differ.", "generated_brief": {"functional_summary": "The S_ODT instruction starts an on-delay timer on a rising edge at input S, runs as long as S is true, and resets the timer and output Q immediately if input R is activated.", "usage_context": "It is used in PLC programs to delay an output signal activation for a preset time duration while allowing dynamic reset control during industrial process automation."}, "generated_keywords": ["on-delay timer", "rising edge start", "timer reset input", "timer status output", "programmable time delay"]}
{"instruction_name": "S_PULSE", "description": "The \"Assign pulse timer parameters and start\" instruction starts the time programmed in the T_NO parameter when a change from \"0\" to \"1\" (positive signal edge) is detected in the result of logic operation (RLO) of the S parameter. The timer runs for the programmed time (TV) as long as the signal state of the S parameter is \"1\". When the signal state of the S parameter changes to \"0\" before the programmed time has expired, the timer is stopped and the Q parameter is reset to \"0\". Internally, the time is made up of a time value and a time base and is programmed in the TV parameter. When the instruction starts, the programmed time value counts down to zero. The time base specifies the time increment by which the time value changes. The current time value is provided at the parameter BI. If the timer is running and the signal state at input R changes to \"1\" then the current time value and the time base are also set to zero. If the timer is not running, the signal state \"1\" at the R input has no effect. Parameter Q returns signal state \"1\" as long as the timer is running and the signal state at parameter S is \"1\". When the signal state of the S parameter changes to \"0\" before the programmed time has expired, the Q parameter returns signal state \"0\". If the timer is reset by parameter R or if the timer has expired then parameter Q also returns signal state \"0\". The instruction data is updated with each access. It is therefore possible that the query of the data at the start of the cycle returns different values from those at the end of the cycle.", "parameters": {"Input": [{"name": "T_NO", "type": "TIMER, INT", "description": "The timer that is started. The number of timers depends on the CPU."}, {"name": "S", "type": "BOOL", "description": "Start input"}, {"name": "TV", "type": "S5TIME, WORD", "description": "Preset time value"}, {"name": "R", "type": "BOOL", "description": "Reset input"}], "Output": [{"name": "Q", "type": "BOOL", "description": "Status of the timer"}, {"name": "BI", "type": "WORD", "description": "Current dual-coded timer value"}, {"name": "Function value", "type": "S5TIME", "description": "Current timer value"}], "InOut": []}, "how_to_use": "Use the instruction to start a pulse timer when there is a positive edge on the start input (S). The timer runs for the preset time (TV) as long as S remains TRUE. If the start input S changes to FALSE before the timer expires, or if the reset input R is set TRUE, the timer stops and output Q resets to FALSE. The current timer value can be read from BI or the function value. Note that timer decrementation is asynchronous and may be up to one time interval shorter than the programmed base.", "example_code": "\"Tag_Result\" := S_PULSE(T_NO := \"Timer_1\", S := \"Tag_1\", TV := \"Tag_Number\", R := \"Tag_Reset\", Q => \"Tag_Status\", BI => \"Tag_Value\");", "additional_info": "In the time cell, the operating system reduces the time value in intervals specified by the time base asynchronously to the user program. The resulting timer can be up to one time interval shorter than the desired time base.", "generated_brief": {"functional_summary": "The S_PULSE instruction starts and runs a pulse timer upon a positive edge on the start input (S), maintaining the timer output (Q) as long as S is TRUE and stopping/resetting it if S goes FALSE or a reset input (R) is triggered before the preset time expires.", "usage_context": "It is typically used in industrial automation to precisely control timed pulse operations that require automatic timer start and stop based on input signal changes."}, "generated_keywords": ["pulse timer", "positive edge trigger", "timer start and stop", "preset time control", "reset input"]}
{"instruction_name": "S_ODTS", "description": "The \"Assign retentive on-delay timer parameters and start\" instruction starts a programmed timer when a positive signal edge is detected at the S parameter. The timer runs for the programmed time (TV) even if the signal state at the S parameter changes to \"0\". When the timer expires, the \"Q\" parameter returns signal state \"1\" regardless of the signal state of the \"S\" parameter. If the signal state at the S parameter changes from \"0\" to \"1\" while the timer is running, the timer is restarted with the programmed time TV. Signal state \"1\" at parameter R resets the current time value and time base to \"0\", independent of the signal state at parameter S. In this case, the signal state at parameter Q is \"0\". The instruction data is updated with each access, so the data queried at the start and end of the cycle may differ.", "parameters": {"Input": [{"name": "T_NO", "type": "TIMER, INT", "description": "The timer that is started. The number of timers depends on the CPU."}, {"name": "S", "type": "BOOL", "description": "Start input"}, {"name": "TV", "type": "S5TIME, WORD", "description": "Preset time value"}, {"name": "R", "type": "BOOL", "description": "Reset input"}], "Output": [{"name": "Q", "type": "BOOL", "description": "Status of the timer"}, {"name": "BI", "type": "WORD", "description": "Current dual-coded timer value"}], "InOut": []}, "how_to_use": "To use the S_ODTS instruction, assign a timer (T_NO), provide a start signal (S) that triggers on the positive edge, specify the preset time (TV), and optionally include a reset signal (R) to reset the timer. Monitor the Q output for the timer status and the BI output for the current timer value in dual-coded format. Note that the timer decrements asynchronously to the user program and the timing may be up to one interval shorter than the programmed time base. The instruction updates data each access; therefore, values can differ within a cycle.", "example_code": "\"Tag_Result\" := S_ODTS(T_NO := \"Timer_1\", S := \"Tag_1\", TV := \"Tag_Number\", R := \"Tag_Reset\", Q => \"Tag_Status\", BI => \"Tag_Value\");", "additional_info": "The operating system reduces the time value in intervals defined by the time base by one unit until zero asynchronously to the user program, possibly making the timer up to one time interval shorter than the desired time base. The current time value is stored dual-coded at parameter BI and also returned as the function value. For valid data types and memory areas refer to additional Siemens documentation.", "generated_brief": {"functional_summary": "The S_ODTS instruction starts a retentive on-delay timer on a rising edge of the start signal and maintains the timer value until it expires or is reset.", "usage_context": "It is typically used in industrial automation to control processes that require a delayed action with the ability to retain timing information across signal interruptions."}, "generated_keywords": ["retentive on-delay timer", "rising edge start", "timer reset input", "preset time delay", "dual-coded timer value"]}
{"instruction_name": "WAIT", "description": "The 'Configure time delay' instruction pauses the program execution for a specific period of time. You indicate the period of time in microseconds on the WT parameter of the instruction.", "parameters": {"Input": [{"name": "WT", "type": "INT", "description": "Time delay in microseconds (μs). You can configure time delays from -32768 up to 32767 microseconds."}], "Output": [], "InOut": []}, "how_to_use": "Specify the desired delay time in microseconds on the WT parameter. Remember that negative delay time will set the enable output ENO and the RLO signal state to FALSE.", "example_code": "", "additional_info": "The execution of the instruction can be interrupted by higher priority events and does not return any error information. In LAD or FBD, instructions linked to enable output ENO are not executed if a negative delay time is specified.", "generated_brief": {"functional_summary": "The WAIT instruction pauses program execution for a specified time delay in microseconds, controlled by the WT parameter.", "usage_context": "It is typically used in PLC programs to introduce precise short delays for timing control or synchronization in industrial automation processes."}, "generated_keywords": ["time delay", "program pause", "microsecond delay", "WAIT instruction", "timing control"]}
{"instruction_name": "DB_ANY_TO_VARIANT", "description": "The \"Convert DB_ANY to VARIANT\" instruction is used to generate a VARIANT tag from a data block that meets the requirements listed below. The operand at the IN parameter has the data type DB_ANY, which means that the data block does not have to be known when the program is created. The data block number is read during runtime.", "parameters": {"Input": [{"name": "IN", "type": "DB_ANY", "description": "Data block whose number is read. You can use a local or global tag at the IN parameter."}], "Output": [{"name": "ERR", "type": "INT", "description": "Error information"}, {"name": "RET_VAL", "type": "VARIANT", "description": "Function value that outputs the VARIANT tag. The tag itself must be declared as InOut in the block interface, but is declared as Output since the data flows into the tag."}], "In": []}, "how_to_use": "Use the DB_ANY_TO_VARIANT instruction by providing a DB_ANY type operand at the IN parameter referencing a data block. The instruction creates a VARIANT tag that addresses the data block. If the requirements are met or the data block does not exist, RET_VAL outputs NULL and ERR provides the corresponding error code. Declare the RET_VAL tag as InOut in the block interface despite it being an output parameter. If the error code 16#8155 occurs, follow workaround to familiarize the program with the user data type by creating an FC with a VARIANT InOut parameter and an FC that calls it, or call VariantGet or VariantPut after DB_ANY_TO_VARIANT.", "example_code": "#tempVARIANT := DB_ANY_TO_VARIANT(IN := \"InputDB\", ERR := \"Tag_Error\");", "additional_info": "Conversion is possible if the input data block is an instance data block of a PLC or system data type (SDT) or an ARRAY DB. Conversion is not possible for instance data blocks of function blocks or global data blocks. The ERR parameter codes indicate various status and error conditions, such as non-existent data blocks, short blocks, write protection, or incorrect data types. The RET_VAL parameter must be declared as InOut in the block interface to work properly. For the error code 16#8155, the data type must be introduced to the program with an additional FC, or by calling VariantGet or VariantPut afterwards.", "generated_brief": {"functional_summary": "The DB_ANY_TO_VARIANT instruction converts a data block reference of type DB_ANY into a VARIANT tag during runtime for flexible data handling.", "usage_context": "It is typically used when a program needs to dynamically access and manipulate data blocks whose identity is not known at compile time, such as instance data blocks or arrays."}, "generated_keywords": ["DB_ANY to VARIANT conversion", "dynamic data block access", "runtime data block referencing", "VARIANT tag creation", "flexible data handling"]}
{"instruction_name": "CTD", "description": "The 'Count down' instruction is used to decrement the value at the parameter CV. When the signal state of the CD parameter changes from '0' to '1' (positive signal edge), the instruction is executed and the current counter value of the CV parameter is decremented by one. Each time a positive signal edge is detected, the counter value is decremented until it reaches the low limit of the specified data type. When the low limit is reached, the signal state of the CD parameter no longer has an effect on the instruction.", "parameters": {"Input": [{"name": "CD", "type": "BOOL", "description": "Count input"}, {"name": "LD", "type": "BOOL", "description": "Load input"}, {"name": "PV", "type": "Integers", "description": "Value to which the CV output is set with LD = 1."}], "Output": [{"name": "Q", "type": "BOOL", "description": "Counter status"}, {"name": "CV", "type": "Integers, CHAR, WCHAR, DATE", "description": "Current counter value"}]}, "how_to_use": "You can declare an IEC counter in a separate data block or as a local tag in a program block. During the increment process, ensure the CD signal is managed correctly to avoid counting errors.", "example_code": "\"IEC_SCOUNTER_DB\".CTD(CD := \"Tag_Start\", LD := \"Tag_Load\", PV := \"Tag_PresetValue\", Q => \"Tag_Status\", CV => \"Tag_CounterValue\");", "additional_info": "Only use a counter at a single point in the program to avoid the risk of counting errors.", "generated_brief": {"functional_summary": "The CTD instruction decrements the current counter value by one on each rising edge of the count input signal until it reaches the predefined lower limit.", "usage_context": "It is typically used in industrial automation to count down events or items, such as tracking the remaining quantity of materials or timing operations that require decrementing counts."}, "generated_keywords": ["count down", "decrement counter", "rising edge detection", "counter limit", "PLC counter instruction"]}
{"instruction_name": "BITSUM", "description": "The \"Count number of set bits\" instruction is used to count the number of bits of an operand that are set to the signal state \"1\".", "parameters": {"Input": [{"name": "<Operand>", "type": "DWORD", "description": "Operand whose set bits are counted"}], "Output": [{"name": "Function value", "type": "INT", "description": "Result of the instruction"}], "InOut": []}, "how_to_use": "Use BITSUM instruction to count how many bits of a DWORD input are set to 1. Pass the operand as input and the function returns the count as an INT. Make sure the input is a DWORD located in one of the memory areas I, Q, M, D, L, or P.", "example_code": "\"Tag_Result\" := BITSUM(\"Tag_Input\");", "additional_info": "The error codes can be displayed as integer or hexadecimal values in the program editor. For information on toggling display formats, refer to the linked documentation.", "generated_brief": {"functional_summary": "The BITSUM instruction counts the number of bits set to 1 in a 32-bit DWORD operand and returns this count as an integer.", "usage_context": "It is typically used in industrial control systems to quickly determine how many binary flags or signals are active within a given memory word."}, "generated_keywords": ["count set bits", "bit counting", "DWORD operand", "binary flags count", "signal state tally"]}
{"instruction_name": "SEG", "description": "The 'Create bit pattern for seven-segment display' instruction is used to convert each of the four hexadecimal digits of the specified source word (IN) into an equivalent bit pattern for a 7-segment display. The result of the instruction is output in the double word on the OUT parameter.", "parameters": {"Input": [{"name": "IN", "type": "WORD", "description": "Source word with four hexadecimal digits"}], "Output": [{"name": "OUT", "type": "DWORD", "description": "Bit pattern for the seven-segment display"}], "InOut": []}, "how_to_use": "To use this instruction, assign a hexadecimal value to the IN parameter and the instruction will generate the corresponding bit pattern for a seven-segment display in the OUT parameter.", "example_code": "SEG(IN := \"Tag_Input\", OUT => \"Tag_Output\");", "additional_info": "Ensure that the input value is a valid 4-digit hexadecimal number to get the correct display output.", "generated_brief": {"functional_summary": "The SEG instruction converts a 4-digit hexadecimal input word into a corresponding bit pattern for a seven-segment display output.", "usage_context": "It is used in industrial control systems to visually represent hexadecimal values on seven-segment displays for monitoring or debugging purposes."}, "generated_keywords": ["seven-segment display", "hexadecimal to bit pattern", "display conversion", "PLC output encoding", "visual numeric representation"]}
{"instruction_name": "BCDCPL", "description": "The \"Create tens complement\" instruction is used to create the tens complement of a seven-digit BCD number specified by the operand. This instruction uses the following mathematical formula to calculate: 10000000 (as BCD) – 7-digit BCD value = Tens complement (as BCD).", "parameters": {"Input": [{"name": "Operand", "type": "Bit strings", "description": "7-digit BCD number; can be located in memory areas I, Q, M, D, L, P."}], "Output": [{"name": "Function value", "type": "DWORD", "description": "Result of the instruction; can be located in memory areas I, Q, M, D, L, P."}], "InOut": []}, "how_to_use": "Use the BCDCPL instruction by supplying a seven-digit BCD operand. The instruction returns the tens complement of the input BCD number as the function value. Ensure the input operand is correctly formatted as a 7-digit BCD number located in one of the supported memory areas (I, Q, M, D, L, P).", "example_code": "\"Tag_Result\" := BCDCPL(\"Tag_Input\");", "additional_info": "Valid data types and memory areas include I, Q, M, D, L, and P. Error codes can be displayed as integer or hexadecimal values in the program editor. Refer to the documentation for switching display formats valid data types.", "generated_brief": {"functional_summary": "The BCDCPL instruction calculates the tens complement of a seven-digit BCD number by subtracting it from 10,000,000 in BCD format.", "usage_context": "It is typically used in PLC programs for BCD arithmetic operations requiring the tens complement, such as in digital counters or industrial measurement conversions."}, "generated_keywords": ["tens complement", "BCD arithmetic", "seven-digit BCD", "PLC numeric processing", "BCD subtraction"]}
{"instruction_name": "DEMUX", "description": "The \"Demultiplex\" instruction transfers the value of the input parameter IN to a selected output parameter. The selection of the input parameter takes place independent of the parameter value K. The K parameter specifies the output parameter number to which the value of the input parameter IN is transferred. The other output parameters are not changed. Numbering starts at OUT0 and continues consecutively with each new output. You can declare a maximum of 32 output parameters. If the value of the K parameter is greater than the number of output parameters, the content of the IN input parameter is copied to the OUTELSE output parameter and the signal state \"0\" is assigned to the enable output ENO. The function value is invalid if K is greater than the number of available outputs or if errors occurred during the instruction execution.", "parameters": {"Input": [{"name": "K", "type": "Integers", "description": "Specifies the output to which the input value (IN) will be copied. If K = 0 => Parameter OUT0, if K = 1 => Parameter OUT1, etc."}, {"name": "IN", "type": "Binary numbers, integers, floating-point numbers, timers, STRING, CHAR, WCHAR, TOD, DATE, DT", "description": "Input value"}], "Output": [{"name": "OUT0", "type": "Binary numbers, integers, floating-point numbers, timers, STRING, CHAR, WCHAR, TOD, DATE, DT", "description": "First output"}, {"name": "OUT1", "type": "Binary numbers, integers, floating-point numbers, timers, STRING, CHAR, WCHAR, TOD, DATE, DT", "description": "Second output"}, {"name": "OUTn", "type": "Binary numbers, integers, floating-point numbers, timers, STRING, CHAR, WCHAR, TOD, DATE, DT", "description": "Optional outputs"}, {"name": "OUTELSE", "type": "Binary numbers, integers, floating-point numbers, timers, STRING, CHAR, WCHAR, TOD, DATE, DT", "description": "Output to which the value at input IN is copied if K > n."}], "InOut": []}, "how_to_use": "Assign the input value to IN and specify the output using the integer K (starting at 0 for OUT0). If K is out of range (less than 0 or greater than the number of outputs), the input value IN is transferred to OUTELSE. Ensure that IN and all outputs have the same data type to avoid implicit conversion and data changes. You may declare up to 32 output parameters numbered consecutively from OUT0 to OUTn.", "example_code": "DEMUX(K := Tag_Number,\n      IN := Tag_Value,\n      OUT0 := Tag_1,\n      OUT1 := Tag_2,\n      OUTELSE := Tag_3);", "additional_info": "If the K parameter value is outside the range of available outputs (< 0 or > available outputs), the input is routed to OUTELSE and ENO signal is set to 0. Data types of IN and all outputs must match to prevent unintentional conversion. The number of outputs can be up to 32. The ENO output indicates the valid execution of the instruction.", "generated_brief": {"functional_summary": "The DEMUX instruction routes the input value IN to one selected output based on the integer K, leaving other outputs unchanged and sending the input to OUTELSE if K is out of range.", "usage_context": "It is used in PLC programs when a single input value needs to be conditionally directed to one of multiple outputs depending on a control selector, facilitating flexible data distribution in automation logic."}, "generated_keywords": ["demultiplex", "conditional output routing", "input to selected output", "output selection by index", "data distribution"]}
{"instruction_name": "EXP", "description": "The \"Form exponential value\" instruction calculates the exponent from the base e (e = 2.718282) and the input value and saves the result in the specified operand.", "parameters": {"Input": [{"name": "<Expression>", "type": "Floating-point numbers", "description": "Input value"}], "Output": [{"name": "Function value", "type": "Floating-point numbers", "description": "Exponential value of the input value"}], "InOut": []}, "how_to_use": "Use the EXP function to calculate the natural exponential (base e) of a floating-point input expression. Pass the input value as the parameter, and assign the result to the desired output operand of floating-point type.", "example_code": "\"Tag_Result1\" := EXP(\"Tag_Value\");\n\"Tag_Result2\" := EXP(\"Tag_Value1\" / \"Tag_Value2\");", "additional_info": "Valid input and output operands can be located in memory areas I, Q, M, D, L, P. Refer to the connected memory areas and data type documentation for detailed constraints.", "generated_brief": {"functional_summary": "The EXP instruction calculates the natural exponential (e raised to the power of the input floating-point value) and stores the result in the specified operand.", "usage_context": "This function is typically used in PLC programs to perform exponential calculations in processes such as growth modeling, decay analysis, or any control logic requiring natural exponentiation."}, "generated_keywords": ["natural exponential calculation", "floating-point exponentiation", "base e power", "EXP function", "exponential value computation"]}
{"instruction_name": "GET_ERR_ID", "description": "The \"Get error ID locally\" instruction is used to query the occurrence of errors within a block. This is usually to access error. If the system reports during the block processing errors within the block execution since the last execution of the instruction, the instruction outputs the error ID of the first error that occurred. The error ID can only be saved in operands of the WORD data type. If several errors occur in the block, the error ID of the next error to occur in the instruction is output only after the first error that occurred has been remedied.", "parameters": {"Input": [], "Output": [{"name": "Function value", "type": "WORD", "description": "Error ID"}], "InOut": []}, "how_to_use": "Insert the GET_ERR_ID instruction in the program code of a block to enable local error handling. The operand to store the error ID must be of the WORD data type and can be declared in the Temp section or reset to 0 before calling the instruction. The output of the instruction changes only if error information is present and outputs the first error ID detected since the last call. After the error is remedied, it can output the next error. Using this instruction ignores any predefined system reactions to errors in the block.", "example_code": "#TagOut := #Field[#index] * REAL#40.5;\n\n#TagID := GET_ERR_ID();\n\nIF #TagID = 16#2522 THEN\n   MOVE_BLK(IN := #TagArrayIn[0],\n            COUNT := 1,\n            OUT => #TagArrayOut[1]);\nEND_IF;", "additional_info": "The <Operand> is only changed if error information is present. To reset it to 0 after handling the error, either declare the operand in the Temp section of the block interface or reset it before calling GET_ERR_ID. The instruction enables local error handling and suppresses predefined system reactions to errors. The error codes can be displayed as integer or hexadecimal values in the program editor.", "generated_brief": {"functional_summary": "GET_ERR_ID retrieves the ID of the first error that has occurred locally within a block since its last call, allowing step-by-step error identification and handling.", "usage_context": "It is used within a PLC program block to perform local error handling by monitoring and responding to specific errors, bypassing predefined system error reactions."}, "generated_keywords": ["local error handling", "retrieve error ID", "block error monitoring", "step-by-step error identification", "suppress system error reactions"]}
{"instruction_name": "GET_ERROR", "description": "The 'Get error locally' instruction is used to query the occurrence of errors within a program block. This normally involves programming or access errors. If the system reports an error during the execution of the program block, detailed information is output at the <Operand> on the first error to occur during the execution of the block since the last execution of the instruction.", "parameters": {"Input": [{"name": "<Operand>", "type": "ErrorStruct", "description": "Information about errors that have occurred."}], "Output": [], "InOut": []}, "how_to_use": "As soon as you insert the instruction in the program code of a program block, the local error handling is activated and default system reactions are ignored when errors occur.", "example_code": "GET_ERROR(#Error);", "additional_info": "The <Operand> is only changed if error information is present. To set the operand back to '0' after handling the error, declare the operand in theTemp' section of the block interface or reset the operand to '0' before calling the instruction.", "generated_brief": {"functional_summary": "The GET_ERROR instruction retrieves detailed information about the first error that occurs during the execution of a program block since its last call, enabling local error handling.", "usage_context": "It is used within program blocks when custom error processing is required to override default system reactions and manage programming or access errors internally."}, "generated_keywords": ["local error handling", "get first error", "program block error query", "override system error reaction", "error information retrieval"]}
{"instruction_name": "MAX", "description": "The 'Get maximum' instruction compares the values of the available inputs and returns the greatest value as the result.", "parameters": {"Input": [{"name": "IN1", "type": "Integers, floating-point numbers, TIME, TOD, DATE, DTL", "description": "First input value"}, {"name": "IN2", "type": "Integers, floating-point numbers, TIME, TOD, DATE, DTL", "description": "Second input value"}, {"name": "INn", "type": "Integers, floating-point numbers, TIME, TOD, DATE, DTL", "description": "Additionally inserted inputs whose values are to be compared"}], "Output": [{"name": "Function value", "type": "Integers, floating-point numbers, TIME, TOD, DATE, DTL", "description": "Result of the instruction"}], "InOut": []}, "how_to_use": "A minimum of two and a maximum of 32 inputs can be specified at the instruction.", "example_code": "\"Tag_Result\" := MAX(IN1 := \"Tag_Value1\", IN2 := \"Tag_Value2\", IN3 := \"Tag_Value3\");", "additional_info": "The data types TOD, LTOD, DATE and LDT can only be used if the IEC test is not enabled. The result is invalid if any of the following conditions are met: if the implicit conversion of the data types fails during execution of the instruction or if a floating-point number has an invalid value.", "generated_brief": {"functional_summary": "The MAX instruction compares multiple input values and returns the greatest one as the result.", "usage_context": "It is typically used in PLC programs to determine the highest value among several inputs, such as monitoring sensors or process variables."}, "generated_keywords": ["maximum value", "compare inputs", "return greatest", "multiple inputs", "value selection"]}
{"instruction_name": "MIN", "description": "The \"Get minimum\" instruction compares the values of the available inputs and returns the lowest value as the result. A minimum of two and a maximum of 32 inputs can be specified at the instruction. The result is invalid if any of the following conditions are met: The implicit conversion of the data types fails during execution of the instruction; A floating-point number has an invalid value.", "parameters": {"Input": [{"name": "IN1", "type": "Integers, floating-point numbers, TIME, TOD, DATE, DTL", "description": "First input value"}, {"name": "IN2", "type": "Integers, floating-point numbers, TIME, TOD, DATE, DTL", "description": "Second input value"}, {"name": "INn", "type": "Integers, floating-point numbers, TIME, TOD, DATE, DTL", "description": "Additionally inserted inputs whose values are to be compared"}], "Output": [{"name": "Function value", "type": "Integers, floating-point numbers, TIME, TOD, DATE, DTL", "description": "Result of the instruction"}], "InOut": []}, "how_to_use": "Use the MIN instruction to compare two to 32 input values and return the smallest one. Ensure all inputs are compatible data types and that no floating-point inputs have invalid values. The instruction chooses the minimum value among all specified inputs and outputs it as the function value. The data types TOD, LTOD, DATE, and LDT can only be used if the IEC test is not enabled.", "example_code": "\"Tag_Result\" := MIN(IN1 := \"Tag_Value1\",\n                    IN2 := \"Tag_Value2\",\n                    IN3 := \"Tag_Value3\");", "additional_info": "The data types TOD, LTOD, DATE, and LDT can only be used if the IEC test is not enabled. The result is invalid if implicit data type conversion fails or if a floating-point input has an invalid value.", "generated_brief": {"functional_summary": "The MIN instruction compares between two and 32 input values and returns the smallest valid value among them.", "usage_context": "It is used in PLC programs to determine the minimum value from a set of numerical or time-related inputs, typically for decision-making or control processes requiring threshold or limit evaluation."}, "generated_keywords": ["minimum value", "compare inputs", "numeric and time types", "multi-input evaluation", "data type compatibility"]}
{"instruction_name": "INIT_RD", "description": "The \"Initialize all retain data\" instruction is used to reset the retentive data of all data blocks, bit memories and SIMATIC timers and counters at the same time. The instruction can only be executed within a startup OB because the execution exceeds the program cycle duration.", "parameters": {"Input": [{"name": "REQ", "type": "BOOL", "description": "If the input \"REQ\" has the signal state \"1\", all retentive data are reset."}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Error information: If an error occurs during the execution of the instruction, an error code is output at the RET_VAL parameter."}], "InOut": []}, "how_to_use": "Use the instruction within a startup OB. Set the input REQ to '1' to reset all retentive data of all data blocks, bit memories and SIMATIC timers and counters. Monitor the RET_VAL output for error codes. The instruction should not be used outside of a startup OB due to execution time exceeding the program cycle duration.", "example_code": "\"Tag_Result\" := INIT_RD(\"Tag_REQ\");", "additional_info": "RET_VAL error codes include 0000 for no error and 80B5 indicating the instruction was not executed within a startup OB. Error codes may be displayed as integers or hexadecimal values. Refer to GET_ERR_ID and other documentation for detailed error handling.", "generated_brief": {"functional_summary": "The INIT_RD instruction resets all retentive data of data blocks, bit memories, and SIMATIC timers and counters simultaneously when triggered.", "usage_context": "It is used within a startup organization block to clear retain data during system initialization, as it cannot be executed within a normal program cycle."}, "generated_keywords": ["initialize retain data", "reset retentive memory", "startup OB execution", "SIMATIC timers counters reset", "error monitoring RET_VAL"]}
{"instruction_name": "RUNTIME", "description": "The 'Measure program runtime' instruction is used to measure the runtime of the entire program, individual blocks or command sequences.", "parameters": {"Input": [{"name": "<Operand>", "type": "LREAL", "description": "The content is for internal purposes only."}], "Output": [{"name": "Function value", "type": "LREAL", "description": "Returns the measured runtime in seconds."}], "InOut": [{"name": "<Operand>", "type": "LREAL", "description": "The content is for internal purposes only."}]}, "how_to_use": "Call the instruction 'Measure program runtime' in OB1 to measure the runtime of the entire program. For measuring the runtime of individual blocks or command sequences, use three separate networks: the first call starts the measurement, the second executes the block/sequence, and the third call completes the measurement.", "example_code": "\"Tag_Result\" := RUNTIME(\"Tag_Memory\");\n\"Best_before_date_DB\" ();\n\"Tag_Result\" := RUNTIME(\"Tag_Memory\");", "additional_info": "The runtime of a command sequence cannot be determined exactly, as the sequence of instructions within a command sequence is changed during optimized compilation. If the internal high-frequency counter overruns, the instruction returns values <= 0.0, which can occur up to once per minute for S7-1200 CPUs with firmware version <V4.2.", "generated_brief": {"functional_summary": "The RUNTIME instruction measures the execution time of the entire program, individual blocks, or command sequences in seconds.", "usage_context": "It is used in OB1 or specific network sequences to evaluate and optimize the performance of PLC program components during runtime."}, "generated_keywords": ["measure program runtime", "execution time measurement", "PLC performance monitoring", "block runtime measurement", "command sequence timing"]}
{"instruction_name": "GATHER", "description": "\"Merge individual bits into a bit sequence\" instruction merges the bits from an ARRAY of BOOL, an anonymous STRUCT or a PLC data type exclusively with Boolean elements into a bit sequence. The bit sequence is saved in a tag of the data type BYTE, WORD, DWORD or LWORD.", "parameters": {"Input": [{"name": "IN", "type": "ARRAY[*] of BOOL, STRUCT or PLC data type (*: 8, 16, 32 or 64 elements)", "description": "ARRAY, STRUCT or PLC data type, the bits of which are merged into a bit sequence. The values must not be located in the I/O area or in the DB of a technology object."}], "Output": [{"name": "OUT", "type": "BYTE, WORD, DWORD, LWORD", "description": "Merged bit sequence, saved in a tag."}], "InOut": []}, "how_to_use": "Use the GATHER instruction by providing an ARRAY of BOOL, STRUCT, or a user-defined type with only BOOL elements as input (IN). The number of BOOL elements must exactly match the size of the output data type (BYTE = 8 bits, WORD = 16 bits, DWORD = 32 bits, LWORD = 64 bits). The merged bit sequence is output in a corresponding BYTE, WORD, DWORD, or LWORD tag (OUT). Multi-dimensional arrays are not permitted. Ensure that input values are not located in the I/O area or in the DB of a technology object. The enable output ENO signals '0' if the enable input EN is '0', or if input element count mismatches, or insufficient bits are available.", "example_code": "GATHER(IN := #SourceArray, OUT => #DestinationWord);", "additional_info": "The instruction is available on S7-1200 CPUs starting with firmware version >4.2 and on S7-1500 CPUs starting with firmware version 2.1. The bit elements must precisely match the output data type size; otherwise, the bits are not transferred and ENO returns '0'. Multi-dimensional arrays of BOOL are not supported.", "generated_brief": {"functional_summary": "The GATHER instruction merges individual Boolean elements from an array, structure, or user-defined type into a contiguous bit sequence stored in a BYTE, WORD, DWORD, or LWORD data type.", "usage_context": "It is typically used in PLC programming to compact multiple discrete Boolean signals into a single word for efficient data handling or communication."}, "generated_keywords": ["merge Boolean array to bit sequence", "compact BOOL elements into word", "convert BOOL structure to BYTE/WORD", "bit packing from BOOL array", "GATHER instruction PLC bit merge"]}
{"instruction_name": "GATHER_BLK", "description": "The 'Merge individual bits into multiple elements of an ARRAY of bit sequence' instruction merges the bits from an ARRAY of BOOL, an anonymous STRUCT or a PLC data type exclusively with Boolean elements into one or multiple elements of an ARRAY of <bit sequence>. At the COUNT_OUT parameter you specify how many elements of the destination ARRAY are going to be written.", "parameters": {"Input": [{"name": "IN", "type": "ARRAY[*] of BOOL, STRUCT, PLC data type", "description": "ARRAY of BOOL, STRUCT or PLC data type whose bits are merged (source ARRAY). The values must not be located in the I/O area or in the DB of a technology object."}, {"name": "COUNT_OUT", "type": "USINT, UINT, UDINT", "description": "Counter how many elements of the target ARRAY are to be described. The value must not be in the I/O area or in the database of a technology object."}], "Output": [{"name": "OUT", "type": "ARRAY[*] of BYTE, WORD, DWORD", "description": "ARRAY of <bit sequence> to which the bits are saved (destination ARRAY)."}], "InOut": []}, "how_to_use": "Ensure the source ARRAY has the correct structure and that the destination ARRAY has enough elements to store the merged bits. Activate the instruction by providing a high signal to the EN input.", "example_code": "GATHER_BLK(IN := #SourceArrayBool[0], COUNT_OUT := #CounterOutput, OUT => #DestinationArrayWord[2]);", "additional_info": "This instruction can be used with a CPU of the S7-1200 series as of firmware version >4.2, and for a CPU of the S7-1500 series as of firmware version 2.1.", "generated_brief": {"functional_summary": "GATHER_BLK merges individual bits from an array of BOOLs or boolean-based structures into multiple elements of an array of bit sequences like BYTE, WORD, or DWORD.", "usage_context": "This function is typically used in PLC programs when compacting or packing multiple boolean signals into fewer data words for efficient processing or communication."}, "generated_keywords": ["merge boolean array bits", "pack bits into bit sequence array", "bitwise array compaction", "array of BOOL to BYTE WORD DWORD", "PLC bit sequence merging"]}
{"instruction_name": "MCTA", "description": "The 'Motor control-timer alarm' instruction is used to accumulate the time from the point at which one of the command inputs (opening or closing) is switched on. The time is accumulated until the preset time is exceeded or the relevant feedback input indicates that the device has executed the requested operation within the specified time. If the preset time is exceeded before the feedback is received, the corresponding alarm is triggered.", "parameters": {"Input": [{"name": "O_CMD", "type": "BOOL", "description": "\"Open\" command input"}, {"name": "C_CMD", "type": "BOOL", "description": "\"Close\" command input"}, {"name": "S_CMD", "type": "BOOL", "description": "\"Stop\" command input"}, {"name": "O_FB", "type": "BOOL", "description": "Feedback input when opening"}, {"name": "C_FB", "type": "BOOL", "description": "Feedback input when closing"}], "Output": [{"name": "OO", "type": "BOOL", "description": "\"Open\" output"}, {"name": "CO", "type": "BOOL", "description": "\"Close\" output"}, {"name": "OA", "type": "BOOL", "description": "Alarm output when opening"}, {"name": "CA", "type": "BOOL", "description": "Alarm output when closing"}, {"name": "Q", "type": "BOOL", "description": "A signal state of \"0\" indicates an error condition."}], "InOut": []}, "how_to_use": "You can initialize static parameters in the data block.", "example_code": "\"MCAT_DB\"(O_CMD := \"Tag_Input_O_CMD\", C_CMD := \"Tag_Input_C_CMD\", S_CMD := \"Tag_Input_S_CMD\", O_FB := \"Tag_Input_O_FB\", C_FB := \"Tag_Input_C_FB\", OO => \"Tag_OutputOpen\", CO => \"Tag_OutputClosed\", OA => \"Tag_Output_OA\", CA => \"Tag_Output_CA\", Q => \"Tag_Output_Q\");", "additional_info": "The static parameters are not visible when calling the instruction in the program. These are saved in the instance of the instruction.", "generated_brief": {"functional_summary": "The MCTA instruction monitors the operation time of motor commands to open or close a device, triggering an alarm if the action does not complete within the preset time or if a stop command is issued.", "usage_context": "It is typically used in industrial automation to ensure timely and safe motor-driven actuation of devices like valves or doors, providing alarms when mechanical feedback is not received as expected."}, "generated_keywords": ["motor control timer", "command feedback monitoring", "operation timeout alarm", "open close motor control", "stop command handling"]}
{"instruction_name": "MUX", "description": "The \"Multiplex\" instruction copies the value of a selected input parameter and issues it. You can use the parameter K to determine the number of the input parameter whose value will be. Numbering starts at IN0 and is incremented continuously with each new input. You can declare a maximum of 32 inputs. Numerical data types and time data types are permitted at the inputs. All tags with assigned parameters must be of the same data type. The function value is invalid if errors occurred during execution of the instruction or if the input at the K parameter is located outside the available inputs and the INELSE input is not used.", "parameters": {"Input": [{"name": "K", "type": "Integers", "description": "Specifies the parameter whose content is to be transferred. If K = 0 => Parameter IN0; If K = 1 => Parameter IN1, etc."}, {"name": "IN0", "type": "Binary numbers, integers, floating-point numbers, timers, STRING, CHAR, WCHAR, TOD, DATE, DT", "description": "First input value"}, {"name": "IN1", "type": "Binary numbers, integers, floating-point numbers, timers, STRING, CHAR, WCHAR, TOD, DATE, DT", "description": "Second input value"}, {"name": "INn", "type": "Binary numbers, integers, floating-point numbers, timers, STRING, CHAR, WCHAR, TOD, DATE, DT", "description": "Optional input values"}, {"name": "INELSE", "type": "Binary numbers, integers, floating-point numbers, timers, STRING, CHAR, WCHAR, TOD, DATE, DT", "description": "Specifies the value to be copied when K <> n."}], "Output": [{"name": "Function value", "type": "Binary numbers, integers, floating-point numbers, timers, STRING, CHAR, WCHAR, TOD, DATE, DT", "description": "Result of the"}], "InOut": []}, "how_to_use": "Use the MUX instruction to select one input value from multiple inputs based on the index K. Numbering of inputs starts at IN0. You can specify an INELSE input value if K is outside the range of available inputs to avoid invalid values. Ensure all inputs have the same data type. If K is a negative integer and a valid data type tag is at the input parameters, the value of that tag is changed.", "example_code": "\"Tag_Result\" := MUX(K := \"Tag_Number\",\n                IN0 := \"Tag_1\",\n                IN1 := \"Tag_2\",\n                INELSE := \"Tag_3\");", "additional_info": "The result is invalid if execution errors occur or if K is outside valid range and no INELSE value is provided. Up to 32 inputs can be declared. Refer to valid data types and memory areas for compatibility.", "generated_brief": {"functional_summary": "The MUX instruction selects and outputs the value from one of multiple input parameters based on the integer index K, with an optional default output if K is out of range.", "usage_context": "It is used in PLC programs to dynamically choose among several inputs of the same data type, facilitating conditional data routing or selection in control logic."}, "generated_keywords": ["multiplexer", "input selection", "dynamic routing", "conditional data output", "index-based input choice"]}
{"instruction_name": "SCATTER_BLK", "description": "The instruction parses one or more elements of an ARRAY of BYTE, WORD, DWORD or LWORD into bits and saves them in an ARRAY of BOOL, an anonymous STRUCT or a PLC data type exclusively with Boolean elements. At the COUNT_IN parameter you specify how many elements of the source ARRAY are going to be parsed.", "parameters": {"Input": [{"name": "IN", "type": "ARRAY[*] of BYTE, WORD, DWORD, LWORD", "description": "ARRAY of <bit sequence> that is parsed. The values must not be located in the I/O area or in the DB of a technology object."}, {"name": "COUNT_IN", "type": "USINT, UINT, UDINT", "description": "Counter for the number of elements of the source ARRAY that are going to be parsed. The value must not be in the I/O area or in the database of a technology object."}], "Output": [{"name": "OUT", "type": "ARRAY[*] of BOOL, STRUCT, PLC data type", "description": "ARRAY, STRUCT or PLC data type in which the individual bits are stored."}], "InOut": []}, "how_to_use": "To use the SCATTER_BLK instruction, set the IN parameter with the source ARRAY and specify how many elements to parse using COUNT_IN. Ensure the OUT parameter is correctly set up to hold the parsed bits.", "example_code": "SCATTER_BLK(IN := #SourceArrayWord[2], COUNT_IN := #CounterInput, OUT => #DestinationArrayBool[0]);", "additional_info": "The instruction can be used with a CPU of the S7-1200 series as of firmware version >4.2, and for a CPU of the S7-1500 series as of firmware version 2.1.", "generated_brief": {"functional_summary": "SCATTER_BLK parses specified elements of a BYTE, WORD, DWORD, or LWORD array into individual bits and stores them in a BOOL array, STRUCT, or similar Boolean-only data type.", "usage_context": "It is typically used in PLC programs to convert grouped bit data into separate Boolean variables for easier bit-level processing and control logic."}, "generated_keywords": ["array bit parsing", "byte word dword lword conversion", "boolean array output", "bit extraction", "PLC data type parsing"]}
{"instruction_name": "SCATTER", "description": "The \"Parse the bit sequence into individual bits\" instruction parses a tag of the BYTE, WORD, DWORD or LWORD data type into individual bits and saves them in an ARRAY of BOOL, an anonymous STRUCT or a PLC data type exclusively with Boolean elements. The ARRAY, the anonymous STRUCT or the PLC data type must have exactly the number of elements that is specified by the bit sequence (BYTE = 8, WORD = 16, DWORD = 32, LWORD = 64). Use of multi-dimensional ARRAY of BOOL is not permitted. The instruction can be used with S7-1200 CPUs starting from firmware version >4.2 and S7-1500 CPUs starting from firmware version 2.1. The enable output ENO returns 0 if EN = 0 or if the output data structure does not have enough BOOL elements.", "parameters": {"Input": [{"name": "IN", "type": "BYTE, WORD, DWORD, LWORD", "description": "Bit sequence that is parsed. The values must not be located in the I/O area or in the DB of a technology object."}], "Output": [{"name": "OUT", "type": "ARRAY[*] of BOOL, STRUCT or PLC data type", "description": "ARRAY, STRUCT or PLC data type in which the individual bits are stored. Must have exactly 8, 16, 32 or 64 elements according to the bit sequence size."}], "InOut": []}, "how_to_use": "Initialize the input tag with a BYTE, WORD, DWORD or LWORD value representing the bit sequence. Initialize the output tag as an ARRAY of BOOL, anonymous STRUCT or a UDT containing exclusively BOOL elements matching the length of the bit sequence (8 for BYTE, 16 for WORD, etc.). Call SCATTER instruction with these parameters to parse the bit sequence into individual bits, which are stored in the output structure. Do not use multi-dimensional BOOL arrays for output. Ensure firmware compatibility: S7-1200 (v >4.2), S7-1500 (v >=2.1).", "example_code": "SCATTER(IN := #SourceWord, OUT => #DestinationArray);", "additional_info": "The enable output ENO returns 0 if the enable input EN is 0 or if the output structure does not have the required number of BOOL elements. The input bit sequence must not be located in the I/O area or in a DB of a technology object.", "generated_brief": {"functional_summary": "The SCATTER instruction parses a BYTE, WORD, DWORD, or LWORD bit sequence into individual Boolean elements stored in an ARRAY, STRUCT, or PLC data type with matching length.", "usage_context": "It is used when individual bits of a multi-bit value need to be accessed or manipulated separately in PLC programs, especially on compatible S7-1200 and S7-1500 CPUs."}, "generated_keywords": ["parse bit sequence", "bit to boolean array", "BYTE WORD DWORD LWORD parsing", "scatter bits to structure", "S7-1200 S7-1500 compatibility"]}
{"instruction_name": "TypeOfDB", "description": "The \"Query data type of a DB\" instruction is used to query which data type the data block has that the tag of the DB_ANY data type addresses. You can compare the data type of the DB addressed by the tag <Operand> either with the data type of another tag or directly with a data type for \"Equal\" or \"Not equal\".", "parameters": {"Input": [{"name": "<Operand>", "type": "DB_ANY", "description": "Operand to query"}], "Output": [], "InOut": []}, "how_to_use": "You can only use the \"Query data type of a DB\" instruction within an IF or CASE instruction.", "example_code": "IF TypeOfDB(#InputDBAny) = TO_SpeedAxis THEN\n\"TagOut\" := 1;\nEND_IF;", "additional_info": "The \"TagOut\" output is set if the data type of the #InputDBAny operand addressed DB is equal to the TO_SpeedAxis data type. The \"TagOut\" output is not set in certain conditions such as if the number of the data block is \"0\", the data block does not exist, or if the data block is an ARRAY DB.", "generated_brief": {"functional_summary": "The TypeOfDB instruction queries and compares the data type of a data block addressed by a DB_ANY tag to determine if it matches a specified data type.", "usage_context": "It is typically used within IF or CASE instructions to conditionally execute code based on the data of the targeted data block."}, "generated_keywords": ["query DB data type", "compare data block type", "DB_ANY operand", "conditional type check", "IF CASE usage"]}
{"instruction_name": "PEEK", "description": "The 'Read memory address' instruction is used to read a memory address from a standard memory area without specifying a data type.", "parameters": {"Input": [{"name": "AREA", "type": "BYTE", "description": "The following areas can be selected: 16#81: Input, 16#82: Output, 16#83: Bit memory, 16#84: DB, 16#1: Peripheral input (S7-1500 only)"}, {"name": "DBNUMBER", "type": "DINT, DB_ANY", "description": "Number of the data block if AREA = DB, otherwise '0'"}, {"name": "BYTEOFFSET", "type": "DINT", "description": "Address to read from. Only the 16 least significant bits are used."}, {"name": "_<data type>", "type": "-", "description": "Data type of the function value: You can specify the data type of the instruction explicitly using '_'. If you do not specify the data type explicitly, it will be determined by the utilized tags or type-coded constants. If you neither specify the data type explicitly nor specify defined tags or type-coded constants, the default data type will be used."}], "Output": [{"name": "Function value", "type": "Bit strings", "description": "Result of the instruction"}]}, "how_to_use": "To read from a specific memory area, provide the appropriate AREA, DBNUMBER, and BYTEOFFSET parameters. The function returns the value at the specified address.", "example_code": "\"Tag_Result1\" := PEEK(AREA := \"Tag_Area\", DBNUMBER := \"Tag_DBNumber\", BYTEOFFSET := \"Tag_Byte\");", "additional_info": "If you read the memory address from the input, output or bit memory areas, you must assign the DBNUMBER parameter the value '0', as the instruction is invalid otherwise.", "generated_brief": {"functional_summary": "The PEEK instruction reads data from a specified memory area and address in a PLC without requiring an explicit data type.", "usage_context": "It is typically used to access raw memory contents from inputs, outputs, bit memory, or data blocks for diagnostics or low-level data manipulation."}, "generated_keywords": ["read memory address", "access raw memory", "memory area read", "PEEK instruction", "PLC diagnostics"]}
{"instruction_name": "PEEK_BOOL", "description": "The 'Read memory bit' instruction is used to read a memory bit from a standard memory area without specifying a data type.", "parameters": {"Input": [{"name": "AREA", "type": "BYTE", "description": "The following areas can be selected: 16#81: Input, 16#82: Output, 16#83: Bit memory, 16#84: DB, 16#1: Peripheral input (S7-1500 only)"}, {"name": "DBNUMBER", "type": "DINT, DB_ANY", "description": "Number of the data block if AREA = DB, otherwise '0'"}, {"name": "BYTEOFFSET", "type": "DINT", "description": "Address to read from. Only the 16 least significant bits are used."}, {"name": "BITOFFSET", "type": "INT", "description": "Bit to be read from."}], "Output": [{"name": "Function value", "type": "BOOL", "description": "Result of the instruction."}], "InOut": []}, "how_to_use": "If you read memory bit from the input, output or bit memory areas, you must assign the DBNUMBER parameter the value '0', as the instruction is invalid otherwise.", "example_code": "\"Tag_Result\" := PEEK_BOOL(AREA := \"Tag_Area\", DBNUMBER := \"Tag_DBNumber\", BYTEOFFSET := \"Tag_Byte\", BITOFFSET := \"Tag_Bit\");", "additional_info": "The instruction reads the value of memory bit from a specified area and returns the result as a boolean value.", "generated_brief": {"functional_summary": "PEEK_BOOL reads a specific bit from a defined memory area in the PLC and returns its boolean value.", "usage_context": "It is typically used to access individual bits from inputs, outputs, bit memories, or data blocks when precise bit-level information is required without specifying a data type."}, "generated_keywords": ["read memory bit", "boolean bit access", "memory area bit read", "bit-level data read", "PEEK_BOOL instruction"]}
{"instruction_name": "RE_TRIGR", "description": "The 'Restart cycle monitoring time' instruction is used to restart the cycle monitoring time of the CPU. The cycle monitoring time then restarts with the time you have set in the CPU configuration.", "parameters": {"Input": [], "Output": [], "InOut": []}, "how_to_use": "This instruction can be called in a program cycle organization block. Ensure compatibility with the firmware version to avoid execution issues.", "example_code": "", "additional_info": "For S7-1200 series CPUs with firmware versions <= 2.2, the instruction can only be called in a priority 1 organization block. For firmware versions >= 2.2, it can be called regardless of priority.", "generated_brief": {"functional_summary": "The RE_TRIGR instruction restarts the CPU's cycle monitoring timer based on the configured cycle time.", "usage_context": "It is used within program cycle organization blocks to reset the monitoring timer, ensuring proper CPU cycle time tracking and avoiding faults."}, "generated_keywords": ["restart cycle monitoring", "CPU cycle timer reset", "program cycle block", "CPU fault prevention", "firmware compatibility"]}
{"instruction_name": "ROL", "description": "The 'Rotate left' instruction rotates the contents of the IN parameter bit-by-bit to the left and returns it as a function value. The parameter N is used to specify the number of bit places by which the specified value should be rotated. The bit positions freed by rotating are filled with the bit positions that are pushed out.", "parameters": {"Input": [{"name": "IN", "type": "Bit strings, integers", "description": "Value to be rotated"}, {"name": "N", "type": "USINT, UINT, UDINT", "description": "Number of bit positions by which the value (IN) is rotated"}], "Output": [{"name": "Function value", "type": "Bit strings, integers", "description": "Result of the instruction"}], "InOut": []}, "how_to_use": "To use the ROL instruction, specify the value to be rotated in the IN parameter and the number of bit positions to rotate in the N parameter.", "example_code": "\"Tag_Result\" := ROL(IN := \"Tag_Value\", N := \"Tag_Number\");", "additional_info": "If the value of the N parameter is '0', the value at input IN is given as a result. If the value of the N parameter is greater than the number of available bit positions, the operand value at the IN input is still rotated by the specified number of bit positions.", "generated_brief": {"functional_summary": " ROL instruction rotates the bits of an input value to the left by a specified number of positions, wrapping the shifted-out bits back into the emptied positions.", "usage_context": "It is typically used in PLC programs for bit manipulation tasks such as creating cyclic bit patterns, data encoding, or performing circular shifts in control logic."}, "generated_keywords": ["rotate bits left", "circular bit shift", "bit manipulation", "bitwise rotation", "PLC function"]}
{"instruction_name": "ROR", "description": "The \"Rotate right\" instruction rotates the content of the IN parameter bit-by-bit to the right and assigns the result to the specified operand. The parameter N is used to specify the number of bit places by which the specified value should be rotated. The bit positions freed by rotating are filled with the bit positions that are pushed out. If the value of the N parameter is \"0\", the value at input IN is given as a result. If the value at the N parameter is greater than the number of available bit positions, the operand value at the IN input is still rotated by the specified number of bit positions.", "parameters": {"Input": [{"name": "IN", "type": "Bit strings, integers", "description": "Value to be rotated"}, {"name": "N", "type": "USINT, UINT, UDINT", "description": "Number of bit positions by which the value (IN) is rotated"}], "Output": [{"name": "Function value", "type": "Bit strings, integers", "description": "Result of the instruction"}], "InOut": []}, "how_to_use": "Use the ROR instruction to rotate the bits of the input operand IN to the right by N bit positions. If N is zero, input IN is returned unchanged. The instruction works on bit strings or integer types and can rotate by a count exceeding the number of bits in IN, effectively wrapping around.", "example_code": "\"Tag_Result\" := ROR(IN := \"Tag_Value\", N := \"Tag_Number\");", "additional_info": "Valid data types include bit strings and integer types in various memory areas (I, Q, M, D, L). For detailed data types and memory areas, refer to the corresponding Siemens TIA Portal documentation.", "generated_brief": {"functional_summary": "The ROR instruction rotates the bits of the input value to the right by a specified number of positions, wrapping around the bits shifted out.", "usage_context": "It is typically used in PLC programs to manipulate bit patterns for tasks such as data encoding, cyclic bit shifts, or bitwise operations in industrial control systems."}, "generated_keywords": ["rotate bits right", "bitwise rotation", "circular bit shift", "bit pattern manipulation", "PLC bit operation"]}
{"instruction_name": "ROUND", "description": "The \"Round numerical value\" instruction is used to round the value at input IN to the nearest integer. The instruction interprets the value at input IN as a floating-point number and converts it into an integer or floating-point number. If the input value is exactly between an even and odd number, the even number is selected.", "parameters": {"Input": [{"name": "<expression>", "type": "Floating-point numbers", "description": "Input value to be rounded."}], "Output": [{"name": "Function value", "type": "Integers, floating-point numbers", "description": "Result of the rounding"}], "InOut": []}, "how_to_use": "Use the ROUND instruction by providing a floating-point input value. The instruction returns the nearest integer or floating-point number rounded according to the rule that if the input is exactly between an even and odd number, the even number is selected.", "example_code": "\"Tag_Result\" := ROUND(\"Tag_Value\");", "additional_info": "The instruction supports various memory areas such as I, Q, M, D, L, P. Refer to Siemens TIA Portal documentation for details on valid data types and memory areas.", "generated_brief": {"functional_summary": "The ROUND instruction rounds a floating-point input value to the nearest integer or floating-point number, selecting the even number if the value is exactly between two integers.", "usage_context": "This function is typically used in PLC programs to convert precise floating-point measurements into discrete integer values for control logic or display purposes."}, "generated_keywords": ["round numerical value", "floating-point rounding", "nearest integer conversion", "even number selection", "data type conversion"]}
{"instruction_name": "LIMIT", "description": "The \"Set limit value\" instruction limits the value of the parameter IN to the values of the parameters MN and MX. The value of the parameter MN may not be greater than the value of the parameter MX. If the value of the IN parameter fulfills the condition MN <= IN <= MX, it is returned as the result of the instruction. If the condition is not fulfilled and the IN input value is less than the MN low limit, the value of the MN parameter is returned as the result. If the high limit MX is exceeded, the value of the MX parameter is returned as the result. If the value at the MN input is greater than at the MX input, the result is the value specified at the IN parameter and the enable output ENO is \"0\". The instruction is only executed if the operands of all parameters are of the same data type.", "parameters": {"Input": [{"name": "MN", "type": "Integers, floating-point numbers, TIME, TOD, DATE, DTL", "description": "Low limit"}, {"name": "IN", "type": "Integers, floating-point numbers, TIME, TOD, DATE, DTL", "description": "Input value"}, {"name": "MX", "type": "Integers, floating-point numbers, TIME, TOD, DATE, DTL", "description": "High limit"}], "Output": [{"name": "Function value", "": "Integers, floating-point numbers, TIME, TOD, DATE, DTL", "description": "Result of the instruction"}], "InOut": []}, "how_to_use": "Use the LIMIT instruction to constrain a value specified minimum and maximum limits (MN and MX). Ensure the data types of MN, IN, and MX are identical. The instruction compares IN against MN and MX and returns the bounded value. If MN is greater than MX, the instruction returns IN and disables the enable output (ENO = 0). This instruction is typically used to prevent variable values from exceeding defined thresholds.", "example_code": "\"Tag_Result\" := LIMIT(MN := \"Tag_Minimum\", IN := \"Tag_Value\", MX := \"Tag_Maximum\");", "additional_info": "The data types TOD, LTOD, DATE, and LDT can only be used if the IEC test is not enabled. The instruction requires all input operands to have matching data types. Refer to relevant documentation for valid data types and applicable memory areas for S7-1200 and S7-1500.", "generated_brief": {"functional_summary": "The LIMIT instruction restricts an input value to lie within specified minimum (MN) and maximum (MX) limits, returning the bounded value or indicating error if limits are invalid.", "usage_context": "This function is used in industrial control to ensure variable values do not exceed predefined thresholds, maintaining safe and expected operation ranges."}, "generated_keywords": ["value limiting", "min max bounds", "range constraint", "input validation", "threshold enforcement"]}
{"instruction_name": "SHL", "description": "The \"Shift left\" instruction shifts the contents of the IN parameter bit-by-bit to the left and returns it as a function value. The parameter N is used to specify the number of bit positions by which the specified value should be shifted. If the value of the N parameter is \"0\", the value of the IN parameter is given as a result. If the value of the N parameter is greater than the number of bit places, the value of the IN parameter is shifted to the left by the available number of bit places. The bit positions freed by the shift are filled with zeros in the result value.", "parameters": {"Input": [{"name": "IN", "type": "Bit strings, integers", "description": "Value to be shifted"}, {"name": "N", "type": "USINT, UINT, UDINT", "description": "Number of bits by which the value (IN) is shifted"}], "Output": [{"name": "Function value", "type": "Bit strings, integers", "description": "Result of the instruction"}], "InOut": []}, "how_to_use": "Use the SHL instruction to shift the bits of the input value (IN) to the left by the number of bit positions specified in N. If N is 0, the input value is returned unchanged. If N is greater than the bit width of IN, it is shifted by the maximum available bit count, and the freed bits are filled with zeros.", "example_code": "\"Tag_Result\" := SHL(IN := \"Tag_Value\", N := \"Tag_Number\");", "additional_info": "The instruction supports operands in memory areas I, Q, M, D, and L for both S7-1200 and S7-1500. For additional info on valid data types and memory areas, refer to the corresponding Siemens documentation.", "generated_brief": {"functional_summary": "The SHL instruction shifts the bits of an input value to the left by a specified number of positions, filling freed bit positions with zeros and returning the shifted result.", "usage_context": "It is typically used in PLC programs to perform bitwise manipulations such as scaling, masking, or preparing data for communication or control operations."}, "generated_keywords": ["bit shift left", "bitwise manipulation", "integer shift", "zero fill", "PLC bit operation"]}
{"instruction_name": "SHR", "description": "The 'Shift right' instruction shifts the contents of the IN parameter bit-by-bit to the right and returns it as a function value. The parameter N is used to specify the number of bit positions by which the specified value should be shifted.", "parameters": {"Input": [{"name": "IN", "type": "Bit strings, integers", "description": "Value to be shifted"}, {"name": "N", "type": "USINT, UINT, UDINT", "description": "Number of bits by which the value (IN) is shifted"}], "Output": [{"name": "Function value", "type": "Bit strings, integers", "description": "Result of the instruction"}], "InOut": []}, "how_to_use": "To use this instruction, specify the value to be shifted in the 'IN' parameter and the number of bit positions for the shift in the 'N' parameter.", "example_code": "\"Tag_Result\" := SHR(IN := \"Tag_Value\", N := \"Tag_Number\");", "additional_info": "If the value of the N parameter is '0', the value of the IN parameter is returned unchanged. If N exceeds the number of available bit positions, the value is shifted by the available number.", "generated_brief": {"functional_summary": "The SHR instruction shifts the bits of a given value to the right by a specified number of positions and returns the resulting value.", "usage_context": "This function is typically used in PLC programming for bit manipulation tasks such as scaling, extracting, or aligning data within industrial control systems."}, "generated_keywords": ["bitwise shift right", "bit manipulation", "integer shift right", "PLC shift instruction", "data alignment"]}
{"instruction_name": "TRUNC", "description": "The 'Truncate numerical value' instruction is used to generate an integer from the input value without rounding. The instruction selects only the integer part of the input value and returns this part without decimal places as the function value.", "parameters": {"Input": [{"name": "<Expression>", "type": "Floating-point numbers", "description": "Input value"}], "Output": [{"name": "Function value", "type": "Integers, floating-point numbers", "description": "Integer component of the input value"}], "InOut": []}, "how_to": "Use the TRUNC function with the desired data type as TRUNC_<data type>() to obtain the integer part of the floating-point number.", "example_code": "\"Tag_Result1\" := TRUNC(\"Tag_Value1\");\n\"Tag_Result2\" := TRUNC(\"Tag_Value2\" + \"Tag_Value3\");\n\"Tag_Result3\" := TRUNC_SINT(\"Tag_Value4\");", "additional_info": "You can specify the data type of the instruction explicitly using '_'. If not specified, the data type will be determined by the utilized tags or type-coded constants, with the default being DINT.", "generated_brief": {"functional_summary": "The TRUNC function extracts the integer part of a floating-point input value without rounding, returning it as an integer or specified data type.", "usage_context": "This function is typically used in PLC programming when it is necessary to convert floating-point numbers to integers by removing their fractional parts for control logic or data processing."}, "generated_keywords": ["truncate floating-point", "extract integer part", "remove decimal places", "floating-point to integer conversion", "PLC numeric truncation"]}
{"instruction_name": "POKE", "description": "The \"Write memory address\" instruction is used to write a memory address to a standard memory area without specifying a data type.", "parameters": {"Input": [{"name": "AREA", "type": "BYTE", "description": "The following areas can be selected: 16#81: Input, 16#82: Output, 16#83: Bit memory, 16#84: DB, 16#2: Peripheral output (S7-1500 only)"}, {"name": "DBNUMBER", "type": "DINT, DB_ANY", "description": "Number of the data block if AREA = DB, otherwise \"0\""}, {"name": "BYTEOFFSET", "type": "DINT", "description": "Address to be written. Only the 16 least significant bits are used."}, {"name": "VALUE", "type": "Bit sequences", "description": "Value to be written"}], "Output": [], "InOut": []}, "how_to_use": "Use the POKE instruction to write a value to a specific memory address within the selected memory area. If writing to input, output, or bit memory areas, set DBNUMBER to 0. For data blocks, specify the data block number in DBNUMBER. BYTEOFFSET defines the address offset within the memory area, and VALUE is the value to write.", "example_code": "POKE(AREA := 16#84, DBNUMBER := 1, BYTEOFFSET := 2, VALUE := BYTE#7, ENO => ENO);", "additional_info": "If you write the memory address to the input, output or bit memory areas, you must assign the DBNUMBER parameter the value \"0\", as the instruction is invalid otherwise.", "generated_brief": {"functional_summary": "The POKE instruction writes a specified value directly to a given memory address within a selected memory area of a PLC without requiring data type specification.", "usage_context": "It is typically used for low-level memory manipulation in PLC programs to modify inputs, outputs, bit memory, or data block values at precise addresses."}, "generated_keywords": ["write memory address", "memory area manipulation", "POKE instruction", "data block writing", "low-level PLC memory access"]}
{"instruction_name": "POKE_BLK", "description": "The \"Write memory area\" instruction is used to write a memory to a different standard memory area without specifying a data type. It supports writing data blocks as well as input, output, and bit memory areas. The EN/ENO mechanism can be used to recognize possible access errors when the data block is not yet known during program creation.", "parameters": {"Input": [{"name": "AREA_SRC", "type": "BYTE", "description": "The source memory area to read from. The valid values are: 16#81 for Input, 16#82 for Output, 16#83 for Bit memory, and 16#84 for DB."}, {"name": "DBNUMBER_SRC", "type": "DINT, DB_ANY", "description": "Number of the data block in the source memory area if AREA_SRC = DB (16#84); otherwise, must be 0."}, {"name": "BYTEOFFSET_SRC", "type": "DINT", "description": "Address offset in the source memory area to start reading from. Only the 16 least significant bits are used."}, {"name": "AREA_DEST", "type": "BYTE", "description": "The destination memory area to write to. The valid values are: 16#81 for Input, 16#82 for Output, 16#83 for Bit memory, and 16#84 for DB."}, {"name": "DBNUMBER_DEST", "type": "DINT, DB_ANY", "description": "Number of the data block in the destination memory area if AREA_DEST = DB (16#84); otherwise, must be 0."}, {"name": "BYTEOFFSET_DEST", "type": "DINT", "description": "Address offset in the destination memory area to start writing to. Only the 16 least significant bits are used."}, {"name": "COUNT", "type": "DINT", "description": "Number of bytes to copy from source to destination memory."}], "Output": [{"name": "ENO", "type": "BOOL", "description": "Output enable; can be used to detect possible access errors if data block is unknown during code creation."}], "InOut": []}, "how_to_use": "Use POKE_BLK to copy a specified number of bytes from a source memory area to a destination memory area. When using DB areas, specify the DB number; otherwise, set DBNUMBER_SRC or DBNUMBER_DEST to 0. The BYTEOFFSET parameters specify the starting byte within the respective areas. The EN/ENO mechanism is recommended to detect invalid memory accesses.", "example_code": "POKE_BLK(AREA_SRC := 16#84, DBNUMBER_SRC := 1, BYTEOFFSET_SRC := 2, AREA_DEST := 16#84, DBNUMBER_DEST := 11, BYTEOFFSET_DEST := 22, COUNT := 3, ENO => ENO);", "additional_info": "If writing to input, output, or bit memory areas, DBNUMBER parameter must be 0 as the instruction is invalid otherwise. The data types of DBNUMBER_SRC and DBNUMBER_DEST must match (both DINT or both DB_ANY). Only the lower 16 bits of BYTEOFFSET parameters are used.", "generated_brief": {"functional_summary": "POKE_BLK copies a specified number of bytes from a source memory area to a destination memory area in a PLC without requiring a data type.", "usage_context": "It is typically used when transferring raw data blocks or bit-level data between different memory areas, with error detection via the EN/ENO mechanism during runtime."}, "generated_keywords": ["memory area copy", "byte block transfer", "raw data write", "memory write instruction", "EN/ENO error detection"]}
{"instruction_name": "POKE_BOOL", "description": "The \"Write memory bit\" instruction is used to write a memory bit to a standard memory area without specifying a data type.", "parameters": {"Input": [{"name": "AREA", "type": "BYTE", "description": "The following areas can be selected: 16#81: Input, 16#82: Output, 16#83: Bit memory, 16#84: DB, 16#2: Peripheral output (S7-1500 only)"}, {"name": "DBNUMBER", "type": "DINT, DB_ANY", "description": "Number of the data block if AREA = DB, otherwise \"0\""}, {"name": "BYTEOFFSET", "type": "DINT", "description": "Address to be written. Only the 16 least significant bits are used."}, {"name": "BITOFFSET", "type": "INT", "description": "Bit to be written"}, {"name": "VALUE", "type": "BOOL", "description": "Value to be written"}], "Output": [], "InOut": []}, "how_to_use": "Use the POKE_BOOL instruction to write a specified bit in a memory area (Input, Output, Bit memory, DB, or Peripheral output) by specifying the memory area, data block number if applicable, byte offset, bit offset, and the boolean value to write. When writing to the input, output, or bit memory areas, set DBNUMBER to 0 to avoid invalid instruction error. Consider using the EN/ENO mechanism to detect access errors when the DB is not known at compile-time.", "example_code": "POKE_BOOL(AREA := 16#84,\n         DBNUMBER := 1,\n         BYTEOFFSET := 2,\n         BITOFFSET := 4,\n         VALUE := TRUE,\n         ENO => ENO);", "additional_info": "If you write the memory bit to the input, output or bit memory areas, you must assign the DBNUMBER parameter the value \"0\", as the instruction is invalid otherwise.", "generated_brief": {"functional_summary": "POKE_BOOL writes a specified boolean value to a single bit in a designated memory area, such as input, output, bit memory, data blocks, or peripheral outputs.", "usage_context": "This instruction is typically in PLC programs when precise bit-level control or modification of memory areas is required, including writing to data blocks or hardware-specific memory regions."}, "generated_keywords": ["write memory bit", "boolean bit write", "memory area bit set", "bit-level memory access", "POKE_BOOL instruction"]}
{"instruction_name": "DECO", "description": "The instruction \"Decode\" reads the value of the parameter IN and sets the bit in the output value, whose bit position corresponds to the read value. The other bits in the output value are filled with zeroes. If the value of the IN parameter is greater than 31, a modulo 32 instruction is executed.", "parameters": {"Input": [{"name": "IN", "type": "UINT", "description": "Position of the bit in the output value which is set."}], "Output": [{"name": "Function value", "type": "Bit strings (default: DWORD, can be specified with _<Data type>)", "description": "Current output value with the bit at position IN set and other bits cleared."}], "InOut": []}, "how_to_use": "Use DECO or specify the data type explicitly with DECO_<data type>() to decode the input value and set the corresponding bit in the output bit string. If the input value exceeds the maximum bit index, it is taken modulo the bit width (e.g., modulo 32 for DWORD).", "example_code": "\"Tag_Result\" := DECO(IN := \"Tag_Value\");\n\"Tag_Result2\" := DECO_BYTE(IN := \"Tag_Value2\");", "additional_info": "If the data type is not specified explicitly, it is determined by the utilized tags or type-coded constants. If neither is specified, the default data type DWORD is used. Valid memory areas for parameters include I, Q, M, D, L, P.", "generated_brief": {"functional_summary": "The DECO instruction decodes an input UINT value by setting the bit at the position indicated by the input in the output bit string while clearing all other bits.", "usage_context": "It is typically used in PLC programming to convert a numeric index into a bitmask for controlling or monitoring specific bits within a data word."}, "generated_keywords": ["bit position decode", "set bit output", "UINT to bitmask", "bitwise output generation", "modulo bit index"]}
{"instruction_name": "ENCO", "description": "The instruction \"Encode\" reads the bit number of the lowest-value bit set in the input value and issues this as a result. The \"Encode\" instruction selects the least significant bit of the value at the IN parameter and writes this bit number to the operand at the OUT parameter. If the IN parameter has the value DW#16#00000001 or DW#16#00000000, the value \"0\" is output at the OUT output. If, in an SCL block in the block properties, the \"Set ENO automatically\" option is selected and the \"Encode\" instruction is used, the ENO delivers the signal state 0 if the parameter IN delivers the value DW#16#00000000.", "parameters": {"Input": [{"name": "IN", "type": "Bit strings", "description": "Input value"}], "Output": [{"name": "Function value", "type": "INT", "description": "Bit number of the bit in the input value that is read out."}], "InOut": []}, "how_to_use": "Use the ENCO instruction by passing a bit string operand to the IN parameter. The instruction will output the bit number of the lowest set bit in the input. If the input is zero or DW#16#00000001, the output will be 0. When using in SCL, if 'Set ENO automatically' is enabled, the ENO will be reset if the input is zero.", "example_code": "\"Tag_Result\" := ENCO(IN := \"Tag_Value\");", "additional_info": "Valid input data types are bit strings located in memory areas I, Q, M, D, L, P. Refer to 'Overview of the valid data types' and respective memory area documentation for further details.", "generated_brief": {"functional_summary": "The ENCO instruction identifies and outputs the bit number of the least significant set bit in a given bit string input.", "usage_context": "It is typically used in PLC programming to quickly determine the position of the first active bit within status or control word inputs for decision-making or indexing purposes."}, "generated_keywords": ["encode instruction", "lowest set bit", "bit position output", "bit string input", "PLC bit indexing"]}
{"instruction_name": "READ_BIG", "description": "The instruction \"Read data in little endian format\" is used to read data from a memory area and to write this to a single tag in the big endian byte sequence.", "parameters": {"Input": [{"name": "SRC_ARRAY", "type": "ARRAY of BYTE", "description": "Memory area to be read from."}], "Output": [{"name": "DEST_VARIABLE", "type": "Bit strings, integers, floating-point numbers, TOD, DATE, CHAR, WCHAR", "description": "Read value into an elementary data type."}], "InOut": [{"name": "POS", "type": "DINT", "description": "Determines the position at which the reading starts. The POS parameter is calculated zero-based."}]}, "how_to_use": "Specify the source memory area (SRC_ARRAY), the variable to store the result (DEST_VARIABLE), and the starting position for reading (POS).", "example_code": "#TagResult := READ_BIG(SRC_ARRAY := #SourceField, DEST_VARIABLE #DINTVariable, POS := #TagPos);", "additional_info": "If reading a VARIANT or BOOL type, use 'Serialize' or 'Deserialize' instructions.", "generated_brief": {"functional_summary": "READ_BIG reads data from a byte array in little endian format and writes it into a variable using a big endian byte sequence starting from a specified position.", "usage_context": "It is typically used in industrial control systems to correctly interpret and convert data stored in memory buffers for processing or communication where endian formats differ."}, "generated_keywords": ["read little endian data", "big endian conversion", "memory array read", "position based read", "data type conversion"]}
{"instruction_name": "READ_LITTLE", "description": "The instruction \"Read data in little endian format\" is used to read data from a memory area and to write this to a single tag in the little endian byte sequence. With the little endian format, the byte with the least significant bits is saved first, which means at the lowest memory address.", "parameters": {"Input": [{"name": "SRC_ARRAY", "type": "ARRAY of BYTE", "description": "Memory area to be read from"}], "Output": [{"name": "DEST_VARIABLE", "type": "Bit strings, integers, floating-point numbers, TOD, DATE, CHAR, WCHAR", "description": "Read value"}], "InOut": [{"name": "POS", "type": "DINT", "description": "Determines the position at which the reading starts. The POS parameter is calculated zero-based."}]}, "how_to_use": "Use the instruction to read data from a specified memory area (SRC_ARRAY) into a destination variable (DEST_VARIABLE) interpreting bytes in little endian format. The POS parameter sets the zero-based start position in the memory area for reading. The DEST_VARIABLE must be an elementary data type. If reading a VARIANT or BOOL data type, use Serialize/Deserialize or Slice access respectively.", "example_code": "#TagResult := READ_LITTLE(SRC_ARRAY := #SourceField,\n                     DEST_VARIABLE => #DINTVariable,\n                     POS := #TagPos);", "additional_info": "The SRC_ARRAY parameter must be an ARRAY of BYTE. The RET_VAL (function value) parameter returns INT error codes: 0000 for no error, 80B4 if SRC_ARRAY is not ARRAY of BYTE, 8382 if POS is outside the ARRAY limits, and 8383 if POS is inside but the read size exceeds the ARRAY bounds. The DEST_VARIABLE's data type determines how many bytes are read.", "generated_brief": {"functional_summary": "READ_LITTLE reads data from a byte array starting at a specified position and interprets it in little endian format into a single destination variable.", "usage_context": "It is typically used in PLC programs to extract values from memory areas where data is stored in little endian byte order, such as communication buffers or sensor data blocks."}, "generated_keywords": ["read little endian data", "memory array read", "byte array to variable", "position-based data reading", "PLC data extraction"]}
{"instruction_name": "ReadFromArrayDBL", "description": "The instruction \"Read from ARRAY data block in load memory\" is used to read the element ti which the index references from a data block of the ARRAY DB block type in the load memory and write it to the target range. An ARRAY data block is a data block that consists of exactly one ARRAY of <Data type>. The elements of the ARRAY can be of PLC data type or any other elementary data type. Counting of the ARRAY always begins with the low limit \"0\". If the ARRAY data block has been designated with the block attribute \"Only store in load memory\", it will only be stored in the load memory. The instruction is executed when a positive signal edge is detected at the REQ parameter. The BUSY parameter then has the signal state \"1\". The instruction is terminated if a negative signal edge is detected at the BUSY parameter. The DONE parameter has the signal state \"1\" for one program cycle and the read value is output at the VALUE parameter within this cycle. With all other program cycles, the value at the VALUE parameter is not changed.", "parameters": {"Input": [{"name": "REQ", "type": "BOOL", "description": "REQ = \"1\": Begin with the reading of the ARRAY DB"}, {"name": "DB", "type": "DB_ANY", "description": "ARRAY data block that is read."}, {"name": "INDEX", "type": "DINT", "description": "Element in the DB that is read. The specification can be a constant, a global tag or an indexed value."}], "Output": [{"name": "BUSY", "type": "BOOL", "description": "BUSY = \"1\": The array DB is still being read"}, {"name": "DONE", "type": "BOOL", "description": "DONE = \"1\": The instruction was executed successfully"}, {"name": "ERROR", "type": "INT", "description": "Error information: If an error occurs during execution of the instruction, an error code is output at the ERROR parameter."}], "InOut": [{"name": "VALUE", "type": "VARIANT", "description": "Pointer to the DB in the work memory that is to be read and the value of which is to be written. No local constants or tags from the TEMP section must be used."}]}, "how_to_use": "Trigger the instruction by setting the REQ input to TRUE. The instruction reads the element at the given INDEX from the specified ARRAY data block DB and outputs it at VALUE. BUSY signals ongoing read, DONE signals successful completion for one cycle, and ERROR indicates errors. Use optimized ARRAY DBs stored in load memory only.", "example_code": "\"ReadFromArrayDBL_DB\"(REQ := TagReq,\n                      DB := ArrayDB,\n                      INDEX := 2,\n                      VALUE := TargetField,\n                      BUSY => TagBusy,\n                      DONE => TagDone,\n                      ERROR => TagError);", "additional_info": "Error codes are output at ERROR parameter; for example, 80B4 indicates a data type mismatch between ARRAY elements and VALUE VARIANT; 8230-8235 errors relate to invalid or incorrect data blocks; 8382 means INDEX is outside ARRAY limits. Data blocks must have the \"Optimized\" block property and be stored in load memory. VALUE parameter cannot be a local constant or TEMP tag.", "generated_brief": {"functional_summary": "The ReadFromArrayDBL instruction reads a specified element from an optimized ARRAY data block stored in load memory and outputs its value upon a trigger signal.", "usage_context": "This function is typically used in PLC programs to access individual elements from ARRAY data blocks for processing or monitoring during runtime."}, "generated_keywords": ["read array data block", "load memory access", "indexed element read", "optimized ARRAY DB", "PLC data retrieval"]}
{"instruction_name": "ReadFromArrayDB", "description": "The instruction \"Read from ARRAY data block\" is used to read the element from a data block of the ARRAY DB block type to which the index references, and write the value of the element to the target range. An ARRAY data block is a data block that consists of exactly one ARRAY of <Data type>. The elements of the ARRAY can be of PLC data type or any other elementary data type. Counting of the ARRAY always begins with the low limit \"0.\"", "parameters": {"Input": [{"name": "DB", "type": "DB_ANY", "description": "Data block that is read"}, {"name": "INDEX", "type": "DINT", "description": "Element in the DB that is read. The specification can be a constant, a global tag or an indexed value."}], "Output": [{"name": "VALUE", "type": "VARIANT", "description": "Value that is read and output"}, {"name": "Function value (RET_VAL)", "type": "INT", "description": "Result of the instruction"}], "InOut": [{"name": "VALUE", "type": "VARIANT", "description": "The tag itself must be declared as InOut in the block interface, although VALUE is declared as Output since data flows into the tag."}]}, "how_to_use": "Use the ReadFromArrayDB instruction to access elements of an ARRAY data block by specifying the data block (DB) and the element index (INDEX). Declare the VALUE parameter as InOut in the block interface to store the read element. Check the RET_VAL output for error codes to ensure successful execution.", "example_code": "\"TagResult\" := ReadFromArrayDB(DB := \"ArrayDB\", INDEX := 2, VALUE => \"TargetField\");", "additional_info": "RET_VAL parameter provides several error codes indicating issues such as data type mismatches, out-of-range indices, or invalid data blocks. The VALUE parameter must be declared as InOut in the block interface, even though it is declared as Output in the instruction parameters. Ensure that both the ARRAY data block and the VALUE operand are in memory areas compatible with optimized access for correct operation.", "generated_brief": {"functional_summary": "The ReadFromArrayDB instruction reads a specific element from an ARRAY data block using a given index and outputs its value to a specified target.", "usage_context": "This function is typically used in PLC programs when accessing individual elements within an ARRAY data block to retrieve values dynamically during runtime."}, "generated_keywords": ["read array element", "array data block access", "index-based read", "PLC array reading", "data block element retrieval"]}
{"instruction_name": "SEL", "description": "The instruction 'Select' selects one of the parameters IN0 or IN1 depending on a switch (G parameter) and issues its content as a result. When the parameter G has the signal status '0', the value at parameter IN0 is moved. When the parameter G has the signal status '1', the value at parameter IN1 is moved and returned as a function value.", "parameters": {"Input": [{"name": "G", "type": "BOOL", "description": "Switch"}, {"name": "IN0", "type": "Binary numbers, integers, floating-point numbers, timers, strings, TOD, DATE, DT", "description": "First input value"}, {"name": "IN1", "type": "Binary numbers, integers, floating-point numbers, timers, strings, TOD, DATE, DT", "description": "Second input value"}], "Output": [{"name": "Function value", "type": "Binary numbers, integers, floating-point numbers, timers, strings, TOD, DATE, DT", "description": "Result of the instruction"}], "InOut": []}, "how_to_use": "", "example_code": "\"Tag_Result\" := SEL(G := \"Tag_Value\", IN0 := \"Tag_0\", IN1 := \"Tag_1\");", "additional_info": "The instruction is only executed if the tags of all parameters have the same data type class.", "generated_brief": {"functional_summary": "The SEL instruction outputs the value of either IN0 or IN1 based on the boolean status of the selector input G, returning IN0 if G is 0 and IN1 if G is 1.", "usage_context": "This function is typically used to conditionally select between two data inputs or states in PLC programs, facilitating decision-based data routing and control logic."}, "generated_keywords": ["conditional selection", "data routing", "boolean selector", "input switching", "value multiplexing"]}
{"instruction_name": "TONR", "description": "The instruction 'Time accumulator' is used to accumulate time values within a period set by the parameter PT. When the signal state at the IN parameter changes to '1', the time measurement is executed and the time PT is started. While the time duration PT is running, the time values that are recorded when the IN parameter has signal state '1' are accumulated. If the signal state at the 'IN' input changes to '0', the time measurement is interrupted. If the signal state at the 'IN' input changes back to '1', the time measurement is restarted. The accumulated time is output in the ET parameter and can be queried there. When the time duration PT is reached, the Q parameter has signal state '1'. The Q parameter remains set to '1', even when the signal state at the IN parameter changes to '0'. The R parameter resets the ET and Q parameters regardless of the signal state at the IN parameter.", "parameters": {"Input": [{"name": "IN", "type": "BOOL", "description": "Start input"}, {"name": "R", "type": "BOOL", "description": "Reset of the ET and Q parameters"}, {"name": "PT", "type": "TIME (for S7-1200), TIME, LTIME (for S7-1500)", "description": "Maximum duration of time recording. The value of the PT parameter must be positive."}], "Output": [{"name": "Q", "type": "BOOL", "description": "Operand that remains set when the timer PT has expired."}, {"name": "ET", "type": "TIME (for S7-1200), TIME, LTIME (for S7-1500)", "description": "Accumulated time."}], "InOut": []}, "how_to_use": "Each call of the 'Time accumulator' instruction must be assigned an IEC timer in which the instance data is stored. The R input resets the time measurement, while the IN input starts and stops it.", "example_code": "#IEC_Timer_0_Instance(IN:=#Start, R:=#Reset, PT:=_time_in_, Q=>_bool_out_, ET=>_time_out); #Reset := TRUE;", "additional_info": "Reinitializing the actual values of an IEC timer while the time measurement is running disrupts the function of the IEC timer.", "generated_brief": {"functional_summary": "The TONR instruction accumulates elapsed time while the input signal is true, sets an output flag when the preset time is reached, and retains this flag until reset.", "usage_context": "It is typically used in industrial automation to measure cumulative operation time or delays across multiple start-stop cycles within a defined time period."}, "generated_keywords": ["accumulate time", "on-delay timer", "start-stop timing", "preset time expiration", "resettable timer output"]}
{"instruction_name": "WriteToArrayDBL", "description": "The instruction 'Write to ARRAY data block in load memory' is used to write the element to which the index references to a data block of the ARRAY DB block type in load memory.", "parameters": {"Input": [{"name": "REQ", "type": "BOOL", "description": "REQ = '1': Start writing to the array DB"}, {"name": "DB", "type": "DB_ANY", "description": "ARRAY data block to which data is written"}, {"name": "INDEX", "type": "DINT", "description": "Element in the DB to which data is written. The specification can be a constant, a global tag or an indexed value."}, {"name": "VALUE", "type": "VARIANT", "description": "Pointer to the DB in the work memory that is to be read and the value of which is to be written. No local constants or tags from the TEMP section must be used."}], "Output": [{"name": "BUSY", "type": "BOOL", "description": "BUSY = '1': The array DB is still being written"}, {"name": "DONE", "type": "BOOL", "description": "DONE = '1': The instruction was executed successfully"}, {"name": "ERROR", "type": "INT", "description": "Error information: If an error occurs during execution of the instruction, an error code is output at the ERROR parameter."}], "InOut": []}, "how_to_use": "The instruction is executed when a positive signal edge is detected at the REQ parameter. If a negative signal edge is detected at the BUSY parameter, the instruction is terminated and the value at the VALUE parameter is written to the data block.", "example_code": "\"WriteToArrayDBL_DB\"(REQ := \"TagReg\", DB := \"ArrayDB\", INDEX := 2, VALUE := \"SourceField\", BUSY => \"TagBusy\", DONE => \"TagDone\", ERROR => \"TagError\");", "additional_info": "The data blocks must be created with the 'Optimized' block property.", "generated_brief": {"functional_summary": "The WriteToArrayDBL instruction writes a specified element at a given index into an optimized ARRAY data block load memory upon a trigger signal.", "usage_context": "It is typically used in PLC programs when dynamic updating of array elements within optimized data blocks is required based on control logic events."}, "generated_keywords": ["write array data block", "optimized DB memory", "indexed element write", "PLC load memory update", "triggered data writing"]}
{"instruction_name": "WriteToArrayDB", "description": "The instruction \"Write to ARRAY data block\" is used to write the element to which the index references to a data block of the ARRAY DB block type.", "parameters": {"Input": [{"name": "DB", "type": "DB_ANY", "description": "Data block to which data is written"}, {"name": "INDEX", "type": "DINT", "description": "Element in the DB to which data is written. The specification can be a constant, a global tag or an indexed value."}, {"name": "VALUE", "type": "VARIANT", "description": "Value to be written"}], "Output": [{"name": "Function value (RET_VAL)", "type": "INT", "description": "Result of the instruction"}], "InOut": []}, "how_to_use": "Initialize a timer using the WriteToArrayDB instruction to write data to a specified index in an ARRAY data block.", "example_code": "\"TagResult\" := WriteToArrayDB(DB := \"ArrayDB\", INDEX := 2, VALUE := \"SourceField\");", "additional_info": "The value of the \"SourceField\" operand is written to the 2nd element of the ARRAY DB.", "generated_brief": {"functional_summary": "The WriteToArrayDB instruction writes a specified value to a particular indexed element within an ARRAY data block in a PLC program.", "usage_context": "It is typically used when there is a need to update or initialize individual elements of an ARRAY data block dynamically during program execution."}, "generated_keywords": ["write to array data block", "array element update", "indexed write operation", "dynamic array data assignment", "PLC array data manipulation"]}
{"instruction_name": "REF", "description": "The keyword \"REF()\" is used to specify the tag to which a previously declared reference will. As parameter, specify the tag to be referenced. Before you use the keyword \"REF()\", you must first declare a reference in the block interface.", "parameters": {"Input": [{"name": "<Expression>", "type": "Bit sequences except BOOL, Integers, Floating-point numbers, Character strings, PLC data types (UDT), System data types (SDT), ARRAYs of the named data types", "description": "Tag to which the reference will point"}], "Output": [{"name": "Function value", "type": "Corresponds to the data type of the declared reference tag", "description": "Address of the referenced tag"}], "InOut": []}, "how_to_use": "Declare a reference in the block interface first with a specific data type. Use REF() with a tag parameter that exactly matches the declared reference data type and is located in an optimized memory area. Assign the reference in code by passing the tag to REF(). Do reference temporary data, global PLC tags, block parameters, constants, or write-protected tags. For arrays, limits and dimensions must be identical and Array[*] is not supported.", "example_code": "#myRefInt := REF(#a);\n#myRefType := REF(\"myDB\".myUDT);\n#myRefType := REF(\"myArrayDB_UDT\".\"THIS\"[1]);\n#myRefARRAY := REF(\"myDB\".myArray);", "additional_info": "The data type of the tag specified in REF() must exactly match the declared reference type (no conversions). The referenced tag must reside in an optimized memory area such as DB tags or FB block interfaces. References cannot point to TEMP, global tags, block parameters, constants, or write-protected tags. When referencing arrays, the array limits and dimensions must exactly match. Usage examples include referencing UDTs and arrays via .THIS when needed.", "generated_brief": {"functional_summary": "The REF() instruction assigns a declared reference variable to point to a specific tag with a matching data type in optimized memory areas within a PLC program.", "usage_context": "It is used when you need to dynamically reference and manipulate variables such as UDTs or arrays in data blocks or function block interfaces for flexible and efficient data access."}, "generated_keywords": ["reference assignment", "tag referencing", "data type matching", "optimized memory access", "UDT and array reference"]}
{"instruction_name": "FRAC", "description": "The result of the instruction \"Return fraction\" returns the decimal places of a value. Input value 1.125, for example, returns the value 0.125.", "parameters": {"Input": [{"name": "<Expression>", "type": "Floating-point numbers", "description": "Input value"}], "Output": [{"name": "Function value", "type": "Floating-point numbers", "description": "Decimal places of the input value"}], "InOut": []}, "how_to_use": "Use the instruction with the syntax FRAC_<data type>(); to change the data type explicitly. If no data type is specified, it defaults to REAL or follows the type of the utilized tags or type constants. The instruction returns the fractional part of the input floating-point number.", "example_code": "\"Tag_Result1\" := FRAC(\"Tag_Value\");\n\"Tag_Result2\" := FRAC_LREAL(\"Tag_Value\");", "additional_info": "You can specify the data type of the function value explicitly using an underscore followed by the data type. If not specified, it is determined by used tags or constants, or defaults to REAL. Valid memory areas include I, Q, M, D, L, P.", "generated_brief": {"functional_summary": "The FRAC instruction returns the fractional (decimal) part of a floating-point input value.", "usage_context": "It is typically used in industrial control systems to extract the decimal portion of measurements or calculations for further processing or analysis."}, "generated_keywords": ["fractional part extraction", "decimal part of value", "floating-point fraction", "number fractional component", "decimal precision retrieval"]}
{"instruction_name": "TypeOf", "description": "Use the \"TypeOf\" instruction to query the data type of a tag referenced by ResolvedSymbol.", "parameters": {"Input": [{"name": "ResolvedSymbol", "type": "ResolvedSymbol", "description": "The system data type representing a symbolic reference to a tag."}], "Output": [{"name": "Data type info", "type": "DataType", "description": "The data type of the tag referenced by the ResolvedSymbol."}], "InOut": []}, "how_to_use": "Provide a ResolvedSymbol structured variable referencing a tag to the TypeOf instruction; it returns the data type of that referenced tag. Ensure the ResolvedSymbol is successfully resolved before calling.", "example_code": "", "additional_info": "The ResolvedSymbol must be declared in an optimized memory area. The status element indicates if resolution was successful.", "generated_brief": {"functional_summary": "The TypeOf instruction returns the data type of a tag referenced by a resolved symbolic variable.", "usage_context": "It is used when a program needs to determine the data type of a tag dynamically during execution, ensuring type-safe operations or diagnostics."}, "generated_keywords": ["query data type", "resolved symbol reference", "dynamic type determination", "tag data inspection", "type-safe operation"]}
{"instruction_name": "MoveResolvedSymbolsToBuffer", "description": "Copies data from symbols resolved via ResolvedSymbol system data type to a buffer. Execution should be conditioned on resolved status and error checking to prevent invalid references.", "parameters": {"Input": [{"name": "ResolvedSymbolArray", "type": "ARRAY OF ResolvedSymbol", "description": "Array of symbols to be moved to the buffer."}], "Output": [{"name": "err", "type": "INT", "description": "Number of failed copy processes during the move operation."}], "InOut": []}, "how_to_use": "Before calling MoveResolvedSymbolsToBuffer, check the 'resolved' flag of each symbol. Execute this instruction only if symbols are resolved successfully. If any failed copy processes occur, disable further moves and resolve symbols again asynchronously by calling the 'ResolveSymbols' instruction.", "example_code": "", "additional_info": "Symbols overwritten by loading in RUN mode may become invalid. On errors, update the status and resolved parameters and re-invoke the resolution.", "generated_brief": {"functional_summary": "MoveResolvedSymbolsToBuffer copies data from an array of successfully resolved symbols into a buffer while tracking any copy errors that occur.", "usage_context": "This instruction is used after verifying symbols are resolved to transfer their data safely, and it triggers re-resolution if copying errors happen during runtime."}, "generated_keywords": ["copy resolved symbols", "buffer data transfer", "error checking", "symbol resolution validation", "retry on copy failure"]}
{"instruction_name": "ResolveSymbols", "description": "Asynchronously resolves symbolic references in ResolvedSymbol variables again, used when symbols become invalid due to overwrites in RUN mode or errors during MoveResolvedSymbolsToBuffer.", "parameters": {"Input": [{"": "ResolvedSymbolArray", "type": "ARRAY OF ResolvedSymbol", "description": "Array of symbolic references to be resolved."}], "Output": [], "InOut": []}, "how_to_use": "Call ResolveSymbols to refresh symbolic references that have become invalid or no longer resolve correctly, especially after loading overwrites in RUN mode.", "example_code": "", "additional_info": "Use after errors are detected during MoveResolvedSymbolsToBuffer execution to restore valid references.", "generated_brief": {"functional_summary": "ResolveSymbols asynchronously refreshes and resolves symbolic references in ResolvedSymbol arrays that have become invalid or corrupted.", "usage_context": "It is used in RUN mode after overwrites or errors occur, particularly following issues during MoveResolvedSymbolsToBuffer, to restore valid symbol references."}, "generated_keywords": ["resolve symbolic references", "refresh invalid symbols", "asynchronous symbol resolution", "RUN mode error recovery", "MoveResolvedSymbolsToBuffer correction"]}
{"instruction_name": "CONVERT", "description": "Use the \"Convert value instruction to program explicit conversions. When the instruction is inserted, the \"CONVERT\" dialog opens. You specify the source data type and the destination data type of the conversion in this dialog. The source value is read and converted to the specified destination data type.", "parameters": {"Input": [{"name": "<Source type>", "type": "Binary numbers, integers, floating-point numbers, times, date and time, character strings, BCD16, BCD32", "description": "Value to be converted."}], "Output": [{"name": "<Destination type>", "type": "Binary numbers, integers, floating-point numbers, times, date and time, character strings, BCD16, BCD32", "description": "Result of the conversion"}], "InOut": []}, "how_to_use": "Insert the CONVERT instruction. In the CONVERT dialog, specify source and destination data types for conversion. The source value is converted according to the specified data types. For S7-1500 CPUs, DWORD and LWORD can only be converted to/from REAL or LREAL. During conversion, the bit pattern of the source is transferred unchanged and right-justified to the target data type. Enable output ENO indicates success (1) or error (0).", "example_code": "\"Tag_INT\" := REAL_TO_INT(\"Tag_REAL\");", "additional_info": "BYTE and WORD bit strings cannot be selected directly in the instruction box. DWORD or LWORD operands may be specified if input and output operand lengths match; DWORD is interpreted as DINT/UDINT and LWORD as LINT/ULINT. These conversions are also valid with IEC check enabled. For CPU S7-1500, DWORD and LWORD conversions are limited to REAL and LREAL data types. If no error occurs, ENO = 1; if an error occurs, ENO = 0.", "generated_brief": {"functional_summary": "The CONVERT instruction explicitly converts a value from one specified data type to another within a PLC program.", "usage_context": "It is typically used when data types need to be changed for compatibility or processing between different parts of a PLC program or system."}, "generated_keywords": ["data type conversion", "explicit type cast", "PLC value conversion", "source to destination conversion", "numeric and string conversion"]}
{"instruction_name": "CTUD", "description": "Use the \"Count up and down\" instruction to increment or decrement the counter value at the CV parameter. When the signal state of the CU parameter changes from \"0\" to \"1\" (positive signal edge), the current counter value of the CV parameter is incremented by one. When the signal state of the CD parameter changes from \"0\" to \"1\" (positive signal edge), the counter value of the CV parameter is decremented by one. If there is a positive signal edge at the CU and CD inputs in a program cycle, the current counter value of the CV parameter remains unchanged. The counter value can be incremented until it reaches the high limit of the data type specified at the CV parameter. When the high limit is reached, the counter value is no longer incremented on a positive signal edge. The counter value is no longer decremented once the low limit of the specified data type has been reached. When the signal state of the LD parameter changes to \"1\", the counter value of the CV parameter is set the value of the PV parameter. As long as the LD parameter has signal state \"1\", the signal state of the CU and CD parameters has no effect on the instruction. The counter value is set to zero when the signal state of the R parameter changes to \"1\". As long as the R parameter has signal state \"1\", a change in the signal state of the CU, CD and LD parameters has no effect on the \"Count up and down\" instruction. You can query the status of the up counter at the QU parameter. When the current counter value is greater than or equal to the value of the PV parameter, the QU parameter is set to signal state \"1\". In all other cases, the signal state of the QU parameter is \"0\". You can also specify a constant for the PV parameter. You can query the status of the down counter at the QD parameter. If the current counter value is less than or equal to zero, the QD parameter is set to signal state \"1\". In all other cases, the signal state of the QD parameter is \"0\".", "parameters": {"Input": [{"name": "CU", "type": "BOOL", "description": "Count up input"}, {"name": "CD", "type": "BOOL", "description": "Count down input"}, {"name": "R", "type": "BOOL", "description": "Reset input"}, {"name": "LD", "type": "BOOL", "description": "Load input"}, {"name": "PV", "type": "Integers", "description": "Value at which the QU output is set / value to which the CV output is set when LD = 1."}], "Output": [{"name": "QU", "type": "BOOL", "description": "Status of the up counter"}, {"name": "QD", "type": "BOOL", "description": "Status of the down counter"}, {"name": "CV", "type": "Integers, CHAR, WCHAR, DATE", "description": "Current counter value"}], "InOut": []}, "how_to_use": "Each call of the \"Count up and down\" instruction must be assigned an IEC counter in which the instruction data is stored. An IEC counter is a structure of system data type IEC_<Counter> (shared DB) or a local tag of corresponding CTUD_<DataType>. Declare the IEC counter either as an instance data block or as a local tag. Apply the instruction by calling the CTUD() method on the IEC counter data block or local tag and mapping the inputs and outputs accordingly. Note that when a positive edge occurs at both CU and CD inputs in the same cycle, the counter value remains unchanged. Use the LD input to load the counter with the PV value, which disables counting while active. Use the R input to reset the counter to zero, which disables counting and loading while active. Only use the counter instance at one point in the program to avoid counting errors.", "example_code": "\"IEC_COUNTER_DB\".CTUD(CU := \"Tag_Start1\",\n                 CD := \"Tag_Start2\",\n                 LD := \"Tag_Load\",\n                 R := \"Tag_Reset\",\n                 PV := \"Tag_PresetValue\",\n                 QU => \"Tag_CU_Status\",\n                 QD => \"Tag_CD_Status\",\n                 CV => \"Tag_CounterValue\");", "additional_info": "The counter value respects the limits of the data type of the CV parameter and does not increment beyond the maximum or decrement below the minimum. The QU output is set when the current counter value is greater than or equal to PV, the QD output is set when the counter value is less than or equal to zero. When LD=1, the counter value is loaded with PV and counting inputs are ignored. When R=1, the counter is reset to zero and counting and load inputs are ignored. Use optimized block access and retentive settings according to whether the IEC counter is a single instance data block or a multi-instance local tag.", "generated_brief": {"functional_summary": "The CTUD instruction increments or decrements an integrated counter based on positive signal edges at count-up (CU) and count-down (CD) inputs, with reset (R), load (LD), preset (PV), and status outputs for upper and lower limits.", "usage_context": "It is typically used in PLC programs to track quantities or events that require bidirectional counting with the ability to reset, load preset values, and monitor when counts reach specified thresholds."}, "generated_keywords": ["bidirectional counter", "count up and down", "preset and reset", "edge-triggered counting", "counter limit monitoring"]}
{"instruction_name": "ABS", "description": "Use the 'Form absolute value' instruction to calculate the absolute value of an input value and to save the result in the specified operands.", "parameters": {"Input": [{"name": "<expression>", "type": "SINT, INT, DINT, floating-point numbers", "description": "Input value"}], "Output": [{"name": "Function value", "type": "SINT, INT, DINT, floating-point numbers", "description": "Absolute value of the input value"}], "InOut": []}, "how_to_use": "Initialize the instruction with an appropriate input value, and the absolute value will be returned in the same format as the input value.", "example_code": "\"Tag_Result1\" := ABS(\"Tag_Value\");\n\"Tag_Result2\" := ABS(\"Tag_Value1\"*\"Tag_Value2\");", "additional_info": "The absolute value of the input value is returned in the format of the input value as a function value.", "generated_brief": {"functional_summary": "The ABS instruction calculates and returns the absolute value of a given numerical input in the same data type format.", "usage_context": "It is typically used in PLC programs whenever the magnitude of a number is needed regardless of its sign, such as processing sensor or mathematical."}, "generated_keywords": ["absolute value", "numerical magnitude", "input value processing", "mathematical function", "data type preservation"]}
{"instruction_name": "COS", "description": "Use the 'Form cosine value' instruction to calculate the cosine of the input value. The input value must be given in radians.", "parameters": {"Input": [{"name": "<Expression>", "type": "Floating-point numbers", "description": "Input value (size of an angle in radians)"}], "Output": [{"name": "Function value", "type": "Floating-point numbers", "description": "Result of the instruction"}], "InOut": []}, "how_to_use": "To use the COS instruction, provide the input angle in radians, and it will return the cosine of that angle.", "example_code": "\"Tag_Result\" := COS(\"Tag_Value\");", "additional_info": "Ensure that the input is in radians for accurate calculations.", "generated_brief": {"functional_summary": "The COS instruction calculates the cosine of a given input angle specified in radians.", "usage_context": "This function is typically used in PLC programs requiring trigonometric calculations for tasks such as motion control, signal processing, or coordinate transformations."}, "generated_keywords": ["cosine calculation", "trigonometric function", "input in radians", "angle cosine", "floating-point computation"]}
{"instruction_name": "SIN", "description": "Use the \"Form sine value\" instruction to calculate the sine of the input value. The input value must be given in radians.", "parameters": {"Input": [{"name": "<Expression>", "type": "Floating-point numbers", "description": "Input value (size of an angle in radians) stored in memory areas I, Q, M, D, L, P"}], "Output": [{"name": "Function value", "type": "Floating-point numbers", "description": "Result of the instruction stored in memory areas I, Q, M, D, L, P"}], "InOut": []}, "how_to_use": "Assign the input angle in radians to the input operand and use the SIN function to compute the sine value, which is returned as the function output.", "example_code": "\"Tag_Result\" := SIN(\"Tag_Value\");", "additional_info": "The input and output operands must be floating-point numbers and can be stored in various memory areas including I, Q, M, D, L, and P.", "generated_brief": {"functional_summary": "The SIN instruction calculates the sine of a given input angle expressed in radians and returns the result as a floating-point number.", "usage_context": "This function is typically used in PLC programs for applications involving trigonometric calculations such as motion control, signal processing, or mathematical modeling."}, "generated_keywords": ["sine calculation", "trigonometric function", "input in radians", "floating-point operation", "angle sine value"]}
{"instruction_name": "SQRT", "description": "Use the 'Form square root' instruction to calculate the square root of the input value and save the result in the specified operand. The instruction has a positive result if the input value is greater than zero. If input values are less than zero, the instruction returns an invalid floating-point number. If the input value is '0', the result is also '0'.", "parameters": {"Input": [{"name": "<Expression>", "type": "Floating-point numbers", "description": "Input value"}], "Output": [{"name": "Function value", "type": "Floating-point numbers", "description": "Square root of the input value"}], "InOut": []}, "how_to_use": "", "example_code": "\"Tag_Result1\" := SQRT(\"Tag_Value\");\n\"Tag_Result2\" := SQRT((SQR(\"Tag_Value1\")) + \"Tag_Value2\");", "additional_info": "", "generated_brief": {"functional_summary": "The SQRT instruction calculates the square root of a given floating-point input value and outputs the result, returning zero for an input of zero and an invalid number for negative inputs.", "usage_context": "This function is typically used in industrial control systems to compute square roots in mathematical operations involving measurements or process variables."}, "generated_keywords": ["square root calculation", "floating-point math", "input validation", "mathematical function", "process variable computation"]}
{"instruction_name": "SQR", "description": "Use the \"Form square\" instruction to square the input value and save the result in the specified operand.", "parameters": {"Input": [{"name": "<Expression>", "type": "Floating-point numbers", "description": "Input value"}], "Output": [{"name": "Function value", "type": "Floating-point numbers", "description": "Square of the input value"}], "InOut": []}, "how_to_use": "Use the SQR instruction to calculate the square of a floating-point input expression. The result is returned as the function value which can be assigned to a variable or operand. It works with operands located in memory areas I, Q, M, D, L, P.", "example_code": "\"Tag_Result1\" := SQR(\"Tag_Value\");\n\"Tag_Result2\" := SQR((SQR(\"Tag_Value1\"))*\"Tag_Value2\");", "additional_info": "The instruction supports floating-point inputs and outputs in memory areas I, Q, M, D, L, and P. Refer to valid data types and memory areas for details.", "generated_brief": {"functional_summary": "The SQR instruction calculates the square of a floating-point input value and stores the result in a specified operand.", "usage_context": "It is typically used in industrial control systems for mathematical computations requiring the squaring of floating-point numbers within various memory areas."}, "generated_keywords": ["square calculation", "floating-point arithmetic", "mathematical computation", "memory operand processing", "industrial control systems"]}
{"instruction_name": "TAN", "description": "Use the \"Form tangent value\" instruction to calculate the sine of the input value. The input value must be given in radians.", "parameters": {"Input": [{"name": "<Expression>", "type": "Floating-point numbers", "description": "Input value (size of an angle in radians)"}], "Output": [{"name": "Function value", "type": "Floating-point numbers", "description": "Result of the instruction"}], "InOut": []}, "how_to_use": "Provide the input angle in radians as a floating-point number to the TAN instruction. The instruction returns the tangent of this angle as a floating-point number. Ensure that the input value is within the valid range for tangent calculation to avoid exceptions or unexpected results.", "example_code": "\"Tag_Result\" := TAN(\"Tag_Value\");", "additional_info": "Input and output operands can reside in memory areas I, Q, M, D, L, P. For more information on valid data types and memory areas, refer to the corresponding documentation.", "generated_brief": {"functional_summary": "The TAN instruction calculates the tangent of an input angle provided in radians and returns the result as a floating-point number.", "usage_context": "This function is typically used in PLC programs requiring trigonometric calculations for control or measurement purposes involving angular data."}, "generated_keywords": ["tangent calculation", "trigonometric function", "angle in radians", "floating-point input", "PLC math instruction"]}
{"instruction_name": "CEIL", "description": "Use the \"Generate next higher integer from floating-point number\" instruction to round the value to the nearest integer. The instruction interprets the input value as floating-point number and converts it to the next higher integer. The function value can be greater than or equal to the input value.", "parameters": {"Input": [{"name": "<Expression>", "type": "Floating-point numbers", "description": "Input value"}], "Output": [{"name": "Function value", "type": "Integers, floating-point numbers", "description": "Input value rounded up"}], "InOut": []}, "how_to_use": "Use CEIL_<data type>() syntax to change the data type of the instruction explicitly. If the data type is not specified explicitly, it will be determined by the utilized tags or type-coded constants. If neither is specified, the default data type DINT will be used.", "example_code": "\"Tag_Result1\" := CEIL(\"Tag_Value\");\n\"Tag_Result2\" := CEIL_REAL(\"Tag_Value\");", "additional_info": "You can specify the data type of the function value explicitly using \"_\". Memory areas applicable are I, Q, M, D, L, P for input and I, Q, M, D, L for function value.", "generated_brief": {"functional_summary": "The CEIL instruction rounds a floating-point input value up to the nearest higher integer value.", "usage_context": "It is typically used in industrial control systems when an integer representation of a measurement or calculation is needed without losing magnitude due to rounding down."}, "generated_keywords": ["round up", "floating-point to integer", "next higher integer", "CEIL function", "data type conversion"]}
{"instruction_name": "FLOOR", "description": "Use the \"Generate next lower integer from floating-point number\" instruction to round the value of a floating point number to the next lower integer. The instruction interprets the input value as floating-point number and converts it to the next lower integer. The function value can be equal or less than the input value.", "parameters": {"Input": [{"name": "<Expression>", "type": "Floating-point numbers", "description": "Input value"}], "Output": [{"name": "Function value", "type": "Integers, floating-point numbers", "description": "Input value rounded"}], "InOut": []}, "how_to_use": "Use the syntax FLOOR_<data type>(); to specify the data type of the instruction explicitly. If not specified, the data type is determined by the utilized tags or type-coded constants or defaults to DINT.", "example_code": "\"Tag_Result1\" := FLOOR(\"Tag_Value\");\n\"Tag_Result2\" := FLOOR_REAL(\"Tag_Value\");", "additional_info": "The data type of the function value can be specified explicitly or inferred. Input can be from various memory areas including I, Q, M, D, L, P.", "generated_brief": {"functional_summary": "The FLOOR instruction rounds a floating-point number down to the nearest lower integer value.", "usage_context": "It is typically used in industrial control systems when precise integer values are needed from floating-point measurements or calculations."}, "generated_keywords": ["floor rounding", "floating-point to integer", "round down", "numeric conversion", "data type specification"]}
{"instruction_name": "MoveFromResolvedSymbol", "description": "Use the \"Read value from resolved symbol\" instruction to read the value of a tag that is referenced by a resolved symbol and write it to a target tag. The \"SRC\" parameter has the data type ResolvedSymbol. It points to a tag in the PLC program that is read. The tag must have been resolved before with the \"ResolveSymbols\" instruction. The \"DST\" parameter has the data type VARIANT. It points to a tag that is written. Source and target tag must have the same data type.", "parameters": {"Input": [{"name": "SRC", "type": "ResolvedSymbol", "description": "Source tag that is referenced by the resolved symbol."}], "Output": [{"name": "DST", "type": "Variant", "description": "Target tag."}, {"name": "RET_VAL", "type": "INT", "description": "Error information."}], "InOut": []}, "_to_use": "Use this instruction to read the value of a resolved symbol (SRC) and write it to a target (DST). Ensure that the source tag has been resolved beforehand using the \"ResolveSymbols\" instruction. The source and target tags must have the same data type. Monitor the RET_VAL output parameter for error codes indicating issues like invalid references, non-existing data blocks, or data type mismatches. If references become invalid after a load in RUN mode, resolve symbols again using \"ResolveSymbols\".", "example_code": "#Tag_RetVal := MoveFromResolvedSymbol(SRC := \"MySrcDB\".Input_ResolvedSymbol,\n                      DST => \"MyTargetDB\".Output_Variant);", "additional_info": "The references in the ResolvedSymbol can become invalid if tags they point to are overwritten by loading in RUN mode. Error codes returned in RET_VAL parameter include: 0000 (No error), 8024 (reference points to a non-existent tag), 8031 (reference points to a non-existent data block), and 80B4 (data types of source and target tag do not match). Use \"TypeOf\" instruction to query the data type of a tag referenced by ResolvedSymbol before writing.", "generated_brief": {"functional_summary": "The MoveFromResolvedSymbol instruction reads the value of a previously resolved symbol tag and writes it to a target tag of the same data type while providing error feedback.", "usage_context": "This function is used in PLC programs to dynamically access and transfer data from tags resolved at runtime, especially after symbol resolution with ResolveSymbols, ensuring data integrity in applications where tag references can change."}, "generated_keywords": ["read resolved symbol", "write to target tag", "symbol resolution", "data type validation", "error handling"]}
{"instruction_name": "SCALE", "description": "Use the \"Scale\" instruction to convert the integer at the IN parameter into a floating-point number that can be scaled in physical units between a low limit value and a high limit value. You can use the LO_LIM and HI_LIM parameters to specify the low limit and high limit of the value range to which the input value is scaled. The result of the instruction is output at the OUT parameter. The instruction works with the equation: OUT = [((FLOAT (IN) – K1)/(K2–K1)) * (HI_LIM–LO_LIM)] + LO_LIM. The values of constants K1 and K2 depend on the signal state on the BIPOLAR parameter: if BIPOLAR = 1, IN is bipolar in the range -27648 to 27648 with K1 = -27648.0 and K2 = +27648.0; if BIPOLAR = 0, IN is unipolar in the range 0 to 27648 with K1 = 0.0 and K2 = +27648.0. Values outside the range K1 to K2 result in the output set to LO_LIM or HI_LIM with an error. If LO_LIM is greater than HI_LIM, scaling is inversely proportionate.", "parameters": {"Input": [{"name": "IN", "type": "INT", "description": "Input value to be scaled."}, {"name": "HI_LIM", "type": "REAL", "description": "High limit"}, {"name": "LO_LIM", "type": "REAL", "description": "Low limit"}, {"name": "BIPOLAR", "type": "BOOL", "description": "Indicates whether the value at the IN parameter is bipolar or unipolar. 1: Bipolar, 0: Unipolar."}], "Output": [{"name": "OUT", "type": "REAL", "description": "Result of the instruction."}, {"name": "RET_VAL", "type": "WORD", "description": "Error information as function return value."}], "InOut": []}, "how_to_use": "Provide an integer input value IN which will be scaled linearly between LO_LIM and HI_LIM. Set BIPOLAR to TRUE if input is bipolar (-27648 to 27648) or FALSE if unipolar (0 to 27648). The output REAL value will be the scaled result. Monitor RET_VAL for error codes indicating out-of-range input values.", "example_code": "\"Tag_ErrorCode\" := SCALE(IN := \"Tag_InputValue\",\n                         HI_LIM := \"Tag_HighLimit\",\n                         LO_LIM := \"Tag_LowLimit\",\n                         BIPOLAR := \"Tag_Bipolar\",\n                         OUT => \"Tag_Result\");", "additional_info": "RET_VAL returns 0000 if no error occurs. Error code 0008 indicates IN is outside the valid range for the selected BIPOLAR mode (greater than 27648 or less than 0 for unipolar; less than -27648 for bipolar). For error details, use GET_ERR_ID. The instruction clamps results at LO_LIM or HI_LIM if input is out of bounds, generating error codes.", "generated_brief": {"functional_summary": "The SCALE instruction converts an integer input into a scaled floating-point value within specified physical limits, supporting both bipolar and unipolar input ranges.", "usage_context": "It is typically used in PLC programs to translate raw sensor or signal integer data into meaningful engineering units for monitoring and control purposes."}, "generated_keywords": ["integer to float scaling", "bipolar and unipolar input", "linear scaling between limits", "physical unit conversion", "error handling out of range"]}
{"instruction_name": "SCALE_X", "description": "Use the 'Scale' instruction to scale a floating-point number by mapping it to a specific value range. You specify the value range with the MIN and MAX parameters. The result of the scaling is an integer.", "parameters": {"Input": [{"name": "EN", "type": "BOOL", "description": "Enable input"}, {"name": "MIN", "type": "Integers, floating-point numbers", "description": "Low limit of the value range"}, {"name": "VALUE", "type": "Floating-point numbers", "description": "Value to be scaled. If you enter a constant, you must declare it."}, {"": "MAX", "type": "Integers, floating-point numbers", "description": "High limit of the value range"}], "Output": [{"name": "ENO", "type": "BOOL", "description": "Enable output"}, {"name": "Function value", "type": "Integers, floating-point numbers", "description": "Result of scaling"}], "InOut": []}, "how_to_use": "", "example_code": "\"Tag_Result1\" := SCALE_X(MIN := \"Tag_Value1\", VALUE := \"Tag_Real\", MAX := \"Tag_Value2\");\n\"Tag_Result2\" := SCALE_X_REAL(MIN := \"Tag_Value1\", VALUE := \"Tag_Real\", MAX := \"Tag_Value2\");", "additional_info": "Enable output ENO returns the signal state '0' if one of the specified conditions applies.", "generated_brief": {"functional_summary": "The SCALE_X instruction scales a floating-point input value to an integer within a specified minimum and maximum range.", "usage_context": "It is typically used in PLC programs to convert analog input values into scaled integer outputs for easier processing or display."}, "generated_keywords": ["scale floating-point to integer", "value range mapping", "analog input scaling", "MIN MAX parameters", "integer output"]}
{"instruction_name": "MoveToResolvedSymbol", "description": "Use the \"Write value into resolved symbol\" instruction to read the value of a tag and write it to a target tag that is referenced by a resolved symbol.", "parameters": {"Input": [{"name": "SRC", "type": "Variant", "description": "Source tag"}, {"name": "DST", "type": "ResolvedSymbol", "description": "Target tag that is referenced by the resolved symbol."}], "Output": [{"name": "Function value (RET_VAL)", "type": "INT", "": "Error information"}], "InOut": []}, "how_to_use": "Source and target tag must have the same data type. Before you execute this instruction, you can use the instruction \"TypeOf\" to query the data type of the tag that is referenced by ResSymbol.", "example_code": "#Tag_RetVal := MoveToResolvedSymbol(SRC := \"MySrcDB\".Input_Variant, DST => \"MyTargetDB\".Output_ResolvedSymbol);", "additional_info": "The references in the SDT \"ResolvedSymbol\" can become invalid when the referenced tags are overwritten by loading in \"RUN\". Resolve the symbols again with the instruction \"ResolveSymbols\" if encounter errors.", "generated_brief": {"functional_summary": "MoveToResolvedSymbol reads the value from a source tag and writes it to a target tag identified by a resolved symbol with matching data types.", "usage_context": "It is typically used in PLC programs to dynamically update tags referenced by resolved symbols, especially after symbol references may have become invalid during runtime."}, "generated_keywords": ["write to resolved symbol", "tag value transfer", "dynamic tag update", "data type matching", "symbol resolution"]}
{"instruction_name": "GOTO", "description": "Use the instruction \"Jump\" to resume the execution of a program at a given point marked with a jump label. The jump labels and the instruction \"Jump\" must be in the same block. The name of a jump label can only be once within a block. Each jump label can be the target of several jump instructions. A jump from the \"outside\" into a program loop is not permitted, but a jump from a loop to the \"outside\" is possible. Adhere to the grammatical rules for jump labels: Letters (a to z, A to Z), a combination of letters and numbers with letters first then numbers (a-z, A-Z, 0-9). Special characters or reversed order (numbers then letters) are not allowed.", "parameters": {"Input": [{"name": "<jump label>", "type": "-", "description": "Jump label to be jumped to"}], "Output": [], "InOut": []}, "how_to_use": "Declare the instruction as GOTO <jump label>; Place the jump label in the same block followed by the instructions to execute after the jump. Ensure jump labels follow the naming conventions and are unique within the block. Avoid jumping into loops from outside but jumping from loops to outside is allowed.", "example_code": "CASE \"Tag_Value\" OF\n  1 : GOTO MyLABEL1;\n  2 : GOTO MyLABEL2;\n  3 : GOTO MyLABEL3;\n  ELSE GOTO MyLABEL4;\nEND_CASE;\nMyLABEL1: \"Tag_1\" := 1;\nMyLABEL2: \"Tag_2\" := 1;\nMyLABEL3: \"Tag_3\" := 1;\nMyLABEL4: \"Tag_4\" := 1;", "additional_info": "", "generated_brief": {"functional_summary": "The GOTO instruction causes the program execution to jump to a specified label within the same block, enabling conditional or direct transfer of control flow.", "usage_context": "It is typically used to simplify program flow by directing execution to different code sections based on conditions, especially within CASE statements or conditional branches in PLC control logic."}, "generated_keywords": ["program flow control", "jump to label", "conditional branching", "control transfer", "GOTO instruction"]}
{"instruction_name": "AssignmentAttempt", "description": "With the \"AssignmentAttempt\" instruction, you attempt an assignment to a reference tag. The following assignment attempts are possible: Assignment attempt of a VARIANT to a reference; Assignment attempt of a DB_ANY to the reference of a technology object. In SCL, you can also assign NULL in the assignment attempt to specifically set the reference to NULL. The data type of a reference tag is determined at the time of declaration. However, the data type of a VARIANT tag is determined during runtime. An implicit data type conversion is not permitted with reference tags. To assign the two data types to each other therefore, use the assignment attempt. With the assignment attempt, a check is made at runtime to find out whether the assigned tag is of the correct data type. If this is the case, the instruction is executed. If the instruction is executed successfully, there is a valid reference in the target tag, otherwise a NULL. After the assignment attempt, you can check if the attempt was successful and, depending on the result, continue processing the program. In LAD and FBD, you can use the enable output \"ENO\" for the check. \"ENO\" returns the signal state \"1\" if the assignment attempt was successful. Only then are the subsequent instructions executed in the network. In STL and SCL, you can use the instructions \"IS_NULL\" or \"NOT_NULL\", for example, to check the success of an assignment attempt.", "parameters": {"Input": [{"name": "SRC", "type": "VARIANT, DB_ANY, NULL", "description": "Pointer to the source tag whose address will be read out or NULL"}], "Output": [{"name": "DST", "type": "reference to Bit sequences except BOOL, Integers, Floating-point numbers, Character strings, PLC data types (UDT), System data types (SDT), ARRAYs of the named data types (if SRC = VARIANT); reference to Technology object (if SRC = DB_ANY)", "description": "Reference to which the address of the source tag will be transferred"}], "InOut": []}, "how_to_use": "Use AssignmentAttempt to safely assign the address of a VARIANT or DB_ANY source to a reference output. In LAD/FBD, verify success using the ENO output (1 means success). In STL/SCL, use IS_NULL or NOT_NULL functions to check if the assignment succeeded. In SCL, you can assign NULL to explicitly invalidate a reference. Ensure VARIANT tags point to valid optimized memory areas and match array limits exactly. For technology objects assignable by DB_ANY, ensure types match or derive correctly.", "example_code": "VAR\n    myVariant : VARIANT;\n    myReference : REF_TO INT;\nEND_VAR\n\n// Attempt assignment\nmyReference ?= myVariant;\n\n// Check success\nIF NOT_NULL(myReference) THEN\n    myReference^ := 10;\nEND_IF;", "additional_info": "VARIANT must not point to temporary memory. Arrays must exactly match declared reference ranges. Assignment attempts of VARIANT to technology object references are not possible. DB_ANY references to technology objects must be in optimized memory. Derived types can be assigned to base types but not vice versa. Assignment attempts cannot be used in chained assignments in SCL.", "generated_brief": {"functional_summary": "The AssignmentAttempt instruction tries to safely assign the address of a VARIANT or DB_ANY source to a strongly typed reference tag at runtime, validating the data type compatibility and setting the reference to NULL if unsuccessful.", "usage_context": "It is typically used in PLC programs to dynamically link references to variable data or technology objects while ensuring safe type assignments and enabling conditional program flow based on assignment success."}, "generated_keywords": ["runtime safe assignment", "reference tag assignment", "VARIANT and DB_ANY assignment", "assignment success check", "type-compatible reference linking"]}
{"instruction_name": "F_TRIG", "description": "With the \"Detect negative signal edge\" instruction, you can detect a state change from \"1\" to \"0\" at the CLK input. The instruction compares the current value at the CLK input with the state of the previous query (edge memory bit) that is saved in the specified instance. If the instruction detects a state change at the CLK input from \"1\" to \"0\", a negative signal edge is generated at the Q output, i.e., the output has the value TRUE or \"1\" for exactly one cycle. In all other cases, the signal state at the output of the instruction is \"0\".", "parameters": {"Input": [{"name": "CLK", "type": "BOOL", "description": "Incoming signal, the edge of which is to be queried"}], "Output": [{"name": "Q", "type": "BOOL", "description": "Result of edge evaluation"}], "InOut": []}, "how_to_use": "The instruction requires an instance to store the edge memory bit, which must be initialized to TRUE to ensure correct negative edge detection behavior after CPU startup according to the IEC61131 standard. Use the input CLK to provide the signal to be monitored. The output Q goes TRUE for one cycle upon detection of a falling edge (1 to 0) at CLK.", "example_code": "\"F_TRIG_DB\"(CLK := \"TagIn\", Q => \"TagOut\");", "additional_info": "After CPU startup, to comply with the IEC61131 standard where output Q is TRUE if input CLK is FALSE, the instance representing the edge memory bit (Stat_Bit) must be initialized with TRUE.", "generated_brief": {"functional_summary": "The F_TRIG instruction detects a falling edge (transition from TRUE to FALSE) on its input signal and outputs a TRUE value for one cycle when this negative edge occurs.", "usage_context": "It is typically used in PLC programs to trigger events or actions precisely at the moment a signal changes from high to low, such as monitoring sensor state changes or initiating processes on signal fall."}, "generated_keywords": ["falling edge detection", "negative edge trigger", "signal transition monitoring", "one cycle pulse output", "PLC event triggering"]}
{"instruction_name": "R_TRIG", "description": "With the \"Detect positive signal edge\" instruction, you can detect a state change from \"0\" to \"1\" at the CLK input. The instruction compares the current value at the CLK input with the state of the previous query (edge memory bit) that is saved in the specified instance. If the instruction detects a state change at the CLK input from \"0\" to \"1\", a positive signal edge is generated at the Q output, i.e., the output has the value TRUE or \"1\" for exactly one cycle. In all other cases, the signal state at the output of the instruction is \"0\".", "parameters": {"Input": [{"name": "CLK", "type": "BOOL", "description": "Incoming signal, the edge of which is to be queried"}], "Output": [{"name": "Q", "type": "BOOL", "description": "Result of edge evaluation"}], "InOut": []}, "how_to_use": "Use this instruction to detect a positive edge (0 to 1) on a boolean input signal. Connect the signal to the CLK input, and the output Q will be set to TRUE for one PLC cycle upon detecting a positive edge. The previous state is stored internally in the instance of the instruction and must be retained across scans.", "example_code": "\"R_TRIG_DB\"(CLK := \"TagIn\",\n            Q => \"TagOut\");", "additional_info": "The previous state of the input signal must be stored in the instance data (e.g., \"R_TRIG_DB\") for the edge detection to work. Output Q is TRUE for exactly one cycle when a rising edge is detected. The parameters can be located in various memory areas such as I, Q, M, D, L.", "generated_brief": {"functional_summary": "The R_TRIG instruction detects a rising edge (transition from 0 to 1) on a boolean input signal and outputs a TRUE signal for exactly one PLC cycle when this occurs.", "usage_context": "It is typically used in automation programs to trigger actions or events precisely at the moment an input signal changes from low to high."}, "generated_keywords": ["rising edge detection", "positive edge trigger", "boolean input signal", "single cycle output", "edge detection instance"]}
{"instruction_name": "MoveResolvedSymbolsFromBuffer", "description": "With the 'Read values from buffer and write them into resolved symbols' instruction, you read values from a memory area (Array of BYTE) and write them into the values of several resolved symbols. In this way, you can process a memory area that you have received from a communication instruction, such as TRCV.", "parameters": {"Input": [{"name": "firstIndex", "type": "DINT", "description": "Index of the first resolved symbol in the target buffer that is to be written."}, {"name": "lastIndex", "type": "DINT", "description": "Index of the last resolved symbol in the target buffer that is to be written."}, {"name": "mode", "type": "DWORD", "description": "Memory format (2#0 = Big-Endian, 2#1 = Little-Endian)."}, {"name": "src", "type": "Array of BYTE", "description": "Source buffer from which the values are read."}, {"name": "srcOffsets", "type": "Array of DINT", "description": "Offsets of the values in the source buffer."}], "Output": [], "InOut": [{"name": "dst", "type": "Array of ResolvedSymbol", "description": "Target buffer that contains the references to the resolved symbols."}, {"name": "status", "type": "Array of INT", "description": "Contains a copy status for each value to be written."}]}, "how_to_use": "This instruction allows you to copy values from a source buffer into specified resolved symbols based on provided offsets. Ensure that the arrays for srcOffsets and dst have the same limits.", "example_code": "#Tag_RetVal := MoveResolvedSymbolsFromBuffer(firstIndex := 2,\n                                 lastIndex := 7,\n                                 mode := 2#0,\n                                 src := 'MySrcDB'.Input_Buffer,\n                                 srcOffsets := #Input_Offset,\n                                 dst := 'MyTargetDB'.InOut_ResolvedSymbols,\n                                 status := #InOut_Status);", "additional_info": "The instruction does not check for overlapping offsets, which can lead to random values being read if not managed correctly.", "generated_brief": {"functional_summary": "This instruction reads values from a specified memory buffer and writes them into a range of resolved symbols using given offsets and memory format settings.", "usage_context": "It is typically used to process data received from communication instructions by transferring raw byte arrays into meaningful PLC variables for further automation tasks."}, "generated_keywords": ["read values from buffer", "write to resolved symbols", "data transfer from byte array", "memory format handling", "process communication data"]}
{"instruction_name": "MoveResolvedSymbolsToBuffer", "description": "With the \"Read values from resolved symbols and write them into buffer\" instruction, you read values from several resolved symbols and write them into a memory area (Array of BYTE). In this way, you can prepare values of resolved symbols for further use, such as sending using communication instructions, e.g. TSEND.", "parameters": {"Input": [{"name": "firstIndex", "type": "DINT", "description": "Index of the first resolved symbol to be copied."}, {"name": "lastIndex", "type": "DINT", "description": "Index of the last resolved symbol to be copied."}, {"name": "src", "type": "Array of ResolvedSymbol", "description": "List of resolved symbols"}, {"name": "dstOffsets", "type": "Array of DINT", "description": "Contains a bit offset for each element in the destination buffer"}, {"name": "mode", "type": "DWORD", "description": "Memory format:\n2#0 = Big-Endian\n2#1 = Little-Endian"}], "Output": [], "InOut": [{"name": "dst", "type": "Array of BYTE", "description": "Target buffer to which the values of the resolved symbols are copied"}, {"name": "status", "type": "Array of INT", "description": "Contains a copy status for each resolved symbol"}]}, "how_to_use": "Specify the source resolved symbols array and the destination buffer matching array limits. Use firstIndex and lastIndex to select the range of symbols to copy. Use dstOffsets to define bit offsets for each corresponding symbol value in the destination buffer and set the memory format via mode. After execution, check the status array for copy result per symbol and RET_VAL for overall error information. If status indicates invalid references, resolve symbols again with the instruction \"ResolveSymbols\".", "example_code": "#Tag_RetVal := MoveResolvedSymbolsToBuffer(firstIndex := 2,\n                                lastIndex := 7, \n                                src := \"MySrcDB\".Input_ResolvedSymbols,\n                                dstOffsets := #Input_Offset,\n                                mode := 2#0,\n                                dst := \"MyTargetDB\".InOut_Buffer,\n                                status := #InOut_Status);", "additional_info": "The and dstOffsets arrays must have the same limits. The instruction does not verify overlapping offsets; overlapping causes indeterminate content in dst without error. Values can be stored in Big-Endian or Little-Endian format. For BOOL data types, values can be stored at bit positions within a byte; for other types, offsets must start at bit positions divisible by 8. Status values indicate specific error codes for invalid references, unsuitable data types, or memory issues. RET_VAL provides overall call error codes. ResolvedSymbol references may become invalid after loading during RUN and require re-resolution.", "generated_brief": {"functional_summary": "The MoveResolvedSymbolsToBuffer instruction reads values from a range of resolved symbols and writes them into a specified byte buffer with configurable bit offsets and memory format.", "usage_context": "It is typically used to prepare symbol data for communication tasks, such as transmitting the values via network protocols using communication instructions like TSEND."}, "generated_keywords": ["read resolved symbols", "write to byte buffer", "symbol data serialization", "memory format conversion", "data preparation for communication"]}
{"instruction_name": "ResolveSymbols", "description": "With the \"Resolve several symbols\" instruction, you resolve multiple symbolic tag names. As a result, you receive references to the tags. References are typed pointers that give you read or write access to the tags.", "parameters": {"Input": [{"name": "execute", "type": "BOOL", "description": "With a rising signal edge, execution of the instruction is started."}, {"name": "firstIndex", "type": "DINT", "description": "Index of the first tag name to be resolved."}, {"name": "lastIndex", "type": "DINT", "description": "Index of the last tag name to be resolved."}], "Output": [{"name": "done", "type": "BOOL", "description": "Done = 1. Execution of the instruction is complete."}, {"name": "busy", "type": "BOOL", "description": "Busy = 1. The instruction is currently being executed."}, {"name": "error", "type": "BOOL", "description": "ERROR = 1. Error occurred during processing. The error message is output at the STATUS parameter."}, {"name": "status", "type": "INT", "description": "Block status / error number (see \"STATUS parameter\")"}], "InOut": [{"name": "nameList", "type": "Array of WSTRING", "description": "List of tag names to be resolved."}, {"name": "referenceList", "type": "Array of ResolvedSymbol", "description": "List of references"}]}, "how_to_use": "Initialize the instruction by providing an array of tag names in the \"nameList\" parameter and an array of ResolvedSymbol structures in the \"referenceList\" parameter. Trigger execution by a rising edge on the \"execute\" input. Specify the range of tag names to resolve using \"firstIndex\" and \"lastIndex\". Wait for \"done\" output to become TRUE indicating completion. Do not modify \"nameList\" or \"referenceList\" while \"busy\" is TRUE. After execution, references to the tags will be available in \"referenceList\".", "example_code": "\"ResolveSymbols_DB\"(execute := #Input_Execute,\n                firstIndex := 0,\n                lastIndex := 9,\n                done => #Output_Done,\n                busy => #Output_Busy,\n                error => _bool_out_,\n                status => _int_out_,\n                nameList := \"MySrcDB\".InOut_Symbols,\n                referenceList := \"MyTargetDB\".InOut_ResolvedSymbols);", "additional_info": "The symbolic tag names must be WSTRINGs of maximum length 254 UTF-16 characters, fully qualified including namespaces. The '#' qualifier for local tags is not supported. Array elements must specify fixed indices; variable indexing is not supported. Maximum 10 instances of ResolveSymbols can be active simultaneously with a combined limit of resolving 2,000 symbols. The instruction executes asynchronously and resets values in the \"referenceList\" array within the specified indices before resolution. Error codes indicate specific issues such as invalid indices or memory area violations.", "generated_brief": {"functional_summary": "The ResolveSymbols instruction asynchronously resolves multiple symbolic tag names into typed references that allow read/write access to those tags.", "usage_context": "This function is typically used in PLC automation programs when you need to dynamically obtain references to multiple tags for subsequent manipulation or monitoring within a specified range."}, "generated_keywords": ["resolve symbolic tags", "asynchronous tag referencing", "dynamic tag pointers", "symbolic name resolution", "bulk tag resolution"]}
{"instruction_name": "ENDIS_PW", "description": "With the instruction ENDIS_PW (enable / disable password) you lock the passwords for the individual access levels of your CPU or release them again. By locking the passwords, existing legitimized connections can be terminated. Calling ENDIS_PW with REQ=1 locks or releases passwords depending on the states of the input parameters F_PWD, FULL_PWD, R_PWD, and HMI_PWD. Calling ENDIS_PW with REQ=0 displays the current password status for each access level without changing any lock state. Each password can be locked or released independently of the others, allowing selective limitation of access.", "parameters": {"Input": [{"name": "REQ", "type": "BOOL", "description": "REQ=0: Determine current password status for the individual access levels in your CPU. REQ=1: Lock or release passwords for the individual access levels of your CPU."}, {"name": "F_PWD", "type": "BOOL", "description": "F_PWD=0: Lock password of the access level 'Full access including fail-safe (no protection)'. F_PWD=1: Release password of this access level."}, {"name": "FULL_PWD", "type": "BOOL", "description": "FULL_PWD=0: Lock password of the access level 'Full access (no protection)'. FULL_PWD=1: Release password of this access level."}, {"name": "R_PWD", "type": "BOOL", "description": "R_PWD=0: Lock password of the access level 'Read access'. R_PWD=1: Release password of this access level."}, {"name": "HMI_PWD", "type": "BOOL", "description": "HMI_PWD=0: Lock password of the access level 'HMI access'. HMI_PWD=1: Release password of this access level."}], "Output": [{"name": "F_PWD_ON", "type": "BOOL", "description": "Current password status of 'Full access including fail-safe (no protection)': 0=password locked, 1=password released."}, {"name": "FULL_PWD_ON", "type": "BOOL", "description": "Current password status of 'Full access (no protection)': 0=password locked, 1=password released."}, {"name": "R_PWD_ON", "type": "BOOL", "description": "Current password status of 'Read access': 0=password locked, 1=password released."}, {"name": "HMI_PWD_ON", "type": "BOOL", "description": "Current password status of 'HMI access': 0=password locked, 1=password released."}, {"name": "RET_VAL", "type": "WORD", "description": "Error information. 0x0000: No error; 0x8090: Instruction not supported; 0x80D0 to 0x80D3: Configuration errors related to password inputs."}], "InOut": []}, "how_to_use": "Call ENDIS_PW with REQ=1 to lock or release passwords by setting the respective input parameters to 0 (lock) or 1 (release). Call with REQ=0 to query the current lock status without changing it. Ensure inputs for password levels without configured passwords are set to TRUE, or an error will be returned. Use this instruction to control access levels and prevent unauthorized usage. For S7-1500 CPUs with display, password lock state can also be controlled locally. To prevent unintended lockout, handle password status appropriately during mode transitions or startup.", "example_code": "\"Tag_Result\" := ENDIS_PW(REQ := 0,\n                         F_PWD := 0,\n                         FULL_PWD := 0,\n                         R_PWD := 1,\n                         HMI_PWD := 0,\n                         F_PWD_ON => \"Status_F_PWD\",\n                         FULL_PWD_ON => \"Status_FULL_PWD\",\n                         R_PWD_ON => \"Status_R_PWD\",\n                         HMI_PWD_ON => \"Status_HMI_PWD\");", "additional_info": "If ENDIS_PW returns an error, the call has no effect and password states remain unchanged. Locking the HMI password blocks HMI system access to the CPU. Existing legitimized connections may be terminated if relevant passwords are locked. Password locks can be temporarily removed by switching CPU modes or power cycling (S7-1200). Use timers or interrupts at startup to call ENDIS_PW and avoid unintentional lockout. In case of lost password on S7-1200, use empty transfer or program cards to reset memory and reload the program. Handle transfer/program cards carefully during runtime to avoid unexpected CPU STOP and unsafe system behavior.", "generated_brief": {"functional_summary": "The ENDIS_PW instruction locks or releases passwords for different CPU access levels and can also query their current lock status.", "usage_context": "It is used to control and manage password-protected access levels in a PLC to prevent unauthorized use and manage existing connections securely."}, "generated_keywords": ["password lock control", "CPU access management", "access level security", "password status query", "unauthorized access prevention"]}
{"instruction_name": "LOWER_BOUND", "description": "The \"Read out ARRAY low limit\" instruction is used to read out the variable low limit of the ARRAY.", "parameters": {"Input": [{"name": "ARR", "type": "ARRAY[*]", "description": "ARRAY of which the variable low limit is to be read."}, {"name": "DIM", "type": "UDINT", "description": "Dimension of the ARRAY of which the variable low limit is to be read."}], "Output": [{"name": "Function value", "type": "DINT", "description": "Result"}], "InOut": []}, "how_to_use": "Use LOWER_BOUND to read the variable low limit of an ARRAY parameter within a function block or function. Specify the target ARRAY as ARR and the dimension index as DIM. The instruction returns the low boundary for the specified dimension. Ensure the ARR parameter is declared with data type ARRAY[*].", "example_code": "\"Result\" := LOWER_BOUND(ARR := #ARRAY_A, DIM := 2);", "additional_info": "This instruction is available for S7-1200 CPUs with firmware version >= 4.2 and S7-1500 CPUs with firmware version >= 2.0.", "generated_brief": {"functional_summary": "The LOWER_BOUND instruction reads and returns the low limit index of a specified dimension in an ARRAY variable.", "usage_context": "It is used within function blocks or functions when it is necessary to determine the starting index of an ARRAY dimension for processing or validation in S7-1200 and S7-1500 PLCs."}, "generated_keywords": ["read array lower bound", "array dimension low limit", "ARRAY index retrieval", "LOWER_BOUND instruction", "PLC array boundary"]}
{"instruction_name": "UPPER_BOUND", "description": "The instruction 'Read out ARRAY high limit' is used to read out the variable high limit of the ARRAY.", "parameters": {"Input": [{"name": "ARR", "type": "ARRAY[*]", "description": "ARRAY of which the variable high limit is to be read."}, {"name": "DIM", "type": "UDINT", "description": "Dimension of the ARRAY of which the variable high limit is to be read."}], "Output": [{"name": "Function value", "type": "DINT", "description": "Result"}], "InOut": []}, "how_to_use": "You need to provide the ARRAY and the dimension as inputs to read the variable high limit.", "example_code": "\"Result\" := UPPER_BOUND(ARR := #ARRAY_A,\n                              DIM := 2);", "additional_info": "The instruction is available for a CPU of the S7-1200 series as of firmware version >= 4.2, and for a CPU of the S7-1500 series as of firmware version >= 2.0.", "generated_brief": {"functional_summary": "The UPPER_BOUND instruction returns the highest valid index of a specified dimension in an array.", "usage_context": "It is used when determining the upper boundary of an array dimension for bounds checking or iterative processing in S7-1200 and S7-1500 PLC programs."}, "generated_keywords": ["read array upper bound", "array high limit", "array dimension upper index", "array bounds checking", "array iteration limit"]}
{"instruction_name": "S_CD", "description": "You can use the \"Assign parameters and count down\" instruction to decrement the value of a counter. When the signal state of the CD parameter changes from \"0\" to \"1\" (positive signal edge), the current counter value is decreased by one. The current counter value is provided at the parameter CV. The counter value is decreased until the low limit of \"0\" is reached. When the low limit is reached, the counter value is no longer decreased on a positive signal edge.\n\nWhen the signal state of the S parameter changes from \"0\" to \"1\", the counter value is set to the value of the PV parameter. If the counter is set and if the result of logic operation (RLO) at the CD parameter is \"1\", the counter counts once in the next cycle, even when no signal edge change is detected.\n\nThe counter value is set to zero when the signal state of the R parameter changes to \"1\". As long as the R parameter has the signal state \"1\", a change in the signal state of the parameters CD and S has no effect on the counter value.\n\nThe signal state at parameter Q is \"1\" if the counter value is greater than zero. When the counter value equals zero, parameter Q returns signal state \"0\".", "parameters": {"Input": [{"name": "C_NO", "type": "COUNTER, INT", "description": "Counter operations. The number of counters depends on the CPU."}, {"name": "CD", "type": "BOOL", "description": "Count down input"}, {"name": "S", "type": "BOOL", "description": "Input for presetting the counter"}, {"name": "PV", "type": "WORD", "description": "Preset counter value (C#0 to C#999) in BCD format"}, {"name": "R", "type": "BOOL", "description": "Reset input"}], "Output": [{"name": "Q", "type": "BOOL", "description": "Status of the counter"}, {"name": "CV", "type": "WORD", "description": "Current counter value"}, {"name": "Function value", "type": "WORD", "description": "Current counter value in BCD format"}], "InOut": []}, "how_to_use": "Use the CD input to decrement the counter on a positive edge signal; use the S input to preset the counter to PV on a positive edge; use R input to reset the counter to zero. The output Q indicates if the counter value is greater than zero, while CV holds the current counter value. Avoid using the same counter in multiple locations in the program to prevent counting errors.", "example_code": "\"Tag_Result\" := S_CD(C_NO := \"Counter_1\",\n                      CD := \"Tag_Start\",\n                      S := \"Tag_1\",\n                      PV := \"Tag_PresetValue\",\n                      R := \"Tag_Reset\",\n                      Q => \"Tag_Status\",\n                      CV => \"Tag_Value\");", "additional_info": "Only use a counter at a single point in the program to avoid the risk of counting errors.", "generated_brief": {"functional_summary": "The S_CD instruction presets, decrements, and resets a counter value based on input signals, outputting the current count and status indicating if the count is above zero.", "usage_context": "It is typically used in industrial automation to track event occurrences or control sequences by counting down from a preset value, with provisions for resetting and status monitoring."}, "generated_keywords": ["counter decrement", "counter preset", "counter reset", "positive edge trigger", "count status output"]}
{"instruction_name": "S_CD", "description": "You can use the \"Assign parameters and count up / down\" instruction to increment and decrement the value of a counter. When the signal state of the CU parameter changes from \"0\" to \"1\" (positive signal edge), the current counter value is incremented by one. When the signal state of the CD parameter changes from \"0\" to \"1\" (positive signal edge), the counter value is decreased by one. The current counter value is provided at the parameter CV. If there is a positive signal edge at the parameters CU and CD in one program cycle, the counter value remains unchanged.\nThe counter value is incremented until the high limit of \"999\" is reached. When the high limit is reached, the counter value is no longer incremented on a positive signal edge. When the low limit \"0\" is reached, the counter value is not decremented any further.\nWhen the signal state of the S parameter changes from \"0\" to \"1\", the counter value is set to the value of the PV parameter. If the counter is set and if the result of logic operation (RLO) of the CU and CD parameters is \"1\", the counter will count once in the next cycle, even if no signal edge change was detected.\nThe counter value is set to zero when the signal state of the R parameter changes to \"1\". As long as the parameter R has the signal state \"1\", processing of the signal state of the parameters CU, CD and S has no effect on the counter value.\nThe signal state at parameter Q is \"1\" if the counter value is greater than zero. When the counter value equals zero, parameter Q returns signal state \"0\".", "parameters": {"Input": [{"name": "C_NO", "type": "COUNTER, INT", "description": "Counter operations. The number of counters depends on the CPU."}, {"name": "CU", "type": "BOOL", "description": "Count up input"}, {"name": "CD", "type": "BOOL", "description": "Count down input"}, {"name": "S", "type": "BOOL", "description": "Input for presetting the counter"}, {"name": "PV", "type": "WORD", "description": "Preset counter value (C#0 to C#999) in BCD format"}, {"name": "R", "type": "BOOL", "description": "Reset input"}], "Output": [{"name": "Q", "type": "BOOL", "description": "Status of the counter"}, {"name": "CV", "type": "WORD", "description": "Current counter value (hexadecimal)"}, {"name": "Function value", "type": "WORD", "description": "Current counter value in BCD format"}], "InOut": []}, "how_to_use": "Use the S_CD instruction to increment or decrement a counter value on the positive edges of CU (count up) and CD (count down) signals. The counter value saturates at 0 (low) and 999 (high). The S input presets the counter to PV value when a positive edge is detected. The R input resets the counter to zero and disables counting while active. The Q output shows if the counter value is greater than zero. Avoid using a counter instance in multiple places to prevent counting errors.", "example_code": "\"Tag_Result\" := S_CD(C_NO := \"Counter_1\",\n                      CU := \"Tag_CU\",\n                      CD := \"Tag_CD\",\n                      S := \"Tag_1\",\n                      PV := \"Tag_PresetValue\",\n                      R := \"Tag_Reset\",\n                      Q => \"Tag_Status\",\n                      CV => \"Tag_Value\");", "additional_info": "Only use a counter at a single point in the program to avoid the risk of counting errors.", "generated_brief": {"functional_summary": "The S_CD instruction increments or decrements a counter value based on positive edges of count-up and count-down inputs, supports presetting and resetting, and outputs the current count and its status.", "usage_context": "It is typically used in PLC programs to track event occurrences or process counts within defined limits, such as monitoring production quantities or controlling sequential operations."}, "generated_keywords": ["counter increment decrement", "preset counter value", "counter reset", "positive edge counting", "PLC counting instruction"]}
{"instruction_name": "S_CU", "description": "You can use the \"Assign parameters and count up\" instruction to increment the value of a counter. When the signal state of the CU parameter changes from \"0\" to \"1\" (positive signal edge), the current counter value is incremented by one. The current counter value is provided at the parameter CV. The counter value is incremented until the limit of \"999\" is reached. When the limit value is reached, the counter value is no longer incremented on a positive signal edge. When the signal state the S parameter changes from \"0\" to \"1\", the counter value is set to the value of the PV parameter. If the counter is set and if the result of logic operation (RLO) at the CU input is \"1\", the counter counts once in the next cycle, even when no signal edge change is detected. The counter value is set to zero when the signal state of the R parameter changes to \"1\". As long as the R parameter has the signal state \"1\", a change in the signal state of the parameters CU and S has no effect on the counter value. The signal state at parameter Q is \"1\" if the counter value is greater than zero. When the counter value equals zero, parameter Q returns signal state \"0\".", "parameters": {"Input": [{"name": "C_NO", "type": "COUNTER, INT", "description": "Counter operations. The number of counters depends on the CPU."}, {"name": "CU", "type": "BOOL", "description": "Count up input"}, {"name": "S", "type": "BOOL", "description": "Input for presetting the counter"}, {"name": "PV", "type": "WORD", "description": "Preset counter value (C#0 to C#999) in BCD format"}, {"name": "R", "type": "BOOL", "description": "Reset input"}], "Output": [{"name": "Q", "type": "BOOL", "description": "Status of the counter"}, {"name": "CV", "type": "WORD", "description": "Current counter value"}, {"name": "Function value", "type": "WORD", "description": "Current counter value in BCD format"}], "InOut": []}, "how_to_use": "Use this instruction by linking the count up input (CU) to a signal that triggers on a positive edge to increment the counter, the preset input (S) to set a defined counter value according to PV, and the reset input (R) to reset the counter value to zero. Monitor the output Q for status and CV for the current counter value. Ensure the counter is only used at a single point in the program to avoid counting errors.", "example_code": "\"Tag_Result\" := S_CU(C_NO := \"Counter_1\",\n                  CU := \"Tag_Start\",\n                  S := \"Tag_1\",\n                  PV := \"Tag_PresetValue\",\n                  R := \"Tag_Reset\",\n                  Q => \"Tag_Status\",\n                  CV => \"Tag_Value\");", "additional_info": "Only use a counter at a single point in the program to avoid the risk of counting errors. The counter value is limited to 999 and will no longer increment after this limit is reached. The current counter value is stored in hexadecimal form in the CV output and returned as a function value in BCD format.", "generated_brief": {"functional_summary": "The S_CU function increments a counter on a positive edge of the count-up input, allows presetting and resetting the counter value, and outputs the current count along with a status flag indicating if the count is above zero.", "usage_context": "This function is typically used in PLC programs to track event counts or quantities in industrial automation processes, ensuring precise counting control with preset and reset capabilities."}, "generated_keywords": ["counter increment", "positive edge trigger", "preset counter value", "counter reset", "counter status output"]}
{"instruction_name": "TypeOf", "description": "This instruction checks the data type of a tag to which a VARIANT or a ResolvedSymbol is pointing. It allows comparison of the declared data type with another tag or directly with a data type to determine whether they are 'Equal' or 'Not equal'.", "parameters": {"Input": [{"name": "<Operand>", "type": "Binary numbers, integers, floating-point numbers, times, date and time, character strings, VARIANT, ResolvedSymbol", "description": "Operand to query"}], "Output": [], "InOut": []}, "how_to_use": "This instruction can only be used within an IF or CASE instruction.", "example_code": "IF TypeOf(#TagVARIANT) = TypeOf('TagBYTE') THEN\n...\nEND_IF;\n\nIF TypeOf(#TagVARIANT) = BYTE THEN\n...\nEND_IF;\n\nCASE TypeOf(ResolvedSymbol[100]) OF\n   INT:\n   ...;\nEND_CASE;", "additional_info": "Symbolic access during runtime requires the system data type 'ResolvedSymbol' to access tags in the PLC program by an external application.", "generated_brief": {"functional_summary": "The TypeOf instruction determines the data type of a VARIANT or ResolvedSymbol tag and compares it with another data type or tag to check for equality.", "usage_context": "It is typically used within IF or CASE instructions to perform type-based decision making in PLC programs, especially when accessing tags symbolically at runtime."}, "generated_keywords": ["data type comparison", "VARIANT type check", "ResolvedSymbol type", "type equality check", "IF CASE instruction usage"]}
{"instruction_name": "IS_ARRAY", "description": "You can use the \"Check for ARRAY\" instruction to query whether the <operand> parameter points to a tag of the ARRAY data type. You can only use the \"Check for ARRAY\" instruction within an IF instruction.", "parameters": {"Input": [{"name": "<Operand>", "type": "VARIANT, ResolvedSymbol", "description": "Operand that is queried for ARRAY"}], "Output": [{"name": "Function value", "type": "UDINT", "description": "Result of the instruction"}], "InOut": []}, "how_to_use": "The IS_ARRAY instruction is used within an IF statement to check if the given VARIANT operand references an type. If true, the number of elements in the ARRAY can be retrieved (e.g., via CountOfElements). When using an ArrayDB as input, ensure there is a symbolic use of the ArrayDB elsewhere as a VARIANT parameter to function correctly. The point of use must be downloaded but not necessarily executed.", "example_code": "IF IS_ARRAY(#Tag_VARIANTToArray) THEN\n  \"Tag_Result\" := CountOfElements(#Tag_VARIANTToArray);\nEND_IF;", "additional_info": "When using IS_ARRAY with an ArrayDB and creating the VARIANT input via DB_ANY_TO_VARIANT, a symbolic use of the ArrayDB must be present elsewhere in the program as a VARIANT parameter. It is sufficient if this point of use is downloaded to the PLC without requiring execution.", "generated_brief": {"functional_summary": "The IS_ARRAY instruction checks whether a given VARIANT operand references an ARRAY data type within an IF statement.", "usage_context": "It is typically used in conditional logic to verify an operand's type before performing array-specific operations, such as retrieving the number of elements."}, "generated_keywords": ["check array type", "IS_ARRAY instruction", "variant operand type check", "array verification in IF", "conditional array detection"]}
{"instruction_name": "BITCMP", "description": "You can use the \"Compare input bits with the bits of a mask\" instruction to compare the signal state of up to 16 programmed input bits (IN_BIT0 to IN_BIT15) with the corresponding bits of a mask. Up to 16 steps with masks can be programmed. The value of the IN_BIT0 parameter is compared with the value of the mask CMP_VAL[x,0], with \"x\" indicating the step number. In the CMP_STEP parameter, you specify the step number of the mask that is used for the comparison. All programmed values are compared in the same manner. Unprogrammed input bits or unprogrammed bits of the mask have a default signal state FALSE. If a match is found in the comparison, the signal state of the OUT parameter is set to \"1\". Otherwise the OUT parameter is set to \"0\". If the value of the CMP_STEP parameter is greater than 15, the instruction is not executed. An error message is output at the ERR_CODE parameter.", "parameters": {"Input": [{"name": "IN_BIT0", "type": "BOOL", "description": "Input bit 0 is compared with bit 0 of the mask."}, {"name": "IN_BIT1", "type": "BOOL", "description": "Input bit 1 is compared with bit 1 of the mask."}, {"name": "IN_BIT2", "type": "BOOL", "description": "Input bit 2 is compared with bit 2 of the mask."}, {"name": "IN_BIT3", "type": "BOOL", "description": "Input bit 3 is compared with bit 3 of the mask."}, {"name": "IN_BIT4", "type": "BOOL", "description": "Input bit 4 is compared with bit 4 of the mask."}, {"name": "IN_BIT5", "type": "BOOL", "description": "Input bit 5 is compared with bit 5 of the mask."}, {"name": "IN_BIT6", "type": "BOOL", "description": "Input bit 6 is compared with bit 6 of the mask."}, {"name": "IN_BIT7", "type": "BOOL", "description": "Input bit 7 is compared with bit 7 of the mask."}, {"name": "IN_BIT8", "type": "BOOL", "description": "Input bit 8 is compared with bit 8 of the mask."}, {"name": "IN_BIT9", "type": "BOOL", "description": "Input bit 9 is compared with bit 9 of the mask."}, {"name": "IN_BIT10", "type": "BOOL", "description": "Input bit 10 is compared with bit 10 of the mask."}, {"name": "IN_BIT11", "type": "BOOL", "description": "Input bit 11 is compared with bit 11 of the mask."}, {"name": "IN_BIT12", "type": "BOOL", "description": "Input bit 12 is compared with bit 12 of the mask."}, {"name": "IN_BIT13", "type": "BOOL", "description": "Input bit 13 is compared with bit 13 of the mask."}, {"name": "IN_BIT14", "type": "BOOL", "description": "Input bit 14 is compared with bit 14 of the mask."}, {"name": "IN_BIT15", "type": "BOOL", "description": "Input bit 15 is compared with bit 15 of the mask."}, {"name": "CMP_STEP", "type": "BYTE", "description": "The step number of the mask used for the comparison."}], "Output": [{"name": "OUT", "type": "BOOL", "description": "The signal state \"1\" indicates that a match was found. A signal state of \"0\" indicates that no match was found."}, {"name": "ERR_CODE", "type": "WORD", "description": "Error information"}], "InOut": []}, "how_to_use": "Program up to 16 individual input bits (IN_BIT0 to IN_BIT15) to compare against corresponding bits in a mask array (CMP_VAL) at the specified CMP_STEP index (0 to 15). If the input bits match the mask bits, the output OUT is set to TRUE; otherwise FALSE. Monitor ERR_CODE for errors like CMP_STEP greater than 15, which disables the instruction execution.", "example_code": "", "additional_info": "Unprogrammed input bits or unprogrammed bits of the mask have a default signal state FALSE. If CMP_STEP is greater than 15, the instruction does not execute and ERR_CODE outputs error 000A. The CMP_VAL is a static ARRAY OF WORD containing comparison masks indexed by step number and bit number. ERR_CODE 0000 means no error.", "generated_brief": {"functional_summary": "The BITCMP instruction compares up to 16 input bits against a specified mask at a chosen step and outputs TRUE if all bits match exactly, otherwise FALSE.", "usage_context": "It is typically used in PLC programs to verify specific bit pattern matches in input signals for decision-making or control logic based on predefined masks."}, "generated_keywords": ["bit comparison", "input mask matching", "multi-bit signal check", "mask step selection", "error code monitoring"]}
{"instruction_name": "SMC", "description": "You can use the \"Compare scan matrix\" instruction to compare the signal state of up to 16 programmed input bits (IN_BIT0 to IN_BIT15) with the corresponding bit of the comparison masks for each step. Processing starts at step 1 and is continued until the last programmed step (LAST) or until a match is found. The input bit of the IN_BIT0 parameter is compared with the value of the mask CMP_VAL[x,0], with \"x\" indicating the step number. All programmed values are compared in the same manner. If a match is found the signal state of the OUT parameter is set to \"1\" and the step number with the matching mask is written in the OUT_STEP parameter. Unprogrammed input bits or unprogrammed bits of the mask have a default signal state FALSE. If more than one step has a matching mask, only the first one found is indicated in the OUT_STEP parameter. If no match is found, the signal state of the OUT parameter is set to \"0\". In this case the value at the OUT_STEP parameter is greater by \"1\" than the value at the LAST parameter.", "parameters": {"Input": [{"name": "IN_BIT0", "type": "BOOL", "description": "Input bit 0 is compared with bit 0 of the mask."}, {"name": "IN_BIT1", "type": "BOOL", "description": "Input bit 1 is compared with bit 1 of the mask."}, {"name": "IN_BIT2", "type": "BOOL", "description": "Input bit 2 is compared with bit 2 of the mask."}, {"name": "IN_BIT3", "type": "BOOL", "description": "Input bit 3 is compared with bit 3 of the mask."}, {"name": "IN_BIT4", "type": "BOOL", "description": "Input bit 4 is compared with bit 4 of the mask."}, {"name": "IN_BIT5", "type": "BOOL", "description": "Input bit 5 is compared with bit 5 of the mask."}, {"name": "IN_BIT6", "type": "BOOL", "description": "Input bit 6 is compared with bit 6 of the mask."}, {"name": "IN_BIT7", "type": "BOOL", "description": "Input bit 7 is compared with bit 7 of the mask."}, {"name": "IN_BIT8", "type": "BOOL", "description": "Input bit 8 is compared with bit 8 of the mask."}, {"name": "IN_BIT9", "type": "BOOL", "description": "Input bit 9 is compared with bit 9 of the mask."}, {"name": "IN_BIT10", "type": "BOOL", "description": "Input bit 10 is compared with bit 10 of the mask."}, {"name": "IN_BIT11", "type": "BOOL", "description": "Input bit 11 is compared with bit 11 of the mask."}, {"name": "IN_BIT12", "type": "BOOL", "description": "Input bit 12 is compared with bit 12 of the mask."}, {"name": "IN_BIT13", "type": "BOOL", "description": "Input bit 13 is compared with bit 13 of the mask."}, {"name": "IN_BIT14", "type": "BOOL", "description": "Input bit 14 is compared with bit 14 of the mask."}, {"name": "IN_BIT15", "type": "BOOL", "description": "Input bit 15 is compared with bit 15 of the mask."}], "Output": [{"name": "OUT", "type": "BOOL", "description": "The signal state \"1\" indicates that a match was found. A signal state of \"0\" indicates that no match was found."}, {"name": "OUT_STEP", "type": "BYTE", "description": "Contains the step number with the matching mask or the step number which is greater by \"1\" than the value of the LAST parameter, provided no match is found."}, {"name": "ERR_CODE", "type": "WORD", "description": "Error information"}], "InOut": []}, "how_to_use": "Initialize the static parameters LAST and CMP_VAL with the last step to scan and the array of comparison masks, respectively. Then provide the input bits IN_BIT0 to IN_BIT15 to be compared. The instruction scans from step 1 up to LAST for a matching mask. If a match is found, OUT is set to 1 and OUT_STEP contains the matching step number; if no match is found, OUT is 0 and OUT_STEP equals LAST + 1. Check ERR_CODE for error status, e.g. LAST must not exceed 15.", "example_code": "", "additional_info": "Static parameters LAST and CMP_VAL are saved in the instance of the instruction and not visible in the program call. The ERR_CODE output parameter indicates errors, for example an error if LAST is greater than 15 (error code 000E). Unprogrammed input or mask bits default to FALSE for comparison. Only the first matching step is returned if multiple steps match.", "generated_brief": {"functional_summary": "The SMC instruction compares the states of up to 16 input bits against predefined masks across multiple steps and outputs whether a match is found along with the matching number.", "usage_context": "It is used in PLC programs to sequentially identify specific input signal patterns or conditions by scanning through programmed comparison masks for control or diagnostic purposes."}, "generated_keywords": ["scan input bits", "compare with masks", "sequential pattern matching", "output matching step", "error code detection"]}
{"instruction_name": "CTU", "description": "The \"Count up\" instruction increments the value at the CV parameter. When the signal state of the parameter CU changes from \"0\" to \"1\" (positive signal edge), the instruction is executed and the current counter value of the parameter CV is incremented by one. The counter value is incremented each time a positive signal edge is detected, until it reaches the high limit of the data type specified at the CV parameter. When the high limit is reached, the signal state of the CU parameter no longer has an effect on the instruction. You can query the count status of the Q parameter. The signal state of the Q parameter is determined by the PV parameter. When the current counter value is greater than or equal to the value of the PV parameter, the Q parameter is set to signal state \"1\". In all other cases, the signal state of the Q parameter is \"0\". The value of CV parameter is reset to zero when the signal state at the R parameter changes to \"1\". As long as the signal state of the R parameter is \"1\", the signal state of the CU parameter has no effect on the instruction.", "parameters": {"Input": [{"name": "CU", "type": "BOOL", "description": "Count input"}, {"name": "R", "type": "BOOL", "description": "Reset input"}, {"name": "PV", "type": "Integers", "description": "Value at which the Q output is set"}], "Output": [{"name": "Q", "type": "BOOL", "description": "Counter status"}, {"name": "CV", "type": "Integers, CHAR, WCHAR, DATE", "description": "Current counter value"}], "InOut": []}, "how_to_use": "Each call of the CTU instruction must be assigned an IEC counter in which the instruction data is stored. IEC counters can be declared either as instance data blocks of system data type IEC_<Counter> or as local tags (multi-instance) in the 'Static' section of a program block. For S7-1200 and S7-1500 CPUs, appropriate IEC counter data types and corresponding local tags should be used. The CV value is incremented on the positive edge of CU unless R is '1', which resets the counter to zero and disables counting while active. The Q output reflects if the current count CV is greater than or equal to PV. Use the CTU instruction only at a single point in the program to avoid counting errors.", "example_code": "\"IEC_COUNTER_DB\".CTU(CU := \"Tag_Start\",\n                     R := \"Tag_Reset\",\n                     PV := \"Tag_PresetValue\",\n                     Q => \"Tag_Status\",\n                     CV => \"Tag_CounterValue\");", "additional_info": "Only use a counter at single point in the program to avoid risk of counting errors. When IEC counters are declared as instance DBs with optimized block access, the individual tags are retentive. Local tags declared in function blocks with optimized block access are also retentive in the block interface.", "generated_brief": {"functional_summary": "The CTU instruction increments a counter value on each positive edge of the count input and sets a status output when the current count reaches or exceeds a preset value, with a reset input to clear the count.", "usage_context": "It is typically used in PLC programs to track event occurrences or objects counted in industrial processes, triggering actions once specified count thresholds are met."}, "generated_keywords": ["count up", "positive edge counting", "counter reset", "preset value comparison", "counter status output"]}
{"instruction_name": "Deserialize", "description": "You can use the 'Deserialize' instruction to convert back the sequential representation of a PLC data type (UDT), STRUCT or ARRAY of <data type> and to fill its entire contents. You can use the instruction to convert multiple serialized data areas back to their deserialized representation form.", "parameters": {"Input": [{"name": "SRC_ARRAY", "type": "ARRAY[*] of BYTE, ARRAY of CHAR", "description": "ARRAY of BYTE or ARRAY of CHAR in which the data stream which is to be deserialized is saved. For optimum performance, do not provide the parameter with a VARIANT pointer."}], "Output": [], "InOut": [{"name": "DEST_VARIABLE", "type": "all data types", "description": "Tag to which the deserialized data is to be written. For optimum performance, do not provide the parameter with a VARIANT pointer."}, {"name": "POS", "type": "DINT", "description": "The operand at the POS parameter stores the index of the first byte based on the number of bytes occupied by the converted customer data. The POS parameter is calculated zero-based."}]}, "how_to_use": "To deserialize larger structures, declare the memory area for sequential representation with optimized access for a CPU of the S7-1200 series as of firmware version >= 4.2, and for a CPU of the S7-1500 series as of firmware version >= 2.0.", "example_code": "#Tag_RetVal := Deserialize(SRC_ARRAY := 'Buffer'.Field, DEST_VARIABLE := 'Target'.Client, POS := #BufferPos);", "additional_info": "The 'Deserialize' instruction deserializes the sequential representation of the customer data.", "generated_brief": {"functional_summary": "The Deserialize instruction converts a serialized array of bytes or characters back into its original PLC data type format, such as UDTs, STRUCTs, or ARRAYs.", "usage_context": "It is typically used when reconstructing structured data from a sequential byte stream for processing within PLC programs, especially when handling communication or storage data."}, "generated_keywords": ["deserialize", "convert serialized", "UDT conversion", "structured data reconstruction", "byte array to data type"]}
{"instruction_name": "DCAT", "description": "The 'Discrete control-timer alarm' instruction is used to count the time from the point at which the CMD parameter issues the command to open or close. The time is accumulated until the preset time (PT) is exceeded or the information is received that the device was opened or closed (O_FB or C_FB) within the specified time. If the preset time is exceeded before the information on the opening or closing of the device is received, the corresponding alarm is activated. If the signal state of the command input changes before the preset time, the time is restarted.", "parameters": {"Input": [{"name": "CMD", "type": "BOOL", "description": "A signal state of '0' indicates a 'close' command. A signal state of '1' indicates an 'open' command."}, {"name": "O_FB", "type": "BOOL", "description": "Feedback input when opening"}, {"name": "C_FB", "type": "BOOL", "description": "Feedback input when closing"}], "Output": [{"name": "Q", "type": "BOOL", "description": "Shows the status of the parameter CMD"}, {"name": "OA", "type": "BOOL", "description": "Alarm output when opening"}, {"name": "CA", "type": "BOOL", "description": "Alarm output when closing"}], "InOut": []}, "how_to_use": "To use this instruction, initialize the static parameters in the data block. Monitor the feedback signals O_FB and C_FB to determine the state of the device being controlled.", "example_code": "\"DCAT_DB\"(CMD := \"Tag_Input_CMD\", O_FB := \"Tag_Input_O_FB\", C_FB := \"Tag_Input_C_FB\", Q => \"Tag_Output_Q\", OA => \"Tag_Output_OA\", CA => \"Tag_Output_CA\");", "additional_info": "The static parameters are not visible when calling the instruction in the program. These are saved in the instance of the instruction.", "generated_brief": {"functional_summary": "The DCAT instruction monitors the time elapsed after a command to open or close a device and triggers an alarm if the corresponding device feedback is not received within a preset time.", "usage_context": "It is typically used in industrial control systems to ensure timely operation of devices like valves or gates and to alert operators if the device fails to reach the requested state promptly."}, "generated_keywords": ["timed device control", "open close command monitoring", "feedback signal verification", "alarm on timeout", "PLC discrete timer"]}
{"instruction_name": "UFILL_BLK", "description": "You can use the \"Fill block uninterruptible\" instruction to fill a memory area (target range) with the value of the IN input. The instruction cannot be interrupted. The target range is filled beginning with the address specified at the OUT output. The number of repeated copy operations is specified with the COUNT parameter. When the instruction is executed, the value at the input IN is moved to the target range as often as specified by the value of the COUNT parameter. The instruction can only be executed if the source range and the target range have the same data type.", "parameters": {"Input": [{"name": "IN", "type": "Binary numbers, integers, floating-point numbers, timers, DATE, CHAR, WCHAR, TOD (S7-1200); Binary numbers, integers, floating-point numbers, timers, DATE, CHAR, WCHAR, TOD, LTOD (S7-1500)", "description": "Element used to fill the target range"}, {"name": "COUNT", "type": "USINT, UINT, UDINT (S7-1200); USINT, UINT, UDINT, ULINT (S7-1500)", "description": "Number of repeated move operations"}], "Output": [{"name": "OUT", "type": "Binary numbers, integers, floating-point numbers, timers, TOD, DATE, CHAR, WCHAR (S7-1200); Binary numbers, integers, floating-point numbers, timers, DATE, CHAR, WCHAR, TOD, LTOD (S7-1500)", "description": "Address in target range from which filling starts"}], "InOut": []}, "how_to_use": "Use UFILL_BLK to fill an ARRAY or structure elements with the same value starting at a specified address. Ensure the source value (IN) and the target range (OUT) have the same data type. Specify the number of repetitions with COUNT. The instruction is uninterruptible, ensuring atomic update of the target range, but causing increased CPU alarm reaction times during execution. Maximum move size is 16 KB. When filling structures, all elements must be of the same elementary data type. For arrays, the value of IN is copied COUNT times starting from OUT. Be careful not to exceed the target range size to avoid unintended results.", "example_code": "UFILL_BLK(IN := #FillValue,\n          COUNT := Tag_Count,\n          OUT => #TargetArea[1]);", "additional_info": "The move operation cannot be interrupted by other operating system activities. Use caution about CPU alarm reaction times when executing this instruction. The maximum number of elements changed is bounded by the size of the array or structure, copying more than available elements can cause unintended results. Structures filled with this instruction must contain elements of the same elementary data type but can be embedded in other structures. Data types and memory areas are specific for S7-1200 and S7-1500 CPUs with some differences.", "generated_brief": {"functional_summary": "The UFILL_BLK instruction fills a specified memory area with a given value repeatedly without interruption, ensuring atomic update of the target range.", "usage_context": "It is used to initialize or reset arrays or structures with the same data value in industrial PLC programs where uninterruptible and consistent memory updates are required."}, "generated_keywords": ["uninterruptible memory fill", "block fill instruction", "atomic target range update", "array and structure initialization", "value repeated copy"]}
{"instruction_name": "FILL", "description": "You can use the \"Fill block\" instruction to fill a memory area (destination area) with the content of another memory area (source area). The \"Fill block\" instruction moves the content of the source area to the destination area until the destination area is completely written. The move operation takes place in the direction of ascending addresses.", "parameters": {"Input": [{"name": "BVAL", "type": "VARIANT", "description": "Specification of the memory area (source area), the content of which is used to fill the destination area at theK parameter."}], "Output": [{"name": "BLK", "type": "VARIANT", "description": "Specification of the memory area that will be filled with the content of the source area."}, {"name": "RET_VAL", "type": "INT", "description": "Error information returned by the function."}], "InOut": [{"name": "BLK", "type": "VARIANT", "description": "The tag of the BLK parameter must be declared as InOut in the block interface since the data flows into the tag."}]}, "how_to_use": "Define source and destination memory areas using VARIANT or ANY (with restrictions). Ensure the source and destination areas do not overlap. Use the instruction to move contents of the source area to the destination area in ascending address order until the destination is filled. Avoid using in optimized block access areas unless tags are declared with retentivity setting \"Set in IDB\". When transferring structures, ensure length is an even number of bytes.", "example_code": "\"Tag_RetVal\" := FILL(BVAL := P#M14.0 WORD 4, BLK => P#M100.0 WORD 10);", "additional_info": "Source and destination areas must not overlap. If the destination size is smaller than the source size, only the fitting data is copied. For BOOL data type pointers, addresses must be absolute and length divisible by 8. Updating of source data during execution is not allowed. STRING and WSTRING types have specific copy behaviors. Error codes returned in RET_VAL: 0000 (No error), 8092 (Areas only in load memory), 8152 (Unsupported data at BVAL), 8352 (Unsupported data types at BLK). The instruction can only be used in memory areas without optimized block access unless specific retentivity settings are used.", "generated_brief": {"functional_summary": "The FILL instruction copies the content of a specified source memory area into a destination memory area in ascending address order until the destination is completely filled.", "usage_context": "It is used in PLC programs to efficiently initialize or overwrite memory blocks with existing data, ensuring non-overlapping areas and proper data alignment."}, "generated_keywords": ["memory block fill", "source to destination copy", "non-overlapping memory areas", "ascending address data transfer", "PLС data initialization"]}
{"instruction_name": "FILL_BLK", "description": "You can use the 'Fill block' instruction to fill a memory area (target range) with the value of the IN input. The target range is filled beginning with the address specified at the OUT output. The number of repeated copy operations is specified with the COUNT parameter. When the instruction is executed, the value at the input IN is moved to the target range as often as specified by the value of the COUNT parameter.", "parameters": {"Input": [{"name": "IN", "type": "Binary numbers, integers, floating-point numbers, timers, TOD, DATE, CHAR, WCHAR", "description": "Element used to fill the target range"}, {"name": "COUNT", "type": "USINT, UINT, UDINT", "description": "Number of repeated move operations"}], "Output": [{"name": "OUT", "type": "Binary numbers, integers, floating-point numbers, timers, TOD, DATE, CHAR, WCHAR", "description": "Address in target range from which filling starts"}], "InOut": []}, "how_to_use": "To use this instruction, specify the value to fill in the IN parameter, the number of copies in the COUNT parameter, and the starting address in the OUT parameter.", "example_code": "FILL_BLK(IN := #FillValue, COUNT := 'Tag_Count', OUT => #TargetArea[1]);", "additional_info": "The instruction can only be executed if the source range and the target range have the same data type. The maximum number of elements changed is the number of elements in the ARRAY or structure.", "generated_brief": {"functional_summary": "The FILL_BLK instruction copies a specified value into a consecutive memory area a defined number of times starting from a given address.", "usage_context": "It is typically used to initialize or reset blocks of memory or arrays with a uniform value in PLC programming."}, "generated_keywords": ["fill memory block", "copy value repeatedly", "initialize array", "set uniform value", "memory area fill"]}
{"instruction_name": "ACOS", "description": "You can use the 'Form arccosine value' instruction to calculate the size of the angle from a cosine value, which corresponds to this value. Only valid floating-point numbers within the range -1 to +1 can be specified as input values. The calculated angle size is given in radians and can range in value from 0 to +π.", "parameters": {"Input": [{"name": "<Expression>", "type": "Floating-point numbers", "description": "Cosine value"}], "Output": [{"name": "Function value", "type": "Floating-point numbers", "description": "Size of angle in radians"}], "InOut": []}, "how_to_use": "To use this instruction, provide a cosine value as input, ensuring it falls within -1 to +1.", "example_code": "\"Tag_Result\" := ACOS(\"Tag_Value\");", "additional_info": "The result of the instruction is returned in the operand 'Tag_Result' as a function value.", "generated_brief": {"functional_summary": "The ACOS instruction calculates the arccosine of a given floating-point cosine value within the range -1 to +1, returning the corresponding angle in radians between 0 and π.", "usage_context": "It is typically used in PLC programs to determine the angle when only the cosine value is available, such as in motion control or trigonometric computations in automation systems."}, "generated_keywords": ["arccosine calculation", "cosine to angle", "floating-point input", "angle in radians", "trigonometric function"]}
{"instruction_name": "ASIN", "description": "You can use the \"Form arcsine value\" instruction to calculate the size of the angle from a sine value, which corresponds to this value. Only valid floating-point within the range -1 to +1 can be specified as input values. The calculated angle size is given in radians and can range in value from -π/2 to +π/2.", "parameters": {"Input": [{"name": "<Expression>", "type": "Floating-point numbers", "description": "Sine value"}], "Output": [{"name": "Function value", "type": "Floating-point numbers", "description": "Size of angle in radians"}], "InOut": []}, "how_to_use": "Pass a floating-point sine value within the range -1 to +1 as input to the ASIN instruction. The instruction returns the corresponding angle size in radians, ranging from -π/2 to +π/2.", "example_code": "\"Tag_Result\" := ASIN(\"Tag_Value\");", "additional_info": "The input value must be a valid floating-point number within the range -1 to +1. The result is provided in radians. Valid data types and memory areas include I, Q M, D, L, P.", "generated_brief": {"functional_summary": "The ASIN instruction calculates the arcsine (inverse sine) of a floating-point input value between -1 and +1, returning the corresponding angle in radians between -π/2 and +π/2.", "usage_context": "It is typically used in PLC programs to determine angle measurements from sine values in applications involving trigonometric calculations and motion control."}, "generated_keywords": ["arcsine calculation", "inverse sine", "angle in radians", "floating-point input", "trigonometric function"]}
{"instruction_name": "ATAN", "description": "You can use the \"Form arctangent value\" instruction to calculate the size of the angle from a tangent value, which corresponds to this value. It is only permitted to specify valid floating-point numbers (or -NaN/+NaN) as input value. The calculated angle size is given in radians and can range in value from -π/2 to +π/2.", "parameters": {"Input": [{"name": "<Expression>", "type": "Floating-point numbers", "description": "Tangent value"}], "Output": [{"name": "Function value", "type": "Floating-point numbers", "description": "Size of angle in radians"}], "InOut": []}, "how_to_use": "Use this instruction by passing a valid tangent value as a floating-point input to the ATAN function. The result is the angle size in radians (from -π/2 to +π/2). Ensure the input is a valid floating-point number as invalid numbers are not allowed.", "example_code": "\"Tag_Result\" := ATAN(\"Tag_Value\");", "additional_info": "The instruction input must be a valid floating-point number or NaN. The output angle is returned in radians. Valid memory areas for inputs and outputs include I, Q, M, D, L, P.", "generated_brief": {"functional_summary": "The ATAN instruction calculates the arctangent of a given tangent value and returns the corresponding angle in radians between -π/2 and +π/2.", "usage_context": "This function is typically used in PLC programs for converting tangent values to angular measurements in applications like motor control, robotics, or any system requiring angle computations."}, "generated_keywords": ["arctangent calculation", "angle in radians", "floating-point input", "tangent to angle conversion", "PLC math function"]}
{"instruction_name": "LN", "description": "You can use the \"Form natural logarithm\" instruction to calculate the natural logarithm to base e (e=2.718282) from the input value. The instruction has a positive result if the input value is greater than zero. If input values are less than zero, the instruction returns an invalid floating-point number.", "parameters": {"Input": [{"name": "<Expression>", "type": "Floating-point numbers", "description": "Input value"}], "Output": [{"name": "Function value", "type": "Floating-point numbers", "description": "Natural logarithm of the input value"}], "InOut": []}, "how_to_use": "Use the LN instruction to calculate the natural logarithm of a positive floating-point number. The input parameter must be greater than zero to return a valid result. If the input is less than zero, the result will be an invalid floating-point number. Assign the instruction result to a floating-point variable.", "_code": "\"Tag_Result1\" := LN(\"Tag_Value\");\n\"Tag_Result2\" := LN(\"Tag_Value1\" + \"Tag_Value2\");", "additional_info": "For additional information on valid data types, refer to the valid data types overview. Input and output data can be located in various memory areas: I, Q, M, D, L, P.", "generated_brief": {"functional_summary": "The LN instruction calculates the natural logarithm (base e) of a positive floating-point input value and returns the result as a floating-point number.", "usage_context": "This function is typically used in PLC programs to perform mathematical computations involving logarithmic calculations, especially when dealing with exponential processes or data transformations that require logarithmic scaling."}, "generated_keywords": ["natural logarithm", "logarithmic calculation", "floating-point input", "mathematical function", "PLC programming"]}
{"instruction_name": "TOF", "description": "You can use the 'Generate off-delay' instruction to reset the Q output by the programmed time PT. The Q output is set when the result of logic operation (RLO) at input IN changes from '0' to '1' (positive signal edge). When the signal state at input IN changes back to '0' (negative signal edge), the programmed time PT starts. Output Q remains set as long as the time duration PT is running. When the PT time duration expires, the Q output is reset. If the signal state at input IN changes to '1' before the PT time duration expires, the timer is reset.", "parameters": {"Input": [{"name": "IN", "type": "BOOL", "description": "Start input."}, {"name": "PT", "type": "TIME", "description": "Duration of the off delay. The value of the PT parameter must be positive."}], "Output": [{"name": "Q", "type": "BOOL", "description": "Operand that is reset when the time PT expires."}, {"name": "ET", "type": "TIME", "description": "Current timer value."}], "InOut": []}, "how_to_use": "Each call of the instruction must be assigned to an IEC timer in which the instance data is stored. Ensure the IN input is properly set to initiate the timer and the PT parameter is positive to define the duration.", "example_code": "\"TOF_DB\".TOF(IN := \"Tag_Start\", PT := \"Tag_PresetTime\", Q => \"Tag_Status\", ET => \"Tag_ElapsedTime\");", "additional_info": "Reinitializing the actual values of an IEC timer while the time measurement is running disrupts the. Make sure that the plant is in a safe state before overwriting actual values.", "generated_brief": {"functional_summary": "The TOF instruction generates an off-delay by keeping the output Q set when the input IN switches on and continuing to hold Q for a preset time PT after IN switches off before resetting Q.", "usage_context": "It is typically used to maintain a device or signal active for a fixed duration after the controlling input turns off in industrial control applications."}, "generated_keywords": ["off-delay timer", "TOF instruction", "timer reset on input", "output hold after input off", "IEC timer assignment"]}
{"instruction_name": "TON", "description": "You can use the \"Generate on-delay\" instruction to delay the setting of the Q parameter for the programmed duration PT. The instruction is started when the result of logic operation (RLO) of the IN parameter changes from \"0\" to \"1\" (positive signal edge). The programmed time PT begins when the instruction starts. When the PT duration has expired, the Q parameter returns signal state \"1\". The Q parameter remains set as long as the start input is still \"1\". If the signal state of the IN parameter changes from \"1\" to \"0\", the parameter Q will be reset. The timer function is restarted when a new positive signal edge is detected at the IN parameter.\n\nThe current time value can be queried in the ET parameter. The time value starts at T#0s and ends when the value of the time duration PT is reached. The ET parameter reset as soon as the signal state of the IN parameter changes to \"0\".", "parameters": {"Input": [{"name": "IN", "type": "BOOL", "description": "Start input"}, {"name": "PT", "type": "TIME", "description": "Duration of the on delay. The value of the PT parameter must be positive."}], "Output": [{"name": "Q", "type": "BOOL", "description": "Operand that is set when the timer PT expires."}, {"name": "ET", "type": "TIME", "description": "Current timer value"}], "InOut": []}, "how_to_use": "Assign an IEC timer instance data block or local tag to the instruction. When the IN input signal changes from 0 to 1, the timer starts counting the programmed duration PT. Once the duration expires, the output Q is set. The output Q remains set as long as IN is 1. When IN changes from 1 to 0, Q resets and ET resets. If the instruction is skipped in the program or outputs are not read, the ET output remains constant after PT expires. Be cautious not to reinitialize actual values during time measurement to avoid inconsistency.", "example_code": "\"TON_DB\".TON(IN := \"Tag_Start\",\n             PT := \"Tag_PresetTime\",\n             Q => \"Tag_Status\",\n             ET => \"Tag_ElapsedTime\");", "additional_info": "Each call requires an IEC timer instance (of types IEC_TIMER, TON_TIME, or IEC_LTIMER/TON_LTIME depending on CPU). Reinitializing actual timer values during operation (e.g., by loading blocks with reinitialization, snapshots, forcing values, or WRIT_DBL) can cause serious malfunction. Always ensure the plant is in a safe state before reinitialization and that the timer has expired. The instruction stores the previous IN value internally for edge detection, so do not manipulate IN parameter's actual value externally. The ET and Q outputs update only when the instruction is called or their outputs are accessed; otherwise they hold their last value.", "generated_brief": {"functional_summary": "The TON instruction implements an on-delay timer that starts timing when an input signal transitions from 0 to 1 and sets an output signal after the preset time elapses while the input remains high.", "usage_context": "It is typically used in industrial PLC programs to introduce controlled delays before activating outputs or subsequent logic based on the presence of a sustained input signal."}, "generated_keywords": ["on-delay timer", "positive edge trigger", "timing delay", "PLC timer instruction", "output signal delay"]}
{"instruction_name": "TP", "description": "You can use the \"Generate pulse\" instruction to set the parameter Q for a programmed duration. The instruction is started when the result of logic operation (RLO) of the IN parameter changes from \"0\" to \"1\" (positive signal edge). The programmed time PT begins when the instruction starts. The Q parameter is set for the duration PT, independent of the further course of the input signal. While the duration PT is running, the detection of a new positive signal edge at the IN input has no influence on the signal state at the Q output. You can query the current time value set in the ET parameter. The timer value starts at T#0s and ends when the value of the time duration PT is reached. When the time duration PT is reached and the signal state at the IN parameter is \"0\", the ET parameter is reset.", "parameters": {"Input": [{"name": "IN", "type": "BOOL", "description": "Start input"}, {"name": "PT", "type": "TIME, LTIME", "description": "Duration of the pulse. The value of the PT parameter must be positive."}], "Output": [{"name": "Q", "type": "BOOL", "description": "Operand that is set for the PT duration."}, {"name": "ET", "type": "TIME, LTIME", "description": "Current timer value."}], "InOut": []}, "how_to_use": "Assign each call of the \"Generate pulse\" instruction to an IEC timer instance data structure (IEC_TIMER, IEC_LTIMER, TP_TIME, or TP_LTIME depending on the CPU). The instruction starts timing when a positive edge is detected on the IN input. The output Q is set for the PT. The ET output provides the elapsed time. Avoid reinitializing or overwriting actual values during timing to prevent inconsistencies.", "example_code": "\"TP_DB\".TP(IN := \"Tag_Start\",\n           PT := \"Tag_PresetTime\",\n           Q => \"Tag_Status\",\n           ET => \"Tag_ElapsedTime\");", "additional_info": "The timer instance must be declared either as a data block or a local tag depending on the CPU series and programming style. The timer's internal edge memory relies on the IN input. Writing or initializing the IN parameter externally will disrupt edge detection. When the instruction is skipped, ET returns a constant value if time has expired. Reinitializing actual values during running time measurement can cause serious inconsistencies and should be avoided. Use safe states before overwriting actual values and ensure the timer has expired.", "generated_brief": {"functional_summary": "The TP instruction generates a fixed-duration pulse by setting its output Q to true for a programmed time PT upon detecting a rising edge on its input IN.", "usage_context": "It is typically used in PLC programs to create precise timed pulses needed for control signals, independent of the input signal's subsequent state."}, "generated_keywords": ["generate pulse", "rising edge trigger", "fixed duration output", "timer pulse", "PLC timing instruction"]}
{"instruction_name": "DRUM", "description": "You can use the 'Implement sequencer' instruction to assign the programmed values of the OUT_VAL parameter of the corresponding step to the programmed output bits (OUT1 to OUT16) and the output word (OUT_WORD). The specific step must thereby satisfy the conditions of the programmed enable mask on the S_MASK parameter while the instruction remains at this step. The instruction advances to the next step if the event for the step is true and the programmed time for the current step elapses, or if the value at the JOG parameter changes from '0' to '1'. The instruction is reset when the signal state of the RESET parameter changes to '1'. The current step is hereby equated to the preset step (DSP).", "parameters": {"Input": [{"name": "RESET", "type": "BOOL", "description": "The signal state '1' indicates a reset condition."}, {"name": "JOG", "type": "BOOL", "description": "When the signal state changes from '0' to '1', the instruction advances to the next step."}, {"name": "DRUM_EN", "type": "BOOL", "description": "The signal state '1' allows the sequencer to advance based on the event and time criteria."}, {"name": "LST_STEP", "type": "BYTE", "description": "Maximum step number (for example: LST_STEP = 16#08; a maximum of 8 steps is possible)."}, {"name": "EVENT(i)", "type": "BOOL", "description": "Event bit (i); Initial signal state is '1'."}], "Output": [{"name": "OUT(j)", "type": "BOOL", "description": "Output bit (j)."}, {"name": "Q", "type": "BOOL", "description": "The signal state '1' indicates that the time for the last step has elapsed."}, {"name": "OUT_WORD", "type": "WORD", "description": "Word address to which the sequencer writes the output values."}, {"name": "ERR_CODE", "type": "WORD", "description": "Error information."}], "InOut": []}, "how_to_use": "Initialize the parameters appropriately, then call the instruction within the main cycle of your program to advance through the steps based on the defined conditions.", "example_code": "\"DRUM_DB\"(RESET := \"Tag_Reset\", JOG := \"Tag_Input_Jog\", DRUM_EN := \"Tag_Input_DrumEN\", LST_STEP := \"Tag_Number_LastStep\", EVENT1 := \"MyTag_Event_1\", OUT1 => \"MyTag_Output_1\", ... )", "additional_info": "All the bits of the configurable mask for all 16 steps are initialized with a signal state of '1'. The output bit on the OUT1 parameter corresponds to the least significant bit of the output word (OUT_WORD).", "generated_brief": {"functional_summary": "The DRUM instruction implements a sequencer that advances through programmed steps based on event conditions, elapsed time, or manual jogging, outputting predefined values to output bits and words.", "usage_context": "It is typically used in industrial automation to control sequential processes where outputs must change step-by-step under controlled conditions such as timing, events, or manual triggers."}, "generated_keywords": ["sequencer", "step advancement", "event-driven output", "time-based sequencing", "manual jogging control"]}
{"instruction_name": "LEAD_LAG", "description": "You can use the \"Lead and lag algorithm\" instruction to process signals with an analog tag. The gain value at the GAIN parameter must be greater than zero. The result of the \"Lead and lag algorithm\" instruction is calculated using the following equation: OUT = GAIN * ((1 + LD_TIME * s) / (1 + LG_TIME * s)) * IN. The instruction supplies plausible results only when processing is in fixed program cycles. The same units must be specified at the parameters LD_TIME, LG_TIME and SAMPLE_T. When LG_TIME > 4 + SAMPLE_T, the instruction approaches the given function. When the value of the GAIN parameter is less than or equal to zero, the calculation is not performed and an error information is output on the ERR_CODE parameter. The instruction consists of two operations: \"Lead\" shifts the phase of output so that it leads the input, equivalent to a differentiation (high-pass filter). \"Lag\" shifts the output so it lags behind the input, equivalent to an integration (low-pass filter and noise suppressor). Together they form a band pass filter. The instruction can be used as a compensator in dynamic feed-forward control.", "parameters": {"Input": [{"name": "IN", "type": "REAL", "description": "The input value of the current sample time (cycle time) to be processed. Constants can also be specified."}, {"name": "SAMPLE_T", "type": "INT", "description": "Sample time. Constants can also be specified."}], "Output": [{"name": "OUT", "type": "REAL", "description": "Result of the instruction."}, {"name": "ERR_CODE", "type": "WORD", "description": "Error information. For example, if GAIN is less than or equal to zero, an error is indicated."}], "InOut": []}, "how_to_use": "Initialize static parameters LD_TIME, LG_TIME, GAIN, PREV_IN, and PREV_OUT in the instance data block before using the instruction. Call the instruction each program cycle with the current input (IN) and sample time (SAMPLE_T). Use the output OUT as the processed signal. Monitor ERR_CODE for errors such as invalid GAIN. Ensure processing occurs in fixed program cycles and that units for LD_TIME, LG_TIME, and SAMPLE_T are the same.", "example_code": "\"LEAD_LAG_DB\"(IN := \"Tag_Input\", SAMPLE_T := \"Tag_Input_SAMPLE_T\", OUT => \"Tag_Output_Result\", ERR_CODE => \"Tag_ErrorCode\");", "additional_info": "The static parameters (LD_TIME, LG_TIME, GAIN, PREV_IN, PREV_OUT) are saved in the instance of the instruction and not visible when calling it in the program. ERR_CODE values: 0000 means no error; 0009 means GAIN parameter value is less than or equal to zero. The instruction is typically used for signal processing as a compensator or filter in control applications.", "generated_brief": {"functional_summary": "The LEAD_LAG instruction processes an analog input signal using a combined lead (high-pass) and lag (low-pass) filter algorithm to produce a compensated or filtered output signal based on specified gain and timing parameters.", "usage_context": "It is typically used in industrial control systems for dynamic feed-forward control and signal conditioning to improve system response and suppress noise within fixed program cycles."}, "generated_keywords": ["lead lag filter", "analog signal processing", "dynamic feed-forward control", "high-pass and low-pass filter", "noise suppression"]}
{"instruction_name": "PRESET_TIMER", "description": "You can use the \"Load time duration\" instruction to set the time for an IEC timer. The instruction is executed in every cycle when the result of logic operation (RLO) at the input of the instruction has the signal state \"1\". You assign an IEC timer declared in the program to the \"Load time duration\" instruction. The instruction writes the specified time to the structure of the specified IEC timer. The instruction does not influence the RLO.", "parameters": {"Input": [{"name": "Time duration", "type": "TIME", "description": "Duration with which the IEC timer runs."}], "Output": [{"name": "IEC timer", "type": "IEC_TIMER, TP_TIME, TON_TIME, TOF_TIME, TONR_TIME", "description": "IEC timer whose duration is set."}], "InOut": []}, "how_to_use": "Use the instruction to set or overwrite the time duration of an IEC timer by assigning the duration and the IEC timer structure. Be aware that if the IEC timer is running when the instruction executes, the current timer value is overwritten, possibly changing its status. The instruction executes every cycle when the input RLO is 1 and does not affect the RLO. Update of timer actual values occurs on instruction execution and when the timer structure is accessed.", "example_code": "IF #started = false THEN\n  \"TON_DB\".TON(IN := \"Tag_Start\",\n                 PT := \"Tag_PresetTime\",\n                 Q => \"Tag_Status\",\n                 ET => \"Tag_ElapsedTime\");\n  #started := true;\n  #preset = true\nEND_IF;\n\nIF \"TON_DB\".ET < T#10s AND #preset = true THEN\n  PRESET_TIMER(PT := T#25s,\n               TIMER := \"TON_DB\");\n  #preset := false;\nEND_IF;", "additional_info": "Reinitializing the actual values of an IEC timer while it is running disrupts the timer function and can cause serious process inconsistencies and dangers. Functions that cause reinitialization include loading blocks with reinitialization, loading snapshots as actual values, controlling or forcing actual values, and using the WRIT_DBL instruction. Precautions must be taken to ensure the plant is in a safe state, the IEC timer has expired, and no conflicting accesses occur when overwriting actual timer values.", "generated_brief": {"functional_summary": "The PRESET_TIMER instruction sets or overwrites the time duration of an IEC timer by writing a specified time value to the timer structure each execution cycle when enabled.", "usage_context": "It is typically used to initialize or adjust the preset time of IEC timers in control logic, especially before the timer starts or to reset its duration, while ensuring safe conditions to avoid timer function disruption."}, "generated_keywords": ["preset IEC timer", "load timer duration", "overwrite timer value", "timer initialization", "IEC timer adjustment"]}
{"instruction_name": "UBLKMOV", "description": "You can use the 'Move block uninterruptible' instruction to move the content of a memory area (source area) to another memory area (destination area). The move operation takes place in the direction of ascending addresses. You use VARIANT to define the source and destination areas.", "parameters": {"Input": [{"name": "SRCBLK", "type": "VARIANT", "description": "Specifies the memory area to be moved (source area)."}], "Output": [{"name": "DSTBLK", "type": "VARIANT", "description": "Specifies the memory area to which the block is to be moved (destination area)."}], "InOut": [{"name": "Function value (RET_VAL)", "type": "INT", "description": "Error information."}]}, "how_to_use": "Ensure that the source and destination areas do not overlap during the execution. Move a maximum of 16 KB and take note of CPU-specific restrictions.", "example_code": "\"Tag_RetVal\" := UBLKMOV(SRCBLK := P#M100.0 BYTE 10, DSTBLK =&gt; P#DB1.DBX0.0 BYTE 10);", "additional_info": "If the destination area is smaller than the source area, the entire destination area will be written. For BOOL data type, ensure that the length is divisible by 8.", "generated_brief": {"functional_summary": "UBLKMOV performs an uninterruptible move of data from a specified source memory area to a destination memory area in ascending address order.", "usage_context": "It is used in PLC programs to safely transfer blocks of data between memory locations without interruption, ensuring data integrity during the operation."}, "generated_keywords": ["uninterruptible block move", "memory area transfer", "data block copy", "ascending address move", "PLC data integrity"]}
{"instruction_name": "BLKMOV", "description": "You can use the 'Move block' instruction to move the content of a memory area (source area) to another memory area (destination area). The move operation takes place in the direction of ascending addresses. You use VARIANT to define the source and destination areas.", "parameters": {"Input": [{"name": "SRCBLK", "type": "VARIANT", "description": "Specifies the memory area to be moved (source area)."}], "Output": [{"name": "DSTBLK", "type": "VARIANT", "description": "Specifies the memory area to which the block is to be moved (destination area)."}, {"name": "Function value (RET_VAL)", "type": "INT", "description": "Error information."}], "InOut": []}, "how_to_use": "To use this instruction, specify the source and destination memory areas as parameters, ensuring they do not overlap and are compatible in size.", "example_code": "\"Tag_RetVal\" := BLKMOV(SRCBLK := P#M100.0 BYTE 10, DSTBLK => P#DB1.DBX0.0 BYTE 10);", "additional_info": "If the source and destination areas have different lengths, only the length of the smaller area will be moved. The tag must be absolute for BOOL data types and the length must be divisible by 8.", "generated_brief": {"functional_summary": "The BLKMOV instruction copies the contents of a defined source memory area to a specified destination memory area in ascending address order.", "usage_context": "It is typically used in PLC programs to efficiently transfer blocks of data between memory areas without overlap, such as moving sensor data to data blocks for processing."}, "generated_keywords": ["block memory move", "source to destination copy", "memory area transfer", "non-overlapping data move", "ascending address copy"]}
{"instruction_name": "MOVE_BLK", "description": "You can use the \"Move block\" instruction to move the content of a memory area (source range) to another memory area (target range). The number of elements to be moved to the target range is specified with the COUNT parameter. The width of the elements to be moved is defined by the width of the first element in the source area. The instruction can only be executed if the source range and the target range have the same data type. The value of the OUT output is invalid if more data is moved than is made available at the IN parameter or OUT parameter.", "parameters": {"Input": [{"name": "IN", "type": "Binary numbers, integers, floating-point numbers, timers, DATE, CHAR, WCHAR, TOD", "description": "The first element of the source area that is being copied"}, {"name": "COUNT", "type": "USINT, UINT, UDINT", "description": "Number of elements to be copied from the source range to the target range"}], "Output": [{"name": "OUT", "type": "Binary numbers, integers, floating-point numbers, timers, DATE, CHAR, WCHAR, TOD", "description": "The first element of the target range to which the contents of the source range are being copied"}], "InOut": []}, "how_to_use": "Use MOVE_BLK to copy multiple elements from a source array to a target array, starting at specified indices in both arrays. Ensure both the source and target memory ranges have the same data type. Set IN to point to the first source element, COUNT to the number of elements to copy, and OUT to the first target element. The data types for IN and OUT must be ARRAY elements of valid types. The instruction copies COUNT elements sequentially from IN to OUT.", "example_code": "MOVE_BLK(IN := #a_array[2],\n          COUNT := \"Tag_Count\",\n          OUT => #b_array[1]);", "additional_info": "The specified data types for IN and OUT can only be used as elements of an ARRAY structure. The instruction copies the contents starting from the element indicated by IN for COUNT elements to the target starting at OUT's specified element Moving more data than available makes OUT invalid. Refer to Siemens Industry Online Support article: https://support.industry.siemens.com/cs/ww/en/view/42603881 for more details.", "generated_brief": {"functional_summary": "MOVE_BLK copies a specified number of sequential elements from a source memory area to a target memory area of the same data type.", "usage_context": "It is typically used to efficiently transfer blocks of data between arrays or memory areas in PLC programs for data manipulation or storage purposes."}, "generated_keywords": ["move block", "copy array elements", "memory area transfer", "sequential data copy", "data type matching"]}
{"instruction_name": "VariantGet", "description": "You can use the 'Read out VARIANT tag value' instruction to read the value of the tag to which the VARIANT at the SRC parameter points and write it in the tag at the DST parameter.", "parameters": {"Input": [{"name": "SRC", "type": "VARIANT", "description": "Tag to be read"}], "Output": [{"name": "DST", "type": "Bit strings, integers, floating-point numbers, timers, date and time, character strings, ARRAY elements, PLC data types", "description": "Result of the instruction"}], "InOut": []}, "how_to_use": "Initialize the SRC parameter with a VARIANT type tag and the DST parameter with a compatible data type for the value to be written.", "example_code": "VariantGet(SRC := #TagIn_Source, DST => 'TagOut_Dest');", "additional_info": "The data type of the tag specified at the DST parameter must match the data type to which the VARIANT points.", "generated_brief": {"functional_summary": "The VariantGet instruction reads the value from a VARIANT type tag specified by SRC and writes it to a destination tag DST with a matching data type.", "usage_context": "It is typically used when extracting and transferring data from a generic VARIANT tag to a specific data type tag within PLC programs."}, "generated_keywords": ["read VARIANT tag", "transfer VARIANT value", "type-compatible data transfer", "SRC to DST value read", "VARIANT to specific data type"]}
{"instruction_name": "RESET_TIMER", "description": "You can use the 'Reset timer' instruction to reset an IEC timer to '0'. The structure components of the timer in the specified data block are reset to '0'.", "parameters": {"Input": [{"name": "TIMER", "type": "IEC_TIMER, TP_TIME, TON_TIME, TOF_TIME, TONR_TIME", "description": "IEC timer that is reset"}], "Output": [], "InOut": []}, "how_to_use": "The instruction must be programmed in an IF instruction. The instruction data is updated only when the instruction is called and not each time the assigned IEC timer is accessed.", "example_code": "IF 'TON_DB'.ET < T#25s THEN\n    RESET_TIMER(TIMER := 'TON_DB');\nEND_IF;", "additional_info": "Danger when reinitializing the actual values. Reinitializing the actual values of an IEC timer while the timer is running disrupts the function of the IEC timer.", "generated_brief": {"functional_summary": "The RESET_TIMER instruction resets all components of a specified IEC timer to zero.", "usage_context": "It is typically used within conditional statements to reinitialize timers during process control, ensuring the timer restarts under defined conditions."}, "generated_keywords": ["reset IEC timer", "timer reinitialization", "conditional timer reset", "process control timer", "reset timer instruction"]}
{"instruction_name": "Serialize", "description": "You can use the \"Serialize\" instruction convert several PLC data types (UD), STRUCT or ARRAY of <data type> to a sequential representation without losing parts of their structure. You use the instruction to temporarily save multiple structured data items from your program in a buffer, which should preferably be in a global data block, and send them to another CPU. The memory area in which the converted data is stored must have the ARRAY of BYTE or ARRAY of CHAR data type and be declared with standard access in version 1.0. Optimized data is also permitted as of version 2.0. Fill data of the source data area is undefined in the target array. These can be fill bytes or fill bits of a data area (e.g. ARRAY, STRUCT or PLC data type (UDT)) as well as the characters of a string currently not in use.", "parameters": {"Input": [{"name": "SRC_VARIABLE", "type": "all data types", "description": "Tag to be serialized. S7-1500: For optimum performance, do not provide the parameter with a VARIANT pointer."}], "Output": [{"name": "Function value", "type": "INT", "description": "Error information"}], "InOut": [{"name": "DEST_ARRAY", "type": "ARRAY of BYTE or ARRAY of CHAR", "description": "ARRAY in which the generated data stream is stored. S7-1500: For optimum performance, do not provide the parameter with a VARIANT pointer."}, {"name": "POS", "type": "DINT", "description": "The operand at the POS parameter stores the index of the first byte based on the total number of bytes that the converted customer data has occupied. The POS parameter is calculated zero-based."}]}, "how_to_use": "Use the instruction to serialize structured data (UDT, STRUCT or ARRAY) into a sequential memory area of type ARRAY of BYTE or ARRAY of CHAR. The destination memory area is preferably a global data block and must have standard access or optimized as of certain firmware versions. Initialize the POS parameter to indicate the starting position in the target array; it returns the index of the next free byte after serialization. To serialize multiple structures in sequence, ensure position alignment especially on S7-1200 CPUs by checking POS and potentially incrementing it by 1 if odd. Avoid using VARIANT pointers for SRC_VARIABLE and DEST_ARRAY for optimum performance and error avoidance. Use local error handling instructions GET_ERROR and GET_ERR_ID to manage errors safely.", "example_code": "#Tag_RetVal := Serialize(SRC_VARIABLE := \"Source\".Client,\n                      DEST_ARRAY := \"Buffer\".Field,\n                      POS := #BufferPos);\n#Label := STRING_TO_WSTRING('arti');\n#Tag_RetVal := Serialize(SRC_VARIABLE := #Label,\n                      DEST_ARRAY := \"Buffer\".Field,\n                      POS := #BufferPos);\n#Tag_RetVal := Serialize(SRC_VARIABLE := \"Source\".Article[#DeliverPos],\n                      DEST_ARRAY := \"Buffer\".Field,\n                      POS := #BufferPos);", "additional_info": "The capacity of the standard memory area is 64 KB; structures larger than 64 KB cannot be serialized if DEST_ARRAY is in standard memory. Optimized memory areas can be used from firmware version >= 4.2 (S7-1200) and >= 2.0 (S7-1500). When comparing structures, they need to be serialized first. The error codes returned indicate specific issues such as overlapping memory areas, invalid references, or insufficient memory in the destination array. Some error codes changed meaning as of firmware versions 4.2 (S7-0) and 2.0 (S7-1500). Serialization disallows interconnecting elements of technology objects since version 2.2. The optimized Serialize instruction consumes more work memory due to higher data complexity. For preventing CPU STOP on certain errors, use local error handling. It is recommended to order data types in source starting with large types and ending with BOOLs to reduce padding.", "generated_brief": {"functional_summary": "The Serialize instruction converts structured PLC data types like UDTs, STRUCTs, or ARRAYs into a sequential byte or character array representation for transmission or storage without losing their structure.", "usage_context": "It is typically used to temporarily save and transfer complex structured data between CPUs or memory areas by serializing it into a linear buffer for communication or comparison purposes."}, "generated_keywords": ["serialize structured data", "convert UDT to byte array", "PLC data serialization", "transmit structured data", "buffer data serialization"]}
{"instruction_name": "SWAP", "description": "You can use the \"Swap\" instruction to change the arrangement of the bytes of an input value and save the result in the specified operand.", "parameters": {"Input": [{"name": "<Expression>", "type": "WORD, DWORD", "description": "Input value"}], "Output": [{"name": "Function value", "type": "WORD, DWORD", "description": "Result of the instruction"}], "InOut": []}, "how_to_use": "Use the SWAP instruction to reverse the byte order of a WORD or DWORD input. Pass the input operand as an expression, and the function returns the swapped byte value. This is useful when handling data that requires different byte ordering. The result is returned as a function value.", "example_code": "\"Tag_Result\" := SWAP(\"Tag_Value\");", "additional_info": "Valid input data types include WORD and DWORD. The data can reside in memory areas I, Q, M, D, L, or P for S7-1200 and S7-1500. Refer to the valid data types and memory areas documentation for more details.", "generated_brief": {"functional_summary": "The SWAP instruction reverses the byte order of a WORD or DWORD input and returns the result as a function value.", "usage_context": "It is typically used when handling data that requires conversion between different byte ordering formats in industrial control systems."}, "generated_keywords": ["byte order swap", "WORD DWORD byte reversal", "data byte conversion", "SWAP instruction", "PLC data manipulation"]}
{"instruction_name": "VariantPut", "description": "You can use the \"Write VARIANT tag value\" instruction to write the value of the tag at the SRC parameter to the memory at the DST parameter to which the VARIANT points. The DST parameter has the VARIANT data type. Any data type except for VARIANT can be specified at the SRC parameter. The data type of the tag at the SRC parameter must match the data type to which the VARIANT points.", "parameters": {"Input": [{"name": "SRC", "type": "Bit strings, integers, floating-point numbers, timers, date and time, character strings, ARRAY elements, PLC data types", "description": "Tag to be read"}, {"name": "DST", "type": "VARIANT", "description": "Result of the instruction"}], "Output": [], "InOut": []}, "how_to_use": "Use the VariantPut instruction to write the value from the SRC parameter to the memory location pointed to by the VARIANT type at the DST parameter. Ensure the data type at SRC matches the data type the VARIANT points to. For copying structures and ARRAYs, use the MOVE_BLK_VARIANT instruction instead.", "example_code": "VariantPut(SRC := \"TagIn_Source\",\n           DST := #TagIn_Dest);", "additional_info": "To copy structures and ARRAYs, use the MOVE_BLK_VARIANT instruction. DST can be declared in the \"Input\", \"InOut\" and \"Temp\" sections of the block interface. Valid data types for SRC exclude VARIANT itself.", "generated_brief": {"functional_summary": "The VariantPut instruction writes the value from a non-VARIANT source tag to the memory location pointed to by a VARIANT type destination, ensuring data type compatibility.", "usage_context": "It is used when you need to assign or update the value of a VARIANT variable based on a specific typed tag within a PLC program, except when copying complex data like structures or arrays."}, "generated_keywords": ["write variant value", "type-safe variant assignment", "src to variant memory", "plc data type compatibility", "non-variant to variant copy"]}
{"instruction_name": "NORM_X", "description": "You can use the instruction 'Normalize' to normalize the value of the tag at the VALUE input by mapping it to a linear scale. You can use the MIN and MAX parameters to define the limits of a value range that is applied to the scale. The result at the OUT output is calculated and stored as a floating-point number depending on the location of the value to be normalized within this value range. If the value to be normalized equals the value at input MIN, the instruction returns the result '0.0'. If the value to be normalized equals the value at input MAX, the instruction returns the result '1.0'.", "parameters": {"Input": [{"name": "EN", "type": "BOOL", "description": "Enable input"}, {"name": "MIN", "type": "Integers, floating-point numbers", "description": "Low limit of the value range"}, {"name": "VALUE", "type": "Integers, floating-point numbers", "description": "Value to be normalized."}, {"name": "MAX", "type": "Integers, floating-point numbers", "description": "High limit of the value range"}, {"name": "_<Data type>", "type": "Floating-point numbers", "description": "Data type of the function value: You can specify the data type of the instruction explicitly using '_'."}], "Output": [{"name": "ENO", "type": "BOOL", "description": "Enable output"}, {"name": "Function value", "type": "Floating-point numbers", "description": "Result of the normalization"}], "InOut": []}, "how_to_use": "The instruction is used to convert a value within a defined range into a normalized value between 0 and 1 using the equation OUT = (VALUE – MIN) / (MAX – MIN).", "example_code": "\"Tag_Result1\" := NORM_X(MIN := \"Tag_Value1\", VALUE := \"Tag_InputValue\", MAX := \"Tag_Value2\");\n\"Tag_Result2\" := NORM_X_LREAL(MIN := \"Tag_Value1\", VALUE := \"Tag_InputValue\", MAX := \"Tag_Value2\");", "additional_info": "The parameters EN and ENO are not generated automatically when creating the instruction in the SCL programming language.", "generated_brief": {"functional_summary": "The NORM_X instruction normalizes an input value to a floating-point number between 0 and 1 based on specified minimum and maximum range limits.", "usage_context": "It is typically used in industrial control systems to scale sensor readings or process variables to a standardized range for comparison or further processing."}, "generated_keywords": ["value normalization", "linear scaling", "range mapping", "floating-point output", "sensor signal scaling"]}
{"instruction_name": "CTU", "description": "IEC counter instruction that can be declared as single or multiple instance and called in the program code. It is used to count up based on input signals.", "parameters": {"Input": [{"name": "CU", "type": "BOOL", "description": "Counting Up input. Rising edge triggers the counter up."}, {"name": "PV", "type": "INT", "description": "Preset Value. Counter counts up to this value."}], "Output": [], "InOut": []}, "how_to_use": "Declare IEC counters as single instance or multi-instance within arrays or structures in the block interface or data blocks. Call the CTU instruction by passing CU and PV operands to the instance. The counter increments on the rising edge of CU until it reaches PV.", "example_code": "#MyARRAY[1].CTU(CU := <Operand>, PV := <Operand>)", "additional_info": "IEC counters can be declared within anonymous structures, global data blocks, or ARRAY DBs and called accordingly in SCL code by referencing the proper instance path.", "generated_brief": {"functional_summary": "The CTU instruction counts up on the rising edge of a boolean input until reaching a specified preset value.", "usage_context": "It is typically used in PLC programs to track the number of occurrences or events, such as counting parts or operations in industrial automation."}, "generated_keywords": ["count up", "rising edge trigger", "preset value", "IEC counter", "multi-instance counter"]}
{"instruction_name": "TOF", "description": "IEC timer function instruction used to create a time-off delay with multi-instance support within structures, arrays, global and block interface declarations.", "parameters": {"Input": [{"name": "IN", "type": "BOOL", "description": "Input signal to start the timer function."}, {"name": "PT", "type": "TIME", "description": "Preset time duration for the timer."}], "Output": [], "InOut": []}, "how_to_use": "Declare the IEC timer instance in the block interface, data block, or as part of an array or structure. Call the TOF function using the instance name and pass the IN and PT parameters. Use multi-instance declaration to manage multiple timers.", "example_code": "#MyARRAY[1].TOF(IN := <Operand>, PT := <Operand>)", "additional_info": "The IEC timer can be declared as single or multiple instances within a structure or array. It can be accessed via global DB, block interface, or ARRAY DB with proper declaration.", "generated_brief": {"functional_summary": "The TOF instruction creates a time-off delay timer that starts timing when its input signal switches from TRUE to FALSE.", "usage_context": "It is typically used in industrial control systems to delay turning off outputs or processes after an input signal deactivates, supporting multiple timer instances within structured data."}, "generated_keywords": ["time-off delay timer", "IEC timer instruction", "multi-instance timer", "structured timer declaration", "input-triggered timing"]}
{"instruction_name": "TypeOfElements", "description": "You use the \"Check data type of an ARRAY element of a tag\" instruction to query the data type of a tag to which the Input parameter <operand> is pointing. You compare the data type of a tag to the data type of the tag that you have declared in the block interface to determine whether they are \"Equal\" or \"Not equal\". If the data type of the Input tag is an ARRAY, the data type of the ARRAY elements is compared. You can only use the \"Check data type of an ARRAY element of a tag\" instruction within an IF or CASE instruction.", "parameters": {"Input": [{"name": "Operand", "type": "VARIANT, ResSymbol", "description": "Operand to query"}], "Output": [], "InOut": []}, "how_to_use": "Use this instruction within an IF or CASE statement to query and compare the data type of a tag (or an element of an ARRAY tag) specified by the Operand parameter. The Operand must be of type VARIANT or ResolvedSymbol. Compare with another data type using TypeOF to determine equality.", "example_code": "IF TypeOfElements(\"Tag_Variant\") = TypeOF(\"GlobalDB\".Product[1]) THEN\n    \"Tag_Variant\" := \"GlobalDB\".Product[1] * 3;\nEND_IF;", "additional_info": "The comparison operand can be an elementary data type or a PLC data type. The instruction only compares the element data type if the input is an ARRAY. The Operand declaration is possible in the \"Input\", \"InOut\" and \"Temp\" sections of the block interface.", "generated_brief": {"functional_summary": "The TypeOfElements instruction checks and compares the data type of a tag or an element of an ARRAY tag to another specified data type within an IF or CASE statement.", "usage_context": "It is used to verify data type compatibility during runtime in conditional logic to ensure safe and correct operations on tag variables in PLC programs."}, "generated_keywords": ["data type checking", "ARRAY element comparison", "tag type verification", "conditional data type matching", "IF CASE instruction usage"]}
{"instruction_name": "VARIANT_TO_DB_ANY", "description": "You use the \"Convert VARIANT to DB_ANY\" instruction to query the data block number that the operand that is specified at the IN parameter addresses. This can be an instance data block or an ARRAY data block. The operand at the IN parameter has the data type VARIANT, which means you do not need to know the data type of the data block whose number is to be queried when the program is created. The data block number is read during runtime and written to the operand specified at the RET_VAL parameter.", "parameters": {"Input": [{"name": "IN", "type": "VARIANT", "description": "Tag to be read. (The function value of the \"DB_ANY_TO_VARIANT\" instruction). You can use a local or global tag at the IN parameter."}], "Output": [{"name": "ERR", "type": "INT", "description": "Error information"}, {"name": "RET_VAL", "type": "DB_ANY", "description": "Result: Number of the DB"}], "InOut": []}, "how_to_use": "To use this instruction, pass a VARIANT type tag to the IN parameter. The instruction reads the data block number corresponding to that tag and outputs the result through the RET_VAL parameter.", "example_code": "\"OutputDBNumber\" := VARIANT_TO_DB_ANY(IN := #tempVARIANT, ERR := \"Tag_Error\");", "additional_info": "The instruction's execution depends on meeting specific requirements; otherwise, the output will be '0' as the data block number.", "generated_brief": {"functional_summary": "The VARIANT_TO_DB_ANY instruction converts a VARIANT type operand to its corresponding data block number during runtime.", "usage_context": "It is used when the specific data block number of a VARIANT tag needs to be dynamically identified without knowing the data type at program creation."}, "generated_keywords": ["VARIANT to DB_ANY conversion", "data block number query", "runtime data block identification", "dynamic data block lookup", "VARIANT tag processing"]}
{"instruction_name": "CountOfElements", "description": "You use the 'Get number of ARRAY elements' instruction to query how many ARRAY elements a tag to which the 'IN' parameter points has. If it is a single-dimensional ARRAY, the number of ARRAY elements is output as the result. If it is a multi-dimensional ARRAY, the number of all dimensions is output as the result.", "parameters": {"Input": [{"name": "<Operand>", "type": "VARIANT, ResolvedSymbol", "description": "Tag to be queried"}], "Output": [{"name": "Function value", "type": "UDINT", "description": "Result of the instruction"}], "InOut": []}, "how_to_use": "To use this instruction, ensure that the tag pointed by the 'IN' parameter is an ARRAY. If querying an ARRAY located in a data block, the block attribute 'Data block write-protected in the device' must not be activated.", "example_code": "IF IS_ARRAY(#Tag_VARIANTToArray) THEN\n'Tag_Result' := CountOfElements(#Tag_VARIANTToArray);\nEND_IF;", "additional_info": "The result is '0' if the VARIANT or ResolvedSymbol tag is not an ARRAY. If the tag at the 'IN' parameter points to an ARRAY of BOOL, the fill elements are included in the count.", "generated_brief": {"functional_summary": "The CountOfElements instruction returns the total number of elements in a single-dimensional array or the total number of dimensions in a multi-dimensional array referenced by the input tag.", "usage_context": "It is typically used to dynamically determine the size or dimensionality of an array tag during PLC program execution to handle array data appropriately."}, "generated_keywords": ["array element count", "array size query", "multi-dimensional array", "array dimension count", "dynamic array sizing"]}
{"instruction_name": "UMOVE_BLK", "description": "You use the 'Move block uninterruptible' instruction to move the content of a memory area (source range) to another memory area (target range). The instruction cannot be interrupted. The number of elements to be moved to the target range is specified with the COUNT parameter. The width of the elements to be moved is defined by the width of the first element in the source area.", "parameters": {"Input": [{"name": "IN", "type": "Binary numbers, integers, floating-point numbers, timers, DATE, CHAR, WCHAR, TOD", "description": "The first element of the source area that is being copied"}, {"name": "COUNT", "type": "USINT, UINT, UDINT", "description": "Number of elements to be copied from the source range to the target range"}], "Output": [{"name": "OUT", "type": "Binary numbers, integers, floating-point numbers, timers, DATE, CHAR, WCHAR, TOD", "description": "The first element of the target range to which the contents of the source range are being copied"}], "InOut": []}, "how_to_use": "Use this instruction to move the specified number of elements from the source memory area to the target memory area without interruptions.", "example_code": "UMOVE_BLK(IN := #a_array[2], COUNT := 'Tag_Count', OUT => #b_array[1]);", "additional_info": "You can move a maximum of 16 KB. Ensure both source and target ranges have the same data type.", "generated_brief": {"functional_summary": "UMOVE_BLK uninterruptibly copies a specified number of elements from a source memory area to a target memory area with the same data type and element width.", "usage_context": "It is used in PLC programs when an atomic, uninterrupted block data transfer is required to ensure data integrity during the move operation."}, "generated_keywords": ["uninterruptible block move", "memory block transfer", "atomic data copy", "source to target memory", "block data move"]}
{"instruction_name": "MOVE_BLK_VARIANT", "description": "You use the 'Move block' instruction to move the content of a memory area (source range) to another memory area (target range). You can copy a complete ARRAY or elements of an ARRAY to another ARRAY of the same data type. The size (number of elements) of source and destination ARRAY may be different. You can copy multiple or single elements within an ARRAY.", "parameters": {"Input": [{"name": "SRC", "type": "VARIANT (which points to an ARRAY or an individual ARRAY element), ARRAY of <Data_type>", "description": "Source block from which to copy"}, {"name": "COUNT", "type": "UDINT", "description": "Number of elements which are copied. Assign the value '1' to the parameter COUNT, if no ARRAY is specified at parameter SRC or at parameter DEST."}, {"name": "SRC_INDEX", "type": "DINT", "description": "Defines the first element to be copied: The SRC_INDEX parameter is calculated zero-based. If an ARRAY is specified at parameter SRC, the integer at parameter SRC_INDEX specifies the first element within the source area from which it is to be copied."}, {"name": "DEST_INDEX", "type": "DINT", "description": "Defines the start of the destination memory area: The DEST_INDEX parameter is calculated zero-based. If an ARRAY is specified at parameter DEST, the integer at parameter DEST_INDEX specifies the first element within the target range that is to be copied into."}], "Output": [{"name": "DEST", "type": "VARIANT", "description": "Destination area into which the contents of the source block are copied."}, {"name": "RET_VAL", "type": "INT", "description": "Error information."}], "InOut": []}, "how_to_use": "When using the MOVE_BLK_VARIANT instruction, ensure that the number of elements to be copied does not exceed the selected source range or target range, and confirm that the SRC and DEST memory areas are compatible in terms of data types.", "example_code": "\"Tag_Result\" := MOVE_BLK_VARIANT(SRC := #SrcField, COUNT := \"Tag_Count\", SRC_INDEX := \"Tag_Src_Index\", DEST_INDEX := \"Tag_Dest_Index\", DEST => #DestField);", "additional_info": "The instruction is not executed if more data is copied than is made available. Counting at the parameters SRC_INDEX and DEST_INDEX always begins with the low limit '0'.", "generated_brief": {"functional_summary": "The MOVE_BLK_VARIANT instruction copies a specified number of elements from a source memory area or array to a destination memory area or array of the same data type, allowing partial or complete array transfers.", "usage_context": "This function is typically used in PLC programs to efficiently transfer or duplicate data blocks or array elements within memory during industrial automation processes."}, "generated_keywords": ["block memory move", "array copy", "data transfer", "partial array copy", "memory area duplication"]}
{"instruction_name": "UNSCALE", "description": "You use the \"Unscale\" instruction to unscale the floating-point number in the IN parameter into physical units between a low limit and a high limit and convert it into an integer. You use the LO_LIM and HI_LIM parameters to specify the low limit and high limit of the value range to which the input value is unscaled. The result of the instruction is output at the OUT parameter. The \"Unscale\" instruction works with the following equation: OUT = [((IN–LO_LIM)/(HI_LIM–LO_LIM)) ∗ (K2–K1)] + K1. The values of the \"K1\" and \"K2\" constants are determined by the signal state at the BIPOLAR parameter. Signal state \"1\" assumes the value at IN is bipolar between -27648 and 27648 with K1 = -27648.0 and K2 = 27648.0. Signal state \"0\" assumes IN is unipolar between 0 and 27648 with K1 = 0.0 and K2 = 27648.0. When IN is outside the limits HI_LIM and LO_LIM, an error output and the result is set to the nearest limit. If LO_LIM > HI_LIM, the result is scaled in reverse proportion to the input value.", "parameters": {"Input": [{"name": "IN", "type": "REAL", "description": "Input value to be unscaled to an integer value."}, {"name": "HI_LIM", "type": "REAL", "description": "High limit"}, {"name": "LO_LIM", "type": "REAL", "description": "Low limit"}, {"name": "BIPOLAR", "type": "BOOL", "description": "Indicates whether the value at the IN parameter is bipolar or unipolar: 1 = Bipolar, 0 = Unipolar"}], "Output": [{"name": "OUT", "type": "INT", "description": "Result of the instruction"}], "InOut": []}, "how_to_use": "Initialize the input parameters IN (REAL) with the floating-point value, HI_LIM and LO_LIM (REAL) as the unscale limits, and BIPOLAR (BOOL) to indicate signal type (1 for bipolar, 0 for unipolar). Call UNSCALE with these inputs and provide an INT variable for OUT to receive the result. Monitor RET_VAL return value for error codes such as out-of-range conditions.", "example_code": "\"Tag_ErrorCode\" := UNSCALE(IN := \"Tag_InputValue\", HI_LIM := \"Tag_HighLimit\", LO_LIM := \"Tag_LowLimit\", BIPOLAR := \"Tag_Bipolar\", OUT => \"Tag_Result\");", "additional_info": "RET_VAL returns error information: 0000 = no error, 0008 = IN outside HI_LIM or LO_LIM. If LO_LIM > HI_LIM, scaling is reversed. The instruction supports input/output in memory areas I, Q, M, D, L, P except BIPOLAR which does not support P. Refer to the 'GET_ERR_ID' instruction to retrieve detailed error IDs.", "generated_brief": {"functional_summary": "The UNSCALE instruction converts a floating-point input value within specified low and high physical limits into a corresponding integer output, handling both bipolar and unipolar signal scales.", "usage_context": "It is typically used in PLC programs to translate analog measurements or scaled float values back into integer values for processing or control within defined physical units."}, "generated_keywords": ["floating-point to integer conversion", "unscale numeric value", "bipolar and unipolar scaling", "physical units scaling", "range limit handling"]}
{"instruction_name": "WRITE_BIG", "description": "You use the \"Write data in big endian format\" instruction to write the data of a single tag in the big endian byte sequence to a memory area. With the big endian format, the byte with the most significant bits is saved first, which means at the lowest memory address.", "parameters": {"Input": [{"name": "SRC_VARIABLE", "type": "Bit strings, integers, floating-point numbers, TOD, DATE, CHAR, WCHAR", "description": "Tag whose data are written. The VARIANT at the SRC_VARIABLE parameter must point to an elementary data type."}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Error information indicating success or type of error."}], "Out": [{"name": "DEST_ARRAY", "type": "ARRAY of BYTE", "description": "Memory area to which the data are written. The VARIANT at the DEST_ARRAY parameter points to the memory area to which the data is written."}, {"name": "POS", "type": "DINT", "description": "Determines the position at which the writing starts. The POS parameter is calculated zero-based."}]}, "how_to_use": "Provide SRC_VARIABLE with an elementary data type tag to write, DEST_ARRAY with a byte array memory area, and POS indicating the zero-based start position. The instruction writes the data in big endian format starting at the specified position. For VARIANT or BOOL data types, use Serialize/Deserialize or slice access respectively.", "example_code": "#TagResult := WRITE_BIG(SRC_VARIABLE := #DINTVariable,\n                    DEST_ARRAY := #TargetField,\n                    POS := #TagPos);", "additional_info": "RET_VAL error codes: 0000 = No error; 80B4 = SRC_ARRAY not ARRAY of BYTE; 8382 = POS outside ARRAY limits; 8383 = POS within limits but size exceeds ARRAY high limit.", "generated_brief": {"functional_summary": "The WRITE_BIG instruction writes data from a single elementary data type tag into a specified memory area in big endian byte order starting at a given position.", "usage_context": "This function is typically used when storing or transmitting data in big endian format to ensure correct byte order across systems in industrial automation applications."}, "generated_keywords": ["write big endian", "memory writing", "elementary data type", "byte array", "data serialization"]}
{"instruction_name": "WRITE_LITTLE", "description": "You use the \"Write data in little endian format\" instruction to write the data of a single tag in the little endian byte sequence to a memory area. With the little endian format, the byte with the least significant bits is saved first, which means at the lowest memory address.", "parameters": {"Input": [{"name": "SRC_VARIABLE", "type": "Bit strings, integers, floating-point numbers, TOD, DATE, CHAR, WCHAR", "description": "Tag whose data are written. The VARIANT at the SRC_VARIABLE parameter must point to an elementary data type."}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Error information returned by the instruction."}], "InOut": [{"name": "DEST_ARRAY", "type": "ARRAY of BYTE", "description": "Memory area to which the data are written. The VARIANT at the DEST_ARRAY parameter points to this memory area."}, {"name": "POS", "type": "DINT", "description": "Determines the position at which the writing starts. The POS parameter is calculated zero-based."}]}, "how_to_use": "Provide the tag data to SRC_VARIABLE. Provide a BYTE array to DEST_ARRAY the little endian byte sequence will be written, starting at the position specified by POS. POS tracks the current write position and is zero-based. The instruction writes the data according to the data type of SRC_VARIABLE. If you want to write a VARIANT or BOOL, use the Serialize/Deserialize instructions or slice access respectively.", "example_code": "#TagResult := WRITE_LITTLE(SRC_VARIABLE := #DINTVariable,\n                    DEST_ARRAY := #TargetField,\n                    POS := #TagPos);", "additional_info": "RET_VAL returns zero on success. Possible error codes include 80B4 if SRC_ARRAY is not an ARRAY of BYTE, 8382 if POS is out of the ARRAY limits, and 8383 if writing would exceed the array boundary. When writing tags of type VARIANT use Serialize/Deserialize instructions, and for BOOL use slice access.", "generated_brief": {"functional_summary": "The WRITE_LITTLE instruction writes the data of a single tag into a specified memory area in little endian byte order starting at a given position.", "usage_context": "It is typically used when storing or transferring numerical or elementary data types in little endian format within PLC memory arrays for communication or data processing purposes."}, "generated_keywords": ["write little endian data", "memory byte array write", "elementary data type write", "position-based memory write", "PLC data serialization"]}
