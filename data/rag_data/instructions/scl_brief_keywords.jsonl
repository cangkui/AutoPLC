{"instruction_name": "ResolveSymbols", "description": "The asynchronous instruction \"ResolveSymbols\" creates references to the respective tags in the PLC program by resolving symbolic tag names entered during runtime. These references are typed pointers used to address the tags.", "parameters": {"Input": [{"name": "nameList", "type": "Array of WSTRING", "description": "An array containing the symbolic tag names that you wish to resolve."}], "Output": [{"name": "referenceList", "type": "Array of ResolvedSymbol (SDT)", "description": "An array where the references to the resolved tags are saved. Each entry corresponds to a symbolic tag name from nameList."}], "InOut": []}, "how_to_use": "Specify an array of tag names in 'nameList'. 'referenceList' must have the same limits as 'nameList' to receive the resolved references. Use this instruction asynchronously to create typed pointers to tags for later access.", "example_code": "VAR\n  tagNames : ARRAY[0..1] OF WSTRING := ['Tag1', 'Tag2'];\n  references : ARRAY[0..1] OF ResolvedSymbol;\nEND_VAR\n\nResolveSymbols(nameList := tagNames, referenceList => references);", "additional_info": "Available for S7-1500 CPUs with firmware V3.0 or higher. Tags must have the attribute 'Accessible from HMI/OPC UA/Web API' or 'Writable from HMI/OPC UA/Web API'.", "generated_brief": {"functional_summary": "The ResolveSymbols instruction asynchronously converts an array of symbolic tag names into typed references that point to the corresponding tags in the PLC program at runtime.", "usage_context": "This function is typically used when dynamic access to PLC tags is required during operation, such as for HMI or OPC UA interfaces needing runtime tag references."}, "generated_keywords": ["asynchronous tag resolution", "symbolic tag name referencing", "runtime tag pointers", "dynamic PLC tag access", "typed tag references"]}
{"instruction_name": "MoveResolvedSymbolsToBuffer", "description": "A synchronous instruction used to read the values of tags referenced by ResolvedSymbol structures and write these values into a target buffer.", "parameters": {"Input": [{"name": "src", "type": "Array of ResolvedSymbol (SDT)", "description": "Array containing references to resolved tags to be read."}], "Output": [{"name": "dst", "type": "Array of BYTE", "description": "Target buffer where read tag values are written."}], "InOut": []}, "how_to_use": "Use after resolving symbolic tag names with 'ResolveSymbols'. Pass the array of references to 'src' and provide a BYTE array in 'dst' to receive the tag values. This reads tag values dynamically during runtime.", "example_code": "VAR\n  references : ARRAY[0..1] OF ResolvedSymbol;  // previously obtained\n  buffer : ARRAY[0..15] OF BYTE;\nEND_VAR\n\nMoveResolvedSymbolsToBuffer(src := references, dst => buffer);", "additional_info": "This instruction provides dynamic read access to tags during runtime using resolved references. Applicable under the same constraints as 'ResolveSymbols'.", "generated_brief": {"functional_summary": "Moves the current values of tags referenced by ResolvedSymbol structures into a specified byte buffer synchronously.", "usage_context": "Used after resolving symbolic tag names to dynamically read and store tag values during runtime for further processing or communication."}, "generated_keywords": ["read resolved symbols", "move tag values to buffer", "dynamic tag value reading", "runtime data access", "synchronous symbol reading"]}
{"instruction_name": "S_PEXT", "description": "The 'Assign extended pulse timer parameters and start' instruction starts a programmed timer when a positive signal edge is detected at the S parameter. The timer runs for the programmed time (TV) even if the signal state at the S parameter changes to '0'. As long as the timer runs, parameter Q returns the signal state '1'. When the timer has expired, parameter Q is reset to '0'. If the signal state at the S parameter changes from '0' to '1' while the timer is running, the timer is restarted with the time programmed in the TV parameter.", "parameters": {"Input": [{"name": "T_NO", "type": "TIMER, INT", "description": "The timer that is started. The number of timers depends on the CPU."}, {"name": "S", "type": "BOOL", "description": "Start input"}, {"name": "TV", "type": "S5TIME, WORD", "description": "Preset time value"}, {"name": "R", "type": "BOOL", "description": "Reset input"}], "Output": [{"name": "Q", "type": "BOOL", "description": "Status of the timer"}, {"name": "BI", "type": "WORD", "description": "Current dual-coded timer value"}], "InOut": []}, "how_to_use": "To use this instruction, assign the timer number (T_NO) and connect the start (S), time value (TV), and resetR) parameters. Monitor the output (Q) for the timer's status and (BI) for the current time value.", "example_code": "\"Tag_Result\" := S_PEXT(T_NO := \"Timer_1\", S := \"Tag_1\", TV := \"Tag_Number\", R := \"Tag_Reset\", Q => \"Tag_Status\", BI => \"Tag_Value\");", "additional_info": "In the time cell, the operating system reduces the time value in an interval specified by the time base by one unit until the value equals '0'. The decrementation is performed asynchronously to the user program.", "generated_brief": {"functional_summary": "The S_PEXT instruction triggers and manages an extended pulse timer that starts on a positive edge of the input signal and maintains its output for a preset time even if the input signal goes low, restarting if triggered again during timing.", "usage_context": "It is typically used in industrial control systems to reliably time pulse durations for processes requiring precise timing triggered by signal edges."}, "generated_keywords": ["extended pulse timer", "positive edge trigger", "preset timer duration", "timer restart on input", "industrial timing control"]}
{"instruction_name": "S_OFFDT", "description": "The 'Assign off-delay timer parameters and start' instruction starts a programmed timer when a negative signal edge is detected at the S parameter. The timer runs for the programmed time (TV). As long as the timer is running or parameter S returns signal state '1', then parameter Q has signal state '1'. If the timer expires and the signal state is '0' then parameter Q is reset to signal state '0'. If the signal state at parameter S changes from '0' to '1' while the timer is running, the timer is stopped. The timer is only restarted after a falling signal edge is detected at parameter S.", "parameters": {"Input": [{"name": "T_NO", "type": "TIMER, INT", "description": "The timer that is started. The number of timers depends on the CPU."}, {"name": "S", "type": "BOOL", "description": "Start input."}, {"name": "TV", "type": "S5TIME, WORD", "description": "Preset time value."}, {"name": "R", "type": "BOOL", "description": "Reset input."}], "Output": [{"name": "Q", "type": "BOOL", "description": "Status of the timer."}, {"name": "BI", "type": "WORD", "description": "Current dual-coded timer value."}], "InOut": []}, "how_to_use": "To use this instruction, specify the timer number, start input, preset time value, and reset signal. Monitor the output status and current timer value as per your application requirements.", "example_code": "\"Tag_Result\" := S_OFFDT(T_NO := \"Timer_1\",\n                                S := \"Tag_1\",\n                                TV := \"Tag_Number\",\n                                R := \"Tag_Reset\",\n                                Q => \"Tag_Status\",\n                                BI => \"Tag_Value\");", "additional_info": "The operating system reduces the time value in an interval specified by the time base until the value equals '0'. The resulting timer may thus be up to one time interval shorter than the desired time base.", "generated_brief": {"functional_summary": "The S_OFFDT instruction starts an off-delay timer on a falling edge of the input signal, keeping the output active during the timer duration or while the input is high, and stops or resets the timer based on signal changes or reset input.", "usage_context": "It is typically used in industrial automation to delay turning off outputs after an input signal transitions from high to low, such as in motor control or safety interlock timing applications."}, "generated_keywords": ["off-delay timer", "negative edge trigger", "timer reset", "signal state monitoring", "preset time delay"]}
{"instruction_name": "S_ODT", "description": "The \"Assign on-delay timer parameters and start\" instruction starts a programmed timer as on-delay when a positive signal edge is detected at the S parameter. The timer runs for the programmed time (TV) as long as the signal state of the S parameter is \"1\". If the timer expires correctly and parameter S still has signal state \"1\" then parameter Q returns signal state \"1\". If the signal state at the S parameter changes from \"1\" to \"0\" while the timer is running, the timer is stopped. In this case, output Q is reset to signal state \"0\". Internally, the time is made up of a time value and a time base and is programmed in the TV parameter. When the instruction starts, the programmed time value counts down to zero. The time base specifies the time increment by which the time value changes. The current time value is provided at the parameter BI. If the time is running and the signal state at input R changes from \"0\" to \"1\" then the current time value and the time base are also set to zero. In this case, the signal state at parameter Q is \"0\". The timer is reset if the signal state at the R parameter is \"1\", even if the timer is not running and the result of logic operation (RLO) at the S parameter is \"1\". The instruction data is updated with each access. It is therefore possible that the query of the data at the start of the cycle returns different values from those at the end of the cycle.", "parameters": {"Input": [{"name": "T_NO", "type": "TIMER, INT", "description": "The timer that is started. The number of timers depends on the CPU."}, {"name": "S", "type": "BOOL", "description": "Start input"}, {"name": "TV", "type": "S5TIME, WORD", "description": "Preset time value"}, {"name": "R", "type": "BOOL", "description": "Reset input"}], "Output": [{"name": "Q", "type": "BOOL", "description": "Status of the timer"}, {"name": "BI", "type": "WORD", "description": "Current dual-coded timer value"}, {"name": "Function value", "type": "S5TIME", "description": "Current timer value"}], "InOut": []}, "how_to_use": "Use this instruction to start an on-delay timer when a positive edge occurs at input S. The timer runs as long as S remains TRUE. If input R becomes TRUE, the timer is reset immediately regardless of S. The outputs Q and BI provide the timer status and current time respectively. Be aware that the timer value decrements asynchronously, so actual timing may be up to one time base interval shorter than programmed.", "example_code": "\"Tag_Result\" := S_ODT(T_NO := \"Timer_1\",\n                      S := \"Tag_1\",\n                      TV := \"Tag_Number\",\n                      R := \"Tag_Reset\",\n                      Q => \"Tag_Status\",\n                      BI => \"Tag_Value\");", "additional_info": "The time cell internally reduces the time value asynchronously by one unit per time base interval until zero, which means timer durations may be slightly shorter than the programmed time. The instruction updates its data with each access cycle, so data queried at the start and end of a cycle may differ.", "generated_brief": {"functional_summary": "The S_ODT instruction starts an on-delay timer on a rising edge at input S, runs as long as S is true, and resets the timer and output Q immediately if input R is activated.", "usage_context": "It is used in PLC programs to delay an output signal activation for a preset time duration while allowing dynamic reset control during industrial process automation."}, "generated_keywords": ["on-delay timer", "rising edge start", "timer reset input", "timer status output", "programmable time delay"]}
{"instruction_name": "S_PULSE", "description": "The \"Assign pulse timer parameters and start\" instruction starts the time programmed in the T_NO parameter when a change from \"0\" to \"1\" (positive signal edge) is detected in the result of logic operation (RLO) of the S parameter. The timer runs for the programmed time (TV) as long as the signal state of the S parameter is \"1\". When the signal state of the S parameter changes to \"0\" before the programmed time has expired, the timer is stopped and the Q parameter is reset to \"0\". Internally, the time is made up of a time value and a time base and is programmed in the TV parameter. When the instruction starts, the programmed time value counts down to zero. The time base specifies the time increment by which the time value changes. The current time value is provided at the parameter BI. If the timer is running and the signal state at input R changes to \"1\" then the current time value and the time base are also set to zero. If the timer is not running, the signal state \"1\" at the R input has no effect. Parameter Q returns signal state \"1\" as long as the timer is running and the signal state at parameter S is \"1\". When the signal state of the S parameter changes to \"0\" before the programmed time has expired, the Q parameter returns signal state \"0\". If the timer is reset by parameter R or if the timer has expired then parameter Q also returns signal state \"0\". The instruction data is updated with each access. It is therefore possible that the query of the data at the start of the cycle returns different values from those at the end of the cycle.", "parameters": {"Input": [{"name": "T_NO", "type": "TIMER, INT", "description": "The timer that is started. The number of timers depends on the CPU."}, {"name": "S", "type": "BOOL", "description": "Start input"}, {"name": "TV", "type": "S5TIME, WORD", "description": "Preset time value"}, {"name": "R", "type": "BOOL", "description": "Reset input"}], "Output": [{"name": "Q", "type": "BOOL", "description": "Status of the timer"}, {"name": "BI", "type": "WORD", "description": "Current dual-coded timer value"}, {"name": "Function value", "type": "S5TIME", "description": "Current timer value"}], "InOut": []}, "how_to_use": "Use the instruction to start a pulse timer when there is a positive edge on the start input (S). The timer runs for the preset time (TV) as long as S remains TRUE. If the start input S changes to FALSE before the timer expires, or if the reset input R is set TRUE, the timer stops and output Q resets to FALSE. The current timer value can be read from BI or the function value. Note that timer decrementation is asynchronous and may be up to one time interval shorter than the programmed base.", "example_code": "\"Tag_Result\" := S_PULSE(T_NO := \"Timer_1\", S := \"Tag_1\", TV := \"Tag_Number\", R := \"Tag_Reset\", Q => \"Tag_Status\", BI => \"Tag_Value\");", "additional_info": "In the time cell, the operating system reduces the time value in intervals specified by the time base asynchronously to the user program. The resulting timer can be up to one time interval shorter than the desired time base.", "generated_brief": {"functional_summary": "The S_PULSE instruction starts and runs a pulse timer upon a positive edge on the start input (S), maintaining the timer output (Q) as long as S is TRUE and stopping/resetting it if S goes FALSE or a reset input (R) is triggered before the preset time expires.", "usage_context": "It is typically used in industrial automation to precisely control timed pulse operations that require automatic timer start and stop based on input signal changes."}, "generated_keywords": ["pulse timer", "positive edge trigger", "timer start and stop", "preset time control", "reset input"]}
{"instruction_name": "S_ODTS", "description": "The \"Assign retentive on-delay timer parameters and start\" instruction starts a programmed timer when a positive signal edge is detected at the S parameter. The timer runs for the programmed time (TV) even if the signal state at the S parameter changes to \"0\". When the timer expires, the \"Q\" parameter returns signal state \"1\" regardless of the signal state of the \"S\" parameter. If the signal state at the S parameter changes from \"0\" to \"1\" while the timer is running, the timer is restarted with the programmed time TV. Signal state \"1\" at parameter R resets the current time value and time base to \"0\", independent of the signal state at parameter S. In this case, the signal state at parameter Q is \"0\". The instruction data is updated with each access, so the data queried at the start and end of the cycle may differ.", "parameters": {"Input": [{"name": "T_NO", "type": "TIMER, INT", "description": "The timer that is started. The number of timers depends on the CPU."}, {"name": "S", "type": "BOOL", "description": "Start input"}, {"name": "TV", "type": "S5TIME, WORD", "description": "Preset time value"}, {"name": "R", "type": "BOOL", "description": "Reset input"}], "Output": [{"name": "Q", "type": "BOOL", "description": "Status of the timer"}, {"name": "BI", "type": "WORD", "description": "Current dual-coded timer value"}], "InOut": []}, "how_to_use": "To use the S_ODTS instruction, assign a timer (T_NO), provide a start signal (S) that triggers on the positive edge, specify the preset time (TV), and optionally include a reset signal (R) to reset the timer. Monitor the Q output for the timer status and the BI output for the current timer value in dual-coded format. Note that the timer decrements asynchronously to the user program and the timing may be up to one interval shorter than the programmed time base. The instruction updates data each access; therefore, values can differ within a cycle.", "example_code": "\"Tag_Result\" := S_ODTS(T_NO := \"Timer_1\", S := \"Tag_1\", TV := \"Tag_Number\", R := \"Tag_Reset\", Q => \"Tag_Status\", BI => \"Tag_Value\");", "additional_info": "The operating system reduces the time value in intervals defined by the time base by one unit until zero asynchronously to the user program, possibly making the timer up to one time interval shorter than the desired time base. The current time value is stored dual-coded at parameter BI and also returned as the function value. For valid data types and memory areas refer to additional Siemens documentation.", "generated_brief": {"functional_summary": "The S_ODTS instruction starts a retentive on-delay timer on a rising edge of the start signal and maintains the timer value until it expires or is reset.", "usage_context": "It is typically used in industrial automation to control processes that require a delayed action with the ability to retain timing information across signal interruptions."}, "generated_keywords": ["retentive on-delay timer", "rising edge start", "timer reset input", "preset time delay", "dual-coded timer value"]}
{"instruction_name": "WAIT", "description": "The 'Configure time delay' instruction pauses the program execution for a specific period of time. You indicate the period of time in microseconds on the WT parameter of the instruction.", "parameters": {"Input": [{"name": "WT", "type": "INT", "description": "Time delay in microseconds (μs). You can configure time delays from -32768 up to 32767 microseconds."}], "Output": [], "InOut": []}, "how_to_use": "Specify the desired delay time in microseconds on the WT parameter. Remember that negative delay time will set the enable output ENO and the RLO signal state to FALSE.", "example_code": "", "additional_info": "The execution of the instruction can be interrupted by higher priority events and does not return any error information. In LAD or FBD, instructions linked to enable output ENO are not executed if a negative delay time is specified.", "generated_brief": {"functional_summary": "The WAIT instruction pauses program execution for a specified time delay in microseconds, controlled by the WT parameter.", "usage_context": "It is typically used in PLC programs to introduce precise short delays for timing control or synchronization in industrial automation processes."}, "generated_keywords": ["time delay", "program pause", "microsecond delay", "WAIT instruction", "timing control"]}
{"instruction_name": "DB_ANY_TO_VARIANT", "description": "The \"Convert DB_ANY to VARIANT\" instruction is used to generate a VARIANT tag from a data block that meets the requirements listed below. The operand at the IN parameter has the data type DB_ANY, which means that the data block does not have to be known when the program is created. The data block number is read during runtime.", "parameters": {"Input": [{"name": "IN", "type": "DB_ANY", "description": "Data block whose number is read. You can use a local or global tag at the IN parameter."}], "Output": [{"name": "ERR", "type": "INT", "description": "Error information"}, {"name": "RET_VAL", "type": "VARIANT", "description": "Function value that outputs the VARIANT tag. The tag itself must be declared as InOut in the block interface, but is declared as Output since the data flows into the tag."}], "In": []}, "how_to_use": "Use the DB_ANY_TO_VARIANT instruction by providing a DB_ANY type operand at the IN parameter referencing a data block. The instruction creates a VARIANT tag that addresses the data block. If the requirements are met or the data block does not exist, RET_VAL outputs NULL and ERR provides the corresponding error code. Declare the RET_VAL tag as InOut in the block interface despite it being an output parameter. If the error code 16#8155 occurs, follow workaround to familiarize the program with the user data type by creating an FC with a VARIANT InOut parameter and an FC that calls it, or call VariantGet or VariantPut after DB_ANY_TO_VARIANT.", "example_code": "#tempVARIANT := DB_ANY_TO_VARIANT(IN := \"InputDB\", ERR := \"Tag_Error\");", "additional_info": "Conversion is possible if the input data block is an instance data block of a PLC or system data type (SDT) or an ARRAY DB. Conversion is not possible for instance data blocks of function blocks or global data blocks. The ERR parameter codes indicate various status and error conditions, such as non-existent data blocks, short blocks, write protection, or incorrect data types. The RET_VAL parameter must be declared as InOut in the block interface to work properly. For the error code 16#8155, the data type must be introduced to the program with an additional FC, or by calling VariantGet or VariantPut afterwards.", "generated_brief": {"functional_summary": "The DB_ANY_TO_VARIANT instruction converts a data block reference of type DB_ANY into a VARIANT tag during runtime for flexible data handling.", "usage_context": "It is typically used when a program needs to dynamically access and manipulate data blocks whose identity is not known at compile time, such as instance data blocks or arrays."}, "generated_keywords": ["DB_ANY to VARIANT conversion", "dynamic data block access", "runtime data block referencing", "VARIANT tag creation", "flexible data handling"]}
{"instruction_name": "CTD", "description": "The 'Count down' instruction is used to decrement the value at the parameter CV. When the signal state of the CD parameter changes from '0' to '1' (positive signal edge), the instruction is executed and the current counter value of the CV parameter is decremented by one. Each time a positive signal edge is detected, the counter value is decremented until it reaches the low limit of the specified data type. When the low limit is reached, the signal state of the CD parameter no longer has an effect on the instruction.", "parameters": {"Input": [{"name": "CD", "type": "BOOL", "description": "Count input"}, {"name": "LD", "type": "BOOL", "description": "Load input"}, {"name": "PV", "type": "Integers", "description": "Value to which the CV output is set with LD = 1."}], "Output": [{"name": "Q", "type": "BOOL", "description": "Counter status"}, {"name": "CV", "type": "Integers, CHAR, WCHAR, DATE", "description": "Current counter value"}]}, "how_to_use": "You can declare an IEC counter in a separate data block or as a local tag in a program block. During the increment process, ensure the CD signal is managed correctly to avoid counting errors.", "example_code": "\"IEC_SCOUNTER_DB\".CTD(CD := \"Tag_Start\", LD := \"Tag_Load\", PV := \"Tag_PresetValue\", Q => \"Tag_Status\", CV => \"Tag_CounterValue\");", "additional_info": "Only use a counter at a single point in the program to avoid the risk of counting errors.", "generated_brief": {"functional_summary": "The CTD instruction decrements the current counter value by one on each rising edge of the count input signal until it reaches the predefined lower limit.", "usage_context": "It is typically used in industrial automation to count down events or items, such as tracking the remaining quantity of materials or timing operations that require decrementing counts."}, "generated_keywords": ["count down", "decrement counter", "rising edge detection", "counter limit", "PLC counter instruction"]}
{"instruction_name": "BITSUM", "description": "The \"Count number of set bits\" instruction is used to count the number of bits of an operand that are set to the signal state \"1\".", "parameters": {"Input": [{"name": "<Operand>", "type": "DWORD", "description": "Operand whose set bits are counted"}], "Output": [{"name": "Function value", "type": "INT", "description": "Result of the instruction"}], "InOut": []}, "how_to_use": "Use BITSUM instruction to count how many bits of a DWORD input are set to 1. Pass the operand as input and the function returns the count as an INT. Make sure the input is a DWORD located in one of the memory areas I, Q, M, D, L, or P.", "example_code": "\"Tag_Result\" := BITSUM(\"Tag_Input\");", "additional_info": "The error codes can be displayed as integer or hexadecimal values in the program editor. For information on toggling display formats, refer to the linked documentation.", "generated_brief": {"functional_summary": "The BITSUM instruction counts the number of bits set to 1 in a 32-bit DWORD operand and returns this count as an integer.", "usage_context": "It is typically used in industrial control systems to quickly determine how many binary flags or signals are active within a given memory word."}, "generated_keywords": ["count set bits", "bit counting", "DWORD operand", "binary flags count", "signal state tally"]}
{"instruction_name": "SEG", "description": "The 'Create bit pattern for seven-segment display' instruction is used to convert each of the four hexadecimal digits of the specified source word (IN) into an equivalent bit pattern for a 7-segment display. The result of the instruction is output in the double word on the OUT parameter.", "parameters": {"Input": [{"name": "IN", "type": "WORD", "description": "Source word with four hexadecimal digits"}], "Output": [{"name": "OUT", "type": "DWORD", "description": "Bit pattern for the seven-segment display"}], "InOut": []}, "how_to_use": "To use this instruction, assign a hexadecimal value to the IN parameter and the instruction will generate the corresponding bit pattern for a seven-segment display in the OUT parameter.", "example_code": "SEG(IN := \"Tag_Input\", OUT => \"Tag_Output\");", "additional_info": "Ensure that the input value is a valid 4-digit hexadecimal number to get the correct display output.", "generated_brief": {"functional_summary": "The SEG instruction converts a 4-digit hexadecimal input word into a corresponding bit pattern for a seven-segment display output.", "usage_context": "It is used in industrial control systems to visually represent hexadecimal values on seven-segment displays for monitoring or debugging purposes."}, "generated_keywords": ["seven-segment display", "hexadecimal to bit pattern", "display conversion", "PLC output encoding", "visual numeric representation"]}
{"instruction_name": "BCDCPL", "description": "The \"Create tens complement\" instruction is used to create the tens complement of a seven-digit BCD number specified by the operand. This instruction uses the following mathematical formula to calculate: 10000000 (as BCD) – 7-digit BCD value = Tens complement (as BCD).", "parameters": {"Input": [{"name": "Operand", "type": "Bit strings", "description": "7-digit BCD number; can be located in memory areas I, Q, M, D, L, P."}], "Output": [{"name": "Function value", "type": "DWORD", "description": "Result of the instruction; can be located in memory areas I, Q, M, D, L, P."}], "InOut": []}, "how_to_use": "Use the BCDCPL instruction by supplying a seven-digit BCD operand. The instruction returns the tens complement of the input BCD number as the function value. Ensure the input operand is correctly formatted as a 7-digit BCD number located in one of the supported memory areas (I, Q, M, D, L, P).", "example_code": "\"Tag_Result\" := BCDCPL(\"Tag_Input\");", "additional_info": "Valid data types and memory areas include I, Q, M, D, L, and P. Error codes can be displayed as integer or hexadecimal values in the program editor. Refer to the documentation for switching display formats valid data types.", "generated_brief": {"functional_summary": "The BCDCPL instruction calculates the tens complement of a seven-digit BCD number by subtracting it from 10,000,000 in BCD format.", "usage_context": "It is typically used in PLC programs for BCD arithmetic operations requiring the tens complement, such as in digital counters or industrial measurement conversions."}, "generated_keywords": ["tens complement", "BCD arithmetic", "seven-digit BCD", "PLC numeric processing", "BCD subtraction"]}
{"instruction_name": "DEMUX", "description": "The \"Demultiplex\" instruction transfers the value of the input parameter IN to a selected output parameter. The selection of the input parameter takes place independent of the parameter value K. The K parameter specifies the output parameter number to which the value of the input parameter IN is transferred. The other output parameters are not changed. Numbering starts at OUT0 and continues consecutively with each new output. You can declare a maximum of 32 output parameters. If the value of the K parameter is greater than the number of output parameters, the content of the IN input parameter is copied to the OUTELSE output parameter and the signal state \"0\" is assigned to the enable output ENO. The function value is invalid if K is greater than the number of available outputs or if errors occurred during the instruction execution.", "parameters": {"Input": [{"name": "K", "type": "Integers", "description": "Specifies the output to which the input value (IN) will be copied. If K = 0 => Parameter OUT0, if K = 1 => Parameter OUT1, etc."}, {"name": "IN", "type": "Binary numbers, integers, floating-point numbers, timers, STRING, CHAR, WCHAR, TOD, DATE, DT", "description": "Input value"}], "Output": [{"name": "OUT0", "type": "Binary numbers, integers, floating-point numbers, timers, STRING, CHAR, WCHAR, TOD, DATE, DT", "description": "First output"}, {"name": "OUT1", "type": "Binary numbers, integers, floating-point numbers, timers, STRING, CHAR, WCHAR, TOD, DATE, DT", "description": "Second output"}, {"name": "OUTn", "type": "Binary numbers, integers, floating-point numbers, timers, STRING, CHAR, WCHAR, TOD, DATE, DT", "description": "Optional outputs"}, {"name": "OUTELSE", "type": "Binary numbers, integers, floating-point numbers, timers, STRING, CHAR, WCHAR, TOD, DATE, DT", "description": "Output to which the value at input IN is copied if K > n."}], "InOut": []}, "how_to_use": "Assign the input value to IN and specify the output using the integer K (starting at 0 for OUT0). If K is out of range (less than 0 or greater than the number of outputs), the input value IN is transferred to OUTELSE. Ensure that IN and all outputs have the same data type to avoid implicit conversion and data changes. You may declare up to 32 output parameters numbered consecutively from OUT0 to OUTn.", "example_code": "DEMUX(K := Tag_Number,\n      IN := Tag_Value,\n      OUT0 := Tag_1,\n      OUT1 := Tag_2,\n      OUTELSE := Tag_3);", "additional_info": "If the K parameter value is outside the range of available outputs (< 0 or > available outputs), the input is routed to OUTELSE and ENO signal is set to 0. Data types of IN and all outputs must match to prevent unintentional conversion. The number of outputs can be up to 32. The ENO output indicates the valid execution of the instruction.", "generated_brief": {"functional_summary": "The DEMUX instruction routes the input value IN to one selected output based on the integer K, leaving other outputs unchanged and sending the input to OUTELSE if K is out of range.", "usage_context": "It is used in PLC programs when a single input value needs to be conditionally directed to one of multiple outputs depending on a control selector, facilitating flexible data distribution in automation logic."}, "generated_keywords": ["demultiplex", "conditional output routing", "input to selected output", "output selection by index", "data distribution"]}
{"instruction_name": "EXP", "description": "The \"Form exponential value\" instruction calculates the exponent from the base e (e = 2.718282) and the input value and saves the result in the specified operand.", "parameters": {"Input": [{"name": "<Expression>", "type": "Floating-point numbers", "description": "Input value"}], "Output": [{"name": "Function value", "type": "Floating-point numbers", "description": "Exponential value of the input value"}], "InOut": []}, "how_to_use": "Use the EXP function to calculate the natural exponential (base e) of a floating-point input expression. Pass the input value as the parameter, and assign the result to the desired output operand of floating-point type.", "example_code": "\"Tag_Result1\" := EXP(\"Tag_Value\");\n\"Tag_Result2\" := EXP(\"Tag_Value1\" / \"Tag_Value2\");", "additional_info": "Valid input and output operands can be located in memory areas I, Q, M, D, L, P. Refer to the connected memory areas and data type documentation for detailed constraints.", "generated_brief": {"functional_summary": "The EXP instruction calculates the natural exponential (e raised to the power of the input floating-point value) and stores the result in the specified operand.", "usage_context": "This function is typically used in PLC programs to perform exponential calculations in processes such as growth modeling, decay analysis, or any control logic requiring natural exponentiation."}, "generated_keywords": ["natural exponential calculation", "floating-point exponentiation", "base e power", "EXP function", "exponential value computation"]}
{"instruction_name": "GET_ERR_ID", "description": "The \"Get error ID locally\" instruction is used to query the occurrence of errors within a block. This is usually to access error. If the system reports during the block processing errors within the block execution since the last execution of the instruction, the instruction outputs the error ID of the first error that occurred. The error ID can only be saved in operands of the WORD data type. If several errors occur in the block, the error ID of the next error to occur in the instruction is output only after the first error that occurred has been remedied.", "parameters": {"Input": [], "Output": [{"name": "Function value", "type": "WORD", "description": "Error ID"}], "InOut": []}, "how_to_use": "Insert the GET_ERR_ID instruction in the program code of a block to enable local error handling. The operand to store the error ID must be of the WORD data type and can be declared in the Temp section or reset to 0 before calling the instruction. The output of the instruction changes only if error information is present and outputs the first error ID detected since the last call. After the error is remedied, it can output the next error. Using this instruction ignores any predefined system reactions to errors in the block.", "example_code": "#TagOut := #Field[#index] * REAL#40.5;\n\n#TagID := GET_ERR_ID();\n\nIF #TagID = 16#2522 THEN\n   MOVE_BLK(IN := #TagArrayIn[0],\n            COUNT := 1,\n            OUT => #TagArrayOut[1]);\nEND_IF;", "additional_info": "The <Operand> is only changed if error information is present. To reset it to 0 after handling the error, either declare the operand in the Temp section of the block interface or reset it before calling GET_ERR_ID. The instruction enables local error handling and suppresses predefined system reactions to errors. The error codes can be displayed as integer or hexadecimal values in the program editor.", "generated_brief": {"functional_summary": "GET_ERR_ID retrieves the ID of the first error that has occurred locally within a block since its last call, allowing step-by-step error identification and handling.", "usage_context": "It is used within a PLC program block to perform local error handling by monitoring and responding to specific errors, bypassing predefined system error reactions."}, "generated_keywords": ["local error handling", "retrieve error ID", "block error monitoring", "step-by-step error identification", "suppress system error reactions"]}
{"instruction_name": "GET_ERROR", "description": "The 'Get error locally' instruction is used to query the occurrence of errors within a program block. This normally involves programming or access errors. If the system reports an error during the execution of the program block, detailed information is output at the <Operand> on the first error to occur during the execution of the block since the last execution of the instruction.", "parameters": {"Input": [{"name": "<Operand>", "type": "ErrorStruct", "description": "Information about errors that have occurred."}], "Output": [], "InOut": []}, "how_to_use": "As soon as you insert the instruction in the program code of a program block, the local error handling is activated and default system reactions are ignored when errors occur.", "example_code": "GET_ERROR(#Error);", "additional_info": "The <Operand> is only changed if error information is present. To set the operand back to '0' after handling the error, declare the operand in theTemp' section of the block interface or reset the operand to '0' before calling the instruction.", "generated_brief": {"functional_summary": "The GET_ERROR instruction retrieves detailed information about the first error that occurs during the execution of a program block since its last call, enabling local error handling.", "usage_context": "It is used within program blocks when custom error processing is required to override default system reactions and manage programming or access errors internally."}, "generated_keywords": ["local error handling", "get first error", "program block error query", "override system error reaction", "error information retrieval"]}
{"instruction_name": "MAX", "description": "The 'Get maximum' instruction compares the values of the available inputs and returns the greatest value as the result.", "parameters": {"Input": [{"name": "IN1", "type": "Integers, floating-point numbers, TIME, TOD, DATE, DTL", "description": "First input value"}, {"name": "IN2", "type": "Integers, floating-point numbers, TIME, TOD, DATE, DTL", "description": "Second input value"}, {"name": "INn", "type": "Integers, floating-point numbers, TIME, TOD, DATE, DTL", "description": "Additionally inserted inputs whose values are to be compared"}], "Output": [{"name": "Function value", "type": "Integers, floating-point numbers, TIME, TOD, DATE, DTL", "description": "Result of the instruction"}], "InOut": []}, "how_to_use": "A minimum of two and a maximum of 32 inputs can be specified at the instruction.", "example_code": "\"Tag_Result\" := MAX(IN1 := \"Tag_Value1\", IN2 := \"Tag_Value2\", IN3 := \"Tag_Value3\");", "additional_info": "The data types TOD, LTOD, DATE and LDT can only be used if the IEC test is not enabled. The result is invalid if any of the following conditions are met: if the implicit conversion of the data types fails during execution of the instruction or if a floating-point number has an invalid value.", "generated_brief": {"functional_summary": "The MAX instruction compares multiple input values and returns the greatest one as the result.", "usage_context": "It is typically used in PLC programs to determine the highest value among several inputs, such as monitoring sensors or process variables."}, "generated_keywords": ["maximum value", "compare inputs", "return greatest", "multiple inputs", "value selection"]}
{"instruction_name": "MIN", "description": "The \"Get minimum\" instruction compares the values of the available inputs and returns the lowest value as the result. A minimum of two and a maximum of 32 inputs can be specified at the instruction. The result is invalid if any of the following conditions are met: The implicit conversion of the data types fails during execution of the instruction; A floating-point number has an invalid value.", "parameters": {"Input": [{"name": "IN1", "type": "Integers, floating-point numbers, TIME, TOD, DATE, DTL", "description": "First input value"}, {"name": "IN2", "type": "Integers, floating-point numbers, TIME, TOD, DATE, DTL", "description": "Second input value"}, {"name": "INn", "type": "Integers, floating-point numbers, TIME, TOD, DATE, DTL", "description": "Additionally inserted inputs whose values are to be compared"}], "Output": [{"name": "Function value", "type": "Integers, floating-point numbers, TIME, TOD, DATE, DTL", "description": "Result of the instruction"}], "InOut": []}, "how_to_use": "Use the MIN instruction to compare two to 32 input values and return the smallest one. Ensure all inputs are compatible data types and that no floating-point inputs have invalid values. The instruction chooses the minimum value among all specified inputs and outputs it as the function value. The data types TOD, LTOD, DATE, and LDT can only be used if the IEC test is not enabled.", "example_code": "\"Tag_Result\" := MIN(IN1 := \"Tag_Value1\",\n                    IN2 := \"Tag_Value2\",\n                    IN3 := \"Tag_Value3\");", "additional_info": "The data types TOD, LTOD, DATE, and LDT can only be used if the IEC test is not enabled. The result is invalid if implicit data type conversion fails or if a floating-point input has an invalid value.", "generated_brief": {"functional_summary": "The MIN instruction compares between two and 32 input values and returns the smallest valid value among them.", "usage_context": "It is used in PLC programs to determine the minimum value from a set of numerical or time-related inputs, typically for decision-making or control processes requiring threshold or limit evaluation."}, "generated_keywords": ["minimum value", "compare inputs", "numeric and time types", "multi-input evaluation", "data type compatibility"]}
{"instruction_name": "INIT_RD", "description": "The \"Initialize all retain data\" instruction is used to reset the retentive data of all data blocks, bit memories and SIMATIC timers and counters at the same time. The instruction can only be executed within a startup OB because the execution exceeds the program cycle duration.", "parameters": {"Input": [{"name": "REQ", "type": "BOOL", "description": "If the input \"REQ\" has the signal state \"1\", all retentive data are reset."}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Error information: If an error occurs during the execution of the instruction, an error code is output at the RET_VAL parameter."}], "InOut": []}, "how_to_use": "Use the instruction within a startup OB. Set the input REQ to '1' to reset all retentive data of all data blocks, bit memories and SIMATIC timers and counters. Monitor the RET_VAL output for error codes. The instruction should not be used outside of a startup OB due to execution time exceeding the program cycle duration.", "example_code": "\"Tag_Result\" := INIT_RD(\"Tag_REQ\");", "additional_info": "RET_VAL error codes include 0000 for no error and 80B5 indicating the instruction was not executed within a startup OB. Error codes may be displayed as integers or hexadecimal values. Refer to GET_ERR_ID and other documentation for detailed error handling.", "generated_brief": {"functional_summary": "The INIT_RD instruction resets all retentive data of data blocks, bit memories, and SIMATIC timers and counters simultaneously when triggered.", "usage_context": "It is used within a startup organization block to clear retain data during system initialization, as it cannot be executed within a normal program cycle."}, "generated_keywords": ["initialize retain data", "reset retentive memory", "startup OB execution", "SIMATIC timers counters reset", "error monitoring RET_VAL"]}
{"instruction_name": "RUNTIME", "description": "The 'Measure program runtime' instruction is used to measure the runtime of the entire program, individual blocks or command sequences.", "parameters": {"Input": [{"name": "<Operand>", "type": "LREAL", "description": "The content is for internal purposes only."}], "Output": [{"name": "Function value", "type": "LREAL", "description": "Returns the measured runtime in seconds."}], "InOut": [{"name": "<Operand>", "type": "LREAL", "description": "The content is for internal purposes only."}]}, "how_to_use": "Call the instruction 'Measure program runtime' in OB1 to measure the runtime of the entire program. For measuring the runtime of individual blocks or command sequences, use three separate networks: the first call starts the measurement, the second executes the block/sequence, and the third call completes the measurement.", "example_code": "\"Tag_Result\" := RUNTIME(\"Tag_Memory\");\n\"Best_before_date_DB\" ();\n\"Tag_Result\" := RUNTIME(\"Tag_Memory\");", "additional_info": "The runtime of a command sequence cannot be determined exactly, as the sequence of instructions within a command sequence is changed during optimized compilation. If the internal high-frequency counter overruns, the instruction returns values <= 0.0, which can occur up to once per minute for S7-1200 CPUs with firmware version <V4.2.", "generated_brief": {"functional_summary": "The RUNTIME instruction measures the execution time of the entire program, individual blocks, or command sequences in seconds.", "usage_context": "It is used in OB1 or specific network sequences to evaluate and optimize the performance of PLC program components during runtime."}, "generated_keywords": ["measure program runtime", "execution time measurement", "PLC performance monitoring", "block runtime measurement", "command sequence timing"]}
{"instruction_name": "GATHER", "description": "\"Merge individual bits into a bit sequence\" instruction merges the bits from an ARRAY of BOOL, an anonymous STRUCT or a PLC data type exclusively with Boolean elements into a bit sequence. The bit sequence is saved in a tag of the data type BYTE, WORD, DWORD or LWORD.", "parameters": {"Input": [{"name": "IN", "type": "ARRAY[*] of BOOL, STRUCT or PLC data type (*: 8, 16, 32 or 64 elements)", "description": "ARRAY, STRUCT or PLC data type, the bits of which are merged into a bit sequence. The values must not be located in the I/O area or in the DB of a technology object."}], "Output": [{"name": "OUT", "type": "BYTE, WORD, DWORD, LWORD", "description": "Merged bit sequence, saved in a tag."}], "InOut": []}, "how_to_use": "Use the GATHER instruction by providing an ARRAY of BOOL, STRUCT, or a user-defined type with only BOOL elements as input (IN). The number of BOOL elements must exactly match the size of the output data type (BYTE = 8 bits, WORD = 16 bits, DWORD = 32 bits, LWORD = 64 bits). The merged bit sequence is output in a corresponding BYTE, WORD, DWORD, or LWORD tag (OUT). Multi-dimensional arrays are not permitted. Ensure that input values are not located in the I/O area or in the DB of a technology object. The enable output ENO signals '0' if the enable input EN is '0', or if input element count mismatches, or insufficient bits are available.", "example_code": "GATHER(IN := #SourceArray, OUT => #DestinationWord);", "additional_info": "The instruction is available on S7-1200 CPUs starting with firmware version >4.2 and on S7-1500 CPUs starting with firmware version 2.1. The bit elements must precisely match the output data type size; otherwise, the bits are not transferred and ENO returns '0'. Multi-dimensional arrays of BOOL are not supported.", "generated_brief": {"functional_summary": "The GATHER instruction merges individual Boolean elements from an array, structure, or user-defined type into a contiguous bit sequence stored in a BYTE, WORD, DWORD, or LWORD data type.", "usage_context": "It is typically used in PLC programming to compact multiple discrete Boolean signals into a single word for efficient data handling or communication."}, "generated_keywords": ["merge Boolean array to bit sequence", "compact BOOL elements into word", "convert BOOL structure to BYTE/WORD", "bit packing from BOOL array", "GATHER instruction PLC bit merge"]}
{"instruction_name": "GATHER_BLK", "description": "The 'Merge individual bits into multiple elements of an ARRAY of bit sequence' instruction merges the bits from an ARRAY of BOOL, an anonymous STRUCT or a PLC data type exclusively with Boolean elements into one or multiple elements of an ARRAY of <bit sequence>. At the COUNT_OUT parameter you specify how many elements of the destination ARRAY are going to be written.", "parameters": {"Input": [{"name": "IN", "type": "ARRAY[*] of BOOL, STRUCT, PLC data type", "description": "ARRAY of BOOL, STRUCT or PLC data type whose bits are merged (source ARRAY). The values must not be located in the I/O area or in the DB of a technology object."}, {"name": "COUNT_OUT", "type": "USINT, UINT, UDINT", "description": "Counter how many elements of the target ARRAY are to be described. The value must not be in the I/O area or in the database of a technology object."}], "Output": [{"name": "OUT", "type": "ARRAY[*] of BYTE, WORD, DWORD", "description": "ARRAY of <bit sequence> to which the bits are saved (destination ARRAY)."}], "InOut": []}, "how_to_use": "Ensure the source ARRAY has the correct structure and that the destination ARRAY has enough elements to store the merged bits. Activate the instruction by providing a high signal to the EN input.", "example_code": "GATHER_BLK(IN := #SourceArrayBool[0], COUNT_OUT := #CounterOutput, OUT => #DestinationArrayWord[2]);", "additional_info": "This instruction can be used with a CPU of the S7-1200 series as of firmware version >4.2, and for a CPU of the S7-1500 series as of firmware version 2.1.", "generated_brief": {"functional_summary": "GATHER_BLK merges individual bits from an array of BOOLs or boolean-based structures into multiple elements of an array of bit sequences like BYTE, WORD, or DWORD.", "usage_context": "This function is typically used in PLC programs when compacting or packing multiple boolean signals into fewer data words for efficient processing or communication."}, "generated_keywords": ["merge boolean array bits", "pack bits into bit sequence array", "bitwise array compaction", "array of BOOL to BYTE WORD DWORD", "PLC bit sequence merging"]}
{"instruction_name": "MCTA", "description": "The 'Motor control-timer alarm' instruction is used to accumulate the time from the point at which one of the command inputs (opening or closing) is switched on. The time is accumulated until the preset time is exceeded or the relevant feedback input indicates that the device has executed the requested operation within the specified time. If the preset time is exceeded before the feedback is received, the corresponding alarm is triggered.", "parameters": {"Input": [{"name": "O_CMD", "type": "BOOL", "description": "\"Open\" command input"}, {"name": "C_CMD", "type": "BOOL", "description": "\"Close\" command input"}, {"name": "S_CMD", "type": "BOOL", "description": "\"Stop\" command input"}, {"name": "O_FB", "type": "BOOL", "description": "Feedback input when opening"}, {"name": "C_FB", "type": "BOOL", "description": "Feedback input when closing"}], "Output": [{"name": "OO", "type": "BOOL", "description": "\"Open\" output"}, {"name": "CO", "type": "BOOL", "description": "\"Close\" output"}, {"name": "OA", "type": "BOOL", "description": "Alarm output when opening"}, {"name": "CA", "type": "BOOL", "description": "Alarm output when closing"}, {"name": "Q", "type": "BOOL", "description": "A signal state of \"0\" indicates an error condition."}], "InOut": []}, "how_to_use": "You can initialize static parameters in the data block.", "example_code": "\"MCAT_DB\"(O_CMD := \"Tag_Input_O_CMD\", C_CMD := \"Tag_Input_C_CMD\", S_CMD := \"Tag_Input_S_CMD\", O_FB := \"Tag_Input_O_FB\", C_FB := \"Tag_Input_C_FB\", OO => \"Tag_OutputOpen\", CO => \"Tag_OutputClosed\", OA => \"Tag_Output_OA\", CA => \"Tag_Output_CA\", Q => \"Tag_Output_Q\");", "additional_info": "The static parameters are not visible when calling the instruction in the program. These are saved in the instance of the instruction.", "generated_brief": {"functional_summary": "The MCTA instruction monitors the operation time of motor commands to open or close a device, triggering an alarm if the action does not complete within the preset time or if a stop command is issued.", "usage_context": "It is typically used in industrial automation to ensure timely and safe motor-driven actuation of devices like valves or doors, providing alarms when mechanical feedback is not received as expected."}, "generated_keywords": ["motor control timer", "command feedback monitoring", "operation timeout alarm", "open close motor control", "stop command handling"]}
{"instruction_name": "MUX", "description": "The \"Multiplex\" instruction copies the value of a selected input parameter and issues it. You can use the parameter K to determine the number of the input parameter whose value will be. Numbering starts at IN0 and is incremented continuously with each new input. You can declare a maximum of 32 inputs. Numerical data types and time data types are permitted at the inputs. All tags with assigned parameters must be of the same data type. The function value is invalid if errors occurred during execution of the instruction or if the input at the K parameter is located outside the available inputs and the INELSE input is not used.", "parameters": {"Input": [{"name": "K", "type": "Integers", "description": "Specifies the parameter whose content is to be transferred. If K = 0 => Parameter IN0; If K = 1 => Parameter IN1, etc."}, {"name": "IN0", "type": "Binary numbers, integers, floating-point numbers, timers, STRING, CHAR, WCHAR, TOD, DATE, DT", "description": "First input value"}, {"name": "IN1", "type": "Binary numbers, integers, floating-point numbers, timers, STRING, CHAR, WCHAR, TOD, DATE, DT", "description": "Second input value"}, {"name": "INn", "type": "Binary numbers, integers, floating-point numbers, timers, STRING, CHAR, WCHAR, TOD, DATE, DT", "description": "Optional input values"}, {"name": "INELSE", "type": "Binary numbers, integers, floating-point numbers, timers, STRING, CHAR, WCHAR, TOD, DATE, DT", "description": "Specifies the value to be copied when K <> n."}], "Output": [{"name": "Function value", "type": "Binary numbers, integers, floating-point numbers, timers, STRING, CHAR, WCHAR, TOD, DATE, DT", "description": "Result of the"}], "InOut": []}, "how_to_use": "Use the MUX instruction to select one input value from multiple inputs based on the index K. Numbering of inputs starts at IN0. You can specify an INELSE input value if K is outside the range of available inputs to avoid invalid values. Ensure all inputs have the same data type. If K is a negative integer and a valid data type tag is at the input parameters, the value of that tag is changed.", "example_code": "\"Tag_Result\" := MUX(K := \"Tag_Number\",\n                IN0 := \"Tag_1\",\n                IN1 := \"Tag_2\",\n                INELSE := \"Tag_3\");", "additional_info": "The result is invalid if execution errors occur or if K is outside valid range and no INELSE value is provided. Up to 32 inputs can be declared. Refer to valid data types and memory areas for compatibility.", "generated_brief": {"functional_summary": "The MUX instruction selects and outputs the value from one of multiple input parameters based on the integer index K, with an optional default output if K is out of range.", "usage_context": "It is used in PLC programs to dynamically choose among several inputs of the same data type, facilitating conditional data routing or selection in control logic."}, "generated_keywords": ["multiplexer", "input selection", "dynamic routing", "conditional data output", "index-based input choice"]}
{"instruction_name": "SCATTER_BLK", "description": "The instruction parses one or more elements of an ARRAY of BYTE, WORD, DWORD or LWORD into bits and saves them in an ARRAY of BOOL, an anonymous STRUCT or a PLC data type exclusively with Boolean elements. At the COUNT_IN parameter you specify how many elements of the source ARRAY are going to be parsed.", "parameters": {"Input": [{"name": "IN", "type": "ARRAY[*] of BYTE, WORD, DWORD, LWORD", "description": "ARRAY of <bit sequence> that is parsed. The values must not be located in the I/O area or in the DB of a technology object."}, {"name": "COUNT_IN", "type": "USINT, UINT, UDINT", "description": "Counter for the number of elements of the source ARRAY that are going to be parsed. The value must not be in the I/O area or in the database of a technology object."}], "Output": [{"name": "OUT", "type": "ARRAY[*] of BOOL, STRUCT, PLC data type", "description": "ARRAY, STRUCT or PLC data type in which the individual bits are stored."}], "InOut": []}, "how_to_use": "To use the SCATTER_BLK instruction, set the IN parameter with the source ARRAY and specify how many elements to parse using COUNT_IN. Ensure the OUT parameter is correctly set up to hold the parsed bits.", "example_code": "SCATTER_BLK(IN := #SourceArrayWord[2], COUNT_IN := #CounterInput, OUT => #DestinationArrayBool[0]);", "additional_info": "The instruction can be used with a CPU of the S7-1200 series as of firmware version >4.2, and for a CPU of the S7-1500 series as of firmware version 2.1.", "generated_brief": {"functional_summary": "SCATTER_BLK parses specified elements of a BYTE, WORD, DWORD, or LWORD array into individual bits and stores them in a BOOL array, STRUCT, or similar Boolean-only data type.", "usage_context": "It is typically used in PLC programs to convert grouped bit data into separate Boolean variables for easier bit-level processing and control logic."}, "generated_keywords": ["array bit parsing", "byte word dword lword conversion", "boolean array output", "bit extraction", "PLC data type parsing"]}
{"instruction_name": "SCATTER", "description": "The \"Parse the bit sequence into individual bits\" instruction parses a tag of the BYTE, WORD, DWORD or LWORD data type into individual bits and saves them in an ARRAY of BOOL, an anonymous STRUCT or a PLC data type exclusively with Boolean elements. The ARRAY, the anonymous STRUCT or the PLC data type must have exactly the number of elements that is specified by the bit sequence (BYTE = 8, WORD = 16, DWORD = 32, LWORD = 64). Use of multi-dimensional ARRAY of BOOL is not permitted. The instruction can be used with S7-1200 CPUs starting from firmware version >4.2 and S7-1500 CPUs starting from firmware version 2.1. The enable output ENO returns 0 if EN = 0 or if the output data structure does not have enough BOOL elements.", "parameters": {"Input": [{"name": "IN", "type": "BYTE, WORD, DWORD, LWORD", "description": "Bit sequence that is parsed. The values must not be located in the I/O area or in the DB of a technology object."}], "Output": [{"name": "OUT", "type": "ARRAY[*] of BOOL, STRUCT or PLC data type", "description": "ARRAY, STRUCT or PLC data type in which the individual bits are stored. Must have exactly 8, 16, 32 or 64 elements according to the bit sequence size."}], "InOut": []}, "how_to_use": "Initialize the input tag with a BYTE, WORD, DWORD or LWORD value representing the bit sequence. Initialize the output tag as an ARRAY of BOOL, anonymous STRUCT or a UDT containing exclusively BOOL elements matching the length of the bit sequence (8 for BYTE, 16 for WORD, etc.). Call SCATTER instruction with these parameters to parse the bit sequence into individual bits, which are stored in the output structure. Do not use multi-dimensional BOOL arrays for output. Ensure firmware compatibility: S7-1200 (v >4.2), S7-1500 (v >=2.1).", "example_code": "SCATTER(IN := #SourceWord, OUT => #DestinationArray);", "additional_info": "The enable output ENO returns 0 if the enable input EN is 0 or if the output structure does not have the required number of BOOL elements. The input bit sequence must not be located in the I/O area or in a DB of a technology object.", "generated_brief": {"functional_summary": "The SCATTER instruction parses a BYTE, WORD, DWORD, or LWORD bit sequence into individual Boolean elements stored in an ARRAY, STRUCT, or PLC data type with matching length.", "usage_context": "It is used when individual bits of a multi-bit value need to be accessed or manipulated separately in PLC programs, especially on compatible S7-1200 and S7-1500 CPUs."}, "generated_keywords": ["parse bit sequence", "bit to boolean array", "BYTE WORD DWORD LWORD parsing", "scatter bits to structure", "S7-1200 S7-1500 compatibility"]}
{"instruction_name": "TypeOfDB", "description": "The \"Query data type of a DB\" instruction is used to query which data type the data block has that the tag of the DB_ANY data type addresses. You can compare the data type of the DB addressed by the tag <Operand> either with the data type of another tag or directly with a data type for \"Equal\" or \"Not equal\".", "parameters": {"Input": [{"name": "<Operand>", "type": "DB_ANY", "description": "Operand to query"}], "Output": [], "InOut": []}, "how_to_use": "You can only use the \"Query data type of a DB\" instruction within an IF or CASE instruction.", "example_code": "IF TypeOfDB(#InputDBAny) = TO_SpeedAxis THEN\n\"TagOut\" := 1;\nEND_IF;", "additional_info": "The \"TagOut\" output is set if the data type of the #InputDBAny operand addressed DB is equal to the TO_SpeedAxis data type. The \"TagOut\" output is not set in certain conditions such as if the number of the data block is \"0\", the data block does not exist, or if the data block is an ARRAY DB.", "generated_brief": {"functional_summary": "The TypeOfDB instruction queries and compares the data type of a data block addressed by a DB_ANY tag to determine if it matches a specified data type.", "usage_context": "It is typically used within IF or CASE instructions to conditionally execute code based on the data of the targeted data block."}, "generated_keywords": ["query DB data type", "compare data block type", "DB_ANY operand", "conditional type check", "IF CASE usage"]}
{"instruction_name": "PEEK", "description": "The 'Read memory address' instruction is used to read a memory address from a standard memory area without specifying a data type.", "parameters": {"Input": [{"name": "AREA", "type": "BYTE", "description": "The following areas can be selected: 16#81: Input, 16#82: Output, 16#83: Bit memory, 16#84: DB, 16#1: Peripheral input (S7-1500 only)"}, {"name": "DBNUMBER", "type": "DINT, DB_ANY", "description": "Number of the data block if AREA = DB, otherwise '0'"}, {"name": "BYTEOFFSET", "type": "DINT", "description": "Address to read from. Only the 16 least significant bits are used."}, {"name": "_<data type>", "type": "-", "description": "Data type of the function value: You can specify the data type of the instruction explicitly using '_'. If you do not specify the data type explicitly, it will be determined by the utilized tags or type-coded constants. If you neither specify the data type explicitly nor specify defined tags or type-coded constants, the default data type will be used."}], "Output": [{"name": "Function value", "type": "Bit strings", "description": "Result of the instruction"}]}, "how_to_use": "To read from a specific memory area, provide the appropriate AREA, DBNUMBER, and BYTEOFFSET parameters. The function returns the value at the specified address.", "example_code": "\"Tag_Result1\" := PEEK(AREA := \"Tag_Area\", DBNUMBER := \"Tag_DBNumber\", BYTEOFFSET := \"Tag_Byte\");", "additional_info": "If you read the memory address from the input, output or bit memory areas, you must assign the DBNUMBER parameter the value '0', as the instruction is invalid otherwise.", "generated_brief": {"functional_summary": "The PEEK instruction reads data from a specified memory area and address in a PLC without requiring an explicit data type.", "usage_context": "It is typically used to access raw memory contents from inputs, outputs, bit memory, or data blocks for diagnostics or low-level data manipulation."}, "generated_keywords": ["read memory address", "access raw memory", "memory area read", "PEEK instruction", "PLC diagnostics"]}
{"instruction_name": "PEEK_BOOL", "description": "The 'Read memory bit' instruction is used to read a memory bit from a standard memory area without specifying a data type.", "parameters": {"Input": [{"name": "AREA", "type": "BYTE", "description": "The following areas can be selected: 16#81: Input, 16#82: Output, 16#83: Bit memory, 16#84: DB, 16#1: Peripheral input (S7-1500 only)"}, {"name": "DBNUMBER", "type": "DINT, DB_ANY", "description": "Number of the data block if AREA = DB, otherwise '0'"}, {"name": "BYTEOFFSET", "type": "DINT", "description": "Address to read from. Only the 16 least significant bits are used."}, {"name": "BITOFFSET", "type": "INT", "description": "Bit to be read from."}], "Output": [{"name": "Function value", "type": "BOOL", "description": "Result of the instruction."}], "InOut": []}, "how_to_use": "If you read memory bit from the input, output or bit memory areas, you must assign the DBNUMBER parameter the value '0', as the instruction is invalid otherwise.", "example_code": "\"Tag_Result\" := PEEK_BOOL(AREA := \"Tag_Area\", DBNUMBER := \"Tag_DBNumber\", BYTEOFFSET := \"Tag_Byte\", BITOFFSET := \"Tag_Bit\");", "additional_info": "The instruction reads the value of memory bit from a specified area and returns the result as a boolean value.", "generated_brief": {"functional_summary": "PEEK_BOOL reads a specific bit from a defined memory area in the PLC and returns its boolean value.", "usage_context": "It is typically used to access individual bits from inputs, outputs, bit memories, or data blocks when precise bit-level information is required without specifying a data type."}, "generated_keywords": ["read memory bit", "boolean bit access", "memory area bit read", "bit-level data read", "PEEK_BOOL instruction"]}
{"instruction_name": "RE_TRIGR", "description": "The 'Restart cycle monitoring time' instruction is used to restart the cycle monitoring time of the CPU. The cycle monitoring time then restarts with the time you have set in the CPU configuration.", "parameters": {"Input": [], "Output": [], "InOut": []}, "how_to_use": "This instruction can be called in a program cycle organization block. Ensure compatibility with the firmware version to avoid execution issues.", "example_code": "", "additional_info": "For S7-1200 series CPUs with firmware versions <= 2.2, the instruction can only be called in a priority 1 organization block. For firmware versions >= 2.2, it can be called regardless of priority.", "generated_brief": {"functional_summary": "The RE_TRIGR instruction restarts the CPU's cycle monitoring timer based on the configured cycle time.", "usage_context": "It is used within program cycle organization blocks to reset the monitoring timer, ensuring proper CPU cycle time tracking and avoiding faults."}, "generated_keywords": ["restart cycle monitoring", "CPU cycle timer reset", "program cycle block", "CPU fault prevention", "firmware compatibility"]}
{"instruction_name": "ROL", "description": "The 'Rotate left' instruction rotates the contents of the IN parameter bit-by-bit to the left and returns it as a function value. The parameter N is used to specify the number of bit places by which the specified value should be rotated. The bit positions freed by rotating are filled with the bit positions that are pushed out.", "parameters": {"Input": [{"name": "IN", "type": "Bit strings, integers", "description": "Value to be rotated"}, {"name": "N", "type": "USINT, UINT, UDINT", "description": "Number of bit positions by which the value (IN) is rotated"}], "Output": [{"name": "Function value", "type": "Bit strings, integers", "description": "Result of the instruction"}], "InOut": []}, "how_to_use": "To use the ROL instruction, specify the value to be rotated in the IN parameter and the number of bit positions to rotate in the N parameter.", "example_code": "\"Tag_Result\" := ROL(IN := \"Tag_Value\", N := \"Tag_Number\");", "additional_info": "If the value of the N parameter is '0', the value at input IN is given as a result. If the value of the N parameter is greater than the number of available bit positions, the operand value at the IN input is still rotated by the specified number of bit positions.", "generated_brief": {"functional_summary": " ROL instruction rotates the bits of an input value to the left by a specified number of positions, wrapping the shifted-out bits back into the emptied positions.", "usage_context": "It is typically used in PLC programs for bit manipulation tasks such as creating cyclic bit patterns, data encoding, or performing circular shifts in control logic."}, "generated_keywords": ["rotate bits left", "circular bit shift", "bit manipulation", "bitwise rotation", "PLC function"]}
{"instruction_name": "ROR", "description": "The \"Rotate right\" instruction rotates the content of the IN parameter bit-by-bit to the right and assigns the result to the specified operand. The parameter N is used to specify the number of bit places by which the specified value should be rotated. The bit positions freed by rotating are filled with the bit positions that are pushed out. If the value of the N parameter is \"0\", the value at input IN is given as a result. If the value at the N parameter is greater than the number of available bit positions, the operand value at the IN input is still rotated by the specified number of bit positions.", "parameters": {"Input": [{"name": "IN", "type": "Bit strings, integers", "description": "Value to be rotated"}, {"name": "N", "type": "USINT, UINT, UDINT", "description": "Number of bit positions by which the value (IN) is rotated"}], "Output": [{"name": "Function value", "type": "Bit strings, integers", "description": "Result of the instruction"}], "InOut": []}, "how_to_use": "Use the ROR instruction to rotate the bits of the input operand IN to the right by N bit positions. If N is zero, input IN is returned unchanged. The instruction works on bit strings or integer types and can rotate by a count exceeding the number of bits in IN, effectively wrapping around.", "example_code": "\"Tag_Result\" := ROR(IN := \"Tag_Value\", N := \"Tag_Number\");", "additional_info": "Valid data types include bit strings and integer types in various memory areas (I, Q, M, D, L). For detailed data types and memory areas, refer to the corresponding Siemens TIA Portal documentation.", "generated_brief": {"functional_summary": "The ROR instruction rotates the bits of the input value to the right by a specified number of positions, wrapping around the bits shifted out.", "usage_context": "It is typically used in PLC programs to manipulate bit patterns for tasks such as data encoding, cyclic bit shifts, or bitwise operations in industrial control systems."}, "generated_keywords": ["rotate bits right", "bitwise rotation", "circular bit shift", "bit pattern manipulation", "PLC bit operation"]}
{"instruction_name": "ROUND", "description": "The \"Round numerical value\" instruction is used to round the value at input IN to the nearest integer. The instruction interprets the value at input IN as a floating-point number and converts it into an integer or floating-point number. If the input value is exactly between an even and odd number, the even number is selected.", "parameters": {"Input": [{"name": "<expression>", "type": "Floating-point numbers", "description": "Input value to be rounded."}], "Output": [{"name": "Function value", "type": "Integers, floating-point numbers", "description": "Result of the rounding"}], "InOut": []}, "how_to_use": "Use the ROUND instruction by providing a floating-point input value. The instruction returns the nearest integer or floating-point number rounded according to the rule that if the input is exactly between an even and odd number, the even number is selected.", "example_code": "\"Tag_Result\" := ROUND(\"Tag_Value\");", "additional_info": "The instruction supports various memory areas such as I, Q, M, D, L, P. Refer to Siemens TIA Portal documentation for details on valid data types and memory areas.", "generated_brief": {"functional_summary": "The ROUND instruction rounds a floating-point input value to the nearest integer or floating-point number, selecting the even number if the value is exactly between two integers.", "usage_context": "This function is typically used in PLC programs to convert precise floating-point measurements into discrete integer values for control logic or display purposes."}, "generated_keywords": ["round numerical value", "floating-point rounding", "nearest integer conversion", "even number selection", "data type conversion"]}
{"instruction_name": "LIMIT", "description": "The \"Set limit value\" instruction limits the value of the parameter IN to the values of the parameters MN and MX. The value of the parameter MN may not be greater than the value of the parameter MX. If the value of the IN parameter fulfills the condition MN <= IN <= MX, it is returned as the result of the instruction. If the condition is not fulfilled and the IN input value is less than the MN low limit, the value of the MN parameter is returned as the result. If the high limit MX is exceeded, the value of the MX parameter is returned as the result. If the value at the MN input is greater than at the MX input, the result is the value specified at the IN parameter and the enable output ENO is \"0\". The instruction is only executed if the operands of all parameters are of the same data type.", "parameters": {"Input": [{"name": "MN", "type": "Integers, floating-point numbers, TIME, TOD, DATE, DTL", "description": "Low limit"}, {"name": "IN", "type": "Integers, floating-point numbers, TIME, TOD, DATE, DTL", "description": "Input value"}, {"name": "MX", "type": "Integers, floating-point numbers, TIME, TOD, DATE, DTL", "description": "High limit"}], "Output": [{"name": "Function value", "": "Integers, floating-point numbers, TIME, TOD, DATE, DTL", "description": "Result of the instruction"}], "InOut": []}, "how_to_use": "Use the LIMIT instruction to constrain a value specified minimum and maximum limits (MN and MX). Ensure the data types of MN, IN, and MX are identical. The instruction compares IN against MN and MX and returns the bounded value. If MN is greater than MX, the instruction returns IN and disables the enable output (ENO = 0). This instruction is typically used to prevent variable values from exceeding defined thresholds.", "example_code": "\"Tag_Result\" := LIMIT(MN := \"Tag_Minimum\", IN := \"Tag_Value\", MX := \"Tag_Maximum\");", "additional_info": "The data types TOD, LTOD, DATE, and LDT can only be used if the IEC test is not enabled. The instruction requires all input operands to have matching data types. Refer to relevant documentation for valid data types and applicable memory areas for S7-1200 and S7-1500.", "generated_brief": {"functional_summary": "The LIMIT instruction restricts an input value to lie within specified minimum (MN) and maximum (MX) limits, returning the bounded value or indicating error if limits are invalid.", "usage_context": "This function is used in industrial control to ensure variable values do not exceed predefined thresholds, maintaining safe and expected operation ranges."}, "generated_keywords": ["value limiting", "min max bounds", "range constraint", "input validation", "threshold enforcement"]}
{"instruction_name": "SHL", "description": "The \"Shift left\" instruction shifts the contents of the IN parameter bit-by-bit to the left and returns it as a function value. The parameter N is used to specify the number of bit positions by which the specified value should be shifted. If the value of the N parameter is \"0\", the value of the IN parameter is given as a result. If the value of the N parameter is greater than the number of bit places, the value of the IN parameter is shifted to the left by the available number of bit places. The bit positions freed by the shift are filled with zeros in the result value.", "parameters": {"Input": [{"name": "IN", "type": "Bit strings, integers", "description": "Value to be shifted"}, {"name": "N", "type": "USINT, UINT, UDINT", "description": "Number of bits by which the value (IN) is shifted"}], "Output": [{"name": "Function value", "type": "Bit strings, integers", "description": "Result of the instruction"}], "InOut": []}, "how_to_use": "Use the SHL instruction to shift the bits of the input value (IN) to the left by the number of bit positions specified in N. If N is 0, the input value is returned unchanged. If N is greater than the bit width of IN, it is shifted by the maximum available bit count, and the freed bits are filled with zeros.", "example_code": "\"Tag_Result\" := SHL(IN := \"Tag_Value\", N := \"Tag_Number\");", "additional_info": "The instruction supports operands in memory areas I, Q, M, D, and L for both S7-1200 and S7-1500. For additional info on valid data types and memory areas, refer to the corresponding Siemens documentation.", "generated_brief": {"functional_summary": "The SHL instruction shifts the bits of an input value to the left by a specified number of positions, filling freed bit positions with zeros and returning the shifted result.", "usage_context": "It is typically used in PLC programs to perform bitwise manipulations such as scaling, masking, or preparing data for communication or control operations."}, "generated_keywords": ["bit shift left", "bitwise manipulation", "integer shift", "zero fill", "PLC bit operation"]}
{"instruction_name": "SHR", "description": "The 'Shift right' instruction shifts the contents of the IN parameter bit-by-bit to the right and returns it as a function value. The parameter N is used to specify the number of bit positions by which the specified value should be shifted.", "parameters": {"Input": [{"name": "IN", "type": "Bit strings, integers", "description": "Value to be shifted"}, {"name": "N", "type": "USINT, UINT, UDINT", "description": "Number of bits by which the value (IN) is shifted"}], "Output": [{"name": "Function value", "type": "Bit strings, integers", "description": "Result of the instruction"}], "InOut": []}, "how_to_use": "To use this instruction, specify the value to be shifted in the 'IN' parameter and the number of bit positions for the shift in the 'N' parameter.", "example_code": "\"Tag_Result\" := SHR(IN := \"Tag_Value\", N := \"Tag_Number\");", "additional_info": "If the value of the N parameter is '0', the value of the IN parameter is returned unchanged. If N exceeds the number of available bit positions, the value is shifted by the available number.", "generated_brief": {"functional_summary": "The SHR instruction shifts the bits of a given value to the right by a specified number of positions and returns the resulting value.", "usage_context": "This function is typically used in PLC programming for bit manipulation tasks such as scaling, extracting, or aligning data within industrial control systems."}, "generated_keywords": ["bitwise shift right", "bit manipulation", "integer shift right", "PLC shift instruction", "data alignment"]}
{"instruction_name": "TRUNC", "description": "The 'Truncate numerical value' instruction is used to generate an integer from the input value without rounding. The instruction selects only the integer part of the input value and returns this part without decimal places as the function value.", "parameters": {"Input": [{"name": "<Expression>", "type": "Floating-point numbers", "description": "Input value"}], "Output": [{"name": "Function value", "type": "Integers, floating-point numbers", "description": "Integer component of the input value"}], "InOut": []}, "how_to": "Use the TRUNC function with the desired data type as TRUNC_<data type>() to obtain the integer part of the floating-point number.", "example_code": "\"Tag_Result1\" := TRUNC(\"Tag_Value1\");\n\"Tag_Result2\" := TRUNC(\"Tag_Value2\" + \"Tag_Value3\");\n\"Tag_Result3\" := TRUNC_SINT(\"Tag_Value4\");", "additional_info": "You can specify the data type of the instruction explicitly using '_'. If not specified, the data type will be determined by the utilized tags or type-coded constants, with the default being DINT.", "generated_brief": {"functional_summary": "The TRUNC function extracts the integer part of a floating-point input value without rounding, returning it as an integer or specified data type.", "usage_context": "This function is typically used in PLC programming when it is necessary to convert floating-point numbers to integers by removing their fractional parts for control logic or data processing."}, "generated_keywords": ["truncate floating-point", "extract integer part", "remove decimal places", "floating-point to integer conversion", "PLC numeric truncation"]}
{"instruction_name": "POKE", "description": "The \"Write memory address\" instruction is used to write a memory address to a standard memory area without specifying a data type.", "parameters": {"Input": [{"name": "AREA", "type": "BYTE", "description": "The following areas can be selected: 16#81: Input, 16#82: Output, 16#83: Bit memory, 16#84: DB, 16#2: Peripheral output (S7-1500 only)"}, {"name": "DBNUMBER", "type": "DINT, DB_ANY", "description": "Number of the data block if AREA = DB, otherwise \"0\""}, {"name": "BYTEOFFSET", "type": "DINT", "description": "Address to be written. Only the 16 least significant bits are used."}, {"name": "VALUE", "type": "Bit sequences", "description": "Value to be written"}], "Output": [], "InOut": []}, "how_to_use": "Use the POKE instruction to write a value to a specific memory address within the selected memory area. If writing to input, output, or bit memory areas, set DBNUMBER to 0. For data blocks, specify the data block number in DBNUMBER. BYTEOFFSET defines the address offset within the memory area, and VALUE is the value to write.", "example_code": "POKE(AREA := 16#84, DBNUMBER := 1, BYTEOFFSET := 2, VALUE := BYTE#7, ENO => ENO);", "additional_info": "If you write the memory address to the input, output or bit memory areas, you must assign the DBNUMBER parameter the value \"0\", as the instruction is invalid otherwise.", "generated_brief": {"functional_summary": "The POKE instruction writes a specified value directly to a given memory address within a selected memory area of a PLC without requiring data type specification.", "usage_context": "It is typically used for low-level memory manipulation in PLC programs to modify inputs, outputs, bit memory, or data block values at precise addresses."}, "generated_keywords": ["write memory address", "memory area manipulation", "POKE instruction", "data block writing", "low-level PLC memory access"]}
{"instruction_name": "POKE_BLK", "description": "The \"Write memory area\" instruction is used to write a memory to a different standard memory area without specifying a data type. It supports writing data blocks as well as input, output, and bit memory areas. The EN/ENO mechanism can be used to recognize possible access errors when the data block is not yet known during program creation.", "parameters": {"Input": [{"name": "AREA_SRC", "type": "BYTE", "description": "The source memory area to read from. The valid values are: 16#81 for Input, 16#82 for Output, 16#83 for Bit memory, and 16#84 for DB."}, {"name": "DBNUMBER_SRC", "type": "DINT, DB_ANY", "description": "Number of the data block in the source memory area if AREA_SRC = DB (16#84); otherwise, must be 0."}, {"name": "BYTEOFFSET_SRC", "type": "DINT", "description": "Address offset in the source memory area to start reading from. Only the 16 least significant bits are used."}, {"name": "AREA_DEST", "type": "BYTE", "description": "The destination memory area to write to. The valid values are: 16#81 for Input, 16#82 for Output, 16#83 for Bit memory, and 16#84 for DB."}, {"name": "DBNUMBER_DEST", "type": "DINT, DB_ANY", "description": "Number of the data block in the destination memory area if AREA_DEST = DB (16#84); otherwise, must be 0."}, {"name": "BYTEOFFSET_DEST", "type": "DINT", "description": "Address offset in the destination memory area to start writing to. Only the 16 least significant bits are used."}, {"name": "COUNT", "type": "DINT", "description": "Number of bytes to copy from source to destination memory."}], "Output": [{"name": "ENO", "type": "BOOL", "description": "Output enable; can be used to detect possible access errors if data block is unknown during code creation."}], "InOut": []}, "how_to_use": "Use POKE_BLK to copy a specified number of bytes from a source memory area to a destination memory area. When using DB areas, specify the DB number; otherwise, set DBNUMBER_SRC or DBNUMBER_DEST to 0. The BYTEOFFSET parameters specify the starting byte within the respective areas. The EN/ENO mechanism is recommended to detect invalid memory accesses.", "example_code": "POKE_BLK(AREA_SRC := 16#84, DBNUMBER_SRC := 1, BYTEOFFSET_SRC := 2, AREA_DEST := 16#84, DBNUMBER_DEST := 11, BYTEOFFSET_DEST := 22, COUNT := 3, ENO => ENO);", "additional_info": "If writing to input, output, or bit memory areas, DBNUMBER parameter must be 0 as the instruction is invalid otherwise. The data types of DBNUMBER_SRC and DBNUMBER_DEST must match (both DINT or both DB_ANY). Only the lower 16 bits of BYTEOFFSET parameters are used.", "generated_brief": {"functional_summary": "POKE_BLK copies a specified number of bytes from a source memory area to a destination memory area in a PLC without requiring a data type.", "usage_context": "It is typically used when transferring raw data blocks or bit-level data between different memory areas, with error detection via the EN/ENO mechanism during runtime."}, "generated_keywords": ["memory area copy", "byte block transfer", "raw data write", "memory write instruction", "EN/ENO error detection"]}
{"instruction_name": "POKE_BOOL", "description": "The \"Write memory bit\" instruction is used to write a memory bit to a standard memory area without specifying a data type.", "parameters": {"Input": [{"name": "AREA", "type": "BYTE", "description": "The following areas can be selected: 16#81: Input, 16#82: Output, 16#83: Bit memory, 16#84: DB, 16#2: Peripheral output (S7-1500 only)"}, {"name": "DBNUMBER", "type": "DINT, DB_ANY", "description": "Number of the data block if AREA = DB, otherwise \"0\""}, {"name": "BYTEOFFSET", "type": "DINT", "description": "Address to be written. Only the 16 least significant bits are used."}, {"name": "BITOFFSET", "type": "INT", "description": "Bit to be written"}, {"name": "VALUE", "type": "BOOL", "description": "Value to be written"}], "Output": [], "InOut": []}, "how_to_use": "Use the POKE_BOOL instruction to write a specified bit in a memory area (Input, Output, Bit memory, DB, or Peripheral output) by specifying the memory area, data block number if applicable, byte offset, bit offset, and the boolean value to write. When writing to the input, output, or bit memory areas, set DBNUMBER to 0 to avoid invalid instruction error. Consider using the EN/ENO mechanism to detect access errors when the DB is not known at compile-time.", "example_code": "POKE_BOOL(AREA := 16#84,\n         DBNUMBER := 1,\n         BYTEOFFSET := 2,\n         BITOFFSET := 4,\n         VALUE := TRUE,\n         ENO => ENO);", "additional_info": "If you write the memory bit to the input, output or bit memory areas, you must assign the DBNUMBER parameter the value \"0\", as the instruction is invalid otherwise.", "generated_brief": {"functional_summary": "POKE_BOOL writes a specified boolean value to a single bit in a designated memory area, such as input, output, bit memory, data blocks, or peripheral outputs.", "usage_context": "This instruction is typically in PLC programs when precise bit-level control or modification of memory areas is required, including writing to data blocks or hardware-specific memory regions."}, "generated_keywords": ["write memory bit", "boolean bit write", "memory area bit set", "bit-level memory access", "POKE_BOOL instruction"]}
{"instruction_name": "DECO", "description": "The instruction \"Decode\" reads the value of the parameter IN and sets the bit in the output value, whose bit position corresponds to the read value. The other bits in the output value are filled with zeroes. If the value of the IN parameter is greater than 31, a modulo 32 instruction is executed.", "parameters": {"Input": [{"name": "IN", "type": "UINT", "description": "Position of the bit in the output value which is set."}], "Output": [{"name": "Function value", "type": "Bit strings (default: DWORD, can be specified with _<Data type>)", "description": "Current output value with the bit at position IN set and other bits cleared."}], "InOut": []}, "how_to_use": "Use DECO or specify the data type explicitly with DECO_<data type>() to decode the input value and set the corresponding bit in the output bit string. If the input value exceeds the maximum bit index, it is taken modulo the bit width (e.g., modulo 32 for DWORD).", "example_code": "\"Tag_Result\" := DECO(IN := \"Tag_Value\");\n\"Tag_Result2\" := DECO_BYTE(IN := \"Tag_Value2\");", "additional_info": "If the data type is not specified explicitly, it is determined by the utilized tags or type-coded constants. If neither is specified, the default data type DWORD is used. Valid memory areas for parameters include I, Q, M, D, L, P.", "generated_brief": {"functional_summary": "The DECO instruction decodes an input UINT value by setting the bit at the position indicated by the input in the output bit string while clearing all other bits.", "usage_context": "It is typically used in PLC programming to convert a numeric index into a bitmask for controlling or monitoring specific bits within a data word."}, "generated_keywords": ["bit position decode", "set bit output", "UINT to bitmask", "bitwise output generation", "modulo bit index"]}
{"instruction_name": "ENCO", "description": "The instruction \"Encode\" reads the bit number of the lowest-value bit set in the input value and issues this as a result. The \"Encode\" instruction selects the least significant bit of the value at the IN parameter and writes this bit number to the operand at the OUT parameter. If the IN parameter has the value DW#16#00000001 or DW#16#00000000, the value \"0\" is output at the OUT output. If, in an SCL block in the block properties, the \"Set ENO automatically\" option is selected and the \"Encode\" instruction is used, the ENO delivers the signal state 0 if the parameter IN delivers the value DW#16#00000000.", "parameters": {"Input": [{"name": "IN", "type": "Bit strings", "description": "Input value"}], "Output": [{"name": "Function value", "type": "INT", "description": "Bit number of the bit in the input value that is read out."}], "InOut": []}, "how_to_use": "Use the ENCO instruction by passing a bit string operand to the IN parameter. The instruction will output the bit number of the lowest set bit in the input. If the input is zero or DW#16#00000001, the output will be 0. When using in SCL, if 'Set ENO automatically' is enabled, the ENO will be reset if the input is zero.", "example_code": "\"Tag_Result\" := ENCO(IN := \"Tag_Value\");", "additional_info": "Valid input data types are bit strings located in memory areas I, Q, M, D, L, P. Refer to 'Overview of the valid data types' and respective memory area documentation for further details.", "generated_brief": {"functional_summary": "The ENCO instruction identifies and outputs the bit number of the least significant set bit in a given bit string input.", "usage_context": "It is typically used in PLC programming to quickly determine the position of the first active bit within status or control word inputs for decision-making or indexing purposes."}, "generated_keywords": ["encode instruction", "lowest set bit", "bit position output", "bit string input", "PLC bit indexing"]}
{"instruction_name": "READ_BIG", "description": "The instruction \"Read data in little endian format\" is used to read data from a memory area and to write this to a single tag in the big endian byte sequence.", "parameters": {"Input": [{"name": "SRC_ARRAY", "type": "ARRAY of BYTE", "description": "Memory area to be read from."}], "Output": [{"name": "DEST_VARIABLE", "type": "Bit strings, integers, floating-point numbers, TOD, DATE, CHAR, WCHAR", "description": "Read value into an elementary data type."}], "InOut": [{"name": "POS", "type": "DINT", "description": "Determines the position at which the reading starts. The POS parameter is calculated zero-based."}]}, "how_to_use": "Specify the source memory area (SRC_ARRAY), the variable to store the result (DEST_VARIABLE), and the starting position for reading (POS).", "example_code": "#TagResult := READ_BIG(SRC_ARRAY := #SourceField, DEST_VARIABLE #DINTVariable, POS := #TagPos);", "additional_info": "If reading a VARIANT or BOOL type, use 'Serialize' or 'Deserialize' instructions.", "generated_brief": {"functional_summary": "READ_BIG reads data from a byte array in little endian format and writes it into a variable using a big endian byte sequence starting from a specified position.", "usage_context": "It is typically used in industrial control systems to correctly interpret and convert data stored in memory buffers for processing or communication where endian formats differ."}, "generated_keywords": ["read little endian data", "big endian conversion", "memory array read", "position based read", "data type conversion"]}
{"instruction_name": "READ_LITTLE", "description": "The instruction \"Read data in little endian format\" is used to read data from a memory area and to write this to a single tag in the little endian byte sequence. With the little endian format, the byte with the least significant bits is saved first, which means at the lowest memory address.", "parameters": {"Input": [{"name": "SRC_ARRAY", "type": "ARRAY of BYTE", "description": "Memory area to be read from"}], "Output": [{"name": "DEST_VARIABLE", "type": "Bit strings, integers, floating-point numbers, TOD, DATE, CHAR, WCHAR", "description": "Read value"}], "InOut": [{"name": "POS", "type": "DINT", "description": "Determines the position at which the reading starts. The POS parameter is calculated zero-based."}]}, "how_to_use": "Use the instruction to read data from a specified memory area (SRC_ARRAY) into a destination variable (DEST_VARIABLE) interpreting bytes in little endian format. The POS parameter sets the zero-based start position in the memory area for reading. The DEST_VARIABLE must be an elementary data type. If reading a VARIANT or BOOL data type, use Serialize/Deserialize or Slice access respectively.", "example_code": "#TagResult := READ_LITTLE(SRC_ARRAY := #SourceField,\n                     DEST_VARIABLE => #DINTVariable,\n                     POS := #TagPos);", "additional_info": "The SRC_ARRAY parameter must be an ARRAY of BYTE. The RET_VAL (function value) parameter returns INT error codes: 0000 for no error, 80B4 if SRC_ARRAY is not ARRAY of BYTE, 8382 if POS is outside the ARRAY limits, and 8383 if POS is inside but the read size exceeds the ARRAY bounds. The DEST_VARIABLE's data type determines how many bytes are read.", "generated_brief": {"functional_summary": "READ_LITTLE reads data from a byte array starting at a specified position and interprets it in little endian format into a single destination variable.", "usage_context": "It is typically used in PLC programs to extract values from memory areas where data is stored in little endian byte order, such as communication buffers or sensor data blocks."}, "generated_keywords": ["read little endian data", "memory array read", "byte array to variable", "position-based data reading", "PLC data extraction"]}
{"instruction_name": "ReadFromArrayDBL", "description": "The instruction \"Read from ARRAY data block in load memory\" is used to read the element ti which the index references from a data block of the ARRAY DB block type in the load memory and write it to the target range. An ARRAY data block is a data block that consists of exactly one ARRAY of <Data type>. The elements of the ARRAY can be of PLC data type or any other elementary data type. Counting of the ARRAY always begins with the low limit \"0\". If the ARRAY data block has been designated with the block attribute \"Only store in load memory\", it will only be stored in the load memory. The instruction is executed when a positive signal edge is detected at the REQ parameter. The BUSY parameter then has the signal state \"1\". The instruction is terminated if a negative signal edge is detected at the BUSY parameter. The DONE parameter has the signal state \"1\" for one program cycle and the read value is output at the VALUE parameter within this cycle. With all other program cycles, the value at the VALUE parameter is not changed.", "parameters": {"Input": [{"name": "REQ", "type": "BOOL", "description": "REQ = \"1\": Begin with the reading of the ARRAY DB"}, {"name": "DB", "type": "DB_ANY", "description": "ARRAY data block that is read."}, {"name": "INDEX", "type": "DINT", "description": "Element in the DB that is read. The specification can be a constant, a global tag or an indexed value."}], "Output": [{"name": "BUSY", "type": "BOOL", "description": "BUSY = \"1\": The array DB is still being read"}, {"name": "DONE", "type": "BOOL", "description": "DONE = \"1\": The instruction was executed successfully"}, {"name": "ERROR", "type": "INT", "description": "Error information: If an error occurs during execution of the instruction, an error code is output at the ERROR parameter."}], "InOut": [{"name": "VALUE", "type": "VARIANT", "description": "Pointer to the DB in the work memory that is to be read and the value of which is to be written. No local constants or tags from the TEMP section must be used."}]}, "how_to_use": "Trigger the instruction by setting the REQ input to TRUE. The instruction reads the element at the given INDEX from the specified ARRAY data block DB and outputs it at VALUE. BUSY signals ongoing read, DONE signals successful completion for one cycle, and ERROR indicates errors. Use optimized ARRAY DBs stored in load memory only.", "example_code": "\"ReadFromArrayDBL_DB\"(REQ := TagReq,\n                      DB := ArrayDB,\n                      INDEX := 2,\n                      VALUE := TargetField,\n                      BUSY => TagBusy,\n                      DONE => TagDone,\n                      ERROR => TagError);", "additional_info": "Error codes are output at ERROR parameter; for example, 80B4 indicates a data type mismatch between ARRAY elements and VALUE VARIANT; 8230-8235 errors relate to invalid or incorrect data blocks; 8382 means INDEX is outside ARRAY limits. Data blocks must have the \"Optimized\" block property and be stored in load memory. VALUE parameter cannot be a local constant or TEMP tag.", "generated_brief": {"functional_summary": "The ReadFromArrayDBL instruction reads a specified element from an optimized ARRAY data block stored in load memory and outputs its value upon a trigger signal.", "usage_context": "This function is typically used in PLC programs to access individual elements from ARRAY data blocks for processing or monitoring during runtime."}, "generated_keywords": ["read array data block", "load memory access", "indexed element read", "optimized ARRAY DB", "PLC data retrieval"]}
{"instruction_name": "ReadFromArrayDB", "description": "The instruction \"Read from ARRAY data block\" is used to read the element from a data block of the ARRAY DB block type to which the index references, and write the value of the element to the target range. An ARRAY data block is a data block that consists of exactly one ARRAY of <Data type>. The elements of the ARRAY can be of PLC data type or any other elementary data type. Counting of the ARRAY always begins with the low limit \"0.\"", "parameters": {"Input": [{"name": "DB", "type": "DB_ANY", "description": "Data block that is read"}, {"name": "INDEX", "type": "DINT", "description": "Element in the DB that is read. The specification can be a constant, a global tag or an indexed value."}], "Output": [{"name": "VALUE", "type": "VARIANT", "description": "Value that is read and output"}, {"name": "Function value (RET_VAL)", "type": "INT", "description": "Result of the instruction"}], "InOut": [{"name": "VALUE", "type": "VARIANT", "description": "The tag itself must be declared as InOut in the block interface, although VALUE is declared as Output since data flows into the tag."}]}, "how_to_use": "Use the ReadFromArrayDB instruction to access elements of an ARRAY data block by specifying the data block (DB) and the element index (INDEX). Declare the VALUE parameter as InOut in the block interface to store the read element. Check the RET_VAL output for error codes to ensure successful execution.", "example_code": "\"TagResult\" := ReadFromArrayDB(DB := \"ArrayDB\", INDEX := 2, VALUE => \"TargetField\");", "additional_info": "RET_VAL parameter provides several error codes indicating issues such as data type mismatches, out-of-range indices, or invalid data blocks. The VALUE parameter must be declared as InOut in the block interface, even though it is declared as Output in the instruction parameters. Ensure that both the ARRAY data block and the VALUE operand are in memory areas compatible with optimized access for correct operation.", "generated_brief": {"functional_summary": "The ReadFromArrayDB instruction reads a specific element from an ARRAY data block using a given index and outputs its value to a specified target.", "usage_context": "This function is typically used in PLC programs when accessing individual elements within an ARRAY data block to retrieve values dynamically during runtime."}, "generated_keywords": ["read array element", "array data block access", "index-based read", "PLC array reading", "data block element retrieval"]}
{"instruction_name": "SEL", "description": "The instruction 'Select' selects one of the parameters IN0 or IN1 depending on a switch (G parameter) and issues its content as a result. When the parameter G has the signal status '0', the value at parameter IN0 is moved. When the parameter G has the signal status '1', the value at parameter IN1 is moved and returned as a function value.", "parameters": {"Input": [{"name": "G", "type": "BOOL", "description": "Switch"}, {"name": "IN0", "type": "Binary numbers, integers, floating-point numbers, timers, strings, TOD, DATE, DT", "description": "First input value"}, {"name": "IN1", "type": "Binary numbers, integers, floating-point numbers, timers, strings, TOD, DATE, DT", "description": "Second input value"}], "Output": [{"name": "Function value", "type": "Binary numbers, integers, floating-point numbers, timers, strings, TOD, DATE, DT", "description": "Result of the instruction"}], "InOut": []}, "how_to_use": "", "example_code": "\"Tag_Result\" := SEL(G := \"Tag_Value\", IN0 := \"Tag_0\", IN1 := \"Tag_1\");", "additional_info": "The instruction is only executed if the tags of all parameters have the same data type class.", "generated_brief": {"functional_summary": "The SEL instruction outputs the value of either IN0 or IN1 based on the boolean status of the selector input G, returning IN0 if G is 0 and IN1 if G is 1.", "usage_context": "This function is typically used to conditionally select between two data inputs or states in PLC programs, facilitating decision-based data routing and control logic."}, "generated_keywords": ["conditional selection", "data routing", "boolean selector", "input switching", "value multiplexing"]}
{"instruction_name": "TONR", "description": "The instruction 'Time accumulator' is used to accumulate time values within a period set by the parameter PT. When the signal state at the IN parameter changes to '1', the time measurement is executed and the time PT is started. While the time duration PT is running, the time values that are recorded when the IN parameter has signal state '1' are accumulated. If the signal state at the 'IN' input changes to '0', the time measurement is interrupted. If the signal state at the 'IN' input changes back to '1', the time measurement is restarted. The accumulated time is output in the ET parameter and can be queried there. When the time duration PT is reached, the Q parameter has signal state '1'. The Q parameter remains set to '1', even when the signal state at the IN parameter changes to '0'. The R parameter resets the ET and Q parameters regardless of the signal state at the IN parameter.", "parameters": {"Input": [{"name": "IN", "type": "BOOL", "description": "Start input"}, {"name": "R", "type": "BOOL", "description": "Reset of the ET and Q parameters"}, {"name": "PT", "type": "TIME (for S7-1200), TIME, LTIME (for S7-1500)", "description": "Maximum duration of time recording. The value of the PT parameter must be positive."}], "Output": [{"name": "Q", "type": "BOOL", "description": "Operand that remains set when the timer PT has expired."}, {"name": "ET", "type": "TIME (for S7-1200), TIME, LTIME (for S7-1500)", "description": "Accumulated time."}], "InOut": []}, "how_to_use": "Each call of the 'Time accumulator' instruction must be assigned an IEC timer in which the instance data is stored. The R input resets the time measurement, while the IN input starts and stops it.", "example_code": "#IEC_Timer_0_Instance(IN:=#Start, R:=#Reset, PT:=_time_in_, Q=>_bool_out_, ET=>_time_out); #Reset := TRUE;", "additional_info": "Reinitializing the actual values of an IEC timer while the time measurement is running disrupts the function of the IEC timer.", "generated_brief": {"functional_summary": "The TONR instruction accumulates elapsed time while the input signal is true, sets an output flag when the preset time is reached, and retains this flag until reset.", "usage_context": "It is typically used in industrial automation to measure cumulative operation time or delays across multiple start-stop cycles within a defined time period."}, "generated_keywords": ["accumulate time", "on-delay timer", "start-stop timing", "preset time expiration", "resettable timer output"]}
{"instruction_name": "WriteToArrayDBL", "description": "The instruction 'Write to ARRAY data block in load memory' is used to write the element to which the index references to a data block of the ARRAY DB block type in load memory.", "parameters": {"Input": [{"name": "REQ", "type": "BOOL", "description": "REQ = '1': Start writing to the array DB"}, {"name": "DB", "type": "DB_ANY", "description": "ARRAY data block to which data is written"}, {"name": "INDEX", "type": "DINT", "description": "Element in the DB to which data is written. The specification can be a constant, a global tag or an indexed value."}, {"name": "VALUE", "type": "VARIANT", "description": "Pointer to the DB in the work memory that is to be read and the value of which is to be written. No local constants or tags from the TEMP section must be used."}], "Output": [{"name": "BUSY", "type": "BOOL", "description": "BUSY = '1': The array DB is still being written"}, {"name": "DONE", "type": "BOOL", "description": "DONE = '1': The instruction was executed successfully"}, {"name": "ERROR", "type": "INT", "description": "Error information: If an error occurs during execution of the instruction, an error code is output at the ERROR parameter."}], "InOut": []}, "how_to_use": "The instruction is executed when a positive signal edge is detected at the REQ parameter. If a negative signal edge is detected at the BUSY parameter, the instruction is terminated and the value at the VALUE parameter is written to the data block.", "example_code": "\"WriteToArrayDBL_DB\"(REQ := \"TagReg\", DB := \"ArrayDB\", INDEX := 2, VALUE := \"SourceField\", BUSY => \"TagBusy\", DONE => \"TagDone\", ERROR => \"TagError\");", "additional_info": "The data blocks must be created with the 'Optimized' block property.", "generated_brief": {"functional_summary": "The WriteToArrayDBL instruction writes a specified element at a given index into an optimized ARRAY data block load memory upon a trigger signal.", "usage_context": "It is typically used in PLC programs when dynamic updating of array elements within optimized data blocks is required based on control logic events."}, "generated_keywords": ["write array data block", "optimized DB memory", "indexed element write", "PLC load memory update", "triggered data writing"]}
{"instruction_name": "WriteToArrayDB", "description": "The instruction \"Write to ARRAY data block\" is used to write the element to which the index references to a data block of the ARRAY DB block type.", "parameters": {"Input": [{"name": "DB", "type": "DB_ANY", "description": "Data block to which data is written"}, {"name": "INDEX", "type": "DINT", "description": "Element in the DB to which data is written. The specification can be a constant, a global tag or an indexed value."}, {"name": "VALUE", "type": "VARIANT", "description": "Value to be written"}], "Output": [{"name": "Function value (RET_VAL)", "type": "INT", "description": "Result of the instruction"}], "InOut": []}, "how_to_use": "Initialize a timer using the WriteToArrayDB instruction to write data to a specified index in an ARRAY data block.", "example_code": "\"TagResult\" := WriteToArrayDB(DB := \"ArrayDB\", INDEX := 2, VALUE := \"SourceField\");", "additional_info": "The value of the \"SourceField\" operand is written to the 2nd element of the ARRAY DB.", "generated_brief": {"functional_summary": "The WriteToArrayDB instruction writes a specified value to a particular indexed element within an ARRAY data block in a PLC program.", "usage_context": "It is typically used when there is a need to update or initialize individual elements of an ARRAY data block dynamically during program execution."}, "generated_keywords": ["write to array data block", "array element update", "indexed write operation", "dynamic array data assignment", "PLC array data manipulation"]}
{"instruction_name": "REF", "description": "The keyword \"REF()\" is used to specify the tag to which a previously declared reference will. As parameter, specify the tag to be referenced. Before you use the keyword \"REF()\", you must first declare a reference in the block interface.", "parameters": {"Input": [{"name": "<Expression>", "type": "Bit sequences except BOOL, Integers, Floating-point numbers, Character strings, PLC data types (UDT), System data types (SDT), ARRAYs of the named data types", "description": "Tag to which the reference will point"}], "Output": [{"name": "Function value", "type": "Corresponds to the data type of the declared reference tag", "description": "Address of the referenced tag"}], "InOut": []}, "how_to_use": "Declare a reference in the block interface first with a specific data type. Use REF() with a tag parameter that exactly matches the declared reference data type and is located in an optimized memory area. Assign the reference in code by passing the tag to REF(). Do reference temporary data, global PLC tags, block parameters, constants, or write-protected tags. For arrays, limits and dimensions must be identical and Array[*] is not supported.", "example_code": "#myRefInt := REF(#a);\n#myRefType := REF(\"myDB\".myUDT);\n#myRefType := REF(\"myArrayDB_UDT\".\"THIS\"[1]);\n#myRefARRAY := REF(\"myDB\".myArray);", "additional_info": "The data type of the tag specified in REF() must exactly match the declared reference type (no conversions). The referenced tag must reside in an optimized memory area such as DB tags or FB block interfaces. References cannot point to TEMP, global tags, block parameters, constants, or write-protected tags. When referencing arrays, the array limits and dimensions must exactly match. Usage examples include referencing UDTs and arrays via .THIS when needed.", "generated_brief": {"functional_summary": "The REF() instruction assigns a declared reference variable to point to a specific tag with a matching data type in optimized memory areas within a PLC program.", "usage_context": "It is used when you need to dynamically reference and manipulate variables such as UDTs or arrays in data blocks or function block interfaces for flexible and efficient data access."}, "generated_keywords": ["reference assignment", "tag referencing", "data type matching", "optimized memory access", "UDT and array reference"]}
{"instruction_name": "FRAC", "description": "The result of the instruction \"Return fraction\" returns the decimal places of a value. Input value 1.125, for example, returns the value 0.125.", "parameters": {"Input": [{"name": "<Expression>", "type": "Floating-point numbers", "description": "Input value"}], "Output": [{"name": "Function value", "type": "Floating-point numbers", "description": "Decimal places of the input value"}], "InOut": []}, "how_to_use": "Use the instruction with the syntax FRAC_<data type>(); to change the data type explicitly. If no data type is specified, it defaults to REAL or follows the type of the utilized tags or type constants. The instruction returns the fractional part of the input floating-point number.", "example_code": "\"Tag_Result1\" := FRAC(\"Tag_Value\");\n\"Tag_Result2\" := FRAC_LREAL(\"Tag_Value\");", "additional_info": "You can specify the data type of the function value explicitly using an underscore followed by the data type. If not specified, it is determined by used tags or constants, or defaults to REAL. Valid memory areas include I, Q, M, D, L, P.", "generated_brief": {"functional_summary": "The FRAC instruction returns the fractional (decimal) part of a floating-point input value.", "usage_context": "It is typically used in industrial control systems to extract the decimal portion of measurements or calculations for further processing or analysis."}, "generated_keywords": ["fractional part extraction", "decimal part of value", "floating-point fraction", "number fractional component", "decimal precision retrieval"]}
{"instruction_name": "TypeOf", "description": "Use the \"TypeOf\" instruction to query the data type of a tag referenced by ResolvedSymbol.", "parameters": {"Input": [{"name": "ResolvedSymbol", "type": "ResolvedSymbol", "description": "The system data type representing a symbolic reference to a tag."}], "Output": [{"name": "Data type info", "type": "DataType", "description": "The data type of the tag referenced by the ResolvedSymbol."}], "InOut": []}, "how_to_use": "Provide a ResolvedSymbol structured variable referencing a tag to the TypeOf instruction; it returns the data type of that referenced tag. Ensure the ResolvedSymbol is successfully resolved before calling.", "example_code": "", "additional_info": "The ResolvedSymbol must be declared in an optimized memory area. The status element indicates if resolution was successful.", "generated_brief": {"functional_summary": "The TypeOf instruction returns the data type of a tag referenced by a resolved symbolic variable.", "usage_context": "It is used when a program needs to determine the data type of a tag dynamically during execution, ensuring type-safe operations or diagnostics."}, "generated_keywords": ["query data type", "resolved symbol reference", "dynamic type determination", "tag data inspection", "type-safe operation"]}
{"instruction_name": "MoveResolvedSymbolsToBuffer", "description": "Copies data from symbols resolved via ResolvedSymbol system data type to a buffer. Execution should be conditioned on resolved status and error checking to prevent invalid references.", "parameters": {"Input": [{"name": "ResolvedSymbolArray", "type": "ARRAY OF ResolvedSymbol", "description": "Array of symbols to be moved to the buffer."}], "Output": [{"name": "err", "type": "INT", "description": "Number of failed copy processes during the move operation."}], "InOut": []}, "how_to_use": "Before calling MoveResolvedSymbolsToBuffer, check the 'resolved' flag of each symbol. Execute this instruction only if symbols are resolved successfully. If any failed copy processes occur, disable further moves and resolve symbols again asynchronously by calling the 'ResolveSymbols' instruction.", "example_code": "", "additional_info": "Symbols overwritten by loading in RUN mode may become invalid. On errors, update the status and resolved parameters and re-invoke the resolution.", "generated_brief": {"functional_summary": "MoveResolvedSymbolsToBuffer copies data from an array of successfully resolved symbols into a buffer while tracking any copy errors that occur.", "usage_context": "This instruction is used after verifying symbols are resolved to transfer their data safely, and it triggers re-resolution if copying errors happen during runtime."}, "generated_keywords": ["copy resolved symbols", "buffer data transfer", "error checking", "symbol resolution validation", "retry on copy failure"]}
{"instruction_name": "ResolveSymbols", "description": "Asynchronously resolves symbolic references in ResolvedSymbol variables again, used when symbols become invalid due to overwrites in RUN mode or errors during MoveResolvedSymbolsToBuffer.", "parameters": {"Input": [{"": "ResolvedSymbolArray", "type": "ARRAY OF ResolvedSymbol", "description": "Array of symbolic references to be resolved."}], "Output": [], "InOut": []}, "how_to_use": "Call ResolveSymbols to refresh symbolic references that have become invalid or no longer resolve correctly, especially after loading overwrites in RUN mode.", "example_code": "", "additional_info": "Use after errors are detected during MoveResolvedSymbolsToBuffer execution to restore valid references.", "generated_brief": {"functional_summary": "ResolveSymbols asynchronously refreshes and resolves symbolic references in ResolvedSymbol arrays that have become invalid or corrupted.", "usage_context": "It is used in RUN mode after overwrites or errors occur, particularly following issues during MoveResolvedSymbolsToBuffer, to restore valid symbol references."}, "generated_keywords": ["resolve symbolic references", "refresh invalid symbols", "asynchronous symbol resolution", "RUN mode error recovery", "MoveResolvedSymbolsToBuffer correction"]}
{"instruction_name": "CONVERT", "description": "Use the \"Convert value instruction to program explicit conversions. When the instruction is inserted, the \"CONVERT\" dialog opens. You specify the source data type and the destination data type of the conversion in this dialog. The source value is read and converted to the specified destination data type.", "parameters": {"Input": [{"name": "<Source type>", "type": "Binary numbers, integers, floating-point numbers, times, date and time, character strings, BCD16, BCD32", "description": "Value to be converted."}], "Output": [{"name": "<Destination type>", "type": "Binary numbers, integers, floating-point numbers, times, date and time, character strings, BCD16, BCD32", "description": "Result of the conversion"}], "InOut": []}, "how_to_use": "Insert the CONVERT instruction. In the CONVERT dialog, specify source and destination data types for conversion. The source value is converted according to the specified data types. For S7-1500 CPUs, DWORD and LWORD can only be converted to/from REAL or LREAL. During conversion, the bit pattern of the source is transferred unchanged and right-justified to the target data type. Enable output ENO indicates success (1) or error (0).", "example_code": "\"Tag_INT\" := REAL_TO_INT(\"Tag_REAL\");", "additional_info": "BYTE and WORD bit strings cannot be selected directly in the instruction box. DWORD or LWORD operands may be specified if input and output operand lengths match; DWORD is interpreted as DINT/UDINT and LWORD as LINT/ULINT. These conversions are also valid with IEC check enabled. For CPU S7-1500, DWORD and LWORD conversions are limited to REAL and LREAL data types. If no error occurs, ENO = 1; if an error occurs, ENO = 0.", "generated_brief": {"functional_summary": "The CONVERT instruction explicitly converts a value from one specified data type to another within a PLC program.", "usage_context": "It is typically used when data types need to be changed for compatibility or processing between different parts of a PLC program or system."}, "generated_keywords": ["data type conversion", "explicit type cast", "PLC value conversion", "source to destination conversion", "numeric and string conversion"]}
{"instruction_name": "CTUD", "description": "Use the \"Count up and down\" instruction to increment or decrement the counter value at the CV parameter. When the signal state of the CU parameter changes from \"0\" to \"1\" (positive signal edge), the current counter value of the CV parameter is incremented by one. When the signal state of the CD parameter changes from \"0\" to \"1\" (positive signal edge), the counter value of the CV parameter is decremented by one. If there is a positive signal edge at the CU and CD inputs in a program cycle, the current counter value of the CV parameter remains unchanged. The counter value can be incremented until it reaches the high limit of the data type specified at the CV parameter. When the high limit is reached, the counter value is no longer incremented on a positive signal edge. The counter value is no longer decremented once the low limit of the specified data type has been reached. When the signal state of the LD parameter changes to \"1\", the counter value of the CV parameter is set the value of the PV parameter. As long as the LD parameter has signal state \"1\", the signal state of the CU and CD parameters has no effect on the instruction. The counter value is set to zero when the signal state of the R parameter changes to \"1\". As long as the R parameter has signal state \"1\", a change in the signal state of the CU, CD and LD parameters has no effect on the \"Count up and down\" instruction. You can query the status of the up counter at the QU parameter. When the current counter value is greater than or equal to the value of the PV parameter, the QU parameter is set to signal state \"1\". In all other cases, the signal state of the QU parameter is \"0\". You can also specify a constant for the PV parameter. You can query the status of the down counter at the QD parameter. If the current counter value is less than or equal to zero, the QD parameter is set to signal state \"1\". In all other cases, the signal state of the QD parameter is \"0\".", "parameters": {"Input": [{"name": "CU", "type": "BOOL", "description": "Count up input"}, {"name": "CD", "type": "BOOL", "description": "Count down input"}, {"name": "R", "type": "BOOL", "description": "Reset input"}, {"name": "LD", "type": "BOOL", "description": "Load input"}, {"name": "PV", "type": "Integers", "description": "Value at which the QU output is set / value to which the CV output is set when LD = 1."}], "Output": [{"name": "QU", "type": "BOOL", "description": "Status of the up counter"}, {"name": "QD", "type": "BOOL", "description": "Status of the down counter"}, {"name": "CV", "type": "Integers, CHAR, WCHAR, DATE", "description": "Current counter value"}], "InOut": []}, "how_to_use": "Each call of the \"Count up and down\" instruction must be assigned an IEC counter in which the instruction data is stored. An IEC counter is a structure of system data type IEC_<Counter> (shared DB) or a local tag of corresponding CTUD_<DataType>. Declare the IEC counter either as an instance data block or as a local tag. Apply the instruction by calling the CTUD() method on the IEC counter data block or local tag and mapping the inputs and outputs accordingly. Note that when a positive edge occurs at both CU and CD inputs in the same cycle, the counter value remains unchanged. Use the LD input to load the counter with the PV value, which disables counting while active. Use the R input to reset the counter to zero, which disables counting and loading while active. Only use the counter instance at one point in the program to avoid counting errors.", "example_code": "\"IEC_COUNTER_DB\".CTUD(CU := \"Tag_Start1\",\n                 CD := \"Tag_Start2\",\n                 LD := \"Tag_Load\",\n                 R := \"Tag_Reset\",\n                 PV := \"Tag_PresetValue\",\n                 QU => \"Tag_CU_Status\",\n                 QD => \"Tag_CD_Status\",\n                 CV => \"Tag_CounterValue\");", "additional_info": "The counter value respects the limits of the data type of the CV parameter and does not increment beyond the maximum or decrement below the minimum. The QU output is set when the current counter value is greater than or equal to PV, the QD output is set when the counter value is less than or equal to zero. When LD=1, the counter value is loaded with PV and counting inputs are ignored. When R=1, the counter is reset to zero and counting and load inputs are ignored. Use optimized block access and retentive settings according to whether the IEC counter is a single instance data block or a multi-instance local tag.", "generated_brief": {"functional_summary": "The CTUD instruction increments or decrements an integrated counter based on positive signal edges at count-up (CU) and count-down (CD) inputs, with reset (R), load (LD), preset (PV), and status outputs for upper and lower limits.", "usage_context": "It is typically used in PLC programs to track quantities or events that require bidirectional counting with the ability to reset, load preset values, and monitor when counts reach specified thresholds."}, "generated_keywords": ["bidirectional counter", "count up and down", "preset and reset", "edge-triggered counting", "counter limit monitoring"]}
{"instruction_name": "ABS", "description": "Use the 'Form absolute value' instruction to calculate the absolute value of an input value and to save the result in the specified operands.", "parameters": {"Input": [{"name": "<expression>", "type": "SINT, INT, DINT, floating-point numbers", "description": "Input value"}], "Output": [{"name": "Function value", "type": "SINT, INT, DINT, floating-point numbers", "description": "Absolute value of the input value"}], "InOut": []}, "how_to_use": "Initialize the instruction with an appropriate input value, and the absolute value will be returned in the same format as the input value.", "example_code": "\"Tag_Result1\" := ABS(\"Tag_Value\");\n\"Tag_Result2\" := ABS(\"Tag_Value1\"*\"Tag_Value2\");", "additional_info": "The absolute value of the input value is returned in the format of the input value as a function value.", "generated_brief": {"functional_summary": "The ABS instruction calculates and returns the absolute value of a given numerical input in the same data type format.", "usage_context": "It is typically used in PLC programs whenever the magnitude of a number is needed regardless of its sign, such as processing sensor or mathematical."}, "generated_keywords": ["absolute value", "numerical magnitude", "input value processing", "mathematical function", "data type preservation"]}
{"instruction_name": "COS", "description": "Use the 'Form cosine value' instruction to calculate the cosine of the input value. The input value must be given in radians.", "parameters": {"Input": [{"name": "<Expression>", "type": "Floating-point numbers", "description": "Input value (size of an angle in radians)"}], "Output": [{"name": "Function value", "type": "Floating-point numbers", "description": "Result of the instruction"}], "InOut": []}, "how_to_use": "To use the COS instruction, provide the input angle in radians, and it will return the cosine of that angle.", "example_code": "\"Tag_Result\" := COS(\"Tag_Value\");", "additional_info": "Ensure that the input is in radians for accurate calculations.", "generated_brief": {"functional_summary": "The COS instruction calculates the cosine of a given input angle specified in radians.", "usage_context": "This function is typically used in PLC programs requiring trigonometric calculations for tasks such as motion control, signal processing, or coordinate transformations."}, "generated_keywords": ["cosine calculation", "trigonometric function", "input in radians", "angle cosine", "floating-point computation"]}
{"instruction_name": "SIN", "description": "Use the \"Form sine value\" instruction to calculate the sine of the input value. The input value must be given in radians.", "parameters": {"Input": [{"name": "<Expression>", "type": "Floating-point numbers", "description": "Input value (size of an angle in radians) stored in memory areas I, Q, M, D, L, P"}], "Output": [{"name": "Function value", "type": "Floating-point numbers", "description": "Result of the instruction stored in memory areas I, Q, M, D, L, P"}], "InOut": []}, "how_to_use": "Assign the input angle in radians to the input operand and use the SIN function to compute the sine value, which is returned as the function output.", "example_code": "\"Tag_Result\" := SIN(\"Tag_Value\");", "additional_info": "The input and output operands must be floating-point numbers and can be stored in various memory areas including I, Q, M, D, L, and P.", "generated_brief": {"functional_summary": "The SIN instruction calculates the sine of a given input angle expressed in radians and returns the result as a floating-point number.", "usage_context": "This function is typically used in PLC programs for applications involving trigonometric calculations such as motion control, signal processing, or mathematical modeling."}, "generated_keywords": ["sine calculation", "trigonometric function", "input in radians", "floating-point operation", "angle sine value"]}
{"instruction_name": "SQRT", "description": "Use the 'Form square root' instruction to calculate the square root of the input value and save the result in the specified operand. The instruction has a positive result if the input value is greater than zero. If input values are less than zero, the instruction returns an invalid floating-point number. If the input value is '0', the result is also '0'.", "parameters": {"Input": [{"name": "<Expression>", "type": "Floating-point numbers", "description": "Input value"}], "Output": [{"name": "Function value", "type": "Floating-point numbers", "description": "Square root of the input value"}], "InOut": []}, "how_to_use": "", "example_code": "\"Tag_Result1\" := SQRT(\"Tag_Value\");\n\"Tag_Result2\" := SQRT((SQR(\"Tag_Value1\")) + \"Tag_Value2\");", "additional_info": "", "generated_brief": {"functional_summary": "The SQRT instruction calculates the square root of a given floating-point input value and outputs the result, returning zero for an input of zero and an invalid number for negative inputs.", "usage_context": "This function is typically used in industrial control systems to compute square roots in mathematical operations involving measurements or process variables."}, "generated_keywords": ["square root calculation", "floating-point math", "input validation", "mathematical function", "process variable computation"]}
{"instruction_name": "SQR", "description": "Use the \"Form square\" instruction to square the input value and save the result in the specified operand.", "parameters": {"Input": [{"name": "<Expression>", "type": "Floating-point numbers", "description": "Input value"}], "Output": [{"name": "Function value", "type": "Floating-point numbers", "description": "Square of the input value"}], "InOut": []}, "how_to_use": "Use the SQR instruction to calculate the square of a floating-point input expression. The result is returned as the function value which can be assigned to a variable or operand. It works with operands located in memory areas I, Q, M, D, L, P.", "example_code": "\"Tag_Result1\" := SQR(\"Tag_Value\");\n\"Tag_Result2\" := SQR((SQR(\"Tag_Value1\"))*\"Tag_Value2\");", "additional_info": "The instruction supports floating-point inputs and outputs in memory areas I, Q, M, D, L, and P. Refer to valid data types and memory areas for details.", "generated_brief": {"functional_summary": "The SQR instruction calculates the square of a floating-point input value and stores the result in a specified operand.", "usage_context": "It is typically used in industrial control systems for mathematical computations requiring the squaring of floating-point numbers within various memory areas."}, "generated_keywords": ["square calculation", "floating-point arithmetic", "mathematical computation", "memory operand processing", "industrial control systems"]}
{"instruction_name": "TAN", "description": "Use the \"Form tangent value\" instruction to calculate the sine of the input value. The input value must be given in radians.", "parameters": {"Input": [{"name": "<Expression>", "type": "Floating-point numbers", "description": "Input value (size of an angle in radians)"}], "Output": [{"name": "Function value", "type": "Floating-point numbers", "description": "Result of the instruction"}], "InOut": []}, "how_to_use": "Provide the input angle in radians as a floating-point number to the TAN instruction. The instruction returns the tangent of this angle as a floating-point number. Ensure that the input value is within the valid range for tangent calculation to avoid exceptions or unexpected results.", "example_code": "\"Tag_Result\" := TAN(\"Tag_Value\");", "additional_info": "Input and output operands can reside in memory areas I, Q, M, D, L, P. For more information on valid data types and memory areas, refer to the corresponding documentation.", "generated_brief": {"functional_summary": "The TAN instruction calculates the tangent of an input angle provided in radians and returns the result as a floating-point number.", "usage_context": "This function is typically used in PLC programs requiring trigonometric calculations for control or measurement purposes involving angular data."}, "generated_keywords": ["tangent calculation", "trigonometric function", "angle in radians", "floating-point input", "PLC math instruction"]}
{"instruction_name": "CEIL", "description": "Use the \"Generate next higher integer from floating-point number\" instruction to round the value to the nearest integer. The instruction interprets the input value as floating-point number and converts it to the next higher integer. The function value can be greater than or equal to the input value.", "parameters": {"Input": [{"name": "<Expression>", "type": "Floating-point numbers", "description": "Input value"}], "Output": [{"name": "Function value", "type": "Integers, floating-point numbers", "description": "Input value rounded up"}], "InOut": []}, "how_to_use": "Use CEIL_<data type>() syntax to change the data type of the instruction explicitly. If the data type is not specified explicitly, it will be determined by the utilized tags or type-coded constants. If neither is specified, the default data type DINT will be used.", "example_code": "\"Tag_Result1\" := CEIL(\"Tag_Value\");\n\"Tag_Result2\" := CEIL_REAL(\"Tag_Value\");", "additional_info": "You can specify the data type of the function value explicitly using \"_\". Memory areas applicable are I, Q, M, D, L, P for input and I, Q, M, D, L for function value.", "generated_brief": {"functional_summary": "The CEIL instruction rounds a floating-point input value up to the nearest higher integer value.", "usage_context": "It is typically used in industrial control systems when an integer representation of a measurement or calculation is needed without losing magnitude due to rounding down."}, "generated_keywords": ["round up", "floating-point to integer", "next higher integer", "CEIL function", "data type conversion"]}
{"instruction_name": "FLOOR", "description": "Use the \"Generate next lower integer from floating-point number\" instruction to round the value of a floating point number to the next lower integer. The instruction interprets the input value as floating-point number and converts it to the next lower integer. The function value can be equal or less than the input value.", "parameters": {"Input": [{"name": "<Expression>", "type": "Floating-point numbers", "description": "Input value"}], "Output": [{"name": "Function value", "type": "Integers, floating-point numbers", "description": "Input value rounded"}], "InOut": []}, "how_to_use": "Use the syntax FLOOR_<data type>(); to specify the data type of the instruction explicitly. If not specified, the data type is determined by the utilized tags or type-coded constants or defaults to DINT.", "example_code": "\"Tag_Result1\" := FLOOR(\"Tag_Value\");\n\"Tag_Result2\" := FLOOR_REAL(\"Tag_Value\");", "additional_info": "The data type of the function value can be specified explicitly or inferred. Input can be from various memory areas including I, Q, M, D, L, P.", "generated_brief": {"functional_summary": "The FLOOR instruction rounds a floating-point number down to the nearest lower integer value.", "usage_context": "It is typically used in industrial control systems when precise integer values are needed from floating-point measurements or calculations."}, "generated_keywords": ["floor rounding", "floating-point to integer", "round down", "numeric conversion", "data type specification"]}
{"instruction_name": "MoveFromResolvedSymbol", "description": "Use the \"Read value from resolved symbol\" instruction to read the value of a tag that is referenced by a resolved symbol and write it to a target tag. The \"SRC\" parameter has the data type ResolvedSymbol. It points to a tag in the PLC program that is read. The tag must have been resolved before with the \"ResolveSymbols\" instruction. The \"DST\" parameter has the data type VARIANT. It points to a tag that is written. Source and target tag must have the same data type.", "parameters": {"Input": [{"name": "SRC", "type": "ResolvedSymbol", "description": "Source tag that is referenced by the resolved symbol."}], "Output": [{"name": "DST", "type": "Variant", "description": "Target tag."}, {"name": "RET_VAL", "type": "INT", "description": "Error information."}], "InOut": []}, "_to_use": "Use this instruction to read the value of a resolved symbol (SRC) and write it to a target (DST). Ensure that the source tag has been resolved beforehand using the \"ResolveSymbols\" instruction. The source and target tags must have the same data type. Monitor the RET_VAL output parameter for error codes indicating issues like invalid references, non-existing data blocks, or data type mismatches. If references become invalid after a load in RUN mode, resolve symbols again using \"ResolveSymbols\".", "example_code": "#Tag_RetVal := MoveFromResolvedSymbol(SRC := \"MySrcDB\".Input_ResolvedSymbol,\n                      DST => \"MyTargetDB\".Output_Variant);", "additional_info": "The references in the ResolvedSymbol can become invalid if tags they point to are overwritten by loading in RUN mode. Error codes returned in RET_VAL parameter include: 0000 (No error), 8024 (reference points to a non-existent tag), 8031 (reference points to a non-existent data block), and 80B4 (data types of source and target tag do not match). Use \"TypeOf\" instruction to query the data type of a tag referenced by ResolvedSymbol before writing.", "generated_brief": {"functional_summary": "The MoveFromResolvedSymbol instruction reads the value of a previously resolved symbol tag and writes it to a target tag of the same data type while providing error feedback.", "usage_context": "This function is used in PLC programs to dynamically access and transfer data from tags resolved at runtime, especially after symbol resolution with ResolveSymbols, ensuring data integrity in applications where tag references can change."}, "generated_keywords": ["read resolved symbol", "write to target tag", "symbol resolution", "data type validation", "error handling"]}
{"instruction_name": "SCALE", "description": "Use the \"Scale\" instruction to convert the integer at the IN parameter into a floating-point number that can be scaled in physical units between a low limit value and a high limit value. You can use the LO_LIM and HI_LIM parameters to specify the low limit and high limit of the value range to which the input value is scaled. The result of the instruction is output at the OUT parameter. The instruction works with the equation: OUT = [((FLOAT (IN) – K1)/(K2–K1)) * (HI_LIM–LO_LIM)] + LO_LIM. The values of constants K1 and K2 depend on the signal state on the BIPOLAR parameter: if BIPOLAR = 1, IN is bipolar in the range -27648 to 27648 with K1 = -27648.0 and K2 = +27648.0; if BIPOLAR = 0, IN is unipolar in the range 0 to 27648 with K1 = 0.0 and K2 = +27648.0. Values outside the range K1 to K2 result in the output set to LO_LIM or HI_LIM with an error. If LO_LIM is greater than HI_LIM, scaling is inversely proportionate.", "parameters": {"Input": [{"name": "IN", "type": "INT", "description": "Input value to be scaled."}, {"name": "HI_LIM", "type": "REAL", "description": "High limit"}, {"name": "LO_LIM", "type": "REAL", "description": "Low limit"}, {"name": "BIPOLAR", "type": "BOOL", "description": "Indicates whether the value at the IN parameter is bipolar or unipolar. 1: Bipolar, 0: Unipolar."}], "Output": [{"name": "OUT", "type": "REAL", "description": "Result of the instruction."}, {"name": "RET_VAL", "type": "WORD", "description": "Error information as function return value."}], "InOut": []}, "how_to_use": "Provide an integer input value IN which will be scaled linearly between LO_LIM and HI_LIM. Set BIPOLAR to TRUE if input is bipolar (-27648 to 27648) or FALSE if unipolar (0 to 27648). The output REAL value will be the scaled result. Monitor RET_VAL for error codes indicating out-of-range input values.", "example_code": "\"Tag_ErrorCode\" := SCALE(IN := \"Tag_InputValue\",\n                         HI_LIM := \"Tag_HighLimit\",\n                         LO_LIM := \"Tag_LowLimit\",\n                         BIPOLAR := \"Tag_Bipolar\",\n                         OUT => \"Tag_Result\");", "additional_info": "RET_VAL returns 0000 if no error occurs. Error code 0008 indicates IN is outside the valid range for the selected BIPOLAR mode (greater than 27648 or less than 0 for unipolar; less than -27648 for bipolar). For error details, use GET_ERR_ID. The instruction clamps results at LO_LIM or HI_LIM if input is out of bounds, generating error codes.", "generated_brief": {"functional_summary": "The SCALE instruction converts an integer input into a scaled floating-point value within specified physical limits, supporting both bipolar and unipolar input ranges.", "usage_context": "It is typically used in PLC programs to translate raw sensor or signal integer data into meaningful engineering units for monitoring and control purposes."}, "generated_keywords": ["integer to float scaling", "bipolar and unipolar input", "linear scaling between limits", "physical unit conversion", "error handling out of range"]}
{"instruction_name": "SCALE_X", "description": "Use the 'Scale' instruction to scale a floating-point number by mapping it to a specific value range. You specify the value range with the MIN and MAX parameters. The result of the scaling is an integer.", "parameters": {"Input": [{"name": "EN", "type": "BOOL", "description": "Enable input"}, {"name": "MIN", "type": "Integers, floating-point numbers", "description": "Low limit of the value range"}, {"name": "VALUE", "type": "Floating-point numbers", "description": "Value to be scaled. If you enter a constant, you must declare it."}, {"": "MAX", "type": "Integers, floating-point numbers", "description": "High limit of the value range"}], "Output": [{"name": "ENO", "type": "BOOL", "description": "Enable output"}, {"name": "Function value", "type": "Integers, floating-point numbers", "description": "Result of scaling"}], "InOut": []}, "how_to_use": "", "example_code": "\"Tag_Result1\" := SCALE_X(MIN := \"Tag_Value1\", VALUE := \"Tag_Real\", MAX := \"Tag_Value2\");\n\"Tag_Result2\" := SCALE_X_REAL(MIN := \"Tag_Value1\", VALUE := \"Tag_Real\", MAX := \"Tag_Value2\");", "additional_info": "Enable output ENO returns the signal state '0' if one of the specified conditions applies.", "generated_brief": {"functional_summary": "The SCALE_X instruction scales a floating-point input value to an integer within a specified minimum and maximum range.", "usage_context": "It is typically used in PLC programs to convert analog input values into scaled integer outputs for easier processing or display."}, "generated_keywords": ["scale floating-point to integer", "value range mapping", "analog input scaling", "MIN MAX parameters", "integer output"]}
{"instruction_name": "MoveToResolvedSymbol", "description": "Use the \"Write value into resolved symbol\" instruction to read the value of a tag and write it to a target tag that is referenced by a resolved symbol.", "parameters": {"Input": [{"name": "SRC", "type": "Variant", "description": "Source tag"}, {"name": "DST", "type": "ResolvedSymbol", "description": "Target tag that is referenced by the resolved symbol."}], "Output": [{"name": "Function value (RET_VAL)", "type": "INT", "": "Error information"}], "InOut": []}, "how_to_use": "Source and target tag must have the same data type. Before you execute this instruction, you can use the instruction \"TypeOf\" to query the data type of the tag that is referenced by ResSymbol.", "example_code": "#Tag_RetVal := MoveToResolvedSymbol(SRC := \"MySrcDB\".Input_Variant, DST => \"MyTargetDB\".Output_ResolvedSymbol);", "additional_info": "The references in the SDT \"ResolvedSymbol\" can become invalid when the referenced tags are overwritten by loading in \"RUN\". Resolve the symbols again with the instruction \"ResolveSymbols\" if encounter errors.", "generated_brief": {"functional_summary": "MoveToResolvedSymbol reads the value from a source tag and writes it to a target tag identified by a resolved symbol with matching data types.", "usage_context": "It is typically used in PLC programs to dynamically update tags referenced by resolved symbols, especially after symbol references may have become invalid during runtime."}, "generated_keywords": ["write to resolved symbol", "tag value transfer", "dynamic tag update", "data type matching", "symbol resolution"]}
{"instruction_name": "GOTO", "description": "Use the instruction \"Jump\" to resume the execution of a program at a given point marked with a jump label. The jump labels and the instruction \"Jump\" must be in the same block. The name of a jump label can only be once within a block. Each jump label can be the target of several jump instructions. A jump from the \"outside\" into a program loop is not permitted, but a jump from a loop to the \"outside\" is possible. Adhere to the grammatical rules for jump labels: Letters (a to z, A to Z), a combination of letters and numbers with letters first then numbers (a-z, A-Z, 0-9). Special characters or reversed order (numbers then letters) are not allowed.", "parameters": {"Input": [{"name": "<jump label>", "type": "-", "description": "Jump label to be jumped to"}], "Output": [], "InOut": []}, "how_to_use": "Declare the instruction as GOTO <jump label>; Place the jump label in the same block followed by the instructions to execute after the jump. Ensure jump labels follow the naming conventions and are unique within the block. Avoid jumping into loops from outside but jumping from loops to outside is allowed.", "example_code": "CASE \"Tag_Value\" OF\n  1 : GOTO MyLABEL1;\n  2 : GOTO MyLABEL2;\n  3 : GOTO MyLABEL3;\n  ELSE GOTO MyLABEL4;\nEND_CASE;\nMyLABEL1: \"Tag_1\" := 1;\nMyLABEL2: \"Tag_2\" := 1;\nMyLABEL3: \"Tag_3\" := 1;\nMyLABEL4: \"Tag_4\" := 1;", "additional_info": "", "generated_brief": {"functional_summary": "The GOTO instruction causes the program execution to jump to a specified label within the same block, enabling conditional or direct transfer of control flow.", "usage_context": "It is typically used to simplify program flow by directing execution to different code sections based on conditions, especially within CASE statements or conditional branches in PLC control logic."}, "generated_keywords": ["program flow control", "jump to label", "conditional branching", "control transfer", "GOTO instruction"]}
{"instruction_name": "AssignmentAttempt", "description": "With the \"AssignmentAttempt\" instruction, you attempt an assignment to a reference tag. The following assignment attempts are possible: Assignment attempt of a VARIANT to a reference; Assignment attempt of a DB_ANY to the reference of a technology object. In SCL, you can also assign NULL in the assignment attempt to specifically set the reference to NULL. The data type of a reference tag is determined at the time of declaration. However, the data type of a VARIANT tag is determined during runtime. An implicit data type conversion is not permitted with reference tags. To assign the two data types to each other therefore, use the assignment attempt. With the assignment attempt, a check is made at runtime to find out whether the assigned tag is of the correct data type. If this is the case, the instruction is executed. If the instruction is executed successfully, there is a valid reference in the target tag, otherwise a NULL. After the assignment attempt, you can check if the attempt was successful and, depending on the result, continue processing the program. In LAD and FBD, you can use the enable output \"ENO\" for the check. \"ENO\" returns the signal state \"1\" if the assignment attempt was successful. Only then are the subsequent instructions executed in the network. In STL and SCL, you can use the instructions \"IS_NULL\" or \"NOT_NULL\", for example, to check the success of an assignment attempt.", "parameters": {"Input": [{"name": "SRC", "type": "VARIANT, DB_ANY, NULL", "description": "Pointer to the source tag whose address will be read out or NULL"}], "Output": [{"name": "DST", "type": "reference to Bit sequences except BOOL, Integers, Floating-point numbers, Character strings, PLC data types (UDT), System data types (SDT), ARRAYs of the named data types (if SRC = VARIANT); reference to Technology object (if SRC = DB_ANY)", "description": "Reference to which the address of the source tag will be transferred"}], "InOut": []}, "how_to_use": "Use AssignmentAttempt to safely assign the address of a VARIANT or DB_ANY source to a reference output. In LAD/FBD, verify success using the ENO output (1 means success). In STL/SCL, use IS_NULL or NOT_NULL functions to check if the assignment succeeded. In SCL, you can assign NULL to explicitly invalidate a reference. Ensure VARIANT tags point to valid optimized memory areas and match array limits exactly. For technology objects assignable by DB_ANY, ensure types match or derive correctly.", "example_code": "VAR\n    myVariant : VARIANT;\n    myReference : REF_TO INT;\nEND_VAR\n\n// Attempt assignment\nmyReference ?= myVariant;\n\n// Check success\nIF NOT_NULL(myReference) THEN\n    myReference^ := 10;\nEND_IF;", "additional_info": "VARIANT must not point to temporary memory. Arrays must exactly match declared reference ranges. Assignment attempts of VARIANT to technology object references are not possible. DB_ANY references to technology objects must be in optimized memory. Derived types can be assigned to base types but not vice versa. Assignment attempts cannot be used in chained assignments in SCL.", "generated_brief": {"functional_summary": "The AssignmentAttempt instruction tries to safely assign the address of a VARIANT or DB_ANY source to a strongly typed reference tag at runtime, validating the data type compatibility and setting the reference to NULL if unsuccessful.", "usage_context": "It is typically used in PLC programs to dynamically link references to variable data or technology objects while ensuring safe type assignments and enabling conditional program flow based on assignment success."}, "generated_keywords": ["runtime safe assignment", "reference tag assignment", "VARIANT and DB_ANY assignment", "assignment success check", "type-compatible reference linking"]}
{"instruction_name": "F_TRIG", "description": "With the \"Detect negative signal edge\" instruction, you can detect a state change from \"1\" to \"0\" at the CLK input. The instruction compares the current value at the CLK input with the state of the previous query (edge memory bit) that is saved in the specified instance. If the instruction detects a state change at the CLK input from \"1\" to \"0\", a negative signal edge is generated at the Q output, i.e., the output has the value TRUE or \"1\" for exactly one cycle. In all other cases, the signal state at the output of the instruction is \"0\".", "parameters": {"Input": [{"name": "CLK", "type": "BOOL", "description": "Incoming signal, the edge of which is to be queried"}], "Output": [{"name": "Q", "type": "BOOL", "description": "Result of edge evaluation"}], "InOut": []}, "how_to_use": "The instruction requires an instance to store the edge memory bit, which must be initialized to TRUE to ensure correct negative edge detection behavior after CPU startup according to the IEC61131 standard. Use the input CLK to provide the signal to be monitored. The output Q goes TRUE for one cycle upon detection of a falling edge (1 to 0) at CLK.", "example_code": "\"F_TRIG_DB\"(CLK := \"TagIn\", Q => \"TagOut\");", "additional_info": "After CPU startup, to comply with the IEC61131 standard where output Q is TRUE if input CLK is FALSE, the instance representing the edge memory bit (Stat_Bit) must be initialized with TRUE.", "generated_brief": {"functional_summary": "The F_TRIG instruction detects a falling edge (transition from TRUE to FALSE) on its input signal and outputs a TRUE value for one cycle when this negative edge occurs.", "usage_context": "It is typically used in PLC programs to trigger events or actions precisely at the moment a signal changes from high to low, such as monitoring sensor state changes or initiating processes on signal fall."}, "generated_keywords": ["falling edge detection", "negative edge trigger", "signal transition monitoring", "one cycle pulse output", "PLC event triggering"]}
{"instruction_name": "R_TRIG", "description": "With the \"Detect positive signal edge\" instruction, you can detect a state change from \"0\" to \"1\" at the CLK input. The instruction compares the current value at the CLK input with the state of the previous query (edge memory bit) that is saved in the specified instance. If the instruction detects a state change at the CLK input from \"0\" to \"1\", a positive signal edge is generated at the Q output, i.e., the output has the value TRUE or \"1\" for exactly one cycle. In all other cases, the signal state at the output of the instruction is \"0\".", "parameters": {"Input": [{"name": "CLK", "type": "BOOL", "description": "Incoming signal, the edge of which is to be queried"}], "Output": [{"name": "Q", "type": "BOOL", "description": "Result of edge evaluation"}], "InOut": []}, "how_to_use": "Use this instruction to detect a positive edge (0 to 1) on a boolean input signal. Connect the signal to the CLK input, and the output Q will be set to TRUE for one PLC cycle upon detecting a positive edge. The previous state is stored internally in the instance of the instruction and must be retained across scans.", "example_code": "\"R_TRIG_DB\"(CLK := \"TagIn\",\n            Q => \"TagOut\");", "additional_info": "The previous state of the input signal must be stored in the instance data (e.g., \"R_TRIG_DB\") for the edge detection to work. Output Q is TRUE for exactly one cycle when a rising edge is detected. The parameters can be located in various memory areas such as I, Q, M, D, L.", "generated_brief": {"functional_summary": "The R_TRIG instruction detects a rising edge (transition from 0 to 1) on a boolean input signal and outputs a TRUE signal for exactly one PLC cycle when this occurs.", "usage_context": "It is typically used in automation programs to trigger actions or events precisely at the moment an input signal changes from low to high."}, "generated_keywords": ["rising edge detection", "positive edge trigger", "boolean input signal", "single cycle output", "edge detection instance"]}
{"instruction_name": "MoveResolvedSymbolsFromBuffer", "description": "With the 'Read values from buffer and write them into resolved symbols' instruction, you read values from a memory area (Array of BYTE) and write them into the values of several resolved symbols. In this way, you can process a memory area that you have received from a communication instruction, such as TRCV.", "parameters": {"Input": [{"name": "firstIndex", "type": "DINT", "description": "Index of the first resolved symbol in the target buffer that is to be written."}, {"name": "lastIndex", "type": "DINT", "description": "Index of the last resolved symbol in the target buffer that is to be written."}, {"name": "mode", "type": "DWORD", "description": "Memory format (2#0 = Big-Endian, 2#1 = Little-Endian)."}, {"name": "src", "type": "Array of BYTE", "description": "Source buffer from which the values are read."}, {"name": "srcOffsets", "type": "Array of DINT", "description": "Offsets of the values in the source buffer."}], "Output": [], "InOut": [{"name": "dst", "type": "Array of ResolvedSymbol", "description": "Target buffer that contains the references to the resolved symbols."}, {"name": "status", "type": "Array of INT", "description": "Contains a copy status for each value to be written."}]}, "how_to_use": "This instruction allows you to copy values from a source buffer into specified resolved symbols based on provided offsets. Ensure that the arrays for srcOffsets and dst have the same limits.", "example_code": "#Tag_RetVal := MoveResolvedSymbolsFromBuffer(firstIndex := 2,\n                                 lastIndex := 7,\n                                 mode := 2#0,\n                                 src := 'MySrcDB'.Input_Buffer,\n                                 srcOffsets := #Input_Offset,\n                                 dst := 'MyTargetDB'.InOut_ResolvedSymbols,\n                                 status := #InOut_Status);", "additional_info": "The instruction does not check for overlapping offsets, which can lead to random values being read if not managed correctly.", "generated_brief": {"functional_summary": "This instruction reads values from a specified memory buffer and writes them into a range of resolved symbols using given offsets and memory format settings.", "usage_context": "It is typically used to process data received from communication instructions by transferring raw byte arrays into meaningful PLC variables for further automation tasks."}, "generated_keywords": ["read values from buffer", "write to resolved symbols", "data transfer from byte array", "memory format handling", "process communication data"]}
{"instruction_name": "MoveResolvedSymbolsToBuffer", "description": "With the \"Read values from resolved symbols and write them into buffer\" instruction, you read values from several resolved symbols and write them into a memory area (Array of BYTE). In this way, you can prepare values of resolved symbols for further use, such as sending using communication instructions, e.g. TSEND.", "parameters": {"Input": [{"name": "firstIndex", "type": "DINT", "description": "Index of the first resolved symbol to be copied."}, {"name": "lastIndex", "type": "DINT", "description": "Index of the last resolved symbol to be copied."}, {"name": "src", "type": "Array of ResolvedSymbol", "description": "List of resolved symbols"}, {"name": "dstOffsets", "type": "Array of DINT", "description": "Contains a bit offset for each element in the destination buffer"}, {"name": "mode", "type": "DWORD", "description": "Memory format:\n2#0 = Big-Endian\n2#1 = Little-Endian"}], "Output": [], "InOut": [{"name": "dst", "type": "Array of BYTE", "description": "Target buffer to which the values of the resolved symbols are copied"}, {"name": "status", "type": "Array of INT", "description": "Contains a copy status for each resolved symbol"}]}, "how_to_use": "Specify the source resolved symbols array and the destination buffer matching array limits. Use firstIndex and lastIndex to select the range of symbols to copy. Use dstOffsets to define bit offsets for each corresponding symbol value in the destination buffer and set the memory format via mode. After execution, check the status array for copy result per symbol and RET_VAL for overall error information. If status indicates invalid references, resolve symbols again with the instruction \"ResolveSymbols\".", "example_code": "#Tag_RetVal := MoveResolvedSymbolsToBuffer(firstIndex := 2,\n                                lastIndex := 7, \n                                src := \"MySrcDB\".Input_ResolvedSymbols,\n                                dstOffsets := #Input_Offset,\n                                mode := 2#0,\n                                dst := \"MyTargetDB\".InOut_Buffer,\n                                status := #InOut_Status);", "additional_info": "The and dstOffsets arrays must have the same limits. The instruction does not verify overlapping offsets; overlapping causes indeterminate content in dst without error. Values can be stored in Big-Endian or Little-Endian format. For BOOL data types, values can be stored at bit positions within a byte; for other types, offsets must start at bit positions divisible by 8. Status values indicate specific error codes for invalid references, unsuitable data types, or memory issues. RET_VAL provides overall call error codes. ResolvedSymbol references may become invalid after loading during RUN and require re-resolution.", "generated_brief": {"functional_summary": "The MoveResolvedSymbolsToBuffer instruction reads values from a range of resolved symbols and writes them into a specified byte buffer with configurable bit offsets and memory format.", "usage_context": "It is typically used to prepare symbol data for communication tasks, such as transmitting the values via network protocols using communication instructions like TSEND."}, "generated_keywords": ["read resolved symbols", "write to byte buffer", "symbol data serialization", "memory format conversion", "data preparation for communication"]}
{"instruction_name": "ResolveSymbols", "description": "With the \"Resolve several symbols\" instruction, you resolve multiple symbolic tag names. As a result, you receive references to the tags. References are typed pointers that give you read or write access to the tags.", "parameters": {"Input": [{"name": "execute", "type": "BOOL", "description": "With a rising signal edge, execution of the instruction is started."}, {"name": "firstIndex", "type": "DINT", "description": "Index of the first tag name to be resolved."}, {"name": "lastIndex", "type": "DINT", "description": "Index of the last tag name to be resolved."}], "Output": [{"name": "done", "type": "BOOL", "description": "Done = 1. Execution of the instruction is complete."}, {"name": "busy", "type": "BOOL", "description": "Busy = 1. The instruction is currently being executed."}, {"name": "error", "type": "BOOL", "description": "ERROR = 1. Error occurred during processing. The error message is output at the STATUS parameter."}, {"name": "status", "type": "INT", "description": "Block status / error number (see \"STATUS parameter\")"}], "InOut": [{"name": "nameList", "type": "Array of WSTRING", "description": "List of tag names to be resolved."}, {"name": "referenceList", "type": "Array of ResolvedSymbol", "description": "List of references"}]}, "how_to_use": "Initialize the instruction by providing an array of tag names in the \"nameList\" parameter and an array of ResolvedSymbol structures in the \"referenceList\" parameter. Trigger execution by a rising edge on the \"execute\" input. Specify the range of tag names to resolve using \"firstIndex\" and \"lastIndex\". Wait for \"done\" output to become TRUE indicating completion. Do not modify \"nameList\" or \"referenceList\" while \"busy\" is TRUE. After execution, references to the tags will be available in \"referenceList\".", "example_code": "\"ResolveSymbols_DB\"(execute := #Input_Execute,\n                firstIndex := 0,\n                lastIndex := 9,\n                done => #Output_Done,\n                busy => #Output_Busy,\n                error => _bool_out_,\n                status => _int_out_,\n                nameList := \"MySrcDB\".InOut_Symbols,\n                referenceList := \"MyTargetDB\".InOut_ResolvedSymbols);", "additional_info": "The symbolic tag names must be WSTRINGs of maximum length 254 UTF-16 characters, fully qualified including namespaces. The '#' qualifier for local tags is not supported. Array elements must specify fixed indices; variable indexing is not supported. Maximum 10 instances of ResolveSymbols can be active simultaneously with a combined limit of resolving 2,000 symbols. The instruction executes asynchronously and resets values in the \"referenceList\" array within the specified indices before resolution. Error codes indicate specific issues such as invalid indices or memory area violations.", "generated_brief": {"functional_summary": "The ResolveSymbols instruction asynchronously resolves multiple symbolic tag names into typed references that allow read/write access to those tags.", "usage_context": "This function is typically used in PLC automation programs when you need to dynamically obtain references to multiple tags for subsequent manipulation or monitoring within a specified range."}, "generated_keywords": ["resolve symbolic tags", "asynchronous tag referencing", "dynamic tag pointers", "symbolic name resolution", "bulk tag resolution"]}
{"instruction_name": "ENDIS_PW", "description": "With the instruction ENDIS_PW (enable / disable password) you lock the passwords for the individual access levels of your CPU or release them again. By locking the passwords, existing legitimized connections can be terminated. Calling ENDIS_PW with REQ=1 locks or releases passwords depending on the states of the input parameters F_PWD, FULL_PWD, R_PWD, and HMI_PWD. Calling ENDIS_PW with REQ=0 displays the current password status for each access level without changing any lock state. Each password can be locked or released independently of the others, allowing selective limitation of access.", "parameters": {"Input": [{"name": "REQ", "type": "BOOL", "description": "REQ=0: Determine current password status for the individual access levels in your CPU. REQ=1: Lock or release passwords for the individual access levels of your CPU."}, {"name": "F_PWD", "type": "BOOL", "description": "F_PWD=0: Lock password of the access level 'Full access including fail-safe (no protection)'. F_PWD=1: Release password of this access level."}, {"name": "FULL_PWD", "type": "BOOL", "description": "FULL_PWD=0: Lock password of the access level 'Full access (no protection)'. FULL_PWD=1: Release password of this access level."}, {"name": "R_PWD", "type": "BOOL", "description": "R_PWD=0: Lock password of the access level 'Read access'. R_PWD=1: Release password of this access level."}, {"name": "HMI_PWD", "type": "BOOL", "description": "HMI_PWD=0: Lock password of the access level 'HMI access'. HMI_PWD=1: Release password of this access level."}], "Output": [{"name": "F_PWD_ON", "type": "BOOL", "description": "Current password status of 'Full access including fail-safe (no protection)': 0=password locked, 1=password released."}, {"name": "FULL_PWD_ON", "type": "BOOL", "description": "Current password status of 'Full access (no protection)': 0=password locked, 1=password released."}, {"name": "R_PWD_ON", "type": "BOOL", "description": "Current password status of 'Read access': 0=password locked, 1=password released."}, {"name": "HMI_PWD_ON", "type": "BOOL", "description": "Current password status of 'HMI access': 0=password locked, 1=password released."}, {"name": "RET_VAL", "type": "WORD", "description": "Error information. 0x0000: No error; 0x8090: Instruction not supported; 0x80D0 to 0x80D3: Configuration errors related to password inputs."}], "InOut": []}, "how_to_use": "Call ENDIS_PW with REQ=1 to lock or release passwords by setting the respective input parameters to 0 (lock) or 1 (release). Call with REQ=0 to query the current lock status without changing it. Ensure inputs for password levels without configured passwords are set to TRUE, or an error will be returned. Use this instruction to control access levels and prevent unauthorized usage. For S7-1500 CPUs with display, password lock state can also be controlled locally. To prevent unintended lockout, handle password status appropriately during mode transitions or startup.", "example_code": "\"Tag_Result\" := ENDIS_PW(REQ := 0,\n                         F_PWD := 0,\n                         FULL_PWD := 0,\n                         R_PWD := 1,\n                         HMI_PWD := 0,\n                         F_PWD_ON => \"Status_F_PWD\",\n                         FULL_PWD_ON => \"Status_FULL_PWD\",\n                         R_PWD_ON => \"Status_R_PWD\",\n                         HMI_PWD_ON => \"Status_HMI_PWD\");", "additional_info": "If ENDIS_PW returns an error, the call has no effect and password states remain unchanged. Locking the HMI password blocks HMI system access to the CPU. Existing legitimized connections may be terminated if relevant passwords are locked. Password locks can be temporarily removed by switching CPU modes or power cycling (S7-1200). Use timers or interrupts at startup to call ENDIS_PW and avoid unintentional lockout. In case of lost password on S7-1200, use empty transfer or program cards to reset memory and reload the program. Handle transfer/program cards carefully during runtime to avoid unexpected CPU STOP and unsafe system behavior.", "generated_brief": {"functional_summary": "The ENDIS_PW instruction locks or releases passwords for different CPU access levels and can also query their current lock status.", "usage_context": "It is used to control and manage password-protected access levels in a PLC to prevent unauthorized use and manage existing connections securely."}, "generated_keywords": ["password lock control", "CPU access management", "access level security", "password status query", "unauthorized access prevention"]}
{"instruction_name": "LOWER_BOUND", "description": "The \"Read out ARRAY low limit\" instruction is used to read out the variable low limit of the ARRAY.", "parameters": {"Input": [{"name": "ARR", "type": "ARRAY[*]", "description": "ARRAY of which the variable low limit is to be read."}, {"name": "DIM", "type": "UDINT", "description": "Dimension of the ARRAY of which the variable low limit is to be read."}], "Output": [{"name": "Function value", "type": "DINT", "description": "Result"}], "InOut": []}, "how_to_use": "Use LOWER_BOUND to read the variable low limit of an ARRAY parameter within a function block or function. Specify the target ARRAY as ARR and the dimension index as DIM. The instruction returns the low boundary for the specified dimension. Ensure the ARR parameter is declared with data type ARRAY[*].", "example_code": "\"Result\" := LOWER_BOUND(ARR := #ARRAY_A, DIM := 2);", "additional_info": "This instruction is available for S7-1200 CPUs with firmware version >= 4.2 and S7-1500 CPUs with firmware version >= 2.0.", "generated_brief": {"functional_summary": "The LOWER_BOUND instruction reads and returns the low limit index of a specified dimension in an ARRAY variable.", "usage_context": "It is used within function blocks or functions when it is necessary to determine the starting index of an ARRAY dimension for processing or validation in S7-1200 and S7-1500 PLCs."}, "generated_keywords": ["read array lower bound", "array dimension low limit", "ARRAY index retrieval", "LOWER_BOUND instruction", "PLC array boundary"]}
{"instruction_name": "UPPER_BOUND", "description": "The instruction 'Read out ARRAY high limit' is used to read out the variable high limit of the ARRAY.", "parameters": {"Input": [{"name": "ARR", "type": "ARRAY[*]", "description": "ARRAY of which the variable high limit is to be read."}, {"name": "DIM", "type": "UDINT", "description": "Dimension of the ARRAY of which the variable high limit is to be read."}], "Output": [{"name": "Function value", "type": "DINT", "description": "Result"}], "InOut": []}, "how_to_use": "You need to provide the ARRAY and the dimension as inputs to read the variable high limit.", "example_code": "\"Result\" := UPPER_BOUND(ARR := #ARRAY_A,\n                              DIM := 2);", "additional_info": "The instruction is available for a CPU of the S7-1200 series as of firmware version >= 4.2, and for a CPU of the S7-1500 series as of firmware version >= 2.0.", "generated_brief": {"functional_summary": "The UPPER_BOUND instruction returns the highest valid index of a specified dimension in an array.", "usage_context": "It is used when determining the upper boundary of an array dimension for bounds checking or iterative processing in S7-1200 and S7-1500 PLC programs."}, "generated_keywords": ["read array upper bound", "array high limit", "array dimension upper index", "array bounds checking", "array iteration limit"]}
{"instruction_name": "S_CD", "description": "You can use the \"Assign parameters and count down\" instruction to decrement the value of a counter. When the signal state of the CD parameter changes from \"0\" to \"1\" (positive signal edge), the current counter value is decreased by one. The current counter value is provided at the parameter CV. The counter value is decreased until the low limit of \"0\" is reached. When the low limit is reached, the counter value is no longer decreased on a positive signal edge.\n\nWhen the signal state of the S parameter changes from \"0\" to \"1\", the counter value is set to the value of the PV parameter. If the counter is set and if the result of logic operation (RLO) at the CD parameter is \"1\", the counter counts once in the next cycle, even when no signal edge change is detected.\n\nThe counter value is set to zero when the signal state of the R parameter changes to \"1\". As long as the R parameter has the signal state \"1\", a change in the signal state of the parameters CD and S has no effect on the counter value.\n\nThe signal state at parameter Q is \"1\" if the counter value is greater than zero. When the counter value equals zero, parameter Q returns signal state \"0\".", "parameters": {"Input": [{"name": "C_NO", "type": "COUNTER, INT", "description": "Counter operations. The number of counters depends on the CPU."}, {"name": "CD", "type": "BOOL", "description": "Count down input"}, {"name": "S", "type": "BOOL", "description": "Input for presetting the counter"}, {"name": "PV", "type": "WORD", "description": "Preset counter value (C#0 to C#999) in BCD format"}, {"name": "R", "type": "BOOL", "description": "Reset input"}], "Output": [{"name": "Q", "type": "BOOL", "description": "Status of the counter"}, {"name": "CV", "type": "WORD", "description": "Current counter value"}, {"name": "Function value", "type": "WORD", "description": "Current counter value in BCD format"}], "InOut": []}, "how_to_use": "Use the CD input to decrement the counter on a positive edge signal; use the S input to preset the counter to PV on a positive edge; use R input to reset the counter to zero. The output Q indicates if the counter value is greater than zero, while CV holds the current counter value. Avoid using the same counter in multiple locations in the program to prevent counting errors.", "example_code": "\"Tag_Result\" := S_CD(C_NO := \"Counter_1\",\n                      CD := \"Tag_Start\",\n                      S := \"Tag_1\",\n                      PV := \"Tag_PresetValue\",\n                      R := \"Tag_Reset\",\n                      Q => \"Tag_Status\",\n                      CV => \"Tag_Value\");", "additional_info": "Only use a counter at a single point in the program to avoid the risk of counting errors.", "generated_brief": {"functional_summary": "The S_CD instruction presets, decrements, and resets a counter value based on input signals, outputting the current count and status indicating if the count is above zero.", "usage_context": "It is typically used in industrial automation to track event occurrences or control sequences by counting down from a preset value, with provisions for resetting and status monitoring."}, "generated_keywords": ["counter decrement", "counter preset", "counter reset", "positive edge trigger", "count status output"]}
{"instruction_name": "S_CD", "description": "You can use the \"Assign parameters and count up / down\" instruction to increment and decrement the value of a counter. When the signal state of the CU parameter changes from \"0\" to \"1\" (positive signal edge), the current counter value is incremented by one. When the signal state of the CD parameter changes from \"0\" to \"1\" (positive signal edge), the counter value is decreased by one. The current counter value is provided at the parameter CV. If there is a positive signal edge at the parameters CU and CD in one program cycle, the counter value remains unchanged.\nThe counter value is incremented until the high limit of \"999\" is reached. When the high limit is reached, the counter value is no longer incremented on a positive signal edge. When the low limit \"0\" is reached, the counter value is not decremented any further.\nWhen the signal state of the S parameter changes from \"0\" to \"1\", the counter value is set to the value of the PV parameter. If the counter is set and if the result of logic operation (RLO) of the CU and CD parameters is \"1\", the counter will count once in the next cycle, even if no signal edge change was detected.\nThe counter value is set to zero when the signal state of the R parameter changes to \"1\". As long as the parameter R has the signal state \"1\", processing of the signal state of the parameters CU, CD and S has no effect on the counter value.\nThe signal state at parameter Q is \"1\" if the counter value is greater than zero. When the counter value equals zero, parameter Q returns signal state \"0\".", "parameters": {"Input": [{"name": "C_NO", "type": "COUNTER, INT", "description": "Counter operations. The number of counters depends on the CPU."}, {"name": "CU", "type": "BOOL", "description": "Count up input"}, {"name": "CD", "type": "BOOL", "description": "Count down input"}, {"name": "S", "type": "BOOL", "description": "Input for presetting the counter"}, {"name": "PV", "type": "WORD", "description": "Preset counter value (C#0 to C#999) in BCD format"}, {"name": "R", "type": "BOOL", "description": "Reset input"}], "Output": [{"name": "Q", "type": "BOOL", "description": "Status of the counter"}, {"name": "CV", "type": "WORD", "description": "Current counter value (hexadecimal)"}, {"name": "Function value", "type": "WORD", "description": "Current counter value in BCD format"}], "InOut": []}, "how_to_use": "Use the S_CD instruction to increment or decrement a counter value on the positive edges of CU (count up) and CD (count down) signals. The counter value saturates at 0 (low) and 999 (high). The S input presets the counter to PV value when a positive edge is detected. The R input resets the counter to zero and disables counting while active. The Q output shows if the counter value is greater than zero. Avoid using a counter instance in multiple places to prevent counting errors.", "example_code": "\"Tag_Result\" := S_CD(C_NO := \"Counter_1\",\n                      CU := \"Tag_CU\",\n                      CD := \"Tag_CD\",\n                      S := \"Tag_1\",\n                      PV := \"Tag_PresetValue\",\n                      R := \"Tag_Reset\",\n                      Q => \"Tag_Status\",\n                      CV => \"Tag_Value\");", "additional_info": "Only use a counter at a single point in the program to avoid the risk of counting errors.", "generated_brief": {"functional_summary": "The S_CD instruction increments or decrements a counter value based on positive edges of count-up and count-down inputs, supports presetting and resetting, and outputs the current count and its status.", "usage_context": "It is typically used in PLC programs to track event occurrences or process counts within defined limits, such as monitoring production quantities or controlling sequential operations."}, "generated_keywords": ["counter increment decrement", "preset counter value", "counter reset", "positive edge counting", "PLC counting instruction"]}
{"instruction_name": "S_CU", "description": "You can use the \"Assign parameters and count up\" instruction to increment the value of a counter. When the signal state of the CU parameter changes from \"0\" to \"1\" (positive signal edge), the current counter value is incremented by one. The current counter value is provided at the parameter CV. The counter value is incremented until the limit of \"999\" is reached. When the limit value is reached, the counter value is no longer incremented on a positive signal edge. When the signal state the S parameter changes from \"0\" to \"1\", the counter value is set to the value of the PV parameter. If the counter is set and if the result of logic operation (RLO) at the CU input is \"1\", the counter counts once in the next cycle, even when no signal edge change is detected. The counter value is set to zero when the signal state of the R parameter changes to \"1\". As long as the R parameter has the signal state \"1\", a change in the signal state of the parameters CU and S has no effect on the counter value. The signal state at parameter Q is \"1\" if the counter value is greater than zero. When the counter value equals zero, parameter Q returns signal state \"0\".", "parameters": {"Input": [{"name": "C_NO", "type": "COUNTER, INT", "description": "Counter operations. The number of counters depends on the CPU."}, {"name": "CU", "type": "BOOL", "description": "Count up input"}, {"name": "S", "type": "BOOL", "description": "Input for presetting the counter"}, {"name": "PV", "type": "WORD", "description": "Preset counter value (C#0 to C#999) in BCD format"}, {"name": "R", "type": "BOOL", "description": "Reset input"}], "Output": [{"name": "Q", "type": "BOOL", "description": "Status of the counter"}, {"name": "CV", "type": "WORD", "description": "Current counter value"}, {"name": "Function value", "type": "WORD", "description": "Current counter value in BCD format"}], "InOut": []}, "how_to_use": "Use this instruction by linking the count up input (CU) to a signal that triggers on a positive edge to increment the counter, the preset input (S) to set a defined counter value according to PV, and the reset input (R) to reset the counter value to zero. Monitor the output Q for status and CV for the current counter value. Ensure the counter is only used at a single point in the program to avoid counting errors.", "example_code": "\"Tag_Result\" := S_CU(C_NO := \"Counter_1\",\n                  CU := \"Tag_Start\",\n                  S := \"Tag_1\",\n                  PV := \"Tag_PresetValue\",\n                  R := \"Tag_Reset\",\n                  Q => \"Tag_Status\",\n                  CV => \"Tag_Value\");", "additional_info": "Only use a counter at a single point in the program to avoid the risk of counting errors. The counter value is limited to 999 and will no longer increment after this limit is reached. The current counter value is stored in hexadecimal form in the CV output and returned as a function value in BCD format.", "generated_brief": {"functional_summary": "The S_CU function increments a counter on a positive edge of the count-up input, allows presetting and resetting the counter value, and outputs the current count along with a status flag indicating if the count is above zero.", "usage_context": "This function is typically used in PLC programs to track event counts or quantities in industrial automation processes, ensuring precise counting control with preset and reset capabilities."}, "generated_keywords": ["counter increment", "positive edge trigger", "preset counter value", "counter reset", "counter status output"]}
{"instruction_name": "TypeOf", "description": "This instruction checks the data type of a tag to which a VARIANT or a ResolvedSymbol is pointing. It allows comparison of the declared data type with another tag or directly with a data type to determine whether they are 'Equal' or 'Not equal'.", "parameters": {"Input": [{"name": "<Operand>", "type": "Binary numbers, integers, floating-point numbers, times, date and time, character strings, VARIANT, ResolvedSymbol", "description": "Operand to query"}], "Output": [], "InOut": []}, "how_to_use": "This instruction can only be used within an IF or CASE instruction.", "example_code": "IF TypeOf(#TagVARIANT) = TypeOf('TagBYTE') THEN\n...\nEND_IF;\n\nIF TypeOf(#TagVARIANT) = BYTE THEN\n...\nEND_IF;\n\nCASE TypeOf(ResolvedSymbol[100]) OF\n   INT:\n   ...;\nEND_CASE;", "additional_info": "Symbolic access during runtime requires the system data type 'ResolvedSymbol' to access tags in the PLC program by an external application.", "generated_brief": {"functional_summary": "The TypeOf instruction determines the data type of a VARIANT or ResolvedSymbol tag and compares it with another data type or tag to check for equality.", "usage_context": "It is typically used within IF or CASE instructions to perform type-based decision making in PLC programs, especially when accessing tags symbolically at runtime."}, "generated_keywords": ["data type comparison", "VARIANT type check", "ResolvedSymbol type", "type equality check", "IF CASE instruction usage"]}
{"instruction_name": "IS_ARRAY", "description": "You can use the \"Check for ARRAY\" instruction to query whether the <operand> parameter points to a tag of the ARRAY data type. You can only use the \"Check for ARRAY\" instruction within an IF instruction.", "parameters": {"Input": [{"name": "<Operand>", "type": "VARIANT, ResolvedSymbol", "description": "Operand that is queried for ARRAY"}], "Output": [{"name": "Function value", "type": "UDINT", "description": "Result of the instruction"}], "InOut": []}, "how_to_use": "The IS_ARRAY instruction is used within an IF statement to check if the given VARIANT operand references an type. If true, the number of elements in the ARRAY can be retrieved (e.g., via CountOfElements). When using an ArrayDB as input, ensure there is a symbolic use of the ArrayDB elsewhere as a VARIANT parameter to function correctly. The point of use must be downloaded but not necessarily executed.", "example_code": "IF IS_ARRAY(#Tag_VARIANTToArray) THEN\n  \"Tag_Result\" := CountOfElements(#Tag_VARIANTToArray);\nEND_IF;", "additional_info": "When using IS_ARRAY with an ArrayDB and creating the VARIANT input via DB_ANY_TO_VARIANT, a symbolic use of the ArrayDB must be present elsewhere in the program as a VARIANT parameter. It is sufficient if this point of use is downloaded to the PLC without requiring execution.", "generated_brief": {"functional_summary": "The IS_ARRAY instruction checks whether a given VARIANT operand references an ARRAY data type within an IF statement.", "usage_context": "It is typically used in conditional logic to verify an operand's type before performing array-specific operations, such as retrieving the number of elements."}, "generated_keywords": ["check array type", "IS_ARRAY instruction", "variant operand type check", "array verification in IF", "conditional array detection"]}
{"instruction_name": "BITCMP", "description": "You can use the \"Compare input bits with the bits of a mask\" instruction to compare the signal state of up to 16 programmed input bits (IN_BIT0 to IN_BIT15) with the corresponding bits of a mask. Up to 16 steps with masks can be programmed. The value of the IN_BIT0 parameter is compared with the value of the mask CMP_VAL[x,0], with \"x\" indicating the step number. In the CMP_STEP parameter, you specify the step number of the mask that is used for the comparison. All programmed values are compared in the same manner. Unprogrammed input bits or unprogrammed bits of the mask have a default signal state FALSE. If a match is found in the comparison, the signal state of the OUT parameter is set to \"1\". Otherwise the OUT parameter is set to \"0\". If the value of the CMP_STEP parameter is greater than 15, the instruction is not executed. An error message is output at the ERR_CODE parameter.", "parameters": {"Input": [{"name": "IN_BIT0", "type": "BOOL", "description": "Input bit 0 is compared with bit 0 of the mask."}, {"name": "IN_BIT1", "type": "BOOL", "description": "Input bit 1 is compared with bit 1 of the mask."}, {"name": "IN_BIT2", "type": "BOOL", "description": "Input bit 2 is compared with bit 2 of the mask."}, {"name": "IN_BIT3", "type": "BOOL", "description": "Input bit 3 is compared with bit 3 of the mask."}, {"name": "IN_BIT4", "type": "BOOL", "description": "Input bit 4 is compared with bit 4 of the mask."}, {"name": "IN_BIT5", "type": "BOOL", "description": "Input bit 5 is compared with bit 5 of the mask."}, {"name": "IN_BIT6", "type": "BOOL", "description": "Input bit 6 is compared with bit 6 of the mask."}, {"name": "IN_BIT7", "type": "BOOL", "description": "Input bit 7 is compared with bit 7 of the mask."}, {"name": "IN_BIT8", "type": "BOOL", "description": "Input bit 8 is compared with bit 8 of the mask."}, {"name": "IN_BIT9", "type": "BOOL", "description": "Input bit 9 is compared with bit 9 of the mask."}, {"name": "IN_BIT10", "type": "BOOL", "description": "Input bit 10 is compared with bit 10 of the mask."}, {"name": "IN_BIT11", "type": "BOOL", "description": "Input bit 11 is compared with bit 11 of the mask."}, {"name": "IN_BIT12", "type": "BOOL", "description": "Input bit 12 is compared with bit 12 of the mask."}, {"name": "IN_BIT13", "type": "BOOL", "description": "Input bit 13 is compared with bit 13 of the mask."}, {"name": "IN_BIT14", "type": "BOOL", "description": "Input bit 14 is compared with bit 14 of the mask."}, {"name": "IN_BIT15", "type": "BOOL", "description": "Input bit 15 is compared with bit 15 of the mask."}, {"name": "CMP_STEP", "type": "BYTE", "description": "The step number of the mask used for the comparison."}], "Output": [{"name": "OUT", "type": "BOOL", "description": "The signal state \"1\" indicates that a match was found. A signal state of \"0\" indicates that no match was found."}, {"name": "ERR_CODE", "type": "WORD", "description": "Error information"}], "InOut": []}, "how_to_use": "Program up to 16 individual input bits (IN_BIT0 to IN_BIT15) to compare against corresponding bits in a mask array (CMP_VAL) at the specified CMP_STEP index (0 to 15). If the input bits match the mask bits, the output OUT is set to TRUE; otherwise FALSE. Monitor ERR_CODE for errors like CMP_STEP greater than 15, which disables the instruction execution.", "example_code": "", "additional_info": "Unprogrammed input bits or unprogrammed bits of the mask have a default signal state FALSE. If CMP_STEP is greater than 15, the instruction does not execute and ERR_CODE outputs error 000A. The CMP_VAL is a static ARRAY OF WORD containing comparison masks indexed by step number and bit number. ERR_CODE 0000 means no error.", "generated_brief": {"functional_summary": "The BITCMP instruction compares up to 16 input bits against a specified mask at a chosen step and outputs TRUE if all bits match exactly, otherwise FALSE.", "usage_context": "It is typically used in PLC programs to verify specific bit pattern matches in input signals for decision-making or control logic based on predefined masks."}, "generated_keywords": ["bit comparison", "input mask matching", "multi-bit signal check", "mask step selection", "error code monitoring"]}
{"instruction_name": "SMC", "description": "You can use the \"Compare scan matrix\" instruction to compare the signal state of up to 16 programmed input bits (IN_BIT0 to IN_BIT15) with the corresponding bit of the comparison masks for each step. Processing starts at step 1 and is continued until the last programmed step (LAST) or until a match is found. The input bit of the IN_BIT0 parameter is compared with the value of the mask CMP_VAL[x,0], with \"x\" indicating the step number. All programmed values are compared in the same manner. If a match is found the signal state of the OUT parameter is set to \"1\" and the step number with the matching mask is written in the OUT_STEP parameter. Unprogrammed input bits or unprogrammed bits of the mask have a default signal state FALSE. If more than one step has a matching mask, only the first one found is indicated in the OUT_STEP parameter. If no match is found, the signal state of the OUT parameter is set to \"0\". In this case the value at the OUT_STEP parameter is greater by \"1\" than the value at the LAST parameter.", "parameters": {"Input": [{"name": "IN_BIT0", "type": "BOOL", "description": "Input bit 0 is compared with bit 0 of the mask."}, {"name": "IN_BIT1", "type": "BOOL", "description": "Input bit 1 is compared with bit 1 of the mask."}, {"name": "IN_BIT2", "type": "BOOL", "description": "Input bit 2 is compared with bit 2 of the mask."}, {"name": "IN_BIT3", "type": "BOOL", "description": "Input bit 3 is compared with bit 3 of the mask."}, {"name": "IN_BIT4", "type": "BOOL", "description": "Input bit 4 is compared with bit 4 of the mask."}, {"name": "IN_BIT5", "type": "BOOL", "description": "Input bit 5 is compared with bit 5 of the mask."}, {"name": "IN_BIT6", "type": "BOOL", "description": "Input bit 6 is compared with bit 6 of the mask."}, {"name": "IN_BIT7", "type": "BOOL", "description": "Input bit 7 is compared with bit 7 of the mask."}, {"name": "IN_BIT8", "type": "BOOL", "description": "Input bit 8 is compared with bit 8 of the mask."}, {"name": "IN_BIT9", "type": "BOOL", "description": "Input bit 9 is compared with bit 9 of the mask."}, {"name": "IN_BIT10", "type": "BOOL", "description": "Input bit 10 is compared with bit 10 of the mask."}, {"name": "IN_BIT11", "type": "BOOL", "description": "Input bit 11 is compared with bit 11 of the mask."}, {"name": "IN_BIT12", "type": "BOOL", "description": "Input bit 12 is compared with bit 12 of the mask."}, {"name": "IN_BIT13", "type": "BOOL", "description": "Input bit 13 is compared with bit 13 of the mask."}, {"name": "IN_BIT14", "type": "BOOL", "description": "Input bit 14 is compared with bit 14 of the mask."}, {"name": "IN_BIT15", "type": "BOOL", "description": "Input bit 15 is compared with bit 15 of the mask."}], "Output": [{"name": "OUT", "type": "BOOL", "description": "The signal state \"1\" indicates that a match was found. A signal state of \"0\" indicates that no match was found."}, {"name": "OUT_STEP", "type": "BYTE", "description": "Contains the step number with the matching mask or the step number which is greater by \"1\" than the value of the LAST parameter, provided no match is found."}, {"name": "ERR_CODE", "type": "WORD", "description": "Error information"}], "InOut": []}, "how_to_use": "Initialize the static parameters LAST and CMP_VAL with the last step to scan and the array of comparison masks, respectively. Then provide the input bits IN_BIT0 to IN_BIT15 to be compared. The instruction scans from step 1 up to LAST for a matching mask. If a match is found, OUT is set to 1 and OUT_STEP contains the matching step number; if no match is found, OUT is 0 and OUT_STEP equals LAST + 1. Check ERR_CODE for error status, e.g. LAST must not exceed 15.", "example_code": "", "additional_info": "Static parameters LAST and CMP_VAL are saved in the instance of the instruction and not visible in the program call. The ERR_CODE output parameter indicates errors, for example an error if LAST is greater than 15 (error code 000E). Unprogrammed input or mask bits default to FALSE for comparison. Only the first matching step is returned if multiple steps match.", "generated_brief": {"functional_summary": "The SMC instruction compares the states of up to 16 input bits against predefined masks across multiple steps and outputs whether a match is found along with the matching number.", "usage_context": "It is used in PLC programs to sequentially identify specific input signal patterns or conditions by scanning through programmed comparison masks for control or diagnostic purposes."}, "generated_keywords": ["scan input bits", "compare with masks", "sequential pattern matching", "output matching step", "error code detection"]}
{"instruction_name": "CTU", "description": "The \"Count up\" instruction increments the value at the CV parameter. When the signal state of the parameter CU changes from \"0\" to \"1\" (positive signal edge), the instruction is executed and the current counter value of the parameter CV is incremented by one. The counter value is incremented each time a positive signal edge is detected, until it reaches the high limit of the data type specified at the CV parameter. When the high limit is reached, the signal state of the CU parameter no longer has an effect on the instruction. You can query the count status of the Q parameter. The signal state of the Q parameter is determined by the PV parameter. When the current counter value is greater than or equal to the value of the PV parameter, the Q parameter is set to signal state \"1\". In all other cases, the signal state of the Q parameter is \"0\". The value of CV parameter is reset to zero when the signal state at the R parameter changes to \"1\". As long as the signal state of the R parameter is \"1\", the signal state of the CU parameter has no effect on the instruction.", "parameters": {"Input": [{"name": "CU", "type": "BOOL", "description": "Count input"}, {"name": "R", "type": "BOOL", "description": "Reset input"}, {"name": "PV", "type": "Integers", "description": "Value at which the Q output is set"}], "Output": [{"name": "Q", "type": "BOOL", "description": "Counter status"}, {"name": "CV", "type": "Integers, CHAR, WCHAR, DATE", "description": "Current counter value"}], "InOut": []}, "how_to_use": "Each call of the CTU instruction must be assigned an IEC counter in which the instruction data is stored. IEC counters can be declared either as instance data blocks of system data type IEC_<Counter> or as local tags (multi-instance) in the 'Static' section of a program block. For S7-1200 and S7-1500 CPUs, appropriate IEC counter data types and corresponding local tags should be used. The CV value is incremented on the positive edge of CU unless R is '1', which resets the counter to zero and disables counting while active. The Q output reflects if the current count CV is greater than or equal to PV. Use the CTU instruction only at a single point in the program to avoid counting errors.", "example_code": "\"IEC_COUNTER_DB\".CTU(CU := \"Tag_Start\",\n                     R := \"Tag_Reset\",\n                     PV := \"Tag_PresetValue\",\n                     Q => \"Tag_Status\",\n                     CV => \"Tag_CounterValue\");", "additional_info": "Only use a counter at single point in the program to avoid risk of counting errors. When IEC counters are declared as instance DBs with optimized block access, the individual tags are retentive. Local tags declared in function blocks with optimized block access are also retentive in the block interface.", "generated_brief": {"functional_summary": "The CTU instruction increments a counter value on each positive edge of the count input and sets a status output when the current count reaches or exceeds a preset value, with a reset input to clear the count.", "usage_context": "It is typically used in PLC programs to track event occurrences or objects counted in industrial processes, triggering actions once specified count thresholds are met."}, "generated_keywords": ["count up", "positive edge counting", "counter reset", "preset value comparison", "counter status output"]}
{"instruction_name": "Deserialize", "description": "You can use the 'Deserialize' instruction to convert back the sequential representation of a PLC data type (UDT), STRUCT or ARRAY of <data type> and to fill its entire contents. You can use the instruction to convert multiple serialized data areas back to their deserialized representation form.", "parameters": {"Input": [{"name": "SRC_ARRAY", "type": "ARRAY[*] of BYTE, ARRAY of CHAR", "description": "ARRAY of BYTE or ARRAY of CHAR in which the data stream which is to be deserialized is saved. For optimum performance, do not provide the parameter with a VARIANT pointer."}], "Output": [], "InOut": [{"name": "DEST_VARIABLE", "type": "all data types", "description": "Tag to which the deserialized data is to be written. For optimum performance, do not provide the parameter with a VARIANT pointer."}, {"name": "POS", "type": "DINT", "description": "The operand at the POS parameter stores the index of the first byte based on the number of bytes occupied by the converted customer data. The POS parameter is calculated zero-based."}]}, "how_to_use": "To deserialize larger structures, declare the memory area for sequential representation with optimized access for a CPU of the S7-1200 series as of firmware version >= 4.2, and for a CPU of the S7-1500 series as of firmware version >= 2.0.", "example_code": "#Tag_RetVal := Deserialize(SRC_ARRAY := 'Buffer'.Field, DEST_VARIABLE := 'Target'.Client, POS := #BufferPos);", "additional_info": "The 'Deserialize' instruction deserializes the sequential representation of the customer data.", "generated_brief": {"functional_summary": "The Deserialize instruction converts a serialized array of bytes or characters back into its original PLC data type format, such as UDTs, STRUCTs, or ARRAYs.", "usage_context": "It is typically used when reconstructing structured data from a sequential byte stream for processing within PLC programs, especially when handling communication or storage data."}, "generated_keywords": ["deserialize", "convert serialized", "UDT conversion", "structured data reconstruction", "byte array to data type"]}
{"instruction_name": "DCAT", "description": "The 'Discrete control-timer alarm' instruction is used to count the time from the point at which the CMD parameter issues the command to open or close. The time is accumulated until the preset time (PT) is exceeded or the information is received that the device was opened or closed (O_FB or C_FB) within the specified time. If the preset time is exceeded before the information on the opening or closing of the device is received, the corresponding alarm is activated. If the signal state of the command input changes before the preset time, the time is restarted.", "parameters": {"Input": [{"name": "CMD", "type": "BOOL", "description": "A signal state of '0' indicates a 'close' command. A signal state of '1' indicates an 'open' command."}, {"name": "O_FB", "type": "BOOL", "description": "Feedback input when opening"}, {"name": "C_FB", "type": "BOOL", "description": "Feedback input when closing"}], "Output": [{"name": "Q", "type": "BOOL", "description": "Shows the status of the parameter CMD"}, {"name": "OA", "type": "BOOL", "description": "Alarm output when opening"}, {"name": "CA", "type": "BOOL", "description": "Alarm output when closing"}], "InOut": []}, "how_to_use": "To use this instruction, initialize the static parameters in the data block. Monitor the feedback signals O_FB and C_FB to determine the state of the device being controlled.", "example_code": "\"DCAT_DB\"(CMD := \"Tag_Input_CMD\", O_FB := \"Tag_Input_O_FB\", C_FB := \"Tag_Input_C_FB\", Q => \"Tag_Output_Q\", OA => \"Tag_Output_OA\", CA => \"Tag_Output_CA\");", "additional_info": "The static parameters are not visible when calling the instruction in the program. These are saved in the instance of the instruction.", "generated_brief": {"functional_summary": "The DCAT instruction monitors the time elapsed after a command to open or close a device and triggers an alarm if the corresponding device feedback is not received within a preset time.", "usage_context": "It is typically used in industrial control systems to ensure timely operation of devices like valves or gates and to alert operators if the device fails to reach the requested state promptly."}, "generated_keywords": ["timed device control", "open close command monitoring", "feedback signal verification", "alarm on timeout", "PLC discrete timer"]}
{"instruction_name": "UFILL_BLK", "description": "You can use the \"Fill block uninterruptible\" instruction to fill a memory area (target range) with the value of the IN input. The instruction cannot be interrupted. The target range is filled beginning with the address specified at the OUT output. The number of repeated copy operations is specified with the COUNT parameter. When the instruction is executed, the value at the input IN is moved to the target range as often as specified by the value of the COUNT parameter. The instruction can only be executed if the source range and the target range have the same data type.", "parameters": {"Input": [{"name": "IN", "type": "Binary numbers, integers, floating-point numbers, timers, DATE, CHAR, WCHAR, TOD (S7-1200); Binary numbers, integers, floating-point numbers, timers, DATE, CHAR, WCHAR, TOD, LTOD (S7-1500)", "description": "Element used to fill the target range"}, {"name": "COUNT", "type": "USINT, UINT, UDINT (S7-1200); USINT, UINT, UDINT, ULINT (S7-1500)", "description": "Number of repeated move operations"}], "Output": [{"name": "OUT", "type": "Binary numbers, integers, floating-point numbers, timers, TOD, DATE, CHAR, WCHAR (S7-1200); Binary numbers, integers, floating-point numbers, timers, DATE, CHAR, WCHAR, TOD, LTOD (S7-1500)", "description": "Address in target range from which filling starts"}], "InOut": []}, "how_to_use": "Use UFILL_BLK to fill an ARRAY or structure elements with the same value starting at a specified address. Ensure the source value (IN) and the target range (OUT) have the same data type. Specify the number of repetitions with COUNT. The instruction is uninterruptible, ensuring atomic update of the target range, but causing increased CPU alarm reaction times during execution. Maximum move size is 16 KB. When filling structures, all elements must be of the same elementary data type. For arrays, the value of IN is copied COUNT times starting from OUT. Be careful not to exceed the target range size to avoid unintended results.", "example_code": "UFILL_BLK(IN := #FillValue,\n          COUNT := Tag_Count,\n          OUT => #TargetArea[1]);", "additional_info": "The move operation cannot be interrupted by other operating system activities. Use caution about CPU alarm reaction times when executing this instruction. The maximum number of elements changed is bounded by the size of the array or structure, copying more than available elements can cause unintended results. Structures filled with this instruction must contain elements of the same elementary data type but can be embedded in other structures. Data types and memory areas are specific for S7-1200 and S7-1500 CPUs with some differences.", "generated_brief": {"functional_summary": "The UFILL_BLK instruction fills a specified memory area with a given value repeatedly without interruption, ensuring atomic update of the target range.", "usage_context": "It is used to initialize or reset arrays or structures with the same data value in industrial PLC programs where uninterruptible and consistent memory updates are required."}, "generated_keywords": ["uninterruptible memory fill", "block fill instruction", "atomic target range update", "array and structure initialization", "value repeated copy"]}
{"instruction_name": "FILL", "description": "You can use the \"Fill block\" instruction to fill a memory area (destination area) with the content of another memory area (source area). The \"Fill block\" instruction moves the content of the source area to the destination area until the destination area is completely written. The move operation takes place in the direction of ascending addresses.", "parameters": {"Input": [{"name": "BVAL", "type": "VARIANT", "description": "Specification of the memory area (source area), the content of which is used to fill the destination area at theK parameter."}], "Output": [{"name": "BLK", "type": "VARIANT", "description": "Specification of the memory area that will be filled with the content of the source area."}, {"name": "RET_VAL", "type": "INT", "description": "Error information returned by the function."}], "InOut": [{"name": "BLK", "type": "VARIANT", "description": "The tag of the BLK parameter must be declared as InOut in the block interface since the data flows into the tag."}]}, "how_to_use": "Define source and destination memory areas using VARIANT or ANY (with restrictions). Ensure the source and destination areas do not overlap. Use the instruction to move contents of the source area to the destination area in ascending address order until the destination is filled. Avoid using in optimized block access areas unless tags are declared with retentivity setting \"Set in IDB\". When transferring structures, ensure length is an even number of bytes.", "example_code": "\"Tag_RetVal\" := FILL(BVAL := P#M14.0 WORD 4, BLK => P#M100.0 WORD 10);", "additional_info": "Source and destination areas must not overlap. If the destination size is smaller than the source size, only the fitting data is copied. For BOOL data type pointers, addresses must be absolute and length divisible by 8. Updating of source data during execution is not allowed. STRING and WSTRING types have specific copy behaviors. Error codes returned in RET_VAL: 0000 (No error), 8092 (Areas only in load memory), 8152 (Unsupported data at BVAL), 8352 (Unsupported data types at BLK). The instruction can only be used in memory areas without optimized block access unless specific retentivity settings are used.", "generated_brief": {"functional_summary": "The FILL instruction copies the content of a specified source memory area into a destination memory area in ascending address order until the destination is completely filled.", "usage_context": "It is used in PLC programs to efficiently initialize or overwrite memory blocks with existing data, ensuring non-overlapping areas and proper data alignment."}, "generated_keywords": ["memory block fill", "source to destination copy", "non-overlapping memory areas", "ascending address data transfer", "PLС data initialization"]}
{"instruction_name": "FILL_BLK", "description": "You can use the 'Fill block' instruction to fill a memory area (target range) with the value of the IN input. The target range is filled beginning with the address specified at the OUT output. The number of repeated copy operations is specified with the COUNT parameter. When the instruction is executed, the value at the input IN is moved to the target range as often as specified by the value of the COUNT parameter.", "parameters": {"Input": [{"name": "IN", "type": "Binary numbers, integers, floating-point numbers, timers, TOD, DATE, CHAR, WCHAR", "description": "Element used to fill the target range"}, {"name": "COUNT", "type": "USINT, UINT, UDINT", "description": "Number of repeated move operations"}], "Output": [{"name": "OUT", "type": "Binary numbers, integers, floating-point numbers, timers, TOD, DATE, CHAR, WCHAR", "description": "Address in target range from which filling starts"}], "InOut": []}, "how_to_use": "To use this instruction, specify the value to fill in the IN parameter, the number of copies in the COUNT parameter, and the starting address in the OUT parameter.", "example_code": "FILL_BLK(IN := #FillValue, COUNT := 'Tag_Count', OUT => #TargetArea[1]);", "additional_info": "The instruction can only be executed if the source range and the target range have the same data type. The maximum number of elements changed is the number of elements in the ARRAY or structure.", "generated_brief": {"functional_summary": "The FILL_BLK instruction copies a specified value into a consecutive memory area a defined number of times starting from a given address.", "usage_context": "It is typically used to initialize or reset blocks of memory or arrays with a uniform value in PLC programming."}, "generated_keywords": ["fill memory block", "copy value repeatedly", "initialize array", "set uniform value", "memory area fill"]}
{"instruction_name": "ACOS", "description": "You can use the 'Form arccosine value' instruction to calculate the size of the angle from a cosine value, which corresponds to this value. Only valid floating-point numbers within the range -1 to +1 can be specified as input values. The calculated angle size is given in radians and can range in value from 0 to +π.", "parameters": {"Input": [{"name": "<Expression>", "type": "Floating-point numbers", "description": "Cosine value"}], "Output": [{"name": "Function value", "type": "Floating-point numbers", "description": "Size of angle in radians"}], "InOut": []}, "how_to_use": "To use this instruction, provide a cosine value as input, ensuring it falls within -1 to +1.", "example_code": "\"Tag_Result\" := ACOS(\"Tag_Value\");", "additional_info": "The result of the instruction is returned in the operand 'Tag_Result' as a function value.", "generated_brief": {"functional_summary": "The ACOS instruction calculates the arccosine of a given floating-point cosine value within the range -1 to +1, returning the corresponding angle in radians between 0 and π.", "usage_context": "It is typically used in PLC programs to determine the angle when only the cosine value is available, such as in motion control or trigonometric computations in automation systems."}, "generated_keywords": ["arccosine calculation", "cosine to angle", "floating-point input", "angle in radians", "trigonometric function"]}
{"instruction_name": "ASIN", "description": "You can use the \"Form arcsine value\" instruction to calculate the size of the angle from a sine value, which corresponds to this value. Only valid floating-point within the range -1 to +1 can be specified as input values. The calculated angle size is given in radians and can range in value from -π/2 to +π/2.", "parameters": {"Input": [{"name": "<Expression>", "type": "Floating-point numbers", "description": "Sine value"}], "Output": [{"name": "Function value", "type": "Floating-point numbers", "description": "Size of angle in radians"}], "InOut": []}, "how_to_use": "Pass a floating-point sine value within the range -1 to +1 as input to the ASIN instruction. The instruction returns the corresponding angle size in radians, ranging from -π/2 to +π/2.", "example_code": "\"Tag_Result\" := ASIN(\"Tag_Value\");", "additional_info": "The input value must be a valid floating-point number within the range -1 to +1. The result is provided in radians. Valid data types and memory areas include I, Q M, D, L, P.", "generated_brief": {"functional_summary": "The ASIN instruction calculates the arcsine (inverse sine) of a floating-point input value between -1 and +1, returning the corresponding angle in radians between -π/2 and +π/2.", "usage_context": "It is typically used in PLC programs to determine angle measurements from sine values in applications involving trigonometric calculations and motion control."}, "generated_keywords": ["arcsine calculation", "inverse sine", "angle in radians", "floating-point input", "trigonometric function"]}
{"instruction_name": "ATAN", "description": "You can use the \"Form arctangent value\" instruction to calculate the size of the angle from a tangent value, which corresponds to this value. It is only permitted to specify valid floating-point numbers (or -NaN/+NaN) as input value. The calculated angle size is given in radians and can range in value from -π/2 to +π/2.", "parameters": {"Input": [{"name": "<Expression>", "type": "Floating-point numbers", "description": "Tangent value"}], "Output": [{"name": "Function value", "type": "Floating-point numbers", "description": "Size of angle in radians"}], "InOut": []}, "how_to_use": "Use this instruction by passing a valid tangent value as a floating-point input to the ATAN function. The result is the angle size in radians (from -π/2 to +π/2). Ensure the input is a valid floating-point number as invalid numbers are not allowed.", "example_code": "\"Tag_Result\" := ATAN(\"Tag_Value\");", "additional_info": "The instruction input must be a valid floating-point number or NaN. The output angle is returned in radians. Valid memory areas for inputs and outputs include I, Q, M, D, L, P.", "generated_brief": {"functional_summary": "The ATAN instruction calculates the arctangent of a given tangent value and returns the corresponding angle in radians between -π/2 and +π/2.", "usage_context": "This function is typically used in PLC programs for converting tangent values to angular measurements in applications like motor control, robotics, or any system requiring angle computations."}, "generated_keywords": ["arctangent calculation", "angle in radians", "floating-point input", "tangent to angle conversion", "PLC math function"]}
{"instruction_name": "LN", "description": "You can use the \"Form natural logarithm\" instruction to calculate the natural logarithm to base e (e=2.718282) from the input value. The instruction has a positive result if the input value is greater than zero. If input values are less than zero, the instruction returns an invalid floating-point number.", "parameters": {"Input": [{"name": "<Expression>", "type": "Floating-point numbers", "description": "Input value"}], "Output": [{"name": "Function value", "type": "Floating-point numbers", "description": "Natural logarithm of the input value"}], "InOut": []}, "how_to_use": "Use the LN instruction to calculate the natural logarithm of a positive floating-point number. The input parameter must be greater than zero to return a valid result. If the input is less than zero, the result will be an invalid floating-point number. Assign the instruction result to a floating-point variable.", "_code": "\"Tag_Result1\" := LN(\"Tag_Value\");\n\"Tag_Result2\" := LN(\"Tag_Value1\" + \"Tag_Value2\");", "additional_info": "For additional information on valid data types, refer to the valid data types overview. Input and output data can be located in various memory areas: I, Q, M, D, L, P.", "generated_brief": {"functional_summary": "The LN instruction calculates the natural logarithm (base e) of a positive floating-point input value and returns the result as a floating-point number.", "usage_context": "This function is typically used in PLC programs to perform mathematical computations involving logarithmic calculations, especially when dealing with exponential processes or data transformations that require logarithmic scaling."}, "generated_keywords": ["natural logarithm", "logarithmic calculation", "floating-point input", "mathematical function", "PLC programming"]}
{"instruction_name": "TOF", "description": "You can use the 'Generate off-delay' instruction to reset the Q output by the programmed time PT. The Q output is set when the result of logic operation (RLO) at input IN changes from '0' to '1' (positive signal edge). When the signal state at input IN changes back to '0' (negative signal edge), the programmed time PT starts. Output Q remains set as long as the time duration PT is running. When the PT time duration expires, the Q output is reset. If the signal state at input IN changes to '1' before the PT time duration expires, the timer is reset.", "parameters": {"Input": [{"name": "IN", "type": "BOOL", "description": "Start input."}, {"name": "PT", "type": "TIME", "description": "Duration of the off delay. The value of the PT parameter must be positive."}], "Output": [{"name": "Q", "type": "BOOL", "description": "Operand that is reset when the time PT expires."}, {"name": "ET", "type": "TIME", "description": "Current timer value."}], "InOut": []}, "how_to_use": "Each call of the instruction must be assigned to an IEC timer in which the instance data is stored. Ensure the IN input is properly set to initiate the timer and the PT parameter is positive to define the duration.", "example_code": "\"TOF_DB\".TOF(IN := \"Tag_Start\", PT := \"Tag_PresetTime\", Q => \"Tag_Status\", ET => \"Tag_ElapsedTime\");", "additional_info": "Reinitializing the actual values of an IEC timer while the time measurement is running disrupts the. Make sure that the plant is in a safe state before overwriting actual values.", "generated_brief": {"functional_summary": "The TOF instruction generates an off-delay by keeping the output Q set when the input IN switches on and continuing to hold Q for a preset time PT after IN switches off before resetting Q.", "usage_context": "It is typically used to maintain a device or signal active for a fixed duration after the controlling input turns off in industrial control applications."}, "generated_keywords": ["off-delay timer", "TOF instruction", "timer reset on input", "output hold after input off", "IEC timer assignment"]}
{"instruction_name": "TON", "description": "You can use the \"Generate on-delay\" instruction to delay the setting of the Q parameter for the programmed duration PT. The instruction is started when the result of logic operation (RLO) of the IN parameter changes from \"0\" to \"1\" (positive signal edge). The programmed time PT begins when the instruction starts. When the PT duration has expired, the Q parameter returns signal state \"1\". The Q parameter remains set as long as the start input is still \"1\". If the signal state of the IN parameter changes from \"1\" to \"0\", the parameter Q will be reset. The timer function is restarted when a new positive signal edge is detected at the IN parameter.\n\nThe current time value can be queried in the ET parameter. The time value starts at T#0s and ends when the value of the time duration PT is reached. The ET parameter reset as soon as the signal state of the IN parameter changes to \"0\".", "parameters": {"Input": [{"name": "IN", "type": "BOOL", "description": "Start input"}, {"name": "PT", "type": "TIME", "description": "Duration of the on delay. The value of the PT parameter must be positive."}], "Output": [{"name": "Q", "type": "BOOL", "description": "Operand that is set when the timer PT expires."}, {"name": "ET", "type": "TIME", "description": "Current timer value"}], "InOut": []}, "how_to_use": "Assign an IEC timer instance data block or local tag to the instruction. When the IN input signal changes from 0 to 1, the timer starts counting the programmed duration PT. Once the duration expires, the output Q is set. The output Q remains set as long as IN is 1. When IN changes from 1 to 0, Q resets and ET resets. If the instruction is skipped in the program or outputs are not read, the ET output remains constant after PT expires. Be cautious not to reinitialize actual values during time measurement to avoid inconsistency.", "example_code": "\"TON_DB\".TON(IN := \"Tag_Start\",\n             PT := \"Tag_PresetTime\",\n             Q => \"Tag_Status\",\n             ET => \"Tag_ElapsedTime\");", "additional_info": "Each call requires an IEC timer instance (of types IEC_TIMER, TON_TIME, or IEC_LTIMER/TON_LTIME depending on CPU). Reinitializing actual timer values during operation (e.g., by loading blocks with reinitialization, snapshots, forcing values, or WRIT_DBL) can cause serious malfunction. Always ensure the plant is in a safe state before reinitialization and that the timer has expired. The instruction stores the previous IN value internally for edge detection, so do not manipulate IN parameter's actual value externally. The ET and Q outputs update only when the instruction is called or their outputs are accessed; otherwise they hold their last value.", "generated_brief": {"functional_summary": "The TON instruction implements an on-delay timer that starts timing when an input signal transitions from 0 to 1 and sets an output signal after the preset time elapses while the input remains high.", "usage_context": "It is typically used in industrial PLC programs to introduce controlled delays before activating outputs or subsequent logic based on the presence of a sustained input signal."}, "generated_keywords": ["on-delay timer", "positive edge trigger", "timing delay", "PLC timer instruction", "output signal delay"]}
{"instruction_name": "TP", "description": "You can use the \"Generate pulse\" instruction to set the parameter Q for a programmed duration. The instruction is started when the result of logic operation (RLO) of the IN parameter changes from \"0\" to \"1\" (positive signal edge). The programmed time PT begins when the instruction starts. The Q parameter is set for the duration PT, independent of the further course of the input signal. While the duration PT is running, the detection of a new positive signal edge at the IN input has no influence on the signal state at the Q output. You can query the current time value set in the ET parameter. The timer value starts at T#0s and ends when the value of the time duration PT is reached. When the time duration PT is reached and the signal state at the IN parameter is \"0\", the ET parameter is reset.", "parameters": {"Input": [{"name": "IN", "type": "BOOL", "description": "Start input"}, {"name": "PT", "type": "TIME, LTIME", "description": "Duration of the pulse. The value of the PT parameter must be positive."}], "Output": [{"name": "Q", "type": "BOOL", "description": "Operand that is set for the PT duration."}, {"name": "ET", "type": "TIME, LTIME", "description": "Current timer value."}], "InOut": []}, "how_to_use": "Assign each call of the \"Generate pulse\" instruction to an IEC timer instance data structure (IEC_TIMER, IEC_LTIMER, TP_TIME, or TP_LTIME depending on the CPU). The instruction starts timing when a positive edge is detected on the IN input. The output Q is set for the PT. The ET output provides the elapsed time. Avoid reinitializing or overwriting actual values during timing to prevent inconsistencies.", "example_code": "\"TP_DB\".TP(IN := \"Tag_Start\",\n           PT := \"Tag_PresetTime\",\n           Q => \"Tag_Status\",\n           ET => \"Tag_ElapsedTime\");", "additional_info": "The timer instance must be declared either as a data block or a local tag depending on the CPU series and programming style. The timer's internal edge memory relies on the IN input. Writing or initializing the IN parameter externally will disrupt edge detection. When the instruction is skipped, ET returns a constant value if time has expired. Reinitializing actual values during running time measurement can cause serious inconsistencies and should be avoided. Use safe states before overwriting actual values and ensure the timer has expired.", "generated_brief": {"functional_summary": "The TP instruction generates a fixed-duration pulse by setting its output Q to true for a programmed time PT upon detecting a rising edge on its input IN.", "usage_context": "It is typically used in PLC programs to create precise timed pulses needed for control signals, independent of the input signal's subsequent state."}, "generated_keywords": ["generate pulse", "rising edge trigger", "fixed duration output", "timer pulse", "PLC timing instruction"]}
{"instruction_name": "DRUM", "description": "You can use the 'Implement sequencer' instruction to assign the programmed values of the OUT_VAL parameter of the corresponding step to the programmed output bits (OUT1 to OUT16) and the output word (OUT_WORD). The specific step must thereby satisfy the conditions of the programmed enable mask on the S_MASK parameter while the instruction remains at this step. The instruction advances to the next step if the event for the step is true and the programmed time for the current step elapses, or if the value at the JOG parameter changes from '0' to '1'. The instruction is reset when the signal state of the RESET parameter changes to '1'. The current step is hereby equated to the preset step (DSP).", "parameters": {"Input": [{"name": "RESET", "type": "BOOL", "description": "The signal state '1' indicates a reset condition."}, {"name": "JOG", "type": "BOOL", "description": "When the signal state changes from '0' to '1', the instruction advances to the next step."}, {"name": "DRUM_EN", "type": "BOOL", "description": "The signal state '1' allows the sequencer to advance based on the event and time criteria."}, {"name": "LST_STEP", "type": "BYTE", "description": "Maximum step number (for example: LST_STEP = 16#08; a maximum of 8 steps is possible)."}, {"name": "EVENT(i)", "type": "BOOL", "description": "Event bit (i); Initial signal state is '1'."}], "Output": [{"name": "OUT(j)", "type": "BOOL", "description": "Output bit (j)."}, {"name": "Q", "type": "BOOL", "description": "The signal state '1' indicates that the time for the last step has elapsed."}, {"name": "OUT_WORD", "type": "WORD", "description": "Word address to which the sequencer writes the output values."}, {"name": "ERR_CODE", "type": "WORD", "description": "Error information."}], "InOut": []}, "how_to_use": "Initialize the parameters appropriately, then call the instruction within the main cycle of your program to advance through the steps based on the defined conditions.", "example_code": "\"DRUM_DB\"(RESET := \"Tag_Reset\", JOG := \"Tag_Input_Jog\", DRUM_EN := \"Tag_Input_DrumEN\", LST_STEP := \"Tag_Number_LastStep\", EVENT1 := \"MyTag_Event_1\", OUT1 => \"MyTag_Output_1\", ... )", "additional_info": "All the bits of the configurable mask for all 16 steps are initialized with a signal state of '1'. The output bit on the OUT1 parameter corresponds to the least significant bit of the output word (OUT_WORD).", "generated_brief": {"functional_summary": "The DRUM instruction implements a sequencer that advances through programmed steps based on event conditions, elapsed time, or manual jogging, outputting predefined values to output bits and words.", "usage_context": "It is typically used in industrial automation to control sequential processes where outputs must change step-by-step under controlled conditions such as timing, events, or manual triggers."}, "generated_keywords": ["sequencer", "step advancement", "event-driven output", "time-based sequencing", "manual jogging control"]}
{"instruction_name": "LEAD_LAG", "description": "You can use the \"Lead and lag algorithm\" instruction to process signals with an analog tag. The gain value at the GAIN parameter must be greater than zero. The result of the \"Lead and lag algorithm\" instruction is calculated using the following equation: OUT = GAIN * ((1 + LD_TIME * s) / (1 + LG_TIME * s)) * IN. The instruction supplies plausible results only when processing is in fixed program cycles. The same units must be specified at the parameters LD_TIME, LG_TIME and SAMPLE_T. When LG_TIME > 4 + SAMPLE_T, the instruction approaches the given function. When the value of the GAIN parameter is less than or equal to zero, the calculation is not performed and an error information is output on the ERR_CODE parameter. The instruction consists of two operations: \"Lead\" shifts the phase of output so that it leads the input, equivalent to a differentiation (high-pass filter). \"Lag\" shifts the output so it lags behind the input, equivalent to an integration (low-pass filter and noise suppressor). Together they form a band pass filter. The instruction can be used as a compensator in dynamic feed-forward control.", "parameters": {"Input": [{"name": "IN", "type": "REAL", "description": "The input value of the current sample time (cycle time) to be processed. Constants can also be specified."}, {"name": "SAMPLE_T", "type": "INT", "description": "Sample time. Constants can also be specified."}], "Output": [{"name": "OUT", "type": "REAL", "description": "Result of the instruction."}, {"name": "ERR_CODE", "type": "WORD", "description": "Error information. For example, if GAIN is less than or equal to zero, an error is indicated."}], "InOut": []}, "how_to_use": "Initialize static parameters LD_TIME, LG_TIME, GAIN, PREV_IN, and PREV_OUT in the instance data block before using the instruction. Call the instruction each program cycle with the current input (IN) and sample time (SAMPLE_T). Use the output OUT as the processed signal. Monitor ERR_CODE for errors such as invalid GAIN. Ensure processing occurs in fixed program cycles and that units for LD_TIME, LG_TIME, and SAMPLE_T are the same.", "example_code": "\"LEAD_LAG_DB\"(IN := \"Tag_Input\", SAMPLE_T := \"Tag_Input_SAMPLE_T\", OUT => \"Tag_Output_Result\", ERR_CODE => \"Tag_ErrorCode\");", "additional_info": "The static parameters (LD_TIME, LG_TIME, GAIN, PREV_IN, PREV_OUT) are saved in the instance of the instruction and not visible when calling it in the program. ERR_CODE values: 0000 means no error; 0009 means GAIN parameter value is less than or equal to zero. The instruction is typically used for signal processing as a compensator or filter in control applications.", "generated_brief": {"functional_summary": "The LEAD_LAG instruction processes an analog input signal using a combined lead (high-pass) and lag (low-pass) filter algorithm to produce a compensated or filtered output signal based on specified gain and timing parameters.", "usage_context": "It is typically used in industrial control systems for dynamic feed-forward control and signal conditioning to improve system response and suppress noise within fixed program cycles."}, "generated_keywords": ["lead lag filter", "analog signal processing", "dynamic feed-forward control", "high-pass and low-pass filter", "noise suppression"]}
{"instruction_name": "PRESET_TIMER", "description": "You can use the \"Load time duration\" instruction to set the time for an IEC timer. The instruction is executed in every cycle when the result of logic operation (RLO) at the input of the instruction has the signal state \"1\". You assign an IEC timer declared in the program to the \"Load time duration\" instruction. The instruction writes the specified time to the structure of the specified IEC timer. The instruction does not influence the RLO.", "parameters": {"Input": [{"name": "Time duration", "type": "TIME", "description": "Duration with which the IEC timer runs."}], "Output": [{"name": "IEC timer", "type": "IEC_TIMER, TP_TIME, TON_TIME, TOF_TIME, TONR_TIME", "description": "IEC timer whose duration is set."}], "InOut": []}, "how_to_use": "Use the instruction to set or overwrite the time duration of an IEC timer by assigning the duration and the IEC timer structure. Be aware that if the IEC timer is running when the instruction executes, the current timer value is overwritten, possibly changing its status. The instruction executes every cycle when the input RLO is 1 and does not affect the RLO. Update of timer actual values occurs on instruction execution and when the timer structure is accessed.", "example_code": "IF #started = false THEN\n  \"TON_DB\".TON(IN := \"Tag_Start\",\n                 PT := \"Tag_PresetTime\",\n                 Q => \"Tag_Status\",\n                 ET => \"Tag_ElapsedTime\");\n  #started := true;\n  #preset = true\nEND_IF;\n\nIF \"TON_DB\".ET < T#10s AND #preset = true THEN\n  PRESET_TIMER(PT := T#25s,\n               TIMER := \"TON_DB\");\n  #preset := false;\nEND_IF;", "additional_info": "Reinitializing the actual values of an IEC timer while it is running disrupts the timer function and can cause serious process inconsistencies and dangers. Functions that cause reinitialization include loading blocks with reinitialization, loading snapshots as actual values, controlling or forcing actual values, and using the WRIT_DBL instruction. Precautions must be taken to ensure the plant is in a safe state, the IEC timer has expired, and no conflicting accesses occur when overwriting actual timer values.", "generated_brief": {"functional_summary": "The PRESET_TIMER instruction sets or overwrites the time duration of an IEC timer by writing a specified time value to the timer structure each execution cycle when enabled.", "usage_context": "It is typically used to initialize or adjust the preset time of IEC timers in control logic, especially before the timer starts or to reset its duration, while ensuring safe conditions to avoid timer function disruption."}, "generated_keywords": ["preset IEC timer", "load timer duration", "overwrite timer value", "timer initialization", "IEC timer adjustment"]}
{"instruction_name": "UBLKMOV", "description": "You can use the 'Move block uninterruptible' instruction to move the content of a memory area (source area) to another memory area (destination area). The move operation takes place in the direction of ascending addresses. You use VARIANT to define the source and destination areas.", "parameters": {"Input": [{"name": "SRCBLK", "type": "VARIANT", "description": "Specifies the memory area to be moved (source area)."}], "Output": [{"name": "DSTBLK", "type": "VARIANT", "description": "Specifies the memory area to which the block is to be moved (destination area)."}], "InOut": [{"name": "Function value (RET_VAL)", "type": "INT", "description": "Error information."}]}, "how_to_use": "Ensure that the source and destination areas do not overlap during the execution. Move a maximum of 16 KB and take note of CPU-specific restrictions.", "example_code": "\"Tag_RetVal\" := UBLKMOV(SRCBLK := P#M100.0 BYTE 10, DSTBLK =&gt; P#DB1.DBX0.0 BYTE 10);", "additional_info": "If the destination area is smaller than the source area, the entire destination area will be written. For BOOL data type, ensure that the length is divisible by 8.", "generated_brief": {"functional_summary": "UBLKMOV performs an uninterruptible move of data from a specified source memory area to a destination memory area in ascending address order.", "usage_context": "It is used in PLC programs to safely transfer blocks of data between memory locations without interruption, ensuring data integrity during the operation."}, "generated_keywords": ["uninterruptible block move", "memory area transfer", "data block copy", "ascending address move", "PLC data integrity"]}
{"instruction_name": "BLKMOV", "description": "You can use the 'Move block' instruction to move the content of a memory area (source area) to another memory area (destination area). The move operation takes place in the direction of ascending addresses. You use VARIANT to define the source and destination areas.", "parameters": {"Input": [{"name": "SRCBLK", "type": "VARIANT", "description": "Specifies the memory area to be moved (source area)."}], "Output": [{"name": "DSTBLK", "type": "VARIANT", "description": "Specifies the memory area to which the block is to be moved (destination area)."}, {"name": "Function value (RET_VAL)", "type": "INT", "description": "Error information."}], "InOut": []}, "how_to_use": "To use this instruction, specify the source and destination memory areas as parameters, ensuring they do not overlap and are compatible in size.", "example_code": "\"Tag_RetVal\" := BLKMOV(SRCBLK := P#M100.0 BYTE 10, DSTBLK => P#DB1.DBX0.0 BYTE 10);", "additional_info": "If the source and destination areas have different lengths, only the length of the smaller area will be moved. The tag must be absolute for BOOL data types and the length must be divisible by 8.", "generated_brief": {"functional_summary": "The BLKMOV instruction copies the contents of a defined source memory area to a specified destination memory area in ascending address order.", "usage_context": "It is typically used in PLC programs to efficiently transfer blocks of data between memory areas without overlap, such as moving sensor data to data blocks for processing."}, "generated_keywords": ["block memory move", "source to destination copy", "memory area transfer", "non-overlapping data move", "ascending address copy"]}
{"instruction_name": "MOVE_BLK", "description": "You can use the \"Move block\" instruction to move the content of a memory area (source range) to another memory area (target range). The number of elements to be moved to the target range is specified with the COUNT parameter. The width of the elements to be moved is defined by the width of the first element in the source area. The instruction can only be executed if the source range and the target range have the same data type. The value of the OUT output is invalid if more data is moved than is made available at the IN parameter or OUT parameter.", "parameters": {"Input": [{"name": "IN", "type": "Binary numbers, integers, floating-point numbers, timers, DATE, CHAR, WCHAR, TOD", "description": "The first element of the source area that is being copied"}, {"name": "COUNT", "type": "USINT, UINT, UDINT", "description": "Number of elements to be copied from the source range to the target range"}], "Output": [{"name": "OUT", "type": "Binary numbers, integers, floating-point numbers, timers, DATE, CHAR, WCHAR, TOD", "description": "The first element of the target range to which the contents of the source range are being copied"}], "InOut": []}, "how_to_use": "Use MOVE_BLK to copy multiple elements from a source array to a target array, starting at specified indices in both arrays. Ensure both the source and target memory ranges have the same data type. Set IN to point to the first source element, COUNT to the number of elements to copy, and OUT to the first target element. The data types for IN and OUT must be ARRAY elements of valid types. The instruction copies COUNT elements sequentially from IN to OUT.", "example_code": "MOVE_BLK(IN := #a_array[2],\n          COUNT := \"Tag_Count\",\n          OUT => #b_array[1]);", "additional_info": "The specified data types for IN and OUT can only be used as elements of an ARRAY structure. The instruction copies the contents starting from the element indicated by IN for COUNT elements to the target starting at OUT's specified element Moving more data than available makes OUT invalid. Refer to Siemens Industry Online Support article: https://support.industry.siemens.com/cs/ww/en/view/42603881 for more details.", "generated_brief": {"functional_summary": "MOVE_BLK copies a specified number of sequential elements from a source memory area to a target memory area of the same data type.", "usage_context": "It is typically used to efficiently transfer blocks of data between arrays or memory areas in PLC programs for data manipulation or storage purposes."}, "generated_keywords": ["move block", "copy array elements", "memory area transfer", "sequential data copy", "data type matching"]}
{"instruction_name": "VariantGet", "description": "You can use the 'Read out VARIANT tag value' instruction to read the value of the tag to which the VARIANT at the SRC parameter points and write it in the tag at the DST parameter.", "parameters": {"Input": [{"name": "SRC", "type": "VARIANT", "description": "Tag to be read"}], "Output": [{"name": "DST", "type": "Bit strings, integers, floating-point numbers, timers, date and time, character strings, ARRAY elements, PLC data types", "description": "Result of the instruction"}], "InOut": []}, "how_to_use": "Initialize the SRC parameter with a VARIANT type tag and the DST parameter with a compatible data type for the value to be written.", "example_code": "VariantGet(SRC := #TagIn_Source, DST => 'TagOut_Dest');", "additional_info": "The data type of the tag specified at the DST parameter must match the data type to which the VARIANT points.", "generated_brief": {"functional_summary": "The VariantGet instruction reads the value from a VARIANT type tag specified by SRC and writes it to a destination tag DST with a matching data type.", "usage_context": "It is typically used when extracting and transferring data from a generic VARIANT tag to a specific data type tag within PLC programs."}, "generated_keywords": ["read VARIANT tag", "transfer VARIANT value", "type-compatible data transfer", "SRC to DST value read", "VARIANT to specific data type"]}
{"instruction_name": "RESET_TIMER", "description": "You can use the 'Reset timer' instruction to reset an IEC timer to '0'. The structure components of the timer in the specified data block are reset to '0'.", "parameters": {"Input": [{"name": "TIMER", "type": "IEC_TIMER, TP_TIME, TON_TIME, TOF_TIME, TONR_TIME", "description": "IEC timer that is reset"}], "Output": [], "InOut": []}, "how_to_use": "The instruction must be programmed in an IF instruction. The instruction data is updated only when the instruction is called and not each time the assigned IEC timer is accessed.", "example_code": "IF 'TON_DB'.ET < T#25s THEN\n    RESET_TIMER(TIMER := 'TON_DB');\nEND_IF;", "additional_info": "Danger when reinitializing the actual values. Reinitializing the actual values of an IEC timer while the timer is running disrupts the function of the IEC timer.", "generated_brief": {"functional_summary": "The RESET_TIMER instruction resets all components of a specified IEC timer to zero.", "usage_context": "It is typically used within conditional statements to reinitialize timers during process control, ensuring the timer restarts under defined conditions."}, "generated_keywords": ["reset IEC timer", "timer reinitialization", "conditional timer reset", "process control timer", "reset timer instruction"]}
{"instruction_name": "Serialize", "description": "You can use the \"Serialize\" instruction convert several PLC data types (UD), STRUCT or ARRAY of <data type> to a sequential representation without losing parts of their structure. You use the instruction to temporarily save multiple structured data items from your program in a buffer, which should preferably be in a global data block, and send them to another CPU. The memory area in which the converted data is stored must have the ARRAY of BYTE or ARRAY of CHAR data type and be declared with standard access in version 1.0. Optimized data is also permitted as of version 2.0. Fill data of the source data area is undefined in the target array. These can be fill bytes or fill bits of a data area (e.g. ARRAY, STRUCT or PLC data type (UDT)) as well as the characters of a string currently not in use.", "parameters": {"Input": [{"name": "SRC_VARIABLE", "type": "all data types", "description": "Tag to be serialized. S7-1500: For optimum performance, do not provide the parameter with a VARIANT pointer."}], "Output": [{"name": "Function value", "type": "INT", "description": "Error information"}], "InOut": [{"name": "DEST_ARRAY", "type": "ARRAY of BYTE or ARRAY of CHAR", "description": "ARRAY in which the generated data stream is stored. S7-1500: For optimum performance, do not provide the parameter with a VARIANT pointer."}, {"name": "POS", "type": "DINT", "description": "The operand at the POS parameter stores the index of the first byte based on the total number of bytes that the converted customer data has occupied. The POS parameter is calculated zero-based."}]}, "how_to_use": "Use the instruction to serialize structured data (UDT, STRUCT or ARRAY) into a sequential memory area of type ARRAY of BYTE or ARRAY of CHAR. The destination memory area is preferably a global data block and must have standard access or optimized as of certain firmware versions. Initialize the POS parameter to indicate the starting position in the target array; it returns the index of the next free byte after serialization. To serialize multiple structures in sequence, ensure position alignment especially on S7-1200 CPUs by checking POS and potentially incrementing it by 1 if odd. Avoid using VARIANT pointers for SRC_VARIABLE and DEST_ARRAY for optimum performance and error avoidance. Use local error handling instructions GET_ERROR and GET_ERR_ID to manage errors safely.", "example_code": "#Tag_RetVal := Serialize(SRC_VARIABLE := \"Source\".Client,\n                      DEST_ARRAY := \"Buffer\".Field,\n                      POS := #BufferPos);\n#Label := STRING_TO_WSTRING('arti');\n#Tag_RetVal := Serialize(SRC_VARIABLE := #Label,\n                      DEST_ARRAY := \"Buffer\".Field,\n                      POS := #BufferPos);\n#Tag_RetVal := Serialize(SRC_VARIABLE := \"Source\".Article[#DeliverPos],\n                      DEST_ARRAY := \"Buffer\".Field,\n                      POS := #BufferPos);", "additional_info": "The capacity of the standard memory area is 64 KB; structures larger than 64 KB cannot be serialized if DEST_ARRAY is in standard memory. Optimized memory areas can be used from firmware version >= 4.2 (S7-1200) and >= 2.0 (S7-1500). When comparing structures, they need to be serialized first. The error codes returned indicate specific issues such as overlapping memory areas, invalid references, or insufficient memory in the destination array. Some error codes changed meaning as of firmware versions 4.2 (S7-0) and 2.0 (S7-1500). Serialization disallows interconnecting elements of technology objects since version 2.2. The optimized Serialize instruction consumes more work memory due to higher data complexity. For preventing CPU STOP on certain errors, use local error handling. It is recommended to order data types in source starting with large types and ending with BOOLs to reduce padding.", "generated_brief": {"functional_summary": "The Serialize instruction converts structured PLC data types like UDTs, STRUCTs, or ARRAYs into a sequential byte or character array representation for transmission or storage without losing their structure.", "usage_context": "It is typically used to temporarily save and transfer complex structured data between CPUs or memory areas by serializing it into a linear buffer for communication or comparison purposes."}, "generated_keywords": ["serialize structured data", "convert UDT to byte array", "PLC data serialization", "transmit structured data", "buffer data serialization"]}
{"instruction_name": "SWAP", "description": "You can use the \"Swap\" instruction to change the arrangement of the bytes of an input value and save the result in the specified operand.", "parameters": {"Input": [{"name": "<Expression>", "type": "WORD, DWORD", "description": "Input value"}], "Output": [{"name": "Function value", "type": "WORD, DWORD", "description": "Result of the instruction"}], "InOut": []}, "how_to_use": "Use the SWAP instruction to reverse the byte order of a WORD or DWORD input. Pass the input operand as an expression, and the function returns the swapped byte value. This is useful when handling data that requires different byte ordering. The result is returned as a function value.", "example_code": "\"Tag_Result\" := SWAP(\"Tag_Value\");", "additional_info": "Valid input data types include WORD and DWORD. The data can reside in memory areas I, Q, M, D, L, or P for S7-1200 and S7-1500. Refer to the valid data types and memory areas documentation for more details.", "generated_brief": {"functional_summary": "The SWAP instruction reverses the byte order of a WORD or DWORD input and returns the result as a function value.", "usage_context": "It is typically used when handling data that requires conversion between different byte ordering formats in industrial control systems."}, "generated_keywords": ["byte order swap", "WORD DWORD byte reversal", "data byte conversion", "SWAP instruction", "PLC data manipulation"]}
{"instruction_name": "VariantPut", "description": "You can use the \"Write VARIANT tag value\" instruction to write the value of the tag at the SRC parameter to the memory at the DST parameter to which the VARIANT points. The DST parameter has the VARIANT data type. Any data type except for VARIANT can be specified at the SRC parameter. The data type of the tag at the SRC parameter must match the data type to which the VARIANT points.", "parameters": {"Input": [{"name": "SRC", "type": "Bit strings, integers, floating-point numbers, timers, date and time, character strings, ARRAY elements, PLC data types", "description": "Tag to be read"}, {"name": "DST", "type": "VARIANT", "description": "Result of the instruction"}], "Output": [], "InOut": []}, "how_to_use": "Use the VariantPut instruction to write the value from the SRC parameter to the memory location pointed to by the VARIANT type at the DST parameter. Ensure the data type at SRC matches the data type the VARIANT points to. For copying structures and ARRAYs, use the MOVE_BLK_VARIANT instruction instead.", "example_code": "VariantPut(SRC := \"TagIn_Source\",\n           DST := #TagIn_Dest);", "additional_info": "To copy structures and ARRAYs, use the MOVE_BLK_VARIANT instruction. DST can be declared in the \"Input\", \"InOut\" and \"Temp\" sections of the block interface. Valid data types for SRC exclude VARIANT itself.", "generated_brief": {"functional_summary": "The VariantPut instruction writes the value from a non-VARIANT source tag to the memory location pointed to by a VARIANT type destination, ensuring data type compatibility.", "usage_context": "It is used when you need to assign or update the value of a VARIANT variable based on a specific typed tag within a PLC program, except when copying complex data like structures or arrays."}, "generated_keywords": ["write variant value", "type-safe variant assignment", "src to variant memory", "plc data type compatibility", "non-variant to variant copy"]}
{"instruction_name": "NORM_X", "description": "You can use the instruction 'Normalize' to normalize the value of the tag at the VALUE input by mapping it to a linear scale. You can use the MIN and MAX parameters to define the limits of a value range that is applied to the scale. The result at the OUT output is calculated and stored as a floating-point number depending on the location of the value to be normalized within this value range. If the value to be normalized equals the value at input MIN, the instruction returns the result '0.0'. If the value to be normalized equals the value at input MAX, the instruction returns the result '1.0'.", "parameters": {"Input": [{"name": "EN", "type": "BOOL", "description": "Enable input"}, {"name": "MIN", "type": "Integers, floating-point numbers", "description": "Low limit of the value range"}, {"name": "VALUE", "type": "Integers, floating-point numbers", "description": "Value to be normalized."}, {"name": "MAX", "type": "Integers, floating-point numbers", "description": "High limit of the value range"}, {"name": "_<Data type>", "type": "Floating-point numbers", "description": "Data type of the function value: You can specify the data type of the instruction explicitly using '_'."}], "Output": [{"name": "ENO", "type": "BOOL", "description": "Enable output"}, {"name": "Function value", "type": "Floating-point numbers", "description": "Result of the normalization"}], "InOut": []}, "how_to_use": "The instruction is used to convert a value within a defined range into a normalized value between 0 and 1 using the equation OUT = (VALUE – MIN) / (MAX – MIN).", "example_code": "\"Tag_Result1\" := NORM_X(MIN := \"Tag_Value1\", VALUE := \"Tag_InputValue\", MAX := \"Tag_Value2\");\n\"Tag_Result2\" := NORM_X_LREAL(MIN := \"Tag_Value1\", VALUE := \"Tag_InputValue\", MAX := \"Tag_Value2\");", "additional_info": "The parameters EN and ENO are not generated automatically when creating the instruction in the SCL programming language.", "generated_brief": {"functional_summary": "The NORM_X instruction normalizes an input value to a floating-point number between 0 and 1 based on specified minimum and maximum range limits.", "usage_context": "It is typically used in industrial control systems to scale sensor readings or process variables to a standardized range for comparison or further processing."}, "generated_keywords": ["value normalization", "linear scaling", "range mapping", "floating-point output", "sensor signal scaling"]}
{"instruction_name": "CTU", "description": "IEC counter instruction that can be declared as single or multiple instance and called in the program code. It is used to count up based on input signals.", "parameters": {"Input": [{"name": "CU", "type": "BOOL", "description": "Counting Up input. Rising edge triggers the counter up."}, {"name": "PV", "type": "INT", "description": "Preset Value. Counter counts up to this value."}], "Output": [], "InOut": []}, "how_to_use": "Declare IEC counters as single instance or multi-instance within arrays or structures in the block interface or data blocks. Call the CTU instruction by passing CU and PV operands to the instance. The counter increments on the rising edge of CU until it reaches PV.", "example_code": "#MyARRAY[1].CTU(CU := <Operand>, PV := <Operand>)", "additional_info": "IEC counters can be declared within anonymous structures, global data blocks, or ARRAY DBs and called accordingly in SCL code by referencing the proper instance path.", "generated_brief": {"functional_summary": "The CTU instruction counts up on the rising edge of a boolean input until reaching a specified preset value.", "usage_context": "It is typically used in PLC programs to track the number of occurrences or events, such as counting parts or operations in industrial automation."}, "generated_keywords": ["count up", "rising edge trigger", "preset value", "IEC counter", "multi-instance counter"]}
{"instruction_name": "TOF", "description": "IEC timer function instruction used to create a time-off delay with multi-instance support within structures, arrays, global and block interface declarations.", "parameters": {"Input": [{"name": "IN", "type": "BOOL", "description": "Input signal to start the timer function."}, {"name": "PT", "type": "TIME", "description": "Preset time duration for the timer."}], "Output": [], "InOut": []}, "how_to_use": "Declare the IEC timer instance in the block interface, data block, or as part of an array or structure. Call the TOF function using the instance name and pass the IN and PT parameters. Use multi-instance declaration to manage multiple timers.", "example_code": "#MyARRAY[1].TOF(IN := <Operand>, PT := <Operand>)", "additional_info": "The IEC timer can be declared as single or multiple instances within a structure or array. It can be accessed via global DB, block interface, or ARRAY DB with proper declaration.", "generated_brief": {"functional_summary": "The TOF instruction creates a time-off delay timer that starts timing when its input signal switches from TRUE to FALSE.", "usage_context": "It is typically used in industrial control systems to delay turning off outputs or processes after an input signal deactivates, supporting multiple timer instances within structured data."}, "generated_keywords": ["time-off delay timer", "IEC timer instruction", "multi-instance timer", "structured timer declaration", "input-triggered timing"]}
{"instruction_name": "TypeOfElements", "description": "You use the \"Check data type of an ARRAY element of a tag\" instruction to query the data type of a tag to which the Input parameter <operand> is pointing. You compare the data type of a tag to the data type of the tag that you have declared in the block interface to determine whether they are \"Equal\" or \"Not equal\". If the data type of the Input tag is an ARRAY, the data type of the ARRAY elements is compared. You can only use the \"Check data type of an ARRAY element of a tag\" instruction within an IF or CASE instruction.", "parameters": {"Input": [{"name": "Operand", "type": "VARIANT, ResSymbol", "description": "Operand to query"}], "Output": [], "InOut": []}, "how_to_use": "Use this instruction within an IF or CASE statement to query and compare the data type of a tag (or an element of an ARRAY tag) specified by the Operand parameter. The Operand must be of type VARIANT or ResolvedSymbol. Compare with another data type using TypeOF to determine equality.", "example_code": "IF TypeOfElements(\"Tag_Variant\") = TypeOF(\"GlobalDB\".Product[1]) THEN\n    \"Tag_Variant\" := \"GlobalDB\".Product[1] * 3;\nEND_IF;", "additional_info": "The comparison operand can be an elementary data type or a PLC data type. The instruction only compares the element data type if the input is an ARRAY. The Operand declaration is possible in the \"Input\", \"InOut\" and \"Temp\" sections of the block interface.", "generated_brief": {"functional_summary": "The TypeOfElements instruction checks and compares the data type of a tag or an element of an ARRAY tag to another specified data type within an IF or CASE statement.", "usage_context": "It is used to verify data type compatibility during runtime in conditional logic to ensure safe and correct operations on tag variables in PLC programs."}, "generated_keywords": ["data type checking", "ARRAY element comparison", "tag type verification", "conditional data type matching", "IF CASE instruction usage"]}
{"instruction_name": "VARIANT_TO_DB_ANY", "description": "You use the \"Convert VARIANT to DB_ANY\" instruction to query the data block number that the operand that is specified at the IN parameter addresses. This can be an instance data block or an ARRAY data block. The operand at the IN parameter has the data type VARIANT, which means you do not need to know the data type of the data block whose number is to be queried when the program is created. The data block number is read during runtime and written to the operand specified at the RET_VAL parameter.", "parameters": {"Input": [{"name": "IN", "type": "VARIANT", "description": "Tag to be read. (The function value of the \"DB_ANY_TO_VARIANT\" instruction). You can use a local or global tag at the IN parameter."}], "Output": [{"name": "ERR", "type": "INT", "description": "Error information"}, {"name": "RET_VAL", "type": "DB_ANY", "description": "Result: Number of the DB"}], "InOut": []}, "how_to_use": "To use this instruction, pass a VARIANT type tag to the IN parameter. The instruction reads the data block number corresponding to that tag and outputs the result through the RET_VAL parameter.", "example_code": "\"OutputDBNumber\" := VARIANT_TO_DB_ANY(IN := #tempVARIANT, ERR := \"Tag_Error\");", "additional_info": "The instruction's execution depends on meeting specific requirements; otherwise, the output will be '0' as the data block number.", "generated_brief": {"functional_summary": "The VARIANT_TO_DB_ANY instruction converts a VARIANT type operand to its corresponding data block number during runtime.", "usage_context": "It is used when the specific data block number of a VARIANT tag needs to be dynamically identified without knowing the data type at program creation."}, "generated_keywords": ["VARIANT to DB_ANY conversion", "data block number query", "runtime data block identification", "dynamic data block lookup", "VARIANT tag processing"]}
{"instruction_name": "CountOfElements", "description": "You use the 'Get number of ARRAY elements' instruction to query how many ARRAY elements a tag to which the 'IN' parameter points has. If it is a single-dimensional ARRAY, the number of ARRAY elements is output as the result. If it is a multi-dimensional ARRAY, the number of all dimensions is output as the result.", "parameters": {"Input": [{"name": "<Operand>", "type": "VARIANT, ResolvedSymbol", "description": "Tag to be queried"}], "Output": [{"name": "Function value", "type": "UDINT", "description": "Result of the instruction"}], "InOut": []}, "how_to_use": "To use this instruction, ensure that the tag pointed by the 'IN' parameter is an ARRAY. If querying an ARRAY located in a data block, the block attribute 'Data block write-protected in the device' must not be activated.", "example_code": "IF IS_ARRAY(#Tag_VARIANTToArray) THEN\n'Tag_Result' := CountOfElements(#Tag_VARIANTToArray);\nEND_IF;", "additional_info": "The result is '0' if the VARIANT or ResolvedSymbol tag is not an ARRAY. If the tag at the 'IN' parameter points to an ARRAY of BOOL, the fill elements are included in the count.", "generated_brief": {"functional_summary": "The CountOfElements instruction returns the total number of elements in a single-dimensional array or the total number of dimensions in a multi-dimensional array referenced by the input tag.", "usage_context": "It is typically used to dynamically determine the size or dimensionality of an array tag during PLC program execution to handle array data appropriately."}, "generated_keywords": ["array element count", "array size query", "multi-dimensional array", "array dimension count", "dynamic array sizing"]}
{"instruction_name": "UMOVE_BLK", "description": "You use the 'Move block uninterruptible' instruction to move the content of a memory area (source range) to another memory area (target range). The instruction cannot be interrupted. The number of elements to be moved to the target range is specified with the COUNT parameter. The width of the elements to be moved is defined by the width of the first element in the source area.", "parameters": {"Input": [{"name": "IN", "type": "Binary numbers, integers, floating-point numbers, timers, DATE, CHAR, WCHAR, TOD", "description": "The first element of the source area that is being copied"}, {"name": "COUNT", "type": "USINT, UINT, UDINT", "description": "Number of elements to be copied from the source range to the target range"}], "Output": [{"name": "OUT", "type": "Binary numbers, integers, floating-point numbers, timers, DATE, CHAR, WCHAR, TOD", "description": "The first element of the target range to which the contents of the source range are being copied"}], "InOut": []}, "how_to_use": "Use this instruction to move the specified number of elements from the source memory area to the target memory area without interruptions.", "example_code": "UMOVE_BLK(IN := #a_array[2], COUNT := 'Tag_Count', OUT => #b_array[1]);", "additional_info": "You can move a maximum of 16 KB. Ensure both source and target ranges have the same data type.", "generated_brief": {"functional_summary": "UMOVE_BLK uninterruptibly copies a specified number of elements from a source memory area to a target memory area with the same data type and element width.", "usage_context": "It is used in PLC programs when an atomic, uninterrupted block data transfer is required to ensure data integrity during the move operation."}, "generated_keywords": ["uninterruptible block move", "memory block transfer", "atomic data copy", "source to target memory", "block data move"]}
{"instruction_name": "MOVE_BLK_VARIANT", "description": "You use the 'Move block' instruction to move the content of a memory area (source range) to another memory area (target range). You can copy a complete ARRAY or elements of an ARRAY to another ARRAY of the same data type. The size (number of elements) of source and destination ARRAY may be different. You can copy multiple or single elements within an ARRAY.", "parameters": {"Input": [{"name": "SRC", "type": "VARIANT (which points to an ARRAY or an individual ARRAY element), ARRAY of <Data_type>", "description": "Source block from which to copy"}, {"name": "COUNT", "type": "UDINT", "description": "Number of elements which are copied. Assign the value '1' to the parameter COUNT, if no ARRAY is specified at parameter SRC or at parameter DEST."}, {"name": "SRC_INDEX", "type": "DINT", "description": "Defines the first element to be copied: The SRC_INDEX parameter is calculated zero-based. If an ARRAY is specified at parameter SRC, the integer at parameter SRC_INDEX specifies the first element within the source area from which it is to be copied."}, {"name": "DEST_INDEX", "type": "DINT", "description": "Defines the start of the destination memory area: The DEST_INDEX parameter is calculated zero-based. If an ARRAY is specified at parameter DEST, the integer at parameter DEST_INDEX specifies the first element within the target range that is to be copied into."}], "Output": [{"name": "DEST", "type": "VARIANT", "description": "Destination area into which the contents of the source block are copied."}, {"name": "RET_VAL", "type": "INT", "description": "Error information."}], "InOut": []}, "how_to_use": "When using the MOVE_BLK_VARIANT instruction, ensure that the number of elements to be copied does not exceed the selected source range or target range, and confirm that the SRC and DEST memory areas are compatible in terms of data types.", "example_code": "\"Tag_Result\" := MOVE_BLK_VARIANT(SRC := #SrcField, COUNT := \"Tag_Count\", SRC_INDEX := \"Tag_Src_Index\", DEST_INDEX := \"Tag_Dest_Index\", DEST => #DestField);", "additional_info": "The instruction is not executed if more data is copied than is made available. Counting at the parameters SRC_INDEX and DEST_INDEX always begins with the low limit '0'.", "generated_brief": {"functional_summary": "The MOVE_BLK_VARIANT instruction copies a specified number of elements from a source memory area or array to a destination memory area or array of the same data type, allowing partial or complete array transfers.", "usage_context": "This function is typically used in PLC programs to efficiently transfer or duplicate data blocks or array elements within memory during industrial automation processes."}, "generated_keywords": ["block memory move", "array copy", "data transfer", "partial array copy", "memory area duplication"]}
{"instruction_name": "UNSCALE", "description": "You use the \"Unscale\" instruction to unscale the floating-point number in the IN parameter into physical units between a low limit and a high limit and convert it into an integer. You use the LO_LIM and HI_LIM parameters to specify the low limit and high limit of the value range to which the input value is unscaled. The result of the instruction is output at the OUT parameter. The \"Unscale\" instruction works with the following equation: OUT = [((IN–LO_LIM)/(HI_LIM–LO_LIM)) ∗ (K2–K1)] + K1. The values of the \"K1\" and \"K2\" constants are determined by the signal state at the BIPOLAR parameter. Signal state \"1\" assumes the value at IN is bipolar between -27648 and 27648 with K1 = -27648.0 and K2 = 27648.0. Signal state \"0\" assumes IN is unipolar between 0 and 27648 with K1 = 0.0 and K2 = 27648.0. When IN is outside the limits HI_LIM and LO_LIM, an error output and the result is set to the nearest limit. If LO_LIM > HI_LIM, the result is scaled in reverse proportion to the input value.", "parameters": {"Input": [{"name": "IN", "type": "REAL", "description": "Input value to be unscaled to an integer value."}, {"name": "HI_LIM", "type": "REAL", "description": "High limit"}, {"name": "LO_LIM", "type": "REAL", "description": "Low limit"}, {"name": "BIPOLAR", "type": "BOOL", "description": "Indicates whether the value at the IN parameter is bipolar or unipolar: 1 = Bipolar, 0 = Unipolar"}], "Output": [{"name": "OUT", "type": "INT", "description": "Result of the instruction"}], "InOut": []}, "how_to_use": "Initialize the input parameters IN (REAL) with the floating-point value, HI_LIM and LO_LIM (REAL) as the unscale limits, and BIPOLAR (BOOL) to indicate signal type (1 for bipolar, 0 for unipolar). Call UNSCALE with these inputs and provide an INT variable for OUT to receive the result. Monitor RET_VAL return value for error codes such as out-of-range conditions.", "example_code": "\"Tag_ErrorCode\" := UNSCALE(IN := \"Tag_InputValue\", HI_LIM := \"Tag_HighLimit\", LO_LIM := \"Tag_LowLimit\", BIPOLAR := \"Tag_Bipolar\", OUT => \"Tag_Result\");", "additional_info": "RET_VAL returns error information: 0000 = no error, 0008 = IN outside HI_LIM or LO_LIM. If LO_LIM > HI_LIM, scaling is reversed. The instruction supports input/output in memory areas I, Q, M, D, L, P except BIPOLAR which does not support P. Refer to the 'GET_ERR_ID' instruction to retrieve detailed error IDs.", "generated_brief": {"functional_summary": "The UNSCALE instruction converts a floating-point input value within specified low and high physical limits into a corresponding integer output, handling both bipolar and unipolar signal scales.", "usage_context": "It is typically used in PLC programs to translate analog measurements or scaled float values back into integer values for processing or control within defined physical units."}, "generated_keywords": ["floating-point to integer conversion", "unscale numeric value", "bipolar and unipolar scaling", "physical units scaling", "range limit handling"]}
{"instruction_name": "WRITE_BIG", "description": "You use the \"Write data in big endian format\" instruction to write the data of a single tag in the big endian byte sequence to a memory area. With the big endian format, the byte with the most significant bits is saved first, which means at the lowest memory address.", "parameters": {"Input": [{"name": "SRC_VARIABLE", "type": "Bit strings, integers, floating-point numbers, TOD, DATE, CHAR, WCHAR", "description": "Tag whose data are written. The VARIANT at the SRC_VARIABLE parameter must point to an elementary data type."}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Error information indicating success or type of error."}], "Out": [{"name": "DEST_ARRAY", "type": "ARRAY of BYTE", "description": "Memory area to which the data are written. The VARIANT at the DEST_ARRAY parameter points to the memory area to which the data is written."}, {"name": "POS", "type": "DINT", "description": "Determines the position at which the writing starts. The POS parameter is calculated zero-based."}]}, "how_to_use": "Provide SRC_VARIABLE with an elementary data type tag to write, DEST_ARRAY with a byte array memory area, and POS indicating the zero-based start position. The instruction writes the data in big endian format starting at the specified position. For VARIANT or BOOL data types, use Serialize/Deserialize or slice access respectively.", "example_code": "#TagResult := WRITE_BIG(SRC_VARIABLE := #DINTVariable,\n                    DEST_ARRAY := #TargetField,\n                    POS := #TagPos);", "additional_info": "RET_VAL error codes: 0000 = No error; 80B4 = SRC_ARRAY not ARRAY of BYTE; 8382 = POS outside ARRAY limits; 8383 = POS within limits but size exceeds ARRAY high limit.", "generated_brief": {"functional_summary": "The WRITE_BIG instruction writes data from a single elementary data type tag into a specified memory area in big endian byte order starting at a given position.", "usage_context": "This function is typically used when storing or transmitting data in big endian format to ensure correct byte order across systems in industrial automation applications."}, "generated_keywords": ["write big endian", "memory writing", "elementary data type", "byte array", "data serialization"]}
{"instruction_name": "WRITE_LITTLE", "description": "You use the \"Write data in little endian format\" instruction to write the data of a single tag in the little endian byte sequence to a memory area. With the little endian format, the byte with the least significant bits is saved first, which means at the lowest memory address.", "parameters": {"Input": [{"name": "SRC_VARIABLE", "type": "Bit strings, integers, floating-point numbers, TOD, DATE, CHAR, WCHAR", "description": "Tag whose data are written. The VARIANT at the SRC_VARIABLE parameter must point to an elementary data type."}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Error information returned by the instruction."}], "InOut": [{"name": "DEST_ARRAY", "type": "ARRAY of BYTE", "description": "Memory area to which the data are written. The VARIANT at the DEST_ARRAY parameter points to this memory area."}, {"name": "POS", "type": "DINT", "description": "Determines the position at which the writing starts. The POS parameter is calculated zero-based."}]}, "how_to_use": "Provide the tag data to SRC_VARIABLE. Provide a BYTE array to DEST_ARRAY the little endian byte sequence will be written, starting at the position specified by POS. POS tracks the current write position and is zero-based. The instruction writes the data according to the data type of SRC_VARIABLE. If you want to write a VARIANT or BOOL, use the Serialize/Deserialize instructions or slice access respectively.", "example_code": "#TagResult := WRITE_LITTLE(SRC_VARIABLE := #DINTVariable,\n                    DEST_ARRAY := #TargetField,\n                    POS := #TagPos);", "additional_info": "RET_VAL returns zero on success. Possible error codes include 80B4 if SRC_ARRAY is not an ARRAY of BYTE, 8382 if POS is out of the ARRAY limits, and 8383 if writing would exceed the array boundary. When writing tags of type VARIANT use Serialize/Deserialize instructions, and for BOOL use slice access.", "generated_brief": {"functional_summary": "The WRITE_LITTLE instruction writes the data of a single tag into a specified memory area in little endian byte order starting at a given position.", "usage_context": "It is typically used when storing or transferring numerical or elementary data types in little endian format within PLC memory arrays for communication or data processing purposes."}, "generated_keywords": ["write little endian data", "memory byte array write", "elementary data type write", "position-based memory write", "PLC data serialization"]}
{"instruction_name": "DIS_AIRT", "description": "You use \"DIS_AIRT\" to delay the processing of interrupt OBs whose priority are higher than the priority of the current organization block. You can call \"DIS_AIRT\" multiple times in an organization block. The \"DIS_AIRT\" calls are counted by the operating system. Processing is delayed more and more each time \"DIS_AIRT\" is executed. To cancel a delay, you must execute the \"EN_AIRT\" instruction. The processing delay applies until the number of executions of \"EN_AIRT\" matches the number of calls of \"DIS_AIRT\" or the current OB has been worked through.", "parameters": {"Input": [], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Number of delays"}], "InOut": []}, "how_to_use": "Call DIS_AIRT within an organization block to delay processing of higher priority interrupt OBs. Each call increases the delay count. To clear delays, call EN_AIRT the same number of times. The RET_VAL output returns the current count of delays.", "example_code": "", "additional_info": "RET_VAL shows the number of processing delays (number of DIS_AIRT calls) after the instruction is completed. Use EN_AIRT to clear the delays. Valid RET_VAL data types include I, Q, M, D, L memory areas.", "generated_brief": {"functional_summary": "DIS_AIRT delays the processing of higher priority interrupt organization blocks by increasing a delay count each time it is called until the delay is cleared using EN_AIRT.", "usage_context": "It is used within an organization block to temporarily postpone the handling of higher priority interrupts during critical processing in a PLC program."}, "generated_keywords": ["delay_interrupt_processing", "interrupt_priority_management", "defer_higher_priority_OB", "interrupt_delay_count", "EN_AIRT_delay_cancellation"]}
{"instruction_name": "EN_AIRT", "description": "You use \"EN_AIRT\" to enable processing of organization blocks when interrupts occur that have been delayed by the \"DIS_AIRT\" instruction. When \"EN_AIRT\" is executed, you cancel a processing delay that was registered by the operating system when \"DIS_AIRT\" was called. To cancel all delays, the number of \"EN_AIRT\" executions must be equal to the number of \"DIS_AIRT\" calls.", "parameters": {"Input": [], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Number of configured delays. It shows the number of processing delays that are not yet enabled after the instruction is completed. A value of 0 means that interrupt handling is enabled again."}], "InOut": []}, "how_to_use": "Call EN_AIRT to cancel interrupt processing delays previously activated by DIS_AIRT. The number of EN_AIRT calls must match the number of DIS_AIRT calls to fully enable interrupt processing again. Check RET_VAL after execution to determine the remaining delayed interrupts. If RET_VAL is 0, all delays are canceled.", "example_code": "", "additional_info": "If the function is called again when interrupt processing is already enabled, an error code 8080 is returned. Other general error codes may be returned and can be analyzed using GET_ERR_ID. Valid RET_VAL parameter data locations include I, Q, M, D, L.", "generated_brief": {"functional_summary": "EN_AIRT re-enables processing of delayed interrupt organization blocks by canceling delays caused by prior DIS_AIRT.", "usage_context": "It is used when interrupt processing needs to be safely resumed being temporarily disabled in a PLC program, ensuring all delays are cleared by matching the number of EN_AIRT calls to DIS_A calls."}, "generated_keywords": ["enable interrupt processing", "cancel interrupt delay", "interrupt delay counter", "DIS_AIRT delay cancellation", "interrupt processing resume"]}
{"instruction_name": "EN_IRT", "description": "You use the instruction to enable the processing of new interrupts and asynchronous error events that you have previously disabled with the \"DIS_IRT\" instruction. This means that if an interrupt event occurs, the CPU operating system reacts in one of the following ways: It calls an interrupt OB or asynchronous error OB, or it triggers the specified reaction if an interrupt OB or asynchronous error OB is not programmed.", "parameters": {"Input": [{"name": "MODE", "type": "BYTE", "description": "Specifies which interrupts and asynchronous error events will be enabled."}, {"name": "OB_NR", "type": "", "description": "OB number."}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "If an error occurs while the instruction is being executed, the return value contains an error code."}], "InOut": []}, "how_to_use": "Use the EN_IRT instruction to re-enable processing of interrupts and asynchronous error events after they have been disabled by DIS_IRT. Configure the MODE parameter to specify which interrupts to enable: 0 to enable all except programming errors and Motion Control OBs, 1 to enable all events belonging to a specified interrupt class (e.g. 10 for Time-of-day interrupts), or 2 to enable events of a specific interrupt by its OB number specified in OB_NR. Check the RET_VAL output for error codes during execution.", "example_code": "", "additional_info": "Valid MODE values and their meanings: 0 - all except programming error and direct I/O access errors; 1 - enable specific interrupt class (10, 20, 30, 40, 50, 60, 70, 80); 2 - enable specific interrupt by OB number. Error codes include 0000 (no error), 8090 (invalid OB_NR), 8091 (invalid MODE). See also GET_ERR_ID instruction for general error information.", "generated_brief": {"functional_summary": "The EN_IRT instruction enables the processing of new interrupts and asynchronous error events that were previously disabled, based on specified mode and OB number parameters.", "usage_context": "It is used in PLC programs to re-enable interrupt handling after being disabled by DIS_IRT, allowing the CPU to respond to specific or all interrupt events during operation."}, "generated_keywords": ["enable interrupts", "asynchronous error events", "interrupt handling", "interrupt reactivation", "PLC interrupt control"]}
{"instruction_name": "SET_CINT", "description": "You use this instruction to set the parameters for a cyclic interrupt OB. The start time for a cyclic interrupt OB is generated from the respective time interval of the OB and the phase offset.", "parameters": {"Input": [{"name": "OB_NR", "type": "OB_CYCLIC", "description": "OB number (<32768)"}, {"name": "CYCLE", "type": "UDINT", "description": "Time interval in microseconds"}, {"name": "PHASE", "type": "UDINT", "description": "Phase offset in microseconds"}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Status of the instruction"}], "InOut": []}, "how_to_use": "To use the SET_CINT instruction, provide the OB number, cycle time in microseconds, and the phase offset in microseconds. If the configuration is not valid, monitor the RET_VAL for status.", "example_code": "", "additional_info": "If the OB does not exist or if the time interval used is not supported, a corresponding error alarm is output in the RET_VAL parameter.", "generated_brief": {"functional_summary": "The SET_CINT instruction configures the timing parameters, including the cycle time and phase offset, for a cyclic interrupt OB in a PLC system.", "usage_context": "It is used when precise periodic execution of cyclic interrupt OBs is needed in industrial control applications to ensure timely and synchronized task scheduling."}, "generated_keywords": ["cyclic interrupt configuration", "OB timing parameters", "cycle time setup", "phase offset adjustment", "periodic task scheduling"]}
{"instruction_name": "TIME_TCK", "description": "With the 'TIME_TCK' instruction, you read a time counter which counts the ms in which the CPU is in RUN. The time counter counts from 0 to max. 2147483647 ms. In the case of an overflow, counting restarts from 0. The time scale and the accuracy amount to 1 ms. The time counter is only influenced by the operating modes of the CPU. You can, for example, use it to measure the duration of processes by differentiation of the results of two 'TIME_TCK' calls. The instruction does not provide any error information.", "parameters": {"Input": [], "Output": [{"name": "RET_VAL", "type": "TIME", "description": "The RET_VAL parameter contains the read time counter in the range from 0 to 2^31 -1 ms."}], "InOut": []}, "how_to_use": "To use the 'TIME_TCK' instruction, you must create a tag for storing the data in a global data block and interconnect the parameters properly.", "example_code": "VAR\n    outputCPUtimer : TIME;\nEND_VAR\noutputCPUtimer := TIME_TCK();", "additional_info": "The time counter is constantly updated in Startup and RUN modes. It is stopped in STOP mode and deleted on Warm restart.", "generated_brief": {"functional_summary": "The TIME_TCK instruction reads a millisecond time counter that measures CPU runtime while in Run mode, resetting upon overflow or warm restart.", "usage_context": "It is typically used to measure process durations by comparing time counter values at different points during program execution."}, "generated_keywords": ["read CPU runtime", "millisecond time counter", "process duration measurement", "overflow reset", "run mode timer"]}
{"instruction_name": "LEN", "description": "You use the instruction 'LEN' to query the current length of the character string specified at the IN input parameter. This is output as numerical value at the output par OUT. An empty string ('') has the length zero.", "parameters": {"Input": [{"name": "IN", "type": "STRING, WSTRING", "description": "Character string"}], "Output": [{"name": "OUT", "type": "INT", "description": "Number of valid characters"}], "InOut": []}, "how_to_use": "To use the LEN instruction, specify the character string at the IN parameter and the result will be provided at the OUT parameter as the number of valid characters.", "example_code": "stringLengthOUT := LEN(inputSTRING);", "additional_info": "If errors occur during processing of the instruction, the value '0' is output at the OUT parameter.", "generated_brief": {"functional_summary": "The LEN instruction returns the length of a given character string as an integer value.", "usage_context": "It is used in PLC programs to determine the number of characters in a string for processing or validation purposes."}, "generated_keywords": ["string length", "character count", "string processing", "string validation", "LEN instruction"]}
{"instruction_name": "T_COMBINE", "description": "The instruction combines the value of a date with the value of a time, resulting in a combined date and time value.", "parameters": {"Input": [{"name": "IN1", "type": "DATE", "description": "Input tag of the date. Use a value between 1990-01-01 and 2089-12-31 for the data type DATE (this is not checked)."}, {"name": "IN2", "type": "TOD, LTOD", "description": "Input tag of the time."}], "Output": [{"name": "OUT", "type": "DTL", "description": "Return value of the date and time."}], "InOut": []}, "how_to_use": "When you drag the instruction 'T_COMBINE' from the 'Instructions' task card to the SCL programming window, the internal instruction CONCAT_DATE_TOD or CONCAT_DATE_LTOD is displayed there.", "example_code": "", "additional_info": "Create three tags in a global data block for storing the data. The date ('valueDATE') is expanded by the specification of the time of day ('valueTOD') and the return value is displayed at output parameter OUT ('combTIME').", "generated_brief": {"functional_summary": "T_COMBINE merges a separate date value and time value into a single combined date-time value.", "usage_context": "It is typically used in PLC programs to construct complete timestamps from individual date and time inputs for event logging or time-based control."}, "generated_keywords": ["combine date and time", "merge date-time values", "timestamp creation", "date and time input", "DTL output"]}
{"instruction_name": "CONCAT", "description": "You use the instruction 'CONCAT' to combine the character string at the IN1 input parameter with the character string at the IN2 input parameter. The result is output at the OUT output parameter in (W)STRING format. If the resulting character string is longer than the tag specified in the OUT output parameter, then the resulting character string will be limited to the available length.", "parameters": {"Input": [{"name": "IN1", "type": "STRING, WSTRING", "description": "Character string"}, {"name": "IN2", "type": "STRING, WSTRING", "description": "Character string"}], "Output": [{"name": "OUT", "type": "STRING, WSTRING", "description": "Resulting character string"}], "InOut": []}, "how_to_use": "You can extend the 'CONCAT' instruction with additional inputs. The first input must be 'IN1' and must be followed consecutively, such as 'IN2', 'IN3', up to 'IN32'.", "example_code": "CONCAT(IN1 := string_1, IN2 := string_2, … IN32 := string_32)", "additional_info": "If errors occur during processing of the instruction and it is possible to write the OUT output parameter, an empty string will be output.", "generated_brief": {"functional_summary": "The CONCAT instruction combines multiple input character strings into a single concatenated string, truncating if the result exceeds the output length limit.", "usage_context": "It is typically used in PLC programming when concatenating strings for display, communication, or data processing within industrial control systems."}, "generated_keywords": ["string concatenation", "combine character strings", "PLC string operation", "truncate output string", "multi-input concat"]}
{"instruction_name": "LEFT", "description": "You use the instruction 'LEFT' to extract a partial string beginning with the first character of the string at the IN input parameter. You specify the number of characters to be extracted in the L parameter. The extracted characters are output at the OUT output parameter in (W)STRING format.", "parameters": {"Input": [{"name": "IN", "type": "STRING, WSTRING", "description": "Character string"}, {"name": "L", "type": "BYTE, INT, SINT, USINT", "description": "Number of characters to be extracted"}], "Output": [{"name": "OUT", "type": "STRING, WSTRING", "description": "Extracted partial string"}], "InOut": []}, "how_to_use": "Connect the 'IN' parameter with the input string and set the 'L' parameter to the number of characters you want to extract.", "example_code": "VAR\n    inputSTRING : STRING;\n    outputExtractSTRING : STRING;\n    extractNumber : INT := 4;\nEND_VAR\noutputExtractSTRING := LEFT(inputSTRING, extractNumber);", "additional_info": "If the number of characters to be extracted is greater than the current length of the character string, the OUT output parameter returns the input character string as a result. If the L parameter contains the value '0' or the input value is an empty string, an empty string will be returned. If the value in the L parameter is negative, an empty string will be output.", "generated_brief": {"functional_summary": "The LEFT instruction extracts a substring from the beginning of a given string based on the specified number of characters.", "usage_context": "It is typically used in PLC programs to parse or manipulate strings by retrieving a fixed number of leading characters from input strings."}, "generated_keywords": ["string extraction", "substring from start", "fixed length substring", "string parsing", "character count extraction"]}
{"instruction_name": "DP_TOPOL", "description": "You use the instruction to trigger the topology determination for a selected DP master system. Calling the instruction will address all diagnostics repeaters on a DP master system. Topology determination is the prerequisite for the detailed display of the error location if line errors occur. After configuration and after every change to the physical configuration of a DP master system, you must repeat the topology determination with \"DP_TOPOL\". Changes to the physical configuration include changes in line lengths, adding or removing stations or components with repeater function, and changing station addresses. \"DP_TOPOL\" is an asynchronous instruction. Processing takes place across several calls. You start determining the bus topology by calling \"DP_TOPOL\" with REQ=1. If you want to cancel the process, call \"DP_TOPOL\" with R=1. The output parameters RET_VAL and BUSY indicate the status of the job.", "parameters": {"Input": [{"name": "REQ", "type": "BOOL", "description": "REQ=1: Trigger topology determination"}, {"name": "R", "type": "BOOL", "description": "R=1: Cancel topology determination"}, {"name": "DP_ID", "type": "HW_IOSYSTEM", "description": "DP master system ID of those master systems for which the topology will be determined"}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "If an error occurs while the instruction is being executed, the return value contains an error code."}, {"name": "BUSY", "type": "BOOL", "description": "BUSY=1: Topology determination is not yet complete."}, {"name": "DPR", "type": "BYTE", "description": "PROFIBUS address of the diagnostics repeater reporting the error."}, {"name": "DPRI", "type": "BYTE", "description": "Measuring segment diagnostics repeater reporting the error: Bit 0 = 1: Temporary faults on segment DP2; Bit 1 = 1: Permanent faults on segment DP2; Bit 4 = 1: Temporary faults on segment DP3; Bit 5 = 1: Permanent faults on segment DP3"}], "InOut": []}, "_to_use": "Call DP_TOPOL with REQ=1 and the appropriate DP_ID to start bus topology determination. The process is asynchronous and can take several minutes. If needed, call DP_TOPOL again monitor progress or cancel with R=1. Reset the instruction by calling it with REQ=0 and R=1 before repeating topology determination after an error. Monitor RET_VAL for error codes and BUSY for completion status. Use DPR and DPRI outputs to identify errors reported by diagnostics repeaters.", "example_code": "", "additional_info": "Only one DP master system topology can be determined at a time. If DP_TOPOL is called again with the same DP_ID on an ongoing job, RET_VAL = W#16#7002 is returned indicating a follow-up call. Calling with a different DP_ID when a job is active is rejected. RET_VAL codes differentiate temporary and permanent errors; temporary errors may resolve without user action and require repeated calls. Permanent errors require user intervention before retrying. Determining topology may take several minutes.", "generated_brief": {"functional_summary": "DP_TOPOL triggers and manages the asynchronous determination of the physical topology for a selected PROFIBUS DP master system to facilitate detailed diagnostics of line errors.", "usage_context": "It is used after configuring or physically modifying a DP master system to identify network layout changes and diagnose communication faults via repeaters."}, "generated_keywords": ["topology determination", "DP master system", "asynchronous diagnostic", "bus configuration update", "error location detection"]}
{"instruction_name": "DELETE", "description": "You use this instruction to delete a portion of the character string in the IN input parameter. With the P parameter, you specify the position of the first character to be deleted. You specify the number of characters to be deleted in the L parameter. The remaining partial character string is output at the OUT output parameter in (W)STRING format.\n\nNote the following rules when executing the instruction:\n- If the value in the P parameter is less than or equals zero, an empty character string will be output in the OUT output parameter.\n- If the value in the P parameter is greater than the current length of the character string in the IN input, the input character string will be returned in the OUT output parameter.\n- If the value in the L parameter equals zero, the input character string will be returned in the OUT output parameter.\n- If the number of characters to be deleted at the L parameter is greater than the length of the character string at the IN input parameter, the characters starting at the position specified by the P parameter are deleted. The string resulting from this is output.\n- If the value in the L parameter is negative, an empty character string will be output.\n\nIf errors occur during processing of the instruction and it is possible to write the OUT output parameter, an empty string will be output.", "parameters": {"Input": [{"name": "IN", "type": "STRING, WSTRING", "description": "Character string"}, {"name": "L", "type": "BYTE, INT, SINT, USINT", "description": "Number of characters to be deleted"}, {"name": "P", "type": "BYTE, INT, SINT, USINT", "description": "Position of first character to be deleted"}], "Output": [{"name": "OUT", "type": "STRING, WSTRING", "description": "Resulting character string"}], "InOut": []}, "how_to_use": "Connect the parameters as follows: specify the character string to modify on IN input, specify the starting position of deletion on P input, specify the number of characters to delete on L input. The modified string is available at the OUT output. Note the rules on input values (e.g., if P<=0 output is empty string, if L=0 output is full string, etc.).", "example_code": "(* Global Data Block items: *)\nVAR_GLOBAL\n  inputSTRING : STRING[80];\n  startingPoint : INT;\n  deleteNumber : INT;\n  outputResidualSTRING : STRING[80];\nEND_VAR\n\n(* Example usage *)\ninputSTRING := 'Siemens PLC Programming';\nstartingPoint := 3;\ndeleteNumber := 4;\n\noutputResidualSTRING := DELETE(IN := inputSTRING, P := startingPoint, L := deleteNumber);", "additional_info": "If errors occur during execution and the OUT parameter can be written, an empty string will be output. This instruction supports both STRING and WSTRING data types for input and output.", "generated_brief": {"functional_summary": "The DELETE instruction removes a specified number of characters from a given position within an input character string and outputs the resulting modified string.", "usage_context": "It is typically used in PLC programming to manipulate and process strings, such as editing messages or data fields dynamically during automation tasks."}, "generated_keywords": ["string deletion", "character removal", "substring manipulation", "PLC string processing", "dynamic string editing"]}
{"instruction_name": "INSERT", "description": "You use this instruction to insert the character string in the IN2 input parameter to the character string in the IN1 input parameter. With the P parameter, you specify the position of the character starting at which the characters are inserted. The result is output at the OUT output parameter in (W)STRING format. Note the following rules when executing the instruction: If the value in the P parameter exceeds the current length of the character string in the IN1 input parameter, the character string of the IN2 input parameter will be appended to the character string of the IN1 input parameter. If the value in the P parameter is zero, the character string of the IN1 input parameter will be appended to the character string of the IN2 input parameter. If the value in the P parameter is negative, an empty character string will be output in the OUT output parameter. If the resulting character string is longer than the tag specified in the OUT output parameter, the resulting character string will be limited to the available length.", "parameters": {"Input": [{"name": "IN1", "type": "STRING, WSTRING", "description": "Character string"}, {"name": "IN2", "type": "STRING, WSTRING", "description": "String to insert"}, {"name": "P", "type": "BYTE, INT, SINT, USINT", "description": "Insert position"}], "Output": [{"name": "OUT", "type": "STRING, WSTRING", "description": "Resulting character string"}], "InOut": []}, "how_to_use": "Initialize the parameters IN1 and IN2 with the character strings to be combined. Set the parameter P to specify the insertion position: if P is greater than the length of IN1, IN2 is appended to IN1; if P is zero, IN1 is appended to IN2; if P is negative, OUT will be empty. The combined result is stored in OUT. Ensure OUT has sufficient length to store the resulting string as it will be truncated if overflow occurs.", "example_code": "VAR\n  input1_STRING : STRING[20];\n  input2_STRING : STRING[20];\n  startingPoint : INT;\n  outputStrg1AndStrg2 : STRING[40];\nEND_VAR\n\ninput1_STRING := 'ABCDE';\ninput2_STRING := '123';\nstartingPoint := 3;\n\nINSERT(IN1 := input1_STRING, IN2 := input2_STRING, P := startingPoint, OUT => outputStrg1AndStrg2);", "additional_info": "When specifying the P parameter, be mindful of its value relative to IN1's length to control the insertion behavior. The instruction supports both STRING and WSTRING data types. If the output exceeds the allocated length of the OUT parameter, the result will be truncated.", "generated_brief": {"functional_summary": "The INSERT instruction inserts one character string into another at a specified position, producing a combined string as output.", "usage_context": "It is used in PLC programming when dynamically modifying or combining strings based on position within industrial control applications."}, "generated_keywords": ["string insertion", "character string combine", "dynamic string modification", "position-based string insert", "PLC string operation"]}
{"instruction_name": "REPLACE", "description": "You use this instruction to replace a portion of the character string in the IN1 input with the character string in the IN2 input parameter. You specify the position of the first character to be replaced in the P parameter. You specify the number of characters to be replaced in the L parameter. The result is output at the OUT output parameter in (W)STRING format.", "parameters": {"Input": [{"name": "IN1", "type": "STRING, WSTRING", "description": "String with characters to be replaced."}, {"name": "IN2", "type": "STRING, WSTRING", "description": "String with characters to be inserted."}, {"name": "L", "type": "BYTE, INT, SINT, USINT", "description": "Number of characters to be replaced"}, {"name": "P", "type": "BYTE, INT, SINT, USINT", "description": "Position of first character to be replaced"}], "Output": [{"name": "OUT", "type": "STRING, WSTRING", "description": "Resulting character string"}], "InOut": []}, "how_to_use": "Set the input IN1 as the original string, IN2 as the string to insert, P as the starting position for replacement (1-based index), and L as the number of characters to replace. If P is less than or equal to zero or L is less than zero, OUT will be an empty string. If P exceeds the length of IN1, IN2 is appended. If L is zero, the instruction inserts IN2 at position P without replacement. The resulting string is stored in OUT, truncated if necessary to fit the allocated size.", "example_code": "VAR\n  input1_STRING : STRING[20];\n  input2_STRING : STRING[20];\n  startingPoint : INT;\n  replaceNumber : INT;\n  outputNewSTRING : STRING[40];\nEND_VAR\n\ninput1_STRING := 'Siemens PLC Example';\ninput2_STRING := 'Test';\nstartingPoint := 3;\nreplaceNumber := 2;\n\noutputNewSTRING := REPLACE(IN1 := input1_STRING, IN2 := input2_STRING, P := startingPoint, L := replaceNumber);", "additional_info": "If the resulting string length exceeds the OUT parameter's length, it will be truncated. If L equals zero, REPLACE behaves like an INSERT instruction. When P is less than or equal to zero or L less than zero, the output is an empty string.", "generated_brief": {"functional_summary": "The REPLACE instruction modifies a specified portion of an input string by replacing it with another string starting at a given position and for a defined length, outputting the resulting string.", "usage_context": "It is used in PLC programs when dynamic editing of string data is required, such as inserting or substituting parts of strings for text processing and communication tasks."}, "generated_keywords": ["string replacement", "substring editing", "string insertion", "character position", "string manipulation"]}
{"instruction_name": "PE_Measurement_Value_RSP", "description": "The auxiliary block \"PE_Measurement_Value_RSP\" generates the response to the command Get_measurement_values. In the response, return the values of the requested measurements.", "parameters": {"Input": [{"name": "PE_I_DEV_NEW", "type": "BOOL", "description": "The parameter must be interconnected with the output parameter of the \"PE_I_DEV\" instruction. The auxiliary block is processed if the parameter value is set to \"1\"."}, {"name": "CMD", "type": "INT", "description": "Service-Request-ID of the PROFIenergy command. The parameter must be interconnected with the CMD output parameter of the \"PE_I_DEV\" instruction."}, {"name": "CMD_MODIFIER", "type": "INT", "description": "PROFIenergy sub-command (evaluated only if CMD=3, or CMD=16). The parameter must be interconnected with the CMD_MODIFIER output parameter of the \"PE_I_DEV\" instruction."}, {"name": "Count", "type": "BYTE", "description": "Number of measured values (Measurement_Values)."}, {"name": "Measurement_Values", "type": "VARIANT", "description": "Pointer to the array with the measured values (Measurement_IDs). For information on the structure of the array in accordance with the PROFIenergy profile, see PI Command \"Query_Measurement\" - \"Get_Measurement_values\"."}], "Output": [{"name": "ERROR", "type": "BOOL", "description": "\"0\": No error; \"1\": Error occurred."}, {"name": "STATUS", "type": "WORD", "description": "\"0\": No error; \"0x80B1\": Error in VARIANT setting, e.g. incorrect range"}], "InOut": [{"name": "ACTIVATE", "type": "BOOL", "description": "The instruction copies the input parameters to the DATA_ERROR_RSP data area at a rising edge at input ACTIVATE. The parameter is then reset by the instruction. The parameter must be set within 10 seconds after a rising edge is detected at parameter NEW of the \"PE_I_DEV\" instruction."}, {"name": "VALID", "type": "BOOL", "description": "The parameter must be interconnected with the VALID input of the \"PE_I_DEV\" instruction. The auxiliary block sets the parameter once the response data for the PROFIenergy controller is available and ready for transmission."}, {"name": "DATA_ERRORRSP", "type": "VARIANT", "description": "Pointer on the data area in which the response data is stored. The parameter is identical to the pointer for DATA_ERRORRSP of the \"PE_I_DEV\" instruction. The data area contains the complete PROFIenergy frame. Minimum length: 244 bytes"}]}, "how_to_use": "Set the input parameters appropriately, ensuring that PE_I_DEV_NEW is set to '1' to process the auxiliary block. ACTIVATE must receive a rising edge signal and be set within 10 seconds after the NEW parameter of 'PE_I_DEV' is detected. The block will then copy input data to DATA_ERRORRSP and update VALID when the response data is ready.", "example_code": "", "additional_info": "The DATA_ERRORRSP data area must have a minimum length of 244 bytes to contain the complete PROFIenergy frame. Input parameters must be interconnected with corresponding outputs or inputs of the 'PE_I_DEV' instruction. Refer to related PI Commands for array structure details.", "generated_brief": {"functional_summary": "The PE_Measurement_Value_RSP instruction generates and prepares the response containing requested measurement values for the PROFIenergy Get_measurement_values command.", "usage_context": "It is used in PROFIenergy-enabled PLC systems to send measurement data responses following a command, ensuring communication conformity within energy management processes."}, "generated_keywords": ["PROFIenergy measurement response", "Get_measurement_values command", "measurement data transmission", "auxiliary block activation", "energy management communication"]}
{"instruction_name": "QRY_CINT", "description": "The instruction QRY_CINT returns the following parameters of a cyclic interrupt OB: Cycle time, Phase offset, Status of the cyclic interrupt (enabled, delayed, expired, etc.). The cyclic interrupt OB is identified using the OB_NR parameter. The values of the queried cyclic interrupt parameters correspond to those at the time the \"QRY_CINT\" instruction is executed.", "parameters": {"Input": [{"name": "OB_NR", "type": "OB_CYCLIC (INT)", "description": "OB number (<32768) or symbolic addressing via the name of the OB (e.g. OB_MyOB)"}], "Output": [{"name": "CYCLE", "type": "UDINT", "description": "Cycle time in microseconds"}, {"name": "PHASE", "type": "UDINT", "description": "Phase offset"}, {"name": "STATUS", "type": "WORD", "description": "Status of the cyclic interrupt: Bit 0 to bit 4 represent status flags (enabled, delayed, expired, etc.), other bits always \"0\""}], "InOut": [{"name": "RET_VAL", "type": "INT", "description": "Status of the instruction, error codes if applicable"}]}, "how_to_use": "Use QRY_CINT to query the status parameters of a specified cyclic interrupt OB identified by OB_NR. Pass the OB number or symbolic name as the input. Read returned values for cycle time (CYCLE), phase offset (PHASE), and interrupt status (STATUS). Check RET_VAL for execution success or error codes.", "example_code": "", "additional_info": "STATUS bits 0-4 have specific meanings: bit 1 indicates enabled or delayed, bit 2 indicates enabled or expired, bit 4 indicates existence of the OB. On error, RET_VAL contains an error code and STATUS is set to 0. Possible error codes include 0 (no error), 8090 (OB does not exist or wrong type), and 80B2 (no result assigned to OB).", "generated_brief": {"functional_summary": "QRY_CINT retrieves the cycle time, phase offset, and current status flags of a specified cyclic interrupt OB in a PLC system.", "usage_context": "It is used when monitoring or diagnosing the configuration and state of cyclic interrupts during the operation of industrial automation processes."}, "generated_keywords": ["query cyclic interrupt", "cyclic interrupt status", "cyclic interrupt timing", "OB number identification", "interrupt status flags"]}
{"instruction_name": "UPDAT_PI", "description": "With the instruction, you update a partial image partition of the inputs defined in the configuration.", "parameters": {"Input": [{"name": "PART", "type": "PIP", "description": "Number of the process image partition of the inputs to be updated. Maximum value range (depending on the CPU): 1 <= n <= 31 (means process image partition n)."}], "Output": [{"name": "FLADDR", "type": "WORD", "description": "Address of the first byte to cause an error if an access error has occurred."}], "InOut": []}, "how_to_use": "The specified process image partition is updated when the instruction 'UPDAT_PI' is called. Ensure that the process image partition is not assigned to an interrupt OB and that it is not being updated by the system.", "example_code": "PART := 1;\nUPDAT_PI(PART, RET_VAL, FLADDR);\nIF RET_VAL = 16#0000 THEN\n    updateOk := TRUE;\nEND_IF;", "additional_info": "You must not perform a simultaneous update with the 'SYNC_PI' instruction. If using for process image partitions of DP standard slaves, the error codes of the 'DPRD_DAT' instruction may also apply.", "generated_brief": {"functional_summary": "The UPDAT_PI instruction updates a specified partial image partition of the PLC input process image based on the configuration.", "usage_context": "It is typically used when an application needs to refresh a defined input partition safely without conflicts, ensuring that the partition is not being updated by interrupts or system processes."}, "generated_keywords": ["update process image partition", "partial input refresh", "process image synchronization", "input partition update", "PLC input image management"]}
{"instruction_name": "MID", "description": "You use this instruction to extract a portion of the character string in the IN input parameter. With the P parameter, you specify the position of the first character to be extracted. With the L parameter, you define the length of the character string to be extracted. The extracted partial character string is output to the OUT output parameter. Note the following rules when executing the instruction: If the number of characters to be extracted exceeds the current length of the character string in the IN input parameter, a partial character string will be output. The partial character string starts at the P character string and is continued until the end of the character string. If the character position specified in the P parameter falls outside the current character string length in the IN input parameter, an empty character string will be output in the OUT output parameter. If the value of the P or L parameter equals zero or is negative, an empty character string will be output in the OUT output parameter. If errors occur during processing of the instruction and it is possible to write the OUT output parameter, an empty string will be output.", "parameters": {"Input": [{"name": "IN", "type": "STRING, WSTRING", "description": "Character string"}, {"name": "L", "type": "BYTE, INT, SINT, USINT", "description": "Length of the string to be extracted"}, {"name": "P", "type": "BYTE, INT, SINT, USINT", "description": "Position of the first character to be extracted (first character = 1)"}], "Output": [{"name": "OUT", "type": "STRING, WSTRING", "description": "Extracted partial string"}], "InOut": []}, "how_to_use": "Use the MID instruction to extract a substring from the IN parameter starting at position P for length L. Ensure that the positions and lengths are valid; if they exceed or are zero/negative, the result is an empty string. This instruction gracefully handles errors by outputting an empty string if extraction is impossible.", "example_code": "VAR\n  inputSTRING : STRING := 'ExampleString';\n  outputExtractSTRING : STRING;\n  startingPoint : INT := 3;\n  extractNumber : INT := 4;\nEND_VAR\n\n// Extract 4 characters starting from the 3rd character\noutputExtractSTRING := MID(IN := inputSTRING, P := startingPoint, L := extractNumber);", "additional_info": "If the requested length surpasses the input string length from the start position, MID returns the substring from the start position to the end of the input string. If start position or length are zero or negative, or if start position is beyond the string end, an empty string is returned.", "generated_brief": {"functional_summary": "The MID instruction extracts a substring from a given string starting at a specified position for a specified length, returning an empty string if parameters are invalid or out of range.", "usage_context": "This function is typically used in PLC programming to isolate specific parts of text data for processing, such as parsing inputs or preparing data for display or logging."}, "generated_keywords": ["string extraction", "substring", "character position", "string length", "text parsing"]}
{"instruction_name": "LOG2MOD", "description": "You use the \"LOG2MOD\" instruction to determine the hardware identifier for an IO (sub)module from the addressing of STEP 7 5.5 SPx (IO data address or diagnostic address).\nThe hardware identifier is used at the LADDR input parameter for addressing of various instructions. Convert the addressing parameters from STEP 7 5.5 SPx by calling \"LOG2MOD\" beforehand.", "parameters": {"Input": [{"name": "IOID", "type": "BYTE", "description": "Identifier of the address area as in STEP 7 5.5 SPx:\n- B#16#00: Bit15 of ADDR specifies whether an input (Bit15=0) or output address (Bit15=1) exists.\n- B#16#54= Peripheral input (PI)\n- B#16#55= Peripheral output (PQ)"}, {"name": "ADDR", "type": "WORD", "description": "Logical address of the IO data of the module as offset (corresponding addressing in STEP 7 5.5 SPx) or diagnostic address."}], "Output": [{"name": "HWID", "type": "HW_IO", "description": "Determined hardware identifier of the IO (sub)module."}], "InOut": [], "Return": [{"name": "RET_VAL", "type": "INT", "description": "Error code of the instruction."}]}, "how_to_use": "Call LOG2MOD with IOID and ADDR parameters that correspond to the STEP 7 5.5 SPx addressing method. The output HWID can then be used for further addressing of instructions. Check RET_VAL for errors, where 0 means no error, and 8093 means invalid address or IOID value.", "example_code": "", "additional_info": "Error codes:\n- 0: No error occurred.\n- 8093: Specified address is not used by any hardware components or specified IOID parameter value is invalid.\nThe error codes may be displayed as integer or hexadecimal in the program editor. Refer to 'Switching display formats in the program status' for details.", "generated_brief": {"functional_summary": "The LOG2MOD instruction converts STEP 7 5.5 SPx IO data or diagnostic addresses into a hardware identifier for the corresponding IO (sub)module.", "usage_context": "It is used when precise hardware addressing is required for further instruction calls in PLC programs based on STEP 7 5.5 SPx addressing schemes."}, "generated_keywords": ["hardware identifier conversion", "IO module addressing", "STEP 7 5.5 SPx address translation", "LOG2MOD instruction", "PLC IO addressing"]}
{"instruction_name": "DELETE_DB", "description": "You use the instruction \"DELETE_DB\" to delete a data block (DB) that was created from the user program by calling the instruction \"CREATE_DB\". If the data block was not created with \"CREATE_DB\", the error code W#16#80B5 is output at the RET_VAL parameter. The selected data block is not deleted immediately, but rather at the cycle control point after execution of the cycle OB. The \"DELETE_DB\" instruction works asynchronously. Processing takes place across several calls. You start the interrupt transfer by calling the instruction with REQ = 1. Output parameter BUS and bytes 2 and 3 of output parameter RET_VAL show the status of the job. When the output parameter BUSY has the value FALSE, the deletion of the data block is completed.", "parameters": {"Input": [{"name": "REQ", "type": "BOOL", "description": "REQ =1: Request to delete the DB with the number in the DB_NUMBER parameter"}, {"name": "DB_NUMBER", "type": "UINT", "description": "Number of the DB to be deleted"}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Error information (see \"RET_VAL parameter\")"}, {"name": "BUSY", "type": "BOOL", "description": "BUSY =1: The process is not yet complete."}], "InOut": []}, "how_to_use": "Call DELETE_DB with REQ set to TRUE and DB_NUMBER set to the data block number to delete. The deletion process is asynchronous; monitor BUSY output to track progress. When BUSY becomes FALSE, the deletion is complete. Check RET_VAL for any error codes indicating issues such as invalid DB number or DB not created with CREATE_DB. Deletion occurs at the cycle control point after the cycle OB execution. This instruction is only supported on SIMATIC S7-1500R/H-CPUs from firmware version V3.0 onward.", "example_code": "", "additional_info": "If the DB was not created using CREATE_DB, RET_VAL outputs error code W#16#80B5. Other possible error codes include invalid DB number (80A1), DB does not exist (80B1), write-protected memory card (80B4), insufficient load memory (80BB), and temporary resource bottleneck (80C3). The instruction is asynchronous and spans multiple calls. The deletion is not immediate but takes effect after OB cycle execution.", "generated_brief": {"functional_summary": "DELETE_DB asynchronously deletes a user-created data block (DB) from memory after the program cycle completes, providing status and error feedback.", "usage_context": "It is used in SIMATIC S7-1500R/H CPUs to manage and free memory by removing dynamically created data blocks when they are no longer needed."}, "generated_keywords": ["delete data block", "asynchronous deletion", "dynamic DB management", "SIMATIC S7-1500R/H", "memory release"]}
{"instruction_name": "READ_DBL", "description": "With the instruction, you copy a DB or an area of a DB in load memory (Micro Memory Card) to the data area of a destination DB. The destination data block must be runtime-relevant, which means it must not be created with the Only store in load memory attribute. The content of the load memory is not changed during the copy process.", "parameters": {"Input": [{"name": "REQ", "type": "BOOL", "description": "REQ = 1: Read request"}, {"name": "SRCBLK", "type": "VARIANT", "description": "Pointer to data block in the load memory that is to be read from"}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Error information"}, {"name": "BUSY", "type": "BOOL", "description": "BUSY = 1: The reading process is not yet complete."}, {"name": "DSTBLK", "type": "VARIANT", "description": "Pointer to the data block in the work memory that is written to"}], "InOut": []}, "how_to_use": "You start the job by calling 'READ_DBL' with REQ = 1. Ensure data consistency by not changing the destination area during execution.", "example_code": "If (execute) THEN\n    READ_DBL(REQ:=1, SRCBLK:='SourceDB_LoadMemory', DSTBLK:='TargetDB');\nEND_IF;", "additional_info": "The instruction is processed asynchronously and is not suitable for frequent (or cyclic) reading. Only one job can be processed simultaneously, and you may receive error code W#16#80C3 if the maximum number of active instructions is reached.", "generated_brief": {"functional_summary": "READ_DBL copies data from a data block stored in load memory to a runtime-relevant destination data block in work memory asynchronously without altering the source content.", "usage_context": "It is used to read configuration or parameter data from load memory into runtime memory when data consistency must be maintained and only one read operation occurs at a time."}, "generated_keywords": ["asynchronous data block read", "load memory to work memory", "runtime-relevant data copying", "single active read operation", "data consistency during read"]}
{"instruction_name": "WRIT_DBL", "description": "The instruction \"WRIT_DBL\" is used to transfer the contents of a DB or a DB area from the work memory to a DB or a DB area in the load memory (Micro Memory Card). The source DB must be runtime-relevant, which means it must not be created with the Only store in load memory attribute. The instruction works asynchronously, processing extends over multiple calls and is started by calling \"WRIT_DBL\" with REQ=1. The output parameters RET_VAL and BUSY indicate the status of the job.", "parameters": {"Input": [{"name": "REQ", "type": "BOOL", "description": "REQ = 1: Write request"}, {"name": "SRCBLK", "type": "VARIANT", "description": "Pointer to the DB the work memory that is to be read from. Restrictions: For BOOL type, length must be divisible by 8; for STRING type, length must be 1; source and destination blocks must have the same block access (both optimized or both non-optimized); when optimized access is used, STRUCT data type must not be used."}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Error information returned by the instruction. Various error codes indicate success, errors, or states."}, {"name": "BUSY", "type": "BOOL", "description": "BUSY = 1: The writing process is not yet complete."}, {"name": "DSTBLK", "type": "VARIANT", "description": "Pointer to the data block in the load memory that is written to."}], "InOut": []}, "how_to_use": "Initialize the instruction by setting REQ=1 to start the asynchronous write operation from a work-memory DB to a load-memory DB. Monitor the BUSY output to determine when the operation completes (BUSY=0). Check RET_VAL for error status. Ensure that source and destination DB blocks meet the requirements, such as matching block access type and valid VARIANT pointer lengths. Do not change the source range while BUSY is TRUE. Use carefully because frequent writes to the load memory can exceed memory card write limits.", "example_code": "VAR\n  execute : BOOL;\n  returnValue : INT;\n  busyFlag : BOOL;\n  SLI_srcDB_WRIT_DBL : ARRAY[0..9] OF INT; // example source array\n  SLI_dstDB_WRIT_DBL : ARRAY[0..9] OF INT; // destination in load memory\nEND_VAR\n\n// Usage in code\nIF execute THEN\n  WRIT_DBL(REQ:=TRUE, SRCBLK:=SLI_srcDB_WRIT_DBL, RET_VAL=>returnValue, BUSY=>busyFlag, DSTBLK=>SLI_dstDB_WRIT_DBL);\nEND_IF;\n\n// Monitor busyFlag and returnValue for completion and error handling", "additional_info": "Use of \"WRIT_DBL\" with S7-1500R/H-CPUs is supported only from firmware version V3.0. Start values changed by \"WRIT_DBL\" are lost when performing \"Upload from device\". Initial online/offline differences for S7-1200 FW V2.0/V2.1 may cause symbol status inconsistencies until reconnecting online. Changing the source range during execution (when BUSY=TRUE) is not allowed. Writing a DB created by an instruction does not change the user program checksum, but writing a loaded DB changes the checksum. \"WRIT_DBL\" is not suitable for frequent or cyclical writing due to the memory card write access limits.", "generated_brief": {"functional_summary": "WRIT_DBL asynchronously transfers data from a runtime-relevant work memory data block to a load memory data block on a Micro Memory Card, indicating the operation status via output parameters.", "usage_context": "It is used when updating or backing up data from system RAM to persistent load memory in PLCs, particularly for preserving data across power cycles while monitoring write progress and errors."}, "generated_keywords": ["asynchronous data write", "work memory to load memory", "data block transfer", "Micro Memory Card", "write status monitoring"]}
{"instruction_name": "READ_DBL", "description": "The \"READ_DBL\" instruction is used to transfer the contents of a DB or a DB area from the load memory to a DB or a DB area in the work memory. It is generally used to verify successful transfer of data written by \"WRIT_DBL\". The parameters SRCBLK and DSTBLK define the source in load memory and the destination in work memory respectively, and the output RET_VAL indicates processing status.", "parameters": {"Input": [{"name": "SRCBLK", "type": "VARIANT", "description": "Pointer to the DB or DB area in the load memory that is to be read from."}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Error return value that indicates the status of the read operation."}, {"name": "DSTBLK", "type": "VARIANT", "description": "Pointer to the DB or DB area in the work memory where the data is to be written."}], "InOut": []}, "how_to_use": "Use \"READ_DBL\" to read data asynchronously from a load memory DB to a work memory DB after a successful \"WRIT_DBL\" operation. Connect SRCBLK to the DB in load memory and DSTBLK to the destination DB in work memory. Check RET_VAL for errors and use to confirm data consistency.", "example_code": "", "additional_info": "Typically used following a \"WRIT_DBL\" to verify or read back the transferred data. The operation is asynchronous similar to \"WRIT_DBL\".", "generated_brief": {"functional_summary": "READ_DBL transfers data from a data block in load memory to a data block in work memory and provides a status indicating success or failure.", "usage_context": "It is typically used after a WRIT_D operation to asynchronously verify and confirm that data has been correctly written by reading it back into work memory."}, "generated_keywords": ["read data block", "load memory to work memory", "asynchronous data transfer", "data verification", "read after write"]}
{"instruction_name": "MAX_LEN", "description": "The MAX_LEN instruction determines the maximum length of the character string specified at the IN input parameter. This maximum length is output as a numerical value at the OUT parameter. If errors occur during processing of the instruction, the value \"0\" is output at the OUT parameter. Note that MAX_LEN does not check the character string at the IN parameter.", "parameters": {"Input": [{"name": "IN", "type": "STRING, WSTRING", "description": "Character string whose maximum length is to be determined."}], "Output": [{"name": "OUT", "type": "INT, DINT", "description": "Maximum number of characters of the specified character string."}], "InOut": []}, "how_to_use": "Provide the string variable as the IN parameter to the MAX_LEN instruction. The instruction returns the defined maximum length of the string (i.e., the maximum capacity, not the current length) at the OUT parameter. The string type can be either STRING or WSTRING. Ensure to handle the case when OUT returns 0 indicating an error.", "example_code": "VAR\n  inputSTRING : STRING[20];n  stringMLengthOUT : INT;\nEND_VAR\n\nstringMLengthOUT := MAX_LEN(IN := inputSTRING);", "additional_info": "The MAX_LEN instruction only reads the maximum length defined for the string; it does not validate the content of the string. To read the current number of valid characters in the string, use the LEN instruction instead.", "generated_brief": {"functional_summary": "The MAX_LEN instruction returns the maximum defined capacity of a given STRING or WSTRING variable as a numerical value.", "usage_context": "It is used when determining the allocated size of a string variable to manage memory or buffer limits in PLC programs."}, "generated_keywords": ["maximum string length", "string capacity", "STRING WSTRING size", "string buffer limit", "MAX_LEN instruction"]}
{"instruction_name": "RD_LGADR", "description": "Based on the hardware identifier, you can determine the IO addresses of a module, a central submodule or a submodule for PNIO and DP slaves with the \"RD_LGADR\" instruction.", "parameters": {"Input": [{"name": "IOID", "type": "BYTE", "description": "Is not evaluated"}, {"name": "LADDR", "type": "HW_ANY", "description": "Hardware identifier of the module or the submodule."}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Error information"}, {"name": "PEADDR", "type": "ANY", "description": "Field for the PI addresses with the Array of WORD data type. Note: The field has to lie in the non-optimized memory area."}, {"name": "PECOUNT", "type": "INT", "description": "Number of returned PI addresses"}, {"name": "PAADDR", "type": "ANY", "description": "Field for the PQ addresses with the Array of WORD data type. Note: The field has to lie in the non-optimized memory area."}, {"name": "PACOUNT", "type": "INT", "description": "Number of returned PQ addresses"}], "InOut": []}, "how_to_use": "Specify the hardware ID of the submodule at the LADDR parameter. The instruction writes the addresses to PEADDR (inputs) and PAADDR (outputs) in ascending order, using arrays of WORD type. The number of addresses is output at PECOUNT (inputs) and PACOUNT (outputs). For input modules, only PEADDR and PECOUNT are written; for output modules, PAADDR and PACOUNT are written. The address fields must be in a non-optimized memory area. Note that only the returned number of addresses (PECOUNT or PACOUNT) should be evaluated, as earlier calls may have left data in the arrays. When using packed addresses of an ET200, the first module returns all addresses, others output zeros and possibly error codes.", "example_code": "", "additional_info": "Error codes returned via RET_VAL include: 0x0000 (no error), 0x8090 (invalid hardware identifier), 0x80A0/0x80A1 (array elements not WORD type in PEADDR/PAADDR), 0x80A2/0x80A3 (array too small to hold all addresses). See also GET_ERR_ID instruction for general error handling.", "generated_brief": {"functional_summary": "The RD_LGADR instruction retrieves the input and output module IO addresses and their counts based on a given hardware identifier for PNIO and DP slave modules.", "usage_context": "It is used in PLC programs to determine the precise IO address mapping of modules or submodules for accurate data exchange in industrial automation systems."}, "generated_keywords": ["read IO addresses", "module hardware identifier", "PNIO DP slave address mapping", "input output address retrieval", "PLC module address determination"]}
{"instruction_name": "CTRL_PTO", "description": "The \"CTRL_PTO\" instruction makes a pulse sequence available to you with a preset frequency. For this you do not require an axis DB of a technological object.", "parameters": {"Input": [{"name": "REQ", "type": "BOOL", "description": "REQ=1: Sets the frequency of the pulse generator to the value of FREQUENCY. REQ=1 and FREQUENCY=0: Deactivates the pulse generator. REQ=0: No change at pulse generator."}, {"name": "PTO", "type": "HW_PTO", "description": "Hardware identifier of the pulse generator. This can be taken from the properties of the pulse generator in the device view or the list of system constants."}, {"name": "FREQUENCY", "type": "UDINT", "description": "Frequency of the pulse sequence to be output in Hz."}], "Output": [{"name": "DONE", "type": "BOOL", "description": "Status parameter with the following values: 0: Job not yet started or still in progress. 1: Job completed without error."}, {"name": "BUSY", "type": "BOOL", "description": "Processing status. Since the S7-1200 enables the pulse generator when the \"CTRL_PTO\" instruction is executed, BUSY always has the value FALSE with the S7-1200."}, {"name": "ERROR", "type": "BOOL", "description": "Status parameter: 0: No error. 1: An error occurred during execution of the instruction."}, {"name": "STATUS", "type": "WORD", "description": "Status of the instruction indicating error codes: 0 (No error), 8090 (Pulse generator already in use), 8091 (Frequency range exceeded), 80A1 (PTO param invalid hardware ID), 80D0 (Pulse generator not activated or no PTO property)."}], "InOut": []}, "how_to_use": "Activate a pulse generator in the hardware configuration and select the signal type. Specify the hardware pulse generator identifier at the PTO parameter, set REQ to TRUE to start or stop the pulse output by setting FREQUENCY. Monitor DONE, BUSY, ERROR, and STATUS outputs for execution status and errors. Note that only one pulse generator can be used at a time, and PWM/PTO outputs should not be accessed via the process image or forced signals.", "example_code": "", "additional_info": "At any one time a pulse generator can only be used by one instruction. Digital inputs and outputs used for PWM and PTO cannot be forced or controlled via the force table or watch table. PTO/PWM outputs should not be used in the process image due to update rate differences. Use the STATUS output to check specific error codes for troubleshooting.", "generated_brief": {"functional_summary": "The CTRL_PTO instruction controls a hardware pulse generator by outputting a pulse sequence at a specified frequency without requiring an axis data block.", "usage_context": "It is typically used in industrial automation to generate precise pulse sequences for hardware devices when direct axis control is unnecessary or unavailable."}, "generated_keywords": ["pulse generator control", "hardware PTO output", "frequency pulse sequence", "industrial automation pulse", "non-axis pulse generation"]}
{"instruction_name": "CTRL_PWM", "description": "The \"CTRL_PWM\" instruction is used to enable and disable a pulse output supported by the CPU using the software. When the bit in the ENABLE input of the instruction is set, the pulse output is enabled. If ENABLE has a value of TRUE the pulse generator will generate a pulse with the properties defined in the device configuration. When the bit in the ENABLE input is reset or the CPU changes to STOP, the pulse output is disabled and no more pulses are generated. BUSY always has the value of FALSE for S7-1200 since S7-1200 activates the pulse generator if the instruction \"CTRL_PWM\" is executed. When the EN enable input has signal state \"1\" and no errors have occurred during execution of the instruction, the enable output ENO is set.", "parameters": {"Input": [{"name": "PWM", "type": "HW_PWM", "description": "Hardware ID of the pulse generator. The hardware ID can be found in the properties of the pulse generator in the Device view. The hardware IDs of the pulse generators are also listed in the system constants."}, {"name": "ENABLE", "type": "BOOL", "description": "The pulse output is enabled when ENABLE = TRUE and disabled when ENABLE = FALSE."}], "Output": [{"": "BUS", "type": "BOOL", "description": "Processing status"}, {"name": "STATUS", "type": "WORD", "description": "Status of the instruction (contains error codes such as 0 for no errors, 80A1 for invalid hardware ID, 80D0 if pulse generator with specified hardware ID is not activated)."}], "InOut": []}, "how_to_use": "Activate the specified pulse generator in the hardware configuration prior to using the instruction by enabling \"Activate this pulse generator\" under 'Pulse generators (PTO/PWM)' in device properties. The pulse generator parameters (except pulse duration) must be set in the device configuration and CPU must be in STOP mode for changes to take effect. The instruction enables the pulse generator when ENABLE input is TRUE and disables it when FALSE or when CPU goes to STOP. BUSY output is FALSE on S7-1200 CPUs. Use the output STATUS for monitoring execution and errors.", "example_code": "", "additional_info": "Digital inputs and outputs assigned for PWM/PTO cannot be forced via the force table. Do not use PWM/PTO outputs in the process image since the update rate of the process image is slower than the actual PWM signals, and will not reflect the real signal flow. Pulse duration and cycle time parameters can be changed at runtime by writing to the output byte addresses assigned to the pulse generator in the device configuration if enabled in pulse options.", "generated_brief": {"functional_summary": "The CTRL_PWM instruction enables or disables a hardware pulse-width modulation (PWM) output in the CPU based on a boolean enable input while providing status information.", "usage_context": "It is used in industrial automation to control PWM outputs for tasks such as motor speed control or other pulse-driven devices by activating configured hardware pulse generators at runtime."}, "generated_keywords": ["enable disable PWM output", "hardware pulse generator control", "PWM status monitoring", "industrial automation pulse control", "CPU pulse output management"]}
{"instruction_name": "FileReadC", "description": "The \"FileReadC\" instruction is used to read data from a file located on the memory card and write it to a destination area on the CPU. You specify the file by entering its name and complete path. Enable reading from the file using the REQ control parameter. The output parameters Done, Busy, Error and Status indicate the status of the job.", "parameters": {"Input": [{"name": "REQ", "type": "BOOL", "description": "Control parameter Request. Enables reading a file from the memory card with a rising edge."}, {"name": "Name", "type": "STRING", "description": "Name of the file to be read including complete path."}, {"name": "Offset", "type": "UDINT", "description": "Byte offset after which the file is to be read."}, {"name": "Length", "type": "UDINT", "description": "Length of the area to be read in bytes. Length = 0 means that the maximum possible number of data items per call is read (for a S7-1500-CPU, 32 KB or the size of theData\" parameter)."}], "Output": [{"name": "Done", "type": "BOOL", "description": "1: The instruction has been executed successfully. The information read has been transferred to the \"Data\" parameter."}, {"name": "Busy", "type": "BOOL", "description": "Status parameter. 0: Execution of the instruction completed or not yet started. 1: Execution of the instruction not yet complete."}, {"name": "Error", "type": "BOOL", "description": "Status parameter. 0: No error. 1: An error occurred during execution of the instruction. Detailed information is output via the \"Status\" parameter."}, {"name": "Status", "type": "WORD", "description": "Error code."}, {"name": "ResultLength", "type": "UDINT", "description": "Length of data read in bytes."}], "InOut": [{"name": "Data", "type": "VARIANT", "description": "Destination area for data read. Permitted data types: BYTE and Array of BYTE."}]}, "how_to_use": "Call the FileReadC instruction with a rising edge on REQ. Specify the file path and name in 'Name' parameter, set the 'Offset' and 'Length' to read the desired byte range. Manage calls multiple times if data to read exceeds device-specific segment size (e.g. 32 KB on S7-1500). Check 'Busy' while reading is ongoing and 'Done' when finished. Handle errors by checking 'Error' and 'Status'.", "example_code": "", "additional_info": "File path and name must follow specific rules: max 55 characters; permitted characters 0-9, a-z, A-Z, -, _; only one dot '.' allowed; path must not start with '/', '\\' or '.'; path must not contain '..'. Maximum read length is 16 MB. Reading happens asynchronously across multiple calls if needed. Only access the data after the last call completes. Detailed error codes provide guidance on faults such as invalid paths, data area issues, and access violations.", "generated_brief": {"functional_summary": "The FileReadC instruction reads data asynchronously from a specified file on the memory card into a designated CPU memory area, providing status feedback through control signals.", "usage_context": "It is typically used in industrial automation to retrieve file data stored on memory cards for processing or monitoring within a PLC program."}, "generated_keywords": ["asynchronous file read", "memory card file access", "PLC file data transfer", "read file with offset and length", "file read status monitoring"]}
{"instruction_name": "FileWriteC", "description": "The 'FileWriteC' instruction is used to write data located in a source area on the CPU to a file located in the 'UserFiles' folder on the memory card. You specify this file by entering its name and complete path. If the file does not exist, it is created by the CPU in the 'UserFiles' folder.", "parameters": {"Input": [{"name": "REQ", "type": "BOOL", "description": "Control parameter Request. Enables writing a file on the memory card with a rising edge."}, {"name": "Name", "type": "STRING", "description": "Name of the file to be written including the complete path."}, {"name": "Offset", "type": "UDINT", "description": "Byte offset from which the file is to be written."}, {"name": "Length", "type": "UDINT", "description": "Length of the area to be written in bytes. 'Length' = 0 means that the entire source area specified with the 'Data' parameter is written."}], "Output": [{"name": "Done", "type": "BOOL", "description": "1: The instruction has been executed successfully."}, {"name": "Busy", "type": "BOOL", "description": "Status parameter. 0: Execution of the instruction completed or not yet started. 1: Execution of the instruction not yet complete."}, {"name": "Error", "type": "BOOL", "description": "Status parameter. 0: No error. 1: An error occurred during execution of the instruction."}, {"name": "Status", "type": "WORD", "description": "Error code."}, {"name": "ResultLength", "type": "UDINT", "description": "Length of data written in bytes."}], "InOut": [{"name": "Data", "type": "VARIANT", "description": "Source area. Permitted data types: BYTE and Array of BYTE."}]}, "how_to_use": "Start processing with a rising edge at the parameter 'REQ'.", "example_code": "", "additional_info": "You can write up to 16 MB by executing 'FileWriteC'; the data is written segment by segment. Ensure 'Offset' + 'Length' <= 16 MB.", "generated_brief": {"functional_summary": "The FileWriteC instruction writes data from the CPU's memory to a specified file on the memory card, creating the file if it does not exist.", "usage_context": "It is typically used to save process data or logs to persistent storage in industrial automation systems for later retrieval or."}, "generated_keywords": ["file write", "memory card storage", "data logging", "persistent file creation", "CPU to file transfer"]}
{"instruction_name": "GEN_DIAG", "description": "The \"GEN_DIAG\" instruction generates diagnostics information for hardware components from other manufacturers for use in TIA Portal diagnostics. The GSD(GSDL/GSDML) file supplied by the manufacturer must first be installed before the instruction can be used. The instruction generates all diagnostic events (including those for maintenance).", "parameters": {"Input": [{"name": "LADDR", "type": "HW_ANY", "description": "Identification number of the hardware component."}, {"name": "MODE", "type": "UINT", "description": "Selection of incoming/outgoing information:\n1: The diagnostic event specified is an incoming event\n2: The diagnostic event specified is an outgoing event\n3: All diagnostic events are outgoing. There are therefore no hardware component faults (green diagnostics symbol). The DiagEvent parameter is not evaluated when MODE = 3."}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Status of instruction / error message."}], "InOut": [{"name": "DiagEvent", "type": "DiagnosticDetail", "description": "Specifies the diagnostic event. When a tag is defined at the DiagEvent parameter, the DiagnosticDetail structure is created automatically in the local interface of the block."}]}, "how_to_use": "Install the GSD(GSDL/GSDML) file supplied by the manufacturer before using GEN_DIAG. Use the LADDR parameter to specify the hardware component, the MODE parameter to specify the event direction, and the DiagEvent parameter to define the diagnostic event using the DiagnosticDetail structure. RET_VAL is used to check for errors. Diagnostics information is provided synchronously.", "example_code": "", "additional_info": "Failsafe-specific error messages are not valid and cause error code 80A1. The instruction checks for failsafe-specific diagnostics information and returns an error if found. Diagnostics information transfer and alarm output are asynchronous. RET_VAL error codes include: 0 (No error), 8080 (Unsupported MODE value), 8090 (Hardware component ID not available), 8091 (Diagnostics information cannot be generated), 80A (Invalid or inconsistent DiagEvent content or failsafe info), 80A4 (Hardware component cannot be accessed), 80C1 (Insufficient resources for parallel execution).", "generated_brief": {"functional_summary": "The GEN_DIAG instruction generates diagnostic information for third-party hardware components in TIA Portal using manufacturer-supplied GSD files, reporting all diagnostic events including maintenance alerts.", "usage_context": "It is used in industrial automation systems to monitor and diagnose hardware faults or status by specifying component IDs and event types synchronously within PLC programs."}, "generated_keywords": ["hardware diagnostics", "third-party component monitoring", "GSD file integration", "diagnostic event generation", "TIA Portal diagnostics"]}
{"instruction_name": "GET_DIAG", "description": "The \"GET_DIAG\" instruction is used to read the diagnostic information of a hardware component. The hardware component is selected with the parameter LADDR. With the MODE parameter, you select which diagnostic information is read. The S7-1200 CPU ignores the parameter LADDR when MODE=0.", "parameters": {"Input": [{"name": "MODE", "type": "UINT", "description": "Use the MODE parameter to select which diagnostics data is output."}, {"name": "LADDR", "type": "HW_ANY (UINT)", "description": "Hardware ID of the hardware component"}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Status of the instruction"}, {"name": "CNT_DIAG", "type": "UINT", "description": "Reserved (always \"0\")."}], "InOut": [{"name": "DIAG", "type": "VARIANT", "description": "Diagnostic information corresponds to the selected mode."}, {"name": "DETAIL", "type": "VARIANT", "description": "Parameter is hidden. Do not use this parameter!"}]}, "how_to_use": "Select the hardware component by providing its hardware ID via the LADDR parameter. Choose the diagnostic mode via the MODE parameter: 0 for supported diagnostic modes as DWORD (LADDR ignored in S7-1200), 1 for diagnostic status of the addressed hardware component returned in a DIS structure, 2 for diagnostics of subordinate components returned in a DNN structure. Provide variables of appropriate data types (DIS or DNN) for DIAG parameter depending on MODE. Check RET_VAL for the status of the instruction call.", "example_code": "VAR\n  myLADDR : HW_ANY := 52; // Hardware ID of CPUExecUnit\n  diagMODE : UINT := 1;\n  myDIAG : DIS;\n  returnValue : INT;\n  CountDiagDetails : UINT;\nEND_VAR\n\nGET_DIAG(MODE := diagMODE, LADDR := myLADDR, RET_VAL => returnValue, CNT_DIAG => CountDiagDetails, DIAG => myDIAG, DETAIL => );", "additional_info": "For MODE=0, CNT_DIAG is always 0 and LADDR is ignored on S7-1200 CPUs. DIS and DNN are system data types used for detailed diagnostics output in MODE 1 and MODE 2 respectively. RET_VAL error codes include 0 (no error), 8080 (unsupported MODE), 8081/8082 (type not supported for DIAG/DETAIL), 8090 (LADDR does not exist), and 80C1 (insufficient resources for parallel execution). When using DIS structure, bits in ComponentStateDetail indicate detailed status information. Example: To check a specific diagnostic bit, address it using ComponentStateDetail.%X3. In diagnostics of an IO device, reading mode 1 reads the device's self-diagnostics while mode 2 reads subordinate module diagnostics.", "generated_brief": {"functional_summary": "The GET_DIAG instruction reads diagnostic information from a specified hardware component using a selected mode to determine the type of diagnostic data retrieved.", "usage_context": "It is used in PLC programs to monitor and troubleshoot hardware components by accessing their diagnostic status and detailed error information during operation."}, "generated_keywords": ["read hardware diagnostics", "diagnostic mode selection", "hardware component status", "PLC diagnostic instruction", "GET_DIAG instruction"]}
{"instruction_name": "GET_DIAG", "description": "The \"GET_DIAG\" instruction is used to read the diagnostic information of a hardware component. The hardware component is selected with the parameter LADDR. With the MODE parameter, you select which diagnostic information is read. The S7-1200 CPU ignores the parameter LADDR when MODE=0.", "parameters": {"Input": [{"name": "MODE", "type": "UINT", "description": "Use the MODE parameter to select which diagnostics data is output. Can be I, Q, M, D, L or constant."}, {"name": "LADDR", "type": "HW_ANY (UINT)", "description": "Hardware ID of the hardware component. Can be I, Q, M, L or constant."}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Status of the instruction. Can be I, Q, M, D, L."}, {"name": "CNT_DIAG", "type": "UINT", "description": "Reserved (always \"0\"). Can be I, Q, M, D, L."}], "InOut": [{"name": "DIAG", "type": "VARIANT", "description": "Diagnostic information corresponds to the selected mode."}, {"name": "DETAIL", "type": "VARIANT", "description": "Parameter is hidden. Do not use this parameter!"}]}, "how_to_use": "Select the hardware component with LADDR and diagnostic mode with MODE. MODE=0 returns supported diagnostic info bits, MODE=1 returns diagnostic status of the addressed hardware component (structure DIS), MODE=2 returns status of subordinate components (structure DNN). Initialize DIAG variable with the corresponding structure type (DIS or DNN) based on MODE. Check RET_VAL for errors and CNT_DIAG indicates reserved output (always 0). The DETAIL parameter is hidden and should not be used.", "example_code": "VAR\n  myDIAG : DIS;\n  myLADDR : UINT := 52; // Hardware ID for CPUExecUnit\n  diagMODE : UINT := 1;\n  returnValue : INT;\n  CountDiagDetails : UINT;\nEND_VAR\n\nGET_DIAG(\n  MODE:= diagMODE,\n  LADDR:= myLADDR,\n  RET_VAL=> returnValue,\n  CNT_DIAG=> CountDiagDetails,\n  DIAG:= myDIAG\n);", "additional_info": "RET_VAL possible error codes include 0 (no error), 8080 (unsupported MODE), 8081 (DIAG parameter type not supported with MODE), 8082 (DETAIL parameter type not supported with MODE), 8090 (LADDR does not exist), 80C1 (insufficient resources for parallel execution). For standard CPUs, use LADDR = 52 for determining OperatingState with MODE=1. For R/H systems, use LADDR 65147 or 65347 for CPU redundant control and 34 for system state. The diagnostic data structures DIS and DNN must be predefined in your project when using MODE 1 and 2 respectively.", "generated_brief": {"functional_summary": "The GET_DIAG instruction reads diagnostic information from a specified hardware component based on the selected mode and hardware ID parameters.", "usage_context": "It is used in industrial PLC programs to monitor and retrieve status or diagnostic data from hardware components for troubleshooting and system health monitoring."}, "generated_keywords": ["read diagnostic information", "hardware component diagnostics", "diagnostic mode selection", "PLC hardware monitoring", "error status retrieval"]}
{"instruction_name": "IO2MOD", "description": "The \"IO2MOD\" instruction determines the hardware identifier of the module from an IO address (I, Q, PI, PQ) of a module.\nEnter the IO address at the ADDR parameter.\n- If a series of IO addresses is used at this parameter, only the first address is evaluated to determine the hardware identifier.\n- If the first address is correctly specified, the length for the address specification at the ADDR parameter is of no significance.\n- If an address area is used that encompasses several modules or unused addresses, the hardware identifier of the first module can also be determined.\n- If no IO address of a module is specified at parameter ADDR, the error code 8090 is output at parameter RET_VAL.", "parameters": {"Input": [{"name": "ADDR", "type": "VARIANT", "description": "IO address (I, Q, PI, PQ) within a module. Make sure that slice access is not used for the parameter ADDR. If this is the case, incorrect values are output at the LADDR parameter."}], "Output": [{"name": "LADDR", "type": "HW_IO", "description": "Determined hardware identifier (logical address) of the IO module."}], "InOut": []}, "how_to_use": "Provide the IO address at the ADDR parameter to determine the hardware identifier of the corresponding module. Ensure not to use slice access on ADDR to avoid incorrect results. The instruction evaluates only the first IO address if multiple addresses are provided. Check the RET_VAL output parameter to verify successful execution or error conditions.", "example_code": "VAR\n    SLI_IOtest : VARIANT;\n    ioLaddr : HW_IO;\n    returnValue : INT;\n    execute : BOOL;\nEND_VAR\n\nIF execute THEN\n    IO2MOD(ADDR := SLI_IOtest, LADDR => ioLaddr, RET_VAL => returnValue);\nEND_IF;", "additional_info": "Error codes returned in RET_VAL include 0 (no error), 8090 (IO address at ADDR not used by any hardware component), and 8092 (invalid data type used at ADDR). In SCL programming, use symbolic tag names or absolute addresses in the process image instead of direct I/O access IDs like \"%QWx:P\".", "generated_brief": {"functional_summary": "The IO2MOD instruction determines the hardware identifier (logical address) of an IO module based on a provided IO address within that module.", "usage_context": "This function is typically used in PLC programs to map IO addresses to their corresponding physical modules for hardware identification and diagnostics."}, "generated_keywords": ["hardware identifier", "IO address mapping", "module identification", "PLC IO module", "logical address determination"]}
{"instruction_name": "JOIN", "description": "The \"JOIN\" instruction connects multiple strings into an array. It converts multiple strings into a single one using different formats (CSV or FSR) and delimiters for individual strings and the end of the concatenated string.", "parameters": {"Input": [{"name": "Mode", "type": "DWORD", "description": "Specifies how the merger to string is performed, including format selection (CSV or FSR) and whether an additional delimiter character is added at the end."}, {"name": "RecSeparator", "type": "VARIANT", "description": "Delimiter character for the source strings. In CSV format, used as delimiter between strings; in FSR format, used as fill character."}, {"name": "EndSeparator", "type": "VARIANT", "description": "Delimiter character to be written at the end of the characters if bit 3 = 1 is set in Mode parameter."}, {"name": "SrcStruct", "type": "VARIANT", "description": "Pointer to the source strings. Can be Array of STRING, Array of WSTRING or structures containing exclusively STRING or WSTRING data types."}, {"name": "Count", "type": "UDINT", "description": "Number of source strings to join. Only applies if SrcStruct is Array of (W)STRING. Ignored otherwise."}], "Output": [{"name": "Ret_Val", "type": "INT", "description": "Status of the instruction execution with error codes indicating success or specific errors."}], "InOut": [{"name": "DestArray", "type": "VARIANT", "description": "Array of CHAR or WCHAR where the joined string is written. Length should be set based on the source strings' length."}, {"name": "Position", "type": "UDINT", "description": "Index position in DestArray where the conversion writing starts and completes, enabling filling of the array in parts."}]}, "how_to_use": "Set the Mode parameter to choose CSV or FSR format and whether to add an additional delimiter at the end. Specify source strings in SrcStruct as an array or structure of strings. Use Count to limit number of strings if applicable. Choose appropriate delimiter characters for RecSeparator and EndSeparator, ensuring they do not conflict. Provide a DestArray that is sized to hold the result. Position specifies the index within DestArray where writing begins. Monitor Ret_Val for execution status and error handling.", "example_code": "", "additional_info": "Mode parameter bits: Bit 0 selects CSV (0) or FSR (1) format; Bit 3 selects whether to write an end delimiter. Error codes in Ret_Val specify issues like unsupported Mode, invalid source strings, buffer overflow, or mismatching data types. When using FSR format, if source string is longer than reserved space, it is truncated; if shorter, space filled with fill character. Use delimiters carefully to avoid conflicts especially if reversing the conversion with SPLIT instruction.", "generated_brief": {"functional_summary": "The JOIN instruction concatenates multiple strings into a single string array using specified formats (CSV or FSR) and delimiters, allowing controlled string merging with optional end delimiters.", "usage_context": "This function is typically used in PLC programs to combine multiple string variables into one formatted string for data logging, communication, or further processing in industrial automation systems."}, "generated_keywords": ["string concatenation", "string array join", "CSV FSR formatting", "delimiter specification", "PLC string merging"]}
{"instruction_name": "PE_WOL", "description": "The \"PE_WOL\" instruction sends the PROFIenergy commands \"Start_Pause\" and \"End_Pause\" to multiple PROFIenergy-enabled devices in the PROFINET I/O systems. Multiple PE devices can be coordinated via the instruction provided that the PE devices support the \"Wake on LAN\" function over a UDP connection. The \"PE_WOL\" instruction can only be executed on a CPU with an integrated Ethernet interface. This CPU should be able to load blocks with a size of approx. 400 KB. If this CPU is connected via an Ethernet CP, it is not possible to use the block with PROFINET I/O systems. The instruction \"PE_WOL\" is executed asynchronously. The \"PE_WOL\" instruction only supports devices with a device number lower than 256. Devices with a higher device number are not taken into account.", "parameters": {"Input": [{"name": "COM_RST", "type": "BOOL", "description": "Resets the block and performs a re-initialization. As long as True is set here, the initialization is started but not yet fully completed. Only the falling edge continues the initialization and switches to the normal operating mode after initialization."}, {"name": "START", "type": "BOOL", "description": "A rising edge performs a \"CmdStartPause\" PROFIenergy command for all detected devices that support this function."}, {"name": "", "type": "BOOL", "description": "A rising edge performs a \"CmdEndPause\" PROFIenergy command for all detected devices that support this function."}], "Output": [{"name": "STATUS", "type": "DWORD", "description": "Status/error number for the current status of the instruction (see \"STATUS parameter\")."}], "InOut": [{"name": "PENERGY", "type": "PE_PLUS", "description": "Pointer to the user DB that contains the database for processing multiple devices."}]}, "how_to_use": "Initialize the \"PE_WOL\" instruction by setting the COM_RST input to true and then to false to start initialization. Use the START and END input bits with rising edges to send the PROFIenergy commands \"CmdStartPause\" and \"CmdEndPause\" respectively to all recognized PROFIenergy-capable devices in the PROFINET I/O system. The data block referenced by PENERGY must be properly initialized with device and connection data before operation. The instruction processes commands asynchronously, allowing multiple devices to be managed. Only one command is executed at a time based on priority: CmdStartPause highest, CmdEndPause second, CmdUpdateStatus lowest. At least one CPU cycle with the Update bit cleared must occur between command updates to ensure proper edge detection.", "example_code": "", "additional_info": "The instruction requires a CPU with an integrated Ethernet interface capable of loading approx. 400 KB blocks; cannot be used via an Ethernet CP PROFINET I/O. Only devices with device numbers <256 are supported. The user data block (PENERGY, type PE_PLUS) must contain at minimum the PROFINET I/O system ID, Wake on LAN connection data and port, plus device-specific parameters such as PauseTime and EnableSleep. The instruction operates asynchronously. Multiple commands queued are processed in order regardless of success or error states. The status output parameter reports error and current status codes.", "generated_brief": {"functional_summary": "The PE_WOL instruction asynchronously sends PROFIenergy Start_Pause and End_Pause commands via Wake on LAN to multiple PROFIenergy-enabled devices within a PROFINET I/O system using a CPU with an integrated Ethernet interface.", "usage_context": "It is used to coordinate energy management commands among PROFIenergy-capable devices in industrial automation systems to control device power states during operation pauses."}, "generated_keywords": ["PROFIenergy commands", "Wake on LAN", "PROFINET I/O system", "energy management", "asynchronous device control"]}
{"instruction_name": "RD_ADDR", "description": "The \"RD_ADDR\" instruction determines the length and the start address of the inputs or outputs based on the hardware identifier of a sub(module). Use the LADDR parameter to select the input or output module based on the hardware identifier. In the case of an input module the determined values are output at the PIADDR and PIC parameters. In the case of an output module the determined values are output at the PQADDR and PQCOUNT parameters. The PIADDR and PQADDR parameters each contain the start address of the I/O addresses of the module. The PICOUNT and PQCOUNT parameters each contain the number of bytes of the inputs or outputs (1 byte for 8 inputs/outputs, 2 bytes for 16 inputs/outputs).", "parameters": {"Input": [{"name": "LADDR", "type": "HW_IO", "description": "Hardware identifier of the (sub)module."}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Error code of the instruction."}, {"name": "PIADDR", "type": "UDINT", "description": "Start address of the input module."}, {"name": "PICOUNT", "type": "UINT", "description": "Number of bytes of the inputs."}, {"name": "PQADDR", "type": "UDINT", "description": "Start address of the output module."}, {"name": "PQCOUNT", "type": "UINT", "description": "Number of bytes of the outputs."}], "InOut": []}, "how_to_use": "Provide the hardware identifier of the input or output module in the LADDR parameter. When the instruction executes, it determines the start address and the byte length of the input or output module. For input modules, use PIADDR and PICOUNT the start address and length. For output modules, use PQADDR and PQCOUNT. Check the RET_VAL parameter for error codes to ensure the module was identified correctly.", "example_code": "VAR\n    readLaddr : HW_IO;\n    readRetVal : INT;\n    piAddr : UDINT;\n    piCount : UINT;\n    executeRead : BOOL;\nEND_VAR\n\nIF executeRead THEN\n    RD_ADDR(\n        LADDR:=readLaddr,\n        RET_VAL=>readRetVal,\n        PIADDR=>piAddr,\n        PICOUNT=>piCount,\n        PQADDR=>,\n        PQCOUNT=>\n    );\nEND_IF;", "additional_info": "When using packed addresses of an ET200, the first module of the pack group returns all addresses. For other modules, PIADDR and PQADDR may return zero for PROFINET and PROFIBUS (with an additional error code W#16#8090). PICOUNT and PQCOUNT return 0 for these modules. The RET_VAL parameter returns error codes such as 0 for no error and 8090 if the hardware identifier is invalid.", "generated_brief": {"functional_summary": "The RD_ADDR instruction retrieves the start address and byte length of input or output modules based on their hardware identifier.", "usage_context": "It is used in PLC programs to dynamically identify and access the I/O addresses and sizes of connected modules for communication and control purposes."}, "generated_keywords": ["read module address", "input output length", "hardware identifier", "IO address retrieval", "PLC IO configuration"]}
{"instruction_name": "RH_GetPrimaryID", "description": "The \"RH_GetPrimaryID\" instruction is used to determine the redundancy ID of the primary CPU. You can use this instruction in all system states even if the pairing of the two R or H CPUs has not yet been performed.", "parameters": {"Input": [], "Output": [{"name": "Ret_Val", "type": "INT", "description": "Return value containing the redundancy ID of the primary CPU or error code."}], "InOut": []}, "how_to_use": "Use the instruction to retrieve the redundancy ID of the primary CPU in a redundant setup. It can be used at any system state, even before pairing of redundant CPUs. Check the Ret_Val output to determine the primary CPU or to detect errors.", "example_code": "", "additional_info": "The Ret_Val can have values such as 1 or 2 indicating the primary CPU ID, or error codes like 8091 if the CPU does not support this instruction. Error codes are displayed as integer or hexadecimal in the program editor; you can switch display formats via program status settings.", "generated_brief": {"functional_summary": "The RH_GetPrimaryID instruction retrieves the redundancy ID of the primary CPU in a redundant control system.", "usage_context": "It is used in all system states to identify the primary CPU before or after pairing in redundant CPU configurations and to detect related errors."}, "generated_keywords": ["redundancy ID retrieval", "primary CPU identification", "redundant CPU system", "error code detection", "system state independent"]}
{"instruction_name": "Random", "description": "The 'Random' instruction is used to generate a 32-bit random number.", "parameters": {"Input": [], "Output": [{"name": "Ret_Val", "type": "UDINT", "description": "32-bit random number"}], "InOut": []}, "how_to_use": "", "example_code": "", "additional_info": "The 'Random' instruction does not provide any error information.", "generated_brief": {"functional_summary": "The 'Random' instruction generates a 32-bit unsigned random number output.", "usage_context": "It is typically used in PLC programs when a random value is needed for processes such as testing, simulations, or creating variability in control logic."}, "generated_keywords": ["generate random number", "32-bit random value", "unsigned integer output", "random generation", "PLC random instruction"]}
{"instruction_name": "RecipeExport", "description": "The \"RecipeExport\" instruction exports the recipe data from a data block to a CSV file in the load memory.\nWith S7-1500 CPUs, the DB that is to be exported can be located either in the work memory or in the load memory. If the data block is in both the work memory and the load memory, the values from the work memory are exported. For S7-1200 CPUs, the DB to be exported must be present in the load memory.\nThe CSV file is created in the load memory. For S7-1500 CPUs, this is the memory card; for S7-1200 CPUs the internal or external load memory (if a memory card is present).\nDuring the export, the CSV file is created in the \"Recipes\" folder in the main directory of the load memory. The name of the data block is used as file name of the created CSV file. If a CSV file with an identical name already exists, it is overwritten during the export.\nEach recipe data record generates a line in the CSV file. These lines have the following structure:\n- The first line contains the \"Index\" entry and the name of the recipe components.\n- Each additional line contains the number of the recipe data record (index) and the associated components.\nThe maximum size of a data record is 5000 bytes; if exceeded, error code W#16#8092 is returned. The same 5000 byte restriction applies to the size of the header. If the header size exceeds 5000 bytes, S7-1500 CPUs export it up to 5000 bytes and continue with the first recipe data record. S7-1200 CPUs reject the export entirely with error W#16#8092.\nS7-1200 CPUs also the number of columns to 255 (excluding the index column).\nIf the recipe DB with standard access has too many components (e.g. two ARRAYs and one structure), only the first ARRAY is exported and STATUS is set to W#16#0000.", "parameters": {"Input": [{"name": "REQ", "type": "BOOL", "description": "Control parameter REQUEST: Activates the export on a rising edge."}], "Output": [{"name": "DONE", "type": "BOOL", "description": "Status parameter: 0 = Job not yet started or still executing; 1 = Job executed without errors."}, {"name": "BUSY", "type": "BOOL", "description": "Status parameter: 0 = Instruction not executed; 1 = Instruction executed."}, {"name": "ERROR", "type": "BOOL", "description": "Status parameter: 0 = Neither warning nor error; 1 = An error has occurred, STATUS supplies detailed information."}, {"name": "STATUS", "type": "WORD", "description": "Status parameter providing detailed status and error codes."}], "InOut": [{"name": "RECIPE_DB", "type": "VARIANT", "description": "Pointer to the recipe data block located in data memory. The data block structure must follow recipe DB requirements."}]}, "how_to_use": "Trigger the export by setting REQ to TRUE with a rising edge. BUSY is set during export. When done, DONE is set to TRUE and BUSY resets to FALSE. Monitor ERROR and STATUS for error conditions. The CSV file is saved in the 'Recipes' folder in the load memory. Ensure the recipe DB complies with size and structure limitations, especially for S7-1200 CPUs. If the data record or header exceeds 5000 bytes, the export may fail or be partial depending on CPU type.", "example_code": "", "additional_info": "Error codes include:\n- 0: No error\n- 7000: No job processing active\n- 7001: Job started (BUSY=1, DONE=0)\n- 7002: Instruction already active\n- 8090: Invalid characters in CSV file name\n- 8091: Nested structure or column count >255 on S7-1200\n- 8092: Data structure too large\n- 80B3: Insufficient memory\n- 80B4: Memory card write-protected\n- 80B6: Recipe DB not activated (S7-1200 specific)\n- 80C0: CSV file locked temporarily\n- 80C1: Recipe DB temporarily disabled\n- 80C3: Too few resources\n- 8624: RECIPE_DB points to impermissible area\n- 8652: Insufficient tag at RECIPE_DB\nFurthermore, if a CSV file with the same name exists, it will be overwritten. The instruction handles export asynchronously and must not be retriggered while BUSY is set.", "generated_brief": {"functional_summary": "The RecipeExport instruction exports recipe data from a data block to a CSV file stored in the load memory, allowing structured recipe data to be saved externally for further use or backup.", "usage_context": "It is typically used in industrial automation systems to export and backup recipe configurations from PLCs, particularly in S7-1200 and S7-1500 CPUs, ensuring recipe data can be transferred or archived reliably."}, "generated_keywords": ["recipe export", "CSV file generation", "data block export", "load memory storage", "PLC recipe backup"]}
{"instruction_name": "RecipeImport", "description": "The \"RecipeImport\" instruction imports the recipe data from a CSV file of the load memory into the data block at the RECIPE_DB parameter. For S7-1500 CPUs, the CSV file is on the memory card; for S7-1200 CPUs, it is in the internal or external load memory (if a memory card is present). The values in the data block are overwritten in the process. With S7-1500 CPUs, the DB to which the recipe data is to be imported can be located either in the work memory or in the load memory. If it is in both the work memory and the load memory, the values are imported to the data block located in the work memory. For S7-1200 CPUs, the DB into which the recipe data is to be imported must be located in the load memory. The recipe is only maintained permanently if it is imported to a load memory DB. If it is imported to a work memory DB but you need it permanently, you must transfer the recipe to a load memory DB after the import with the help of the WRIT_DBL instruction. Note the following when importing the CSV file: The CSV file must be located in the \"Recipes\" directory of the load memory; the name of the CSV file must match the name of the data block at the RECIPE_DB parameter; each line of the CSV file corresponds to one recipe data record with the first line as a header which is ignored during import; the first value in each line is the index number of the recipe, which must be in ascending order without gaps; the CSV file must not contain more recipe data records than provided for in the data block; if a value does not fit the associated data type, the import is rejected (strings truncated if too long, BOOL type accepted differently on S7-1500 and S7-1200); DATE_AND_TIME values outside permissible range default to default value; if the recipe DB is a DB with standard access and more components than permitted, data is only imported into the first ARRAY and STATUS set to W#16#0000.", "parameters": {"Input": [{"name": "REQ", "type": "BOOL", "description": "Control parameter REQUEST: Activates the import on a positive edge."}], "Output": [{"name": "DONE", "type": "BOOL", "description": "Status parameter. 0: Job not yet started or still executing. 1: Job executed without errors."}, {"name": "BUSY", "type": "BOOL", "description": "Status parameter. 0: The instruction is not executed. 1: The instruction is executed."}, {"name": "ERROR", "type": "BOOL", "description": "Status parameter. 0: Neither warning nor error. 1: An error has occurred, STATUS supplies detailed information on the type of error."}, {"name": "STATUS", "type": "WORD", "description": "Status parameter. Provides detailed error codes."}], "InOut": [{"name": "RECIPE_DB", "type": "VARIANT", "description": "Pointer to the recipe data block. For information on the structure of the data block, refer to the Structure of a recipe DB."}]}, "how_to_use": "Activate the import process by setting REQ parameter to TRUE on a positive edge. Monitor the BUSY parameter to know when the import is in progress (BUSY=1) and when it completes (BUSY=0 and DONE=1 In case of errors during import, ERROR is set and STATUS contains a detailed error code. Ensure the CSV file is correctly named and placed in the 'Recipes' directory of the load memory. After import to a work memory DB, use WRIT_DBL to persist the recipe data to load memory if permanent maintenance is required.", "example_code": "", "additional_info": "Status error codes provide detailed diagnostic information, e.g., 8090 for invalid characters in the filename, 80B0 for non-continuous or invalid indexing in the CSV, 8092 for no matching CSV file, among others. The CSV file's first line is a header and ignored during import. Indexes in the CSV must be continuous and ascending without gaps. Data type mismatches or data exceeding limits will cause import failure or warnings. The recipe DB must be correctly structured to match the CSV content.", "generated_brief": {"functional_summary": "The RecipeImport instruction imports recipe data from a CSV file stored in the load memory into a specified recipe data block in the PLC, overwriting its current values.", "usage_context": "It is typically used in industrial automation to load predefined process parameters or configurations from external files into the PLC for production or process control purposes."}, "generated_keywords": ["Recipe import", "CSV file load", "Data block update", "Load memory access", "PLC recipe management"]}
{"instruction_name": "SPLIT", "description": "The \"SPLIT\" instruction converts an array (Array of CHAR / WCHAR) into several separate strings (Array of STRING / WSTRING or structure).", "parameters": {"Input": [{"name": "Mode", "type": "DWord", "description": "Specifies how the split into multiple strings is performed. The first bit selects CSV or FSR format, other bits specify behavior for additional characters, counting EndSeparator, and handling unwritten strings."}, {"name": "RecSeparator", "type": "Variant", "description": "Delimiter or fill character. With CSV: character used to separate individual strings. With FSR: fill character used in the array."}, {"name": "EndSeparator", "type": "Variant", "description": "Delimiter used to define the end of the total string in the array to be read. Reading stops at this delimiter with higher priority than RecSeparator."}, {"name": "SrcArray", "type": "Variant", "description": "Pointer to the array to be read (Array of CHAR/WCHAR)."}], "Output": [{"name": "Count", "type": "UDInt", "description": "Number of strings that were found. Only valid if DestStruct is an Array of STRING; otherwise, 0 is output."}, {"name": "Ret_Val", "type": "Int", "description": "Result of instruction execution / error code."}], "InOut": [{"name": "DestStruct", "type": "Variant", "description": "Structure which includes the converted strings (Array of STRING / WSTRING)."}, {"name": "Position", "type": "UDInt", "description": "Position from which the array is to be read at the SrcArray parameter and updated to indicate where conversion completed."}]}, "how_to_use": "Specify the source array in SrcArray, select the format with the Mode parameter (bit 0: CSV or FSR), define the delimiters with RecSeparator and EndSeparator and specify the destination strings structure in DestStruct. Use Position for tracking reading progress for subsequent calls. The instruction splits the source array into separate strings based on the selected format and delimiters. Pay attention to matching data types across SrcArray, delimiters, and DestStruct. The Ret_Val parameter indicates success or various error codes.", "example_code": "(* Example of SPLIT with CSV format and Mode=2#10 *)\nVAR\n  SrcArray : ARRAY[1..50] OF CHAR := '1963,Miller,John,Roadname';\n  DestArray : ARRAY[1..4] OF STRING[14];\n  Mode : DWORD := 2#10; (* CSV format, ignore extra characters *)\n  RecSeparator : CHAR := ',';\n  EndSeparator : CHAR := '#';\n  Position : UDINT := 0;\n  Count : UDINT;\n  Ret_Val : INT;\nEND_VAR\n\nRet_Val := SPLIT(\n  Mode := Mode,\n  RecSeparator := RecSeparator,\n  EndSeparator := EndSeparator,\n  SrcArray := SrcArray,\n  DestStruct := DestArray,\n  Position := Position,\n  Count => Count\n);", "additional_info": "The data types of SrcArray (CHAR or WCHAR), RecSeparator, EndSeparator, and DestStruct (STRING or WSTRING) must be compatible to avoid error code 80B4. The Mode parameter bits control: bit 0 for CSV/FSR, bit 1 for handling additional characters, bit 3 for counting EndSeparator in Position, and bit 4 for setting unused strings length to 0. Error codes provide details on issues like missing separators, invalid data types, or out-of-range positions.", "generated_brief": {"functional_summary": "The SPLIT instruction parses an array of CHAR or WCHAR characters into multiple separate strings based on specified delimiters and formats.", "usage_context": "It is typically used in PLC programs to extract individual strings from a combined character array, such as CSV data, for further processing or control logic."}, "generated_keywords": ["array split", "string parsing", "delimiter-based extraction", "CSV and FSR format", "character array to strings"]}
{"instruction_name": "STRG_VAL", "description": "The 'STRG_VAL' instruction converts a character string to an integer or a floating-point number.", "parameters": {"Input": [{"name": "IN", "type": "STRING, WSTRING", "description": "Number string to be converted. Must contain permitted characters."}, {"name": "FORMAT", "type": "WORD", "description": "Input format of the characters. Defines how the characters of the string are interpreted."}, {"name": "P", "type": "UINT", "description": "Reference to the first character to be converted. The first character = 1."}], "Output": [{"name": "OUT", "type": "USINT, SINT, UINT, INT, UDINT, DINT, REAL, LREAL", "description": "Result of the conversion."}], "InOut": []}, "how_to_use": "Specify the character string to convert in the IN parameter, select the desired output data type in the OUT parameter, and reference the starting character in the P parameter.", "example_code": "string inputSTRING := '123.45';\nREAL outputVAL;\nVAR\n   FORMAT : WORD := W#16#0000; // Decimal fraction\n   P : UINT := 1; // Start at first character\nEND_VAR\nSTRG_VAL(IN := inputSTRING, FORMAT := FORMAT, P := P, OUT := outputVAL);", "additional_info": "Permitted characters for the conversion are digits '0' to '9', the decimal point/comma, notations 'E' and 'e', and plus/minus characters. Conversion is canceled if an invalid character is found.", "generated_brief": {"functional_summary": "The STRG_VAL instruction converts a character string representing a number into an integer or floating-point numeric value.", "usage_context": " is used in PLC programs when numeric data is received or stored as strings and must be converted for arithmetic processing or control logic."}, "generated_keywords": ["string to number conversion", "character string parsing", "numeric string conversion", "integer and floating-point conversion", "PLC string to numeric"]}
{"instruction_name": "SYNC_PI", "description": "The 'SYNC_PI' is used to update the process image partition of inputs in isochronous mode. A user program linked to a DP cycle or PN send cycle uses this instruction to update input data acquired in a process image partition of the inputs isochronously and consistently.", "parameters": {"Input": [{"name": "PART", "type": "PIP", "description": "Number of the process image partition of the inputs to be updated isochronously."}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Error information."}, {"name": "FLADDR", "type": "WORD", "description": "Address of the first byte to cause an error if an access error has occurred."}], "InOut": []}, "how_to_use": "Call the 'SYNC_PI' instruction within OBs 61, 62, 63, or 64 while ensuring the affected process image partition is assigned to the OB in the hardware configuration.", "example_code": "", "additional_info": "The 'SYNC_PI' instruction is interruptible and must not be used simultaneously with the 'UPDAT_PI' instruction for the same process image partition.", "generated_brief": {"functional_summary": "The 'SYNC_PI' instruction updates a specified process image partition of input data isochronously and consistently within a user program.", "usage_context": "It is used within OBs 61 to 64 during DP or PN communication cycles to ensure synchronized input data updates assigned to the hardware configuration."}, "generated_keywords": ["process image partition update", "isochronous input synchronization", "DP PN cycle input update", "OB 61 to 64 usage", "input error detection"]}
{"instruction_name": "VAL_STRG", "description": "The 'VAL_STRG' instruction is used to convert a numerical value into a character string.", "parameters": {"Input": [{"name": "IN", "type": "USINT, SINT, UINT, INT, UDINT, DINT, REAL, LREAL", "description": "Value to be converted."}, {"name": "SIZE", "type": "USINT", "description": "Number of character positions."}, {"name": "PREC", "type": "USINT", "description": "Number of decimal places."}, {"name": "FORMAT", "type": "WORD", "description": "Output format of the characters."}], "Output": [{"name": "OUT", "type": "STRING, WSTRING", "description": "Result of the conversion."}], "InOut": [{"name": "P", "type": "UINT", "description": "Character starting at which the result is written."}]}, "how_to_use": "Specify the numerical value in the IN parameter and configure the sizes and formats as needed. Ensure that all parameters are set correctly to avoid conversion errors.", "example_code": "", "additional_info": "The values in the FORMAT parameter are only relevant if the IN parameter has data type REAL or LREAL. If SIZE is set to 0, all necessary characters are written starting from position P.", "generated_brief": {"functional_summary": "The VAL_STRG instruction converts various numerical data types into a formatted character string output.", "usage_context": "It is typically used in PLC programs when displaying or logging numerical values as readable text with specific formatting requirements."}, "generated_keywords": ["numeric to string conversion", "formatted string output", "data type conversion", "decimal precision formatting", "character string generation"]}
{"instruction_name": "PE_Get_Mode_RSP", "description": "The auxiliary block \"PE_Get_Mode_RSP\" generates the response to the command Get_Mode. The response frame contains the time, performance, or energy data of an energy-saving mode.", "parameters": {"Input": [{"name": "PE_I_DEV_NEW", "type": "BOOL", "description": "The parameter must be interconnected with the NEW output parameter of the \"PE_I_DEV\" instruction. The auxiliary block is processed if the parameter value is set to \"1\"."}, {"name": "CMD", "type": "INT", "description": "Service-Request-ID of the PROFIenergy command. The parameter must be interconnected with the CMD output parameter of the \"PE_I_DEV\" instruction."}, {"name": "CMD_MODIFIER", "type": "INT", "description": "PROFIenergy sub-command (evaluated only if CMD=3, or CMD=16). The parameter must be interconnected with the CMD_MODIFIER output parameter of the \"PE_I_DEV\" instruction."}, {"name": "PE_Mode_ID", "type": "BYTE", "description": "ID of the energy-saving mode currently enabled."}, {"name": "PE_Mode_Attributes", "type": "BYTE", "description": "Additional information regarding energy saving mode"}, {"name": "Time_min_Pause", "type": "DWORD", "description": "Minimum pause duration for this PE energy-saving mode. This is the sum of the following three parameters: Time_to_Pause, Time_to_operate, Time_min_length_of_stay."}, {"name": "Time_to_Pause", "type": "DWORD", "description": "Time between the edge at the START parameter (see \"PE_I_DEV\") and the requested PE energy-saving mode being reached."}, {"name": "Time_to_Operate", "type": "DWORD", "description": "Maximum switch-on time to \"PE_ready_to_operate\". The \"Time_to_operate\" parameter can be used directly for the relevant calculations. The value may be a static maximum, or be calculated dynamically by the PE entity."}, {"name": "Time_min_Lenght_of_stay", "type": "DWORD", "description": "Minimum dwell time of the PE entity in this PE mode."}, {"name": "Time_max_Lenght_of_stay", "type": "DWORD", "description": "Maximum dwell time of the PE entity in this PE mode."}, {"name": "Mode_Power_Consumption", "type": "DWORD", "description": "Energy consumption in the current PE mode in [kW]."}, {"name": "Energy_Consum_to_Pause", "type": "DWORD", "description": "Energy consumption from \"PE_ready_to_operate\" to the current PE mode in [kWh]."}, {"name": "Energy_Consum_to_operate", "type": "DWORD", "description": "Energy consumption from the current PE mode to \"PE_ready_to_operate\" in [kWh]."}], "Output": [{"name": "ERROR", "type": "BOOL", "description": "\"0\": No error; \"1\": Error occurred."}, {"name": "STATUS", "type": "WORD", "description": "\"0\": No error; \"0x80B1\": Error in VARIANT setting, e.g. incorrect range"}], "InOut": [{"name": "ACTIVATE", "type": "BOOL", "description": "The instruction copies the input parameters to the DATA_ERROR_RSP data area at a rising edge at input ACTIVATE. The parameter is then reset by the instruction. The parameter must be set within 10 seconds after a rising edge is detected at parameter NEW of the \"PE_I_DEV\" instruction."}, {"name": "VALID", "type": "BOOL", "description": "The parameter must be interconnected with the VALID input of the \"PE_I_DEV\" instruction. The auxiliary block sets the parameter once the response data for the PROFIenergy controller is available and ready for transmission."}, {"name": "DATA_ERRORRSP", "type": "VARIANT", "description": "Pointer on the data area in which the response data is stored. The parameter is identical to the pointer for DATA_ERRORRSP of the \"PE_I_DEV\" instruction. The addressed data area contains the complete PROFIenergy frame. Minimum length: 244 bytes"}]}, "how_to_use": "Use the PE_Get_Mode_RSP auxiliary block to generate the response frame for the Get_Mode command. Connect input parameters such as PE_I_DEV_NEW, CMD, CMD_MODIFIER, and others as specified. Set the ACTIVATE parameter on a rising edge to copy input parameters to the data area. Ensure ACTIVATE is set within 10 seconds after NEW of PE_I_DEV is detected. Monitor VALID to know when response data is ready and check ERROR and STATUS outputs for error handling.", "example_code": "", "additional_info": "All parameters must be mapped to the specified memory areas (I, Q, M, D, L, or constant) as permitted. The DATA_ERRORRSP data area pointed to by DATA_ERRORRSP must have a minimum length of 244 bytes. Pay attention to the timing requirement for ACTIVATE parameter setting to ensure proper processing.", "generated_brief": {"functional_summary": "The PE_Get_Mode_RSP instruction generates a response frame containing time, performance, and energy data for the current energy-saving mode upon receiving a Get_Mode command.", "usage_context": "This function is used within PROFIenergy-enabled systems to provide detailed status and energy consumption information in response to a Get_Mode request, ensuring timely and accurate communication with the energy-saving controller."}, "generated_keywords": ["PROFIenergy response", "Get_Mode command", "energy-saving mode data", "response frame generation", "energy consumption reporting"]}
{"instruction_name": "PE_Identify_RSP", "description": "The auxiliary block \"PE_Identify_RSP\" generates the response to the command PE_Identify. In the response to the command, specify which PROFIenergy commands are supported. Please note that PE_IDENTIFY is itself a PE command and has to be included in the response.", "parameters": {"Input": [{"name": "PE_I_DEV_NEW", "type": "BOOL", "description": "The parameter must be interconnected with the NEW output parameter of the \"PE_I_DEV\" instruction. The auxiliary block is processed if the parameter value is set to \"1\"."}, {"name": "CMD", "type": "INT", "description": "Service-Request-ID of the PROFIenergy command. The parameter must be interconnected with the CMD output parameter of the \"PE_I_DEV\" instruction."}, {"name": "Start_Pause", "type": "BOOL", "description": "One parameter for each of the relevant PROFIenergy commands: 0: PE command is not supported; 1: PE command is supported"}, {"name": "End_Pause", "type": "BOOL", "description": ""}, {"name": "Query_Modes", "type": "BOOL", "description": ""}, {"name": "PEM_Status", "type": "BOOL", "description": ""}, {"name": "PE_Identify", "type": "BOOL", "description": ""}, {"name": "Query_Measurement", "type": "BOOL", "description": ""}], "Output": [{"name": "ERROR", "type": "BOOL", "description": "\"0\": No error; \"1\": Error occurred."}, {"name": "STATUS", "type": "WORD", "description": "\"0\": No error; \"0x80B1\": Error in VARIANT setting, e.g. incorrect range"}], "InOut": [{"name": "ACTIVATE", "type": "BOOL", "description": "The instruction copies the input parameters to the DATA_ERROR_RSP data area at a rising edge at input ACTIVATE. The parameter is then reset by the instruction. The parameter must be set within 10 seconds after a rising edge is detected at parameter NEW of the \"PE_I_DEV\" instruction."}, {"name": "VALID", "type": "BOOL", "description": "The parameter must be interconnected with the VALID input of the \"PE_I_DEV\" instruction. The auxiliary block sets the parameter once the response data for the PROFIenergy controller is available and ready for transmission."}, {"name": "DATA_ERRORRSP", "type": "VARIANT", "description": "Pointer on the data area in which the response data is stored. The parameter is identical to the pointer for DATA_ERRORRSP of the \"PE_I_DEV\" instruction. The addressed data area contains the complete PROFIenergy frame. Minimum length: 244 bytes"}]}, "how_to_use": "Connect the inputs to the outputs of the PE_I_DEV instruction as specified. The auxiliary block processes the inputs when PE_I_DEV_NEW is set to true (1). Activate the response by setting ACTIVATE high within 10 seconds after the NEW signal is detected at PE_I_DEV. Monitor VALID to confirm that the response is ready and check and STATUS outputs for error handling.", "example_code": "", "additional_info": "Data types must be valid and compatible. The DATA_ERRORRSP area must have a minimum length of 244 bytes to store the PROFIenergy frame. PE_IDENTIFY command must always be included in the response.", "generated_brief": {"functional_summary": "The PE_Identify_RSP instruction generates and prepares the response data indicating which PROFIenergy commands, including PE_IDENTIFY, are supported in reply to the PE_Identify command.", "usage_context": "It is typically used within PROFIenergy-enabled automation systems to respond to identification requests by the PROFIenergy controller, ensuring proper communication and command support acknowledgment."}, "generated_keywords": ["PROFIenergy response generation", "PE_Identify command handling", "Command support indication", "PROFIenergy controller communication", "Response data preparation"]}
{"instruction_name": "PE_Measurement_List_RSP", "description": "The auxiliary block \"PE_Measurement_List_RSP\" generates the response to the command Get_measurement_list. In the response, specify which measured values (Measurement-IDs) are supported.", "parameters": {"Input": [{"name": "PE_I_DEV_NEW", "type": "BOOL", "description": "The parameter must be interconnected with the NEW output parameter of the \"PE_I_DEV\" instruction. The auxiliary block is processed if the parameter value is set to \"1\"."}, {"name": "CMD", "type": "INT", "description": "Service-Request-ID of the PROFIenergy command. The parameter must be interconnected with the CMD output parameter of the \"PE_I_DEV\" instruction."}, {"name": "CMD_MODIFIER", "type": "INT", "description": "PROFIenergy sub-command (evaluated only if CMD=3, or CMD=16). The parameter must be interconnected with the CMD_MODIFIER output parameter of the \"PE_I_DEV\" instruction."}, {"name": "Count", "type": "BYTE", "description": "Number of measured values supported (measurement IDs)"}, {"name": "Measurement", "type": "VARIANT", "description": "Pointer to the array with the Measurement_IDs supported. For information on the structure of the array in accordance with the PROFIenergy profile, see: PI Command \"Query_Measurement\" - \"Get_Measurement_list\"."}], "Output": [{"name": "ERROR", "type": "BOOL", "description": "\"0\": No error; \"1\": Error occurred."}, {"name": "STATUS", "type": "WORD", "description": "\"0\": No error; \"0x80B1\": Error in VARIANT setting, e.g. incorrect range"}], "InOut": [{"name": "ACTIVATE", "type": "BOOL", "description": "The instruction copies the input parameters to the DATA_ERROR_RSP data area at a rising edge at input ACTIVATE. The parameter is then reset by the instruction. The parameter must be set within 10 seconds after a rising edge is detected at parameter NEW of the \"PE_I_DEV\" instruction."}, {"name": "VALID", "type": "BOOL", "description": "The parameter must be interconnected with the VALID input of the \"PE_I_DEV\" instruction. The auxiliary block sets the parameter once the response data for the PROFIenergy controller is available and ready for transmission."}, {"name": "DATA_ERRORRSP", "type": "VARIANT", "description": "Pointer on the data area in which the response data is stored. The parameter is identical to the pointer for DATA_ERRORRSP of the \"PE_I_DEV\" instruction. The addressed data area contains complete PROFIenergy frame. Minimum length: 244 bytes"}]}, "how_to_use": "Connect the input parameters as specified, especially those linked to the \"PE_I_DEV\" instruction's outputs. Set the ACTIVATE input TRUE within 10 seconds after the NEW signal is set. The block processes the inputs and writes the response data to the DATA_ERRORRSP area, setting VALID to indicate readiness. Monitor STATUS and ERROR outputs for error handling.", "example_code": "", "additional_info": "Ensure that the DATA_ERRORRSP area is allocated with at least 244 bytes to store the PROFIenergy frame. The Measurement_List array must comply with the PROFIenergy profile structure. The ACTIVATE input triggers data processing on its rising edge and is reset automatically. Data types must follow the allowed data types for PLC memory areas.", "generated_brief": {"functional_summary": "The PE_Measurement_List_RSP instruction generates and sends a response listing the supported measured values (Measurement-IDs) for a PROFIenergy Get_measurement_list command.", "usage_context": "It is used within PROFIenergy-enabled PLC applications to provide measurement capability information to energy management controllers following a measurement list request."}, "generated_keywords": ["PROFIenergy measurement response", "Get_measurement_list handling", "Measurement-IDs supported listing", "PE_I_DEV integration", "Energy data response generation"]}
{"instruction_name": "PE_PEM_Status_RSP", "description": "The auxiliary block \"PE_PEM_Status_RSP\" generates the response to the command PEM_Status.", "parameters": {"Input": [{"name": "PE_I_DEV_NEW", "type": "BOOL", "description": "The parameter must be interconnected with the NEW output parameter of the \"PE_I_DEV\" instruction. The auxiliary block is processed if the parameter value is set to \"1\"."}, {"name": "CMD", "type": "INT", "description": "Service-Request-ID of the PROFIenergy command. The parameter must be interconnected with the CMD output parameter of the \"PE_I_DEV\" instruction."}, {"name": "PE_MODE_ID_Source", "type": "BYTE", "description": "Source and Destination for PEM_STATUS.\nValues:\n0x00: PE_POWER_OFF\n0x01 – 0xFE: manufacturer-specific\n0xFF: PE_READY_TO_OPERATE"}, {"name": "PE_MODE_ID_Destination", "type": "BYTE", "description": ""}, {"name": "Time_to_Operate", "type": "DWORD", "description": "Maximum switch-on time to \"PE_ready_to_operate\". Time_to_operate can be used directly for the relevant calculations. The value may be a static maximum, or be calculated dynamically by the PE entity."}, {"name": "Remaining_time_to_destination", "type": "DWORD", "description": "Optional: Time remaining until the requested PE mode. Dynamic value or static maximum value"}, {"name": "Mode_Power_Consumption", "type": "DWORD", "description": "Energy consumption in the current PE mode in [kW]."}, {"name": "Energy_Consumption_to_Destination", "type": "DWORD", "description": "Energy consumption in the time until the requested PE mode in [kW]."}, {"name": "Energy_Consumption_to_operate", "type": "DWORD", "description": "Energy consumption from the current PE mode to \"PE_ready_to_operate\" in [kWh]."}], "Output": [{"name": "ERROR", "type": "BOOL", "description": "\"0\": No error\n\"1\": Error occurred."}, {"name": "STATUS", "type": "WORD", "description": "\"0\": No error\n\"0x80B1\": Error in VARIANT setting, e.g. incorrect range"}], "InOut": [{"name": "ACTIVATE", "type": "BOOL", "description": "The instruction copies the input parameters to the DATA_ERROR_RSP data area at a rising edge at input ACTIVATE. The parameter is then reset by the instruction. The parameter must be set within 10 seconds after a rising edge is detected at parameter NEW of the \"PE_I_DEV\" instruction."}, {"name": "VALID", "type": "BOOL", "description": "The parameter must be interconnected with the VALID input of the \"PE_I_DEV\" instruction. The auxiliary block sets the parameter once the response data for the PROFIenergy controller is available and ready for transmission."}, {"name": "DATA_ERRORRSP", "type": "VARIANT", "description": "Pointer on the data area in which the response data is stored. The parameter is identical to the pointer for DATA_ERRORRSP of the \"PE_I_DEV\" instruction. The addressed data area contains the complete PROFIenergy frame. Minimum length: 244 bytes"}]}, "how_to_use": "Set the input parameters accordingly, ensuring PE_I_DEV_NEW is set to 1 to process the auxiliary block. Trigger the instruction by a rising edge on ACTIVATE within 10 seconds after the NEW parameter from PE_I_DEV is set. Monitor VALID to confirm response data availability and check ERROR and STATUS outputs for error handling. DATA_ERRORRSP must point to a sufficient data area (minimum 244 bytes) for storing the response frame.", "example_code": "", "additional_info": "If the time period parameters Time_to_Operate or Remaining_time_to_destination are unlimited, specify 0xFFFFFFFF. Use 0x00 to specify zero time period. If no energy consumption value is defined, set it to 0.0. Valid memory areas for most parameters include I, Q, M, D, L or constants.", "generated_brief": {"functional_summary": "The PE_PEM_Status_RSP instruction generates and stores the PROFIenergy response to a PEM_Status command based on various input parameters including mode IDs, timing, and energy consumption.", "usage_context": "It is used in industrial automation systems to communicate energy mode status responses to a PROFIenergy controller after receiving a status request, enabling energy management and monitoring within a specified timing sequence."}, "generated_keywords": ["PROFIenergy response", "PEM_Status command", "energy mode status", "timing and energy consumption", "auxiliary block activation"]}
{"instruction_name": "ASI_CTRL", "description": "The command interface allows the controller and AS-i master to exchange parameter assignment and information data. These commands provide the complete functionality of the M4 master profile of the AS-i master specifications and enable the AS-i master to be completely configured from the controller.", "parameters": {"Input": [{"name": "SD", "type": "ANY", "description": "Start address of the send buffer that contains the command number and job data."}, {"name": "LEN_SD", "type": "INT", "description": "Length in bytes of the send buffer area."}, {"name": "RD", "type": "ANY", "description": "Start address of the receive buffer for receiving response data (virtual buffer may be used if no response is expected)."}, {"name": "LEN_RD", "type": "INT", "description": "Length in bytes of the receive buffer area. Must be sufficient to avoid overwriting neighboring memory areas."}], "Output": [{"name": "STATUS", "type": "INT", "description": "Status information about the execution of the command."}], "InOut": []}, "how_to_use": "Prepare the send buffer according to the command structure with the command number at byte q+0 and the job data in subsequent bytes. The receive buffer must be allocated with sufficient length according to the command. Call the ASI_CTRL instruction to send the command and receive the response. For certain commands (39H, 41H, 42H, 43H, 44H), the receive buffer must be 221 bytes long. Consult the AS-i master documentation for command-specific parameters and expected response lengths.", "example_code": "", "additional_info": "If the receive buffer length is too short, neighboring memory areas may be overwritten regardless of the length parameter specified in the ANY pointer of RD. The required buffer length for each command can be found in the command description of the AS-i master manual. Command 77H can be used to re-initialize the AS-i master command interface, terminating any ongoing command processing.", "generated_brief": {"functional_summary": "The ASI_CTRL instruction enables communication between the PLC controller and the AS-i master by sending command data and receiving corresponding responses for parameter assignment and control functions.", "usage_context": "This function is used when configuring or controlling the AS-i master module from a PLC to manage AS-i network operations and parameters within an industrial automation system."}, "generated_keywords": ["AS-i master communication", "parameter assignment", "command interface", "send and receive buffers", "PLC to AS-i configuration"]}
{"instruction_name": "GEO_LOG", "description": "The corresponding module slot of a signal module is known. Use the \"GEO_LOG\" instruction to determine the corresponding hardware identifier of the module from this.", "parameters": {"Input": [{"name": "MASTER", "type": "INT", "description": "Area ID: 0, if the slot is located in a centralized configuration; 1 to 32: DP master system ID of the associated field device if the slot is located in a field device on PROFIBUS; 100 to 115: PROFINET IO system ID of the associated field device if the slot is located in a field device on PROFINET"}, {"name": "STATION", "type": "INT", "description": "If MASTER = 0: Number of the rack; If MASTER > 0: Station number of the field device"}, {"name": "SLOT", "type": "INT", "description": "Slot number"}, {"name": "SUBSLOT", "type": "INT", "description": "Number of the submodule. If no submodule exists or can be inserted SUBSLOT must have the value \"0\"."}], "Output": [{"name": "LADDR", "type": "HW_IO", "description": "Hardware identifier of the module"}], "InOut": [], "Return": [{"name": "RET_VAL", "type": "INT", "description": "Error information"}]}, "how_to_use": "Initialize the input parameters MASTER, STATION, SLOT, and SUBSLOT to specify the module slot of the signal module. Call the GEO_LOG instruction to obtain the hardware identifier of the module in LADDR. Check RET_VAL for error to validate correct execution.", "example_code": "", "additional_info": "RET_VAL error codes include: 0000 - No error occurred; 8094 - No subnet was configured with the specified SUBNETID; 8095 - Illegal value for STATION parameter; 8096 - Illegal value for SLOT parameter; 8097 - Illegal value for SUBSLOT parameter. For general error information, see GET_ERR_ID. Refer to \"Switching display formats in the program status\" and \"Instructions for address conversion (S7-1200, S7-1500)\" for additional guidance.", "generated_brief": {"functional_summary": "The GEO_LOG instruction converts a specified module slot address into the corresponding hardware identifier of the signal module.", "usage_context": "It is typically used in PLC programs to identify the physical hardware module based on its location in centralized, PROFIBUS, or PROFINET configurations for addressing and control purposes."}, "generated_keywords": ["module slot to hardware ID", "signal module identification", "PROFIBUS PROFINET addressing", "hardware identifier conversion", "PLC module addressing"]}
{"instruction_name": "CAN_TINT", "description": "The instruction \"CAN_TINT\" is used to delete the start date and time of a specified time-of-day interrupt organization block. This deactivates the time-of-day interrupt, and the organization block is no longer called.", "parameters": {"Input": [{"name": "OB_NR", "type": "OB_TOD", "description": "Number of the time-of-day interrupt OB, whose starting date and time-of-day are to be deleted."}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "If an error occurs while the instruction is being executed, the actual parameter of RET_VAL contains an error code."}], "InOut": []}, "how_to_use": "Use CAN_TINT to delete the start date/time of a time-of-day interrupt OB to deactivate it. To reuse the time-of-day interrupt, reset the start time with SET_TINTL or SET_TINT, then reactivate it either by calling ACT_TINT (if the ACTIVE parameter was false) or by setting ACTIVE=true directly in SET_TINTL.", "example_code": "", "additional_info": "Error codes returned via RET_VAL include: 0000 (no error), 8090 (error in OB_NR parameter), 80A0 (no starting date/time-of-day defined). For general error info, refer to GET_ERR_ID. Data types for OB_NR can be I, Q, M, D, L or constant; for RET_VAL I, Q, M, D, L. See the overview of valid data types for more information.", "generated_brief": {"functional_summary": "The CAN_TINT instruction deletes the start date and time of a specified time-of-day interrupt organization block, effectively deactivating the interrupt.", "usage_context": "It is used in PLC programs to deactivate scheduled time-of-day interrupts when they are no longer needed or must be reset."}, "generated_keywords": ["delete start time-of-day interrupt", "deactivate time-of-day interrupt", "time-of-day interrupt OB", "reset interrupt start time", "PLC interrupt management"]}
{"instruction_name": "Program_Alarm", "description": "The instruction 'Generate program alarm with associated values' monitors a signal and on a signal change at the parameter SIG generates a program alarm. An incoming program alarm is generated with a signal change from 0 to 1 and an outgoing program alarm is generated with a signal change from 1 to 0. The program alarm is triggered synchronously to program execution.", "parameters": {"Input": [{"name": "SIG", "type": "BOOL", "description": "The signal to be monitored. Positive signal edge generates an incoming program alarm; negative signal edge generates an outgoing program alarm."}, {"name": "TIMESTAMP", "type": "LDT", "description": "This parameter is used to assign an alarm a time stamp. The time value must be specified in system time (i.e. UTC). If not assigned, the system time of the CPU will be used."}, {"name": "SD_i", "type": "VARIANT", "description": "i-th associated value (1 ≤ i ≤ 10). You can use binary numbers, integers, floating-point numbers, or character strings as associated values."}], "Output": [{"name": "Error", "type": "BOOL", "description": "Status parameter Error. Error = TRUE indicates that an error has occurred during processing."}, {"name": "Status", "type": "WORD", "description": "Status parameter Status. Displays error information."}], "InOut": []}, "how_to_use": "Call the instruction only in a function block (FB). The block is processed synchronously. An alarm is triggered as soon as the block is exited.", "example_code": "Create one tag in a global data block for storing the signal value to be monitored. The instruction is called in a function block. Interconnect the parameters of the instruction as required.", "additional_info": "Make sure the total size of associated values does not exceed 512 bytes, with 400 bytes reserved for specific text fields. The instruction needs to be called in a function block, and proper error handling should be implemented.", "generated_brief": {"functional_summary": "The Program_Alarm instruction monitors a boolean signal for rising or falling edges to generate corresponding incoming or outgoing program alarms with associated values and an optional timestamp.", "usage_context": "It is typically used within function blocks in PLC programs to synchronously trigger alarms during program execution whenever monitored signals change state."}, "generated_keywords": ["program alarm generation", "signal edge detection", "function block usage", "alarm with timestamp", "associated alarm values"]}
{"instruction_name": "PE_CMD", "description": "The instruction 'PE_CMD' is used in the PE controller to start or terminate a pause in the energy-saving mode in the PE entity. Additional information and energy measurements are also read out from a PE entity using 'PE_CMD'.", "parameters": {"Input": [{"name": "REQ", "type": "BOOL", "description": "Starts transferring the PE command upon a positive edge."}, {"name": "ID", "type": "HW_SUBMODULE", "description": "Address of the PE entity. Use the hardware ID of the head module for a PROFINET IO device."}, {"name": "CMD", "type": "BYTE", "description": "Service-Request-ID of the PROenergy command in accordance with the PROFIenergy profile."}, {"name": "CMD_MODIFIER", "type": "BYTE", "description": "PROFIenergy sub-command (only when CMD=3 or CMD=16)."}, {"name": "CMD_PARA", "type": "VARIANT", "description": "Parameters for the PE commands: Get mode: PE_mode_ID; Get measurement values: List of Measurement_Ids."}, {"name": "CMD_PARA_LEN", "type": "INT", "description": "The actual length of the command parameters (<= length defined in CMD_PARA; is verified by the instruction)."}, {"name": "CMD_DATA_STRUCTURE_IDENTIFIER_RQ", "type": "BYTE", "description": "Value of the Data Structure Identifier from the standard."}], "Output": [{"name": "VALID", "type": "BOOL", "description": "Command successfully sent."}, {"name": "BUSY", "type": "BOOL", "description": "Command still being processed."}, {"name": "ERROR", "type": "BOOL", "description": "Error occurred during processing."}, {"name": "STATUS", "type": "DWORD", "description": "Block status / error number."}], "InOut": [{"name": "RESPONSE_DATA", "type": "VARIANT", "description": "PROFIenergy information. May be complete response frame including block header, depending on the command."}]}, "how_to_use": "Initialize the 'RESPONSE_DATA' area before calling 'PE_CMD'.", "example_code": "", "additional_info": "Commands are transferred without plausibility test. Ensure the buffer for 'RESPONSE_DATA' is cleared before each call.", "generated_brief": {"functional_summary": "The PE_CMD instruction sends and manages PROFIenergy commands to start or stop energy-saving pauses and retrieve energy measurements from a PE entity in a PE controller.", "usage_context": "It is typically used in industrial automation to control and monitor energy-saving modes and gather energy data from PROFIenergy-compatible devices."}, "generated_keywords": ["PROFIenergy command", "energy-saving mode control", "PE entity communication", "energy measurement retrieval", "pause start and terminate"]}
{"instruction_name": "PE_DS3_Write_ET200S", "description": "The instruction \"PE_DS3_Write_ET200S\" sends basic settings for power module switching behavior to the ET 200S. The switching behavior of up to 8 slots in the ET 200S (e.g. for power modules) is defined with this instruction. This instruction is not part of the PROIenergy profile but instead supplements SIMATIC-specific functions.", "parameters": {"Input": [{"name": "ENABLE", "type": "BOOL", "description": "A positive edge triggers the transfer of the data record. Transfer the data record again following voltage OFF/ON."}, {"name": "ID", "type": "HW_SUBMODULE", "description": "Address of the ET 200S. Accept the address from the hardware configuration."}, {"name": "SLOT_NO_X", "type": "INT", "description": "Slot number of switchable power module X."}, {"name": "FUNC_X", "type": "INT", "description": "Function of the module in this slot. Use the parameter FUNC_X to define the switching behavior of the PM-E (power module of the ET 200S): FALSE - With \"PAUSE_START\": No effect on PM-E and PM-E remains on; With \"PAUSE_STOP\": Switches PM-E back on. TRUE - With \"PAUSE_START\": Switches PM-E off; With \"PAUSE_STOP\": Switches PM-E back on."}], "Output": [{"name": "BUSY", "type": "BOOL", "description": "Transfer not yet complete."}, {"name": "DONE", "type": "BOOL", "description": "Transfer completed without errors."}, {"name": "ERROR", "type": "BOOL", "description": "Transfer completed with error."}, {"name": "STATUS", "type": "DWORD", "description": "Error number (see STATUS parameter of the instruction \"PE_Start_End\")."}], "InOut": []}, "how_to_use": "Use ENABLE to trigger the data transfer of the configured power module settings to the ET 200S. Provide the ET 200S address via ID. Specify slot numbers and functions for each switchable power module slot using SLOT_NO_X and FUNC_X respectively. Monitor BUSY, DONE, ERROR and STATUS outputs to handle the transfer state and errors.", "example_code": "", "additional_info": "This instruction supplements SIMATIC-specific functions and is not part of the PROIenergy profile. Valid data types for parameters are I, Q, M, D, L, P or constant as applicable.", "generated_brief": {"functional_summary": "The PE_DS3_Write_ET200S instruction configures and transfers power module switching behaviors for up to 8 slots in the ET 200S device.", "usage_context": "It is used when defining or updating the switching behavior settings of power modules in an ET 200S distributed I/O system within SIMATIC automation environments."}, "generated_keywords": ["ET 200S power module configuration", "power module switching behavior", "SIMATIC ET 200S data transfer", "slot function assignment", "power module communication"]}
{"instruction_name": "PE_START_END", "description": "The instruction \"PE_START_END\" is used to start and exit the energy-saving mode of a specified PE entity (e.g. ET 200S). It is used in the PE controller, preferably when only field devices from which energy data does not need to be read out are connected to the corresponding PE devices. The energy-saving modes are configured in the user program of the PE controller. On completion, the PE entity reports its current energy-saving mode and outputs this data at parameter PE_MODE_ID. The instruction sends a PROFIenergy command internally as a write job via WRREC, waits for acknowledgment that is read every 100 ms via RDREC, and repeats the read job for up to 10 seconds until acknowledgment is received. The response data is also read with RDREC.", "parameters": {"Input": [{"name": "START", "type": "BOOL", "description": "Transmitting the PE command \"Start_Pause\" to the PE entity with the address set at parameter ID."}, {"name": "END", "type": "BOOL", "description": "Transmitting the PE command \"End_Pause\" to the PE entity with the address set at parameter ID."}, {"name": "ID", "type": "HW_SUBMODULE", "description": "Address of the PE entity. Use the hardware ID of the head module for a PROFINET IO device, derived from system constants of the assigned IO controller. For I-devices, use the hardware identifier of a transfer area."}, {"name": "PAUSE_TIME", "type": "TIME", "description": "Planned pause duration. Range: T#1MS to T#24D20H31M23S647MS. Start value: T#0MS."}], "Output": [{"name": "VALID", "type": "BOOL", "description": "PE command successfully sent."}, {"name": "BUSY", "type": "BOOL", "description": "PE command still being processed."}, {"name": "ERROR", "type": "BOOL", "description": "Error occurred during processing. The error message is output at the STATUS parameter."}, {"name": "STATUS", "type": "DWORD", "description": "Block status / error number providing detailed error information."}, {"name": "PE_MODE_ID", "type": "BYTE", "description": "Identification number of energy-saving mode (energy-saving level for the duration of the pause)."}], "InOut": []}, "how_to_use": "Invoke PE_START_END with the START input to command the PE entity to enter energy-saving mode and with END to exit it. Set ID to the hardware address of the PE entity. Set PAUSE_TIME to the planned pause duration. The instruction manages internal communication using WRREC and RDREC for PROFIenergy commands. Monitor VALID, BUSY, and ERROR outputs to track command status. Consider that ET 200S requires a minimum pause duration of 10 seconds; shorter pauses will keep power modules on. The module remains off after the pause until END is commanded to prevent undesired peak loads.", "example_code": "", "additional_info": "The STATUS output can be interpreted as an array of four BYTEs providing detailed error descriptions, including causes of errors (Function_Num), location (Error_Decode), and error IDs (Error_Code_1, Error_Code_2). Errors from RDREC and WRREC instructions used internally are also reported here. The minimum pause duration must be greater than the sum of times to switch to and from energy-saving mode. The module does not automatically switch on at the end of the pause.", "generated_brief": {"functional_summary": "PE_START_END controls the entry and exit of energy-saving mode for a specified PE entity by sending PROFIenergy commands and managing communication status signals.", "usage_context": "It is used in PE controllers to pause and resume energy consumption for field devices like ET 200S during planned downtimes or low-demand periods to optimize energy usage."}, "generated_keywords": ["energy-saving mode control", "PE entity pause and resume", "PROFIenergy command", "PE controller device management", "energy consumption optimization"]}
{"instruction_name": "SET_TINT", "description": "The instruction \"SET_TINT\" is used to set the start data and time of the time-of-day interrupt organization blocks from the user program, without having to make settings in the hardware configuration. Enter the number of the time-of-day interrupt-OBs at the parameter OB_NR for which you would like to set the start date and the time-of-day. Use the parameter SDT and PERIOD to specify when and how often the time-of-day interrupt OB should be called: One-time call: Enter the date and the time-of-day at the parameter SDT. Use the value \"0\" at parameter PERIOD. Repeated call: Enter the date and the time-of-day of the first call at the parameter SDT. Use the parameter PERIOD to define the time interval in which subsequent calls of the OBs should take place. Observe the following when setting the start date and start time: The date and the time-of-day specification at the parameter SDT refers to the system time. The seconds and milliseconds specification is ignored and set to \"0\" at the start time. Only the starting date days 1, 2, ... 28 are possible if you want to specify a monthly time-of-day interrupt OBs. This restriction prevents skipping the monthly call (e.g. 30-day months or in February). The setting \"end of the month\" (W#16#2001) can be used at the parameter PERIOD as an alternative to the 29th 30th and the 31st of the month. After setting the time-of-day interrupt with \"SET_TINT\" it still must be activated with the instruction \"ACT_TINT\".", "parameters": {"Input": [{"name": "OB_NR", "type": "OB_TOD", "description": "Number of the time-of-day interrupt OBs. The numbers 10 to 17 are available for the time-of-day interrupt OBs. An OB number starting with 123 can also be assigned as an alternative. The OB number is displayed in the program block folder and in the system constants."}, {"name": "SDT", "type": "DT", "description": "Start date and start time."}, {"name": "PERIOD", "type": "WORD", "description": "Execution intervals from the starting point SDT to: W#16#0000 single execution, W#16#0201 = once every minute, W#16#0401 = once hourly, W#16#1001 = once daily, W#16#1201 = once weekly, W#16#1401 = once monthly, W#16#1801 = once yearly, W#16#2001 = at month's end."}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "If an error occurs while the instruction is being executed, the actual parameter of RET_VAL contains an error code."}], "InOut": []}, "how_to_use": "Call SET_TINT supplying the OB_NR for the desired time-of-day interrupt OB. Specify the start date and time in SDT (system time, seconds and milliseconds ignored) and set the PERIOD to define how often the OB shall be called (single or repeated with specified intervals). Ensure that for monthly settings only start dates 1 to 28 are used or PERIOD equals end of month (W#16#2001). After setting, activate the time-of-day interrupt with ACT_TINT instruction.", "example_code": "", "additional_info": "Error codes returned in RET_VAL include 0000 for no error, 8090 for invalid OB_NR, 8091 for invalid SDT, 8092 for incorrect PERIOD, and 80A1 if start time is in the past when PERIOD is single execution (W#16#0000). The seconds and milliseconds in SDT are ignored and defaulted to zero. Use ACT_TINT to enable the time-of-day interrupt after setting it.", "generated_brief": {"functional_summary": "The SET_TINT instruction configures the start date, time, and recurrence interval of a time-of-day interrupt organization block (OB) in a PLC program without hardware configuration changes.", "usage_context": "It is used when precise scheduling of time-of-day interrupts is needed for periodic or one-time execution of tasks within industrial automation systems."}, "generated_keywords": ["set time-of-day interrupt", "configure start date and time", "schedule periodic OB execution", "time-of-day interrupt setup", "recurrence interval configuration"]}
{"instruction_name": "SET_TINTL", "description": "The instruction \"SET_TINTL\" is used to set the start data and time of the time-of-day interrupt organization blocks from the user program, without having to make settings in the hardware configuration. Use the parameter OB_NR to enter the number of the time-of-day interrupt-OBs to set the start date and time-of-day. Parameters SDT and specify when and how often the interrupt OB is called (one-time call with PERIOD=0, repeated calls with PERIOD defining the interval). LOCAL selects whether the time is local or system time. ACTIVATE determines when settings are applied: immediately (true) or after calling ACT_TINT (false). The seconds and milliseconds in SDT are ignored (set to 0). Only days 1..28 can be specified for monthly interrupts; W#16#2001 can be used to specify 'end of the month' alternative. Special considerations exist for daylight saving time changeover. RET_VAL returns an error code if execution fails.", "parameters": {"Input": [{"name": "OB_NR", "type": "OB_TOD", "description": "Number of the time-of-day interrupt OBs. Numbers 10 to 17 are available; alternatively, OB numbers starting with 123 can be assigned. Can be I, Q, M, D, L or constant."}, {"name": "SDT", "type": "DTL", "description": "Start date and start time. Can be D, L or constant."}, {"name": "LOCAL", "type": "BOOL", "description": "Select whether to use local time (true) or system time (false). Can be I, Q, M, D, L or constant."}, {"name": "PERIOD", "type": "WORD", "description": "Execution intervals from starting point SDT. Supported values: W#16#0000 single execution; W#16#0201 once every minute; W#16#0401 once hourly; W#16#1001 once daily; W#16#1201 once weekly; W#16#1401 once monthly; W#16#1801 once yearly; W#16#2001 at month's end. Can be I, Q, M, D, L or constant."}, {"name": "ACTIVATE", "type": "BOOL", "description": "Specify when the settings are applied: true means settings are applied immediately; false means settings are applied only after calling ACT_TINT. Can be I, Q, M, D, L or constant."}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Return value indicating success or error code if an error occurs during execution. Can be I, Q, M, D, L."}], "InOut": []}, "how_to_use": "Call the SET_TINTL instruction with the OB_NR identifying the time-of-day interrupt OB, specify the start date/time in SDT, and set PERIOD to define the frequency. Use LOCAL to select time reference, ACTIVATE to apply settings immediately or delay until ACT_TINT is called. Handle errors via RET_VAL. Note that seconds and milliseconds in SDT are ignored. For monthly intervals, use only days 1 to 28 or W#16#2001 to specify end of month. Consider daylight saving time changes when setting local time.", "example_code": "", "additional_info": "RET_VAL error codes include 0000 (no error), 8090 (invalid OB_NR), 8091 (invalid SDT), 8092 (incorrect PERIOD), 80A1 (start time in the past for single execution). Time-of-day interrupt OB numbers range from 10 to 17 or with prefix 123. For daylight saving time changes, special handling may be necessary to avoid errors. Settings at SDT and PERIOD correspond the properties of time-of-day interrupt OBs.", "generated_brief": {"functional_summary": "The SET_TINTL instruction configures the start date, time, and execution interval for time-of-day interrupt organization blocks in a PLC program without hardware configuration changes.", "usage_context": "It is used to schedule and manage time-based interrupts for automated tasks in industrial control systems, allowing dynamic adjustments to timing settings during runtime."}, "generated_keywords": ["set time-of-day interrupt", "configure start date and time", "time-of-day OB scheduling", "interrupt interval configuration", "dynamic timer setting"]}
{"instruction_name": "SYNC_PO", "description": "The instruction 'SYNC_PO' is used to update a process image partition of outputs in isochronous mode. An application program linked to a DP cycle or a PN send cycle can use this instruction for the consistent isochronous transfer of the computed output data of a process image partition from outputs to the I/O devices.", "parameters": {"Input": [{"name": "PART", "type": "PIP", "description": "Number of the process image partition of the outputs to be updated isochronously."}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "If an error occurs while the instruction is being executed, the return value contains an error code."}, {"name": "FLADDR", "type": "WORD", "description": "Address of the first byte that has caused the error."}], "InOut": []}, "how_to_use": "The 'SYNC_PO' instruction is interruptible and should only be called in OBs 61, 62, 63 and 64. Ensure you have assigned the affected process image partition to the associated OB in the HW configuration.", "example_code": "", "additional_info": "A process image partition that you update with 'SYNC_PO' must not be updated simultaneously with the 'UPDAT_PO' instruction.", "generated_brief": {"functional_summary": "The SYNC_PO instruction updates a specified process image partition of outputs isochronously, ensuring consistent transfer of output data from the PLC to I/O devices during DP or PN communication cycles.", "usage_context": "It is used within specific interrupt OBs (61-64) to synchronize output data updates in applications requiring precise timing, and must not be mixed with UPDAT_PO for the same partition."}, "generated_keywords": ["isochronous output update", "process image partition", "DP PN cycle synchronization", "interruptible OB call", "SYNC_PO instruction"]}
{"instruction_name": "WRREC", "description": "The instruction \"WRREC\" is used to transfer the RECORD data record to the component addressed using ID. This can be a module in a central rack or a distributed component (PROFIBUS DP or PROFINET IO).", "parameters": {"Input": [{"name": "REQ", "type": "BOOL", "description": "REQ = 1: Transfer data record"}, {"name": "ID", "type": "HW_IO", "description": "ID number of the hardware component (DP/PROFINET IO). The number is assigned automatically and is stored in the properties of the component or of the interface in the hardware configuration."}, {"name": "INDEX", "type": "DINT", "description": "Data record number"}, {"name": "LEN", "type": "UINT", "description": "Maximum length of the data record to be transferred in bytes"}], "Output": [{"name": "DONE", "type": "BOOL", "description": "Data record was transferred"}, {"name": "BUSY", "type": "BOOL", "description": "BUSY = 1: The writing process is not yet complete."}, {"name": "ERROR", "type": "BOOL", "description": "ERROR = 1: An error occurred during the writing process."}, {"name": "STATUS", "type": "DWORD", "description": "Block status or error information"}], "InOut": [{"name": "RECORD", "type": "VARIANT", "description": "Data record"}]}, "how_to_use": "The WRREC instruction is asynchronous and must be called with REQ = 1 to start the data record transfer. The same value must be assigned to the RECORD and LEN parameters for all calls belonging to the same transfer job. The transfer is complete when BUSY becomes FALSE. Error and status information are provided through ERROR and STATUS outputs. When using WRREC in SYNCUP system state of S7-1500-R/H systems, cyclic calls are required due to dynamic behavior.", "example_code": "", "additional_info": "Use only the hardware identifier (HW ID) of the module for the ID parameter, which can be found in system constants. For PROFINET IO, negative values in INDEX and LEN are interpreted as unsigned 16-bit integers. The interface is identical to the WRREC FB in the 'PROFIBUS and PROFINET Guideline Communication Function Blocks'. Status codes provide detailed error information. No implicit type conversion in STL; use valid data types shown in parameter tooltips.", "generated_brief": {"functional_summary": "The WRREC instruction transfers a specified data record asynchronously to a targeted hardware component identified by its hardware ID.", "usage_context": "It is used in industrial automation to send configuration or operational data to central or distributed modules over communication buses like PROFIBUS DP or PROFINET IO."}, "generated_keywords": ["asynchronous data transfer", "hardware module communication", "PROFIBUS DP", "PROFINET IO", "record writing instruction"]}
{"instruction_name": "WR_LOC_T", "description": "The instruction \"WR_LOC_T\" is used to set the date and time of the CPU clock. Enter the date and time-of-day as local time at the input parameter LOCTIME. The value must be in the following range: With DTL: min. DTL#1970-01-01-00:00:00.0, max. DTL#2200-12-31 23:59:59.999999999; With LDT: min. LDT#1970-01-01-0:0:0.000000000, max. LDT#2200-12-31 23:59:59.999999999. The gran of the time information for local time and system time is product-specific and is at least one millisecond. Input values at the LOCTIME parameter which are less than those supported by the CPU are rounded up during system time calculation. You can query whether errors have occurred during execution of the instruction in the RET_VAL output parameter.", "parameters": {"Input": [{"name": "LOCTIME", "type": "DTL", "description": "Local time. Data type DTL cannot be used for the memory areas: input, output and bit memory."}, {"name": "DST", "type": "BOOL", "description": "Daylight Saving Time. Is only evaluated during the \"double hour\" at changeover to standard time. TRUE = daylight saving time (first hour), FALSE = standard time (second hour)."}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Error message indicating status or error codes during execution (see \"RET_VAL parameter\")."}], "InOut": []}, "how_to_use": "To use WR_LOC_T, provide the local time to set via the LOCTIME input parameter in DTL format (or LDT where allowed), ensuring the value is within the valid range. Use the DST boolean input to specify daylight saving time status only during the changeover (the \"double hour\" between 2 AM and 3 AM). Execute the instruction when the local time should update. Check RET_VAL to ensure no errors occurred. Values outside the valid time range or invalid times during time changes produce error codes. The data type DTL cannot be used with input, output, or bit memory areas.", "example_code": "VAR\n  execute: BOOL;\n  inputLocTIME: DTL;\n  dstValue: BOOL;\n  returnValue: INT;\nEND_VAR\n\nIF execute THEN\n  WR_LOC_T(LOCTIME := inputLocTIME, DST := dstValue, RET_VAL => returnValue);\nEND_IF;", "additional_info": "The DST parameter is relevant only during the 'double hour' at the changeover from daylight saving to standard time to distinguish between the repeated hour. During the changeover from standard to daylight saving time, times in the missing hour produce error code W#16#8089. The RET_VAL output reflects detailed error codes such as invalid values in date or time bytes. The instruction affects the CPU clock. Verification of correct time setting can be done via CPU display or the RD_LOC_T instruction.", "generated_brief": {"functional_summary": "WR_LOC_T sets the CPU clock's local date and time, allowing specification of daylight saving status during the hour changeover, and provides error feedback via a return value.", "usage_context": "It is used in industrial control systems when precise synchronization of the CPU clock to local time is required, especially around daylight saving time transitions."}, "generated_keywords": ["set CPU local time", "date and time synchronization", "daylight saving time adjustment", "CPU clock configuration", "error handling in time setting"]}
{"instruction_name": "S_COMP", "description": "The instruction compares the contents of two tags in the (W)STRING format and outputs the result of the comparison as a return value. The tags that are to be compared will be interconnected at the IN1 and IN2 inputs.", "parameters": {"Input": [{"name": "IN1", "type": "STRING, WSTRING*", "description": "Input tag in the STRING / WSTRING format."}, {"name": "IN2", "type": "STRING, WSTRING*", "description": "Input tag in the STRING / WSTRING format."}], "Output": [{"name": "OUT", "type": "BOOL", "description": "Result of comparison."}], "InOut": []}, "how_to_use": "Use the instruction box to select the comparison condition. If the comparison condition (for example, greater than or equal to) is satisfied, the signal state is set to '1' at the output parameter OUT.", "example_code": "stringvalue1 := 'example1';\nstringvalue2 := 'example2';\nresult := S_COMP(IN1 := stringvalue1, IN2 := stringvalue2, condition := 'EQ');", "additional_info": "The characters are compared by their ASCII code. The first character to be different decides the result of the comparison.", "generated_brief": {"functional_summary": "S_COMP compares two STRING or W tags based on a specified condition and outputs a BOOL indicating whether the comparison is true.", "usage_context": "It is typically used in PLC programs to perform string comparisons for control logic decisions such as equality or ordering based on ASCII values."}, "generated_keywords": ["string comparison", "WSTRING compare", "ASCII-based comparison", "boolean output", "PLC string logic"]}
{"instruction_name": "GEO2LOG", "description": "Determine hardware identifier from slot", "parameters": {"Input": [], "Output": [], "InOut": []}, "how_to_use": "", "example_code": "", "additional_info": "", "generated_brief": {"functional_summary": "The GEO2LOG instruction determines the hardware identifier associated with a given slot in a PLC system.", "usage_context": "It is used to map physical slot locations to their corresponding hardware IDs for hardware configuration and diagnostics."}, "generated_keywords": ["hardware identifier", "slot mapping", "hardware configuration", "diagnostics", "PLC slot identification"]}
{"instruction_name": "LOG2GEO", "description": "Determine slot from hardware identifier", "parameters": {"Input": [], "Output": [], "InOut": []}, "how_to_use": "", "example_code": "", "additional_info": "", "generated_brief": {"functional_summary": "The LOG2GEO instruction determines the slot number corresponding to a given hardware identifier.", "usage_context": "It is used in PLC systems to map hardware identifiers to their physical slot positions for configuration or diagnostics."}, "generated_keywords": ["hardware identifier mapping", "slot determination", "PLC hardware slot", "hardware to slot mapping", "slot number retrieval"]}
{"instruction_name": "LOG2MOD", "description": "Determine the hardware identifier from addressing of STEP 7 V5.5 SPx", "parameters": {"Input": [], "Output": [], "InOut": []}, "how_to_use": "", "example_code": "", "additional_info": "", "generated_brief": {"functional_summary": "LOG2MOD determines the hardware identifier based on the addressing scheme used in STEP 7 V5.5 SPx.", "usage_context": "It is used in industrial automation projects to map hardware addresses to their corresponding identifiers within the STEP 7 programming environment."}, "generated_keywords": ["hardware identifier", "addressing", "STEP 7", "module mapping", "industrial automation"]}
{"instruction_name": "IO2MOD", "description": "Determine hardware identifier from an IO address", "parameters": {"Input": [], "Output": [], "InOut": []}, "how_to_use": "", "example_code": "", "additional_info": "", "generated_brief": {"functional_summary": "The IO2MOD instruction determines the hardware module identifier associated a given IO address.", "usage_context": "It is typically used in PLC programs to map IO addresses to specific hardware modules for accurate hardware configuration and diagnostics."}, "generated_keywords": ["hardware module identification", "IO address mapping", "PLC IO configuration", "hardware diagnostics", "module address resolution"]}
{"instruction_name": "RD_ADDR", "description": "Determine IO addresses from the hardware identifier", "parameters": {"Input": [], "Output": [], "InOut": []}, "how_to_use": "", "example_code": "", "additional_info": "", "generated_brief": {"functional_summary": "The RD_ADDR instruction retrieves the I/O addresses corresponding to a given hardware identifier.", "usage_context": "This function is typically used in PLC programs to map hardware components to their specific I/O addresses for control and monitoring purposes."}, "generated_keywords": ["read IO address", "hardware identifier mapping", "address retrieval", "PLC IO mapping", "hardware to address"]}
{"instruction_name": "GEO_LOG", "description": "Determine hardware identifier from slot", "parameters": {"Input": [], "Output": [], "InOut": []}, "how_to_use": "", "example_code": "", "additional_info": "Supported in addition for migrated projects", "generated_brief": {"functional_summary": "The GEO_LOG instruction determines the hardware identifier based on the slot position within a system.", "usage_context": "It is used in migrated industrial automation projects to map hardware components to their physical locations for configuration or diagnostics."}, "generated_keywords": ["hardware identifier", "slot position", "component mapping", "system configuration", "diagnostics"]}
{"instruction_name": "LOG_GEO", "description": "Determine slot from hardware identifier", "parameters": {"Input": [], "Output": [], "InOut": []}, "how_to_use": "", "example_code": "", "additional_info": "Supported in addition for migrated projects", "generated_brief": {"functional_summary": "LOG_GEO determines the slot number associated with a specific hardware identifier in a control system.", "usage_context": "It is typically used in migrated projects to map hardware identifiers to their corresponding slot locations for system organization and troubleshooting."}, "generated_keywords": ["determine slot", "hardware identifier", "slot mapping", "migrated projects", "system troubleshooting"]}
{"instruction_name": "RD_LGADR", "description": "Determine IO addresses from the hardware identifier", "parameters": {"Input": [], "Output": [], "InOut": []}, "how_to_use": "", "example_code": "", "additional_info": "Supported in addition for migrated projects", "generated_brief": {"functional_summary": "The RD_LGADR instruction determines the IO addresses corresponding to a given hardware identifier.", "usage_context": "It is typically used in migrated projects to map hardware identifiers to their associated IO addresses for proper device communication."}, "generated_keywords": ["IO address determination", "hardware identifier mapping", "migrated project support", "device communication setup"]}
{"instruction_name": "GADR_LGC", "description": "Determine hardware identifier from slot and offset in the user data address area", "parameters": {"Input": [], "Output": [], "InOut": []}, "how_to_use": "", "example_code": "", "additional_info": "Supported in addition for migrated projects", "generated_brief": {"functional_summary": "GADR_LGC determines the hardware identifier based on the slot and offset within the user data address area.", "usage_context": "It is used in migrated PLC projects to map logical addresses to physical hardware components for control and diagnostics."}, "generated_keywords": ["hardware identifier determination", "slot and offset mapping", "user data address", "logical to physical address mapping", "migrated projects support"]}
{"instruction_name": "LGC_GADR", "description": "Determine slot from hardware identifier", "parameters": {"Input": [], "Output": [], "InOut": []}, "how_to_use": "", "example_code": "", "additional_info": "Supported in addition for migrated projects", "generated_brief": {"functional_summary": "LGC_GADR is a PLC instruction that determines the slot number from a given hardware identifier.", "usage_context": "It is typically used in migrated projects to map hardware identifiers to their corresponding slots within an industrial control system."}, "generated_keywords": ["determine slot number", "hardware identifier mapping", "PLC instruction", "migrated projects support", "hardware slot determination"]}
{"instruction_name": "T_COMP", "description": "This instruction is used to compare the contents of two tags of the \"Timers\" or \"Date and time\" data type. The instruction supports the comparison of the following data types: DATE, TIME, LTIME, TOD (TIME_OF_DAY), LTOD (LTIME_OF_DAY), DT (DATE_AND_TIME), LDT (DATE_AND_LTIME), DTL, S5Time. The data types must be the same length and format to carry out the comparison. The comparison result is output at the OUT parameter as a return value. For this purpose, the parameter OUT is set to \"1\" if the condition used for the comparison is satisfied. The following comparison options are available: EQ (time is the same), NE (time is not the same), GE (time at IN1 is greater or equal to time at IN2), LE (time at IN1 is smaller or equal to time at IN2), GT (time at IN1 is greater than time at IN2), LT (time at IN1 is smaller than time at IN2).", "parameters": {"Input": [{"name": "IN1", "type": "DATE, TIME, LTIME, TOD, LTOD, DT, LDT, DTL, S5Time", "description": "First value to be compared."}, {"name": "IN2", "type": "DATE, TIME, LTIME, TOD, LTOD, DT, LDT, DTL, S5Time", "description": "Second value to be compared."}], "Output": [{"name": "OUT", "type": "BOOL", "description": "Return value that is set to \"1\" if the comparison condition is fulfilled."}], "InOut": []}, "how_to_use": "Create tags of compatible date/time or timer data types (such as LTIME). Use the T_COMP instruction by connecting two time values to IN1 and IN2, and select a comparison option (e.g., GE for greater or equal). The result of the comparison will be available on the OUT parameter as a BOOL. Ensure that input data types match in length and format to carry out proper comparisons.", "example_code": "(* Example: Compare two LTIME values using the GE (Greater or Equal) comparison option *)\nVAR\n    timeValue1: LTIME;\n    timeValue2: LTIME;\n    value1GEvalue2: BOOL;\nEND_VAR\n\nvalue1GEvalue2 := T_COMP(IN1 := timeValue1, IN2 := timeValue2, OP := GE);", "additional_info": "The input data types must be the same length and format. The OUT parameter is a BOOL indicating whether the comparison condition is true (1) or false (0). Valid data types include DATE, TIME, LTIME, TOD, LTOD, DT, LDT, DTL, and S5Time.", "generated_brief": {"functional_summary": "The T_COMP instruction compares two date or time values of the same data type according to a specified condition and outputs a boolean indicating if the condition is met.", "usage_context": "It is typically used in PLC programs to evaluate timing or date-related conditions for control logic based on timer or date/time tag comparisons."}, "generated_keywords": ["time comparison", "date and time comparison", "timer value comparison", "boolean output", "PLC timing logic"]}
{"instruction_name": "GetSymbolPath", "description": "Use the instruction \"GetSymbolPath\" to read the names of the parameters transferred at the beginning of a call path and passed via multiple block calls.", "parameters": {"Input": [{"name": "VARIABLE", "type": "PARAMETER", "description": "Selection of the formal parameter for which you want to read out the name of the corresponding actual parameter at the beginning of the call path."}, {"name": "SIZE", "type": "DINT", "description": "Limits the number of characters output at the OUT parameter. SIZE > 0: GetSymbolPath returns the first SIZE characters of the name. SIZE = 0: GetSymbolPath returns the entire name. SIZE < 0: GetSymbolPath returns the last SIZE characters of the name."}], "Output": [{"name": "OUT", "type": "WSTRING", "description": "Output of the tag name of the input parameters supply."}], "InOut": []}, "how_to_use": "Specify the formal parameter at VARIABLE to read the name of the actual parameter passed at the beginning of the call path. Use SIZE to limit the output length of the tag name. Note that if the name is truncated, the character \"...\" (Unicode 16#2026) is appended to indicate truncation. It is not allowed to call GetSymbolPath directly in an OB and calling it cyclically is discouraged due to runtime overhead. Typical usage scenarios include error detection or startup routines.", "example_code": "(* FB_Level_1 is called from OB1, FB_Level_2 is called from FB_Level_1. GetSymbolPath is executed in FB_Level_2 to read the name of the parameter passed to REQ2. *)\nVAR\n  OUT : WSTRING;\nEND_VAR\n\nGetSymbolPath(VARIABLE := REQ2, SIZE := 0, OUT => OUT);", "additional_info": "Calling GetSymbolPath increases code memory usage and runtime depending on the frequency of calls and the number of blocks in the call stack at the time of the call. It should not be used in cyclic calls to avoid performance penalties. If a data block tag is used for input parameters, the output includes the DB name and access path to the structured tag; if a PLC tag is used, the PLC tag name is output; if a constant is used, this constant is output.", "generated_brief": {"functional_summary": "GetSymbolPath reads and returns the name of the actual parameter passed at the start of a call path corresponding to a specified formal parameter in PLC block calls.", "usage_context": "It is typically used for error detection or startup routines to identify input parameters without being called cyclically or in organizational blocks to avoid performance overhead."}, "generated_keywords": ["read parameter name", "call path parameter", "symbol path retrieval", "error detection", "startup routines"]}
{"instruction_name": "Get_AlarmState", "description": "Use the instruction \"Output alarm status\" to output the alarm status of a program alarm. The output of the alarm status always refers to a program alarm that was created using the instruction \"Generate program alarm with associated values\". The program alarm is selected with the Alarm input parameter. Specify the instance DB of the instruction \"Generate program alarm with associated values\" at the parameter Alarm. The alarm status is returned in a byte via the AlarmState output parameter. The meaning of the individual bits is shown in the documentation. The execution status of the instruction is shown with the output parameters Error and STATUS.", "parameters": {"Input": [{"name": "Alarm", "type": "ALARM_BASE", "description": "Instance of the instruction \"Generate program alarm with associated values\". Alarm.Messagetype can be Alarm_AP, Notify_AP, or Inforeport_AP. Signal states of bits Ac and Ag vary based on the type and status of the alarm."}], "Output": [{"name": "AlarmState", "type": "BYTE", "description": "Status of the alarm as a bit array."}, {"name": "Error", "type": "BOOL", "description": "Status parameter: 0 = No error, 1 = An error occurred during execution of the instruction."}, {"name": "STATUS", "type": "WORD", "description": "Status parameter providing detailed execution status. The parameter is only set for the duration of one call and should be copied to a free data area to be displayed."}], "InOut": []}, "how_to_use": "Call the instruction with the Alarm parameter set to the instance of the \"Generate program alarm with associated values\" instruction. Monitor the AlarmState output to determine the status of the alarm. Use the Error and STATUS outputs to verify correct execution and check for errors.", "example_code": "FUNCTION_BLOCK FB_AlarmStatus\nVAR_INPUT\n    Alarm : ALARM_BASE; // Instance of Generate program alarm with associated values\nEND_VAR\nVAR_OUTPUT\n    AlarmState : BYTE;\n    Error : BOOL;\n    STATUS : WORD;\nEND_VAR\n// Call the instruction\nGet_AlarmState(ALARM:=Alarm, AlarmState=>AlarmState, Error=>Error, STATUS=>STATUS);\nEND_FUNCTION_BLOCK", "additional_info": "The STATUS output parameter provides error codes such as 8001 (Invalid static alarm instance), 8002 (Invalid alarm ID), and 8003 (No active alarms within the alarm class). These codes should be used to diagnose issues. The AlarmState bits correspond to different alarm statuses: Incoming, Outgoing, and Acknowledged. If the alarm is not active, bit S always has the signal state 0.", "generated_brief": {"functional_summary": "The Get_AlarmState instruction retrieves the current status of a program alarm instance as a bit-encoded byte along with execution error information.", "usage_context": "It is used in industrial PLC programs to monitor and verify the condition and execution status of alarms generated by the system for fault detection and process management."}, "generated_keywords": ["alarm status retrieval", "program alarm monitoring", "alarm error diagnosis", "alarm state byte output", "PLC alarm instruction"]}
{"instruction_name": "SET_TIMEZONE", "description": "Use the instruction \"SET_TIMEZONE\" to set the parameter for the local time zone and the daylight saving / standard time changeover. The settings which are carried out with the instruction \"SET_TIMEZONE\" correspond with the settings for the time-of-day in the properties of the CPU. Define the corresponding parameters in the system data type TimeTransformationRule for execution of the instruction \"SET_TIMEZONE\". The local time is calculated based on the system time using the settings for the time zone and the daylight saving / standard time changeover. The system time of the CPU is the UTC time. The system time is used exclusively for communication within the system.", "parameters": {"Input": [{"name": "REQ", "type": "BOOL", "description": "S7-1200: The function is executed on a positive edge of REQ. S7-1500 and version of SET_TIMEZONE < V2.0: When REQ=1, the function is executed. S7-1500 and version of SET_TIMEZONE >= V2.0: The function is executed on a positive edge of REQ. The execution of the function means that the transfer of the time zone and writing of the load memory are started."}, {"name": "TimeZone", "type": "TimeTransformationRule", "description": "You interconnect the TimeTransformationRule system data type at parameter TimeZone."}], "Output": [{"name": "DONE", "type": "BOOL", "description": "Status parameter: 0: Job not yet started or still in progress; 1: Job completed without error"}, {"name": "BUSY", "type": "BOOL", "description": "Status parameter: 0: Job not yet started or already completed; 1: Job not yet completed. A new job cannot be started."}, {"name": "ERROR", "type": "BOOL", "description": "Status parameter: 0: No error; 1: Error occurred"}, {"name": "STATUS", "type": "WORD", "description": "Detailed error and status information is output at the parameter STATUS. The parameter is only set for the duration of one call. To display the status, you should therefore copy the STATUS parameter to a free data area."}], "InOut": []}, "how_to_use": "Call the instruction once every time the time zone has to be changed, for example in a startup OB. When the input parameter REQ returns TRUE, the data is transferred and the CPU internal load memory is updated to reflect the new time zone settings, applying even after power failure. The instruction is level-triggered or edge-triggered depending on CPU and firmware version. After successful processing, REQ is automatically reset to FALSE. Monitor BUSY, DONE, ERROR, and STATUS outputs to check execution status.", "example_code": "VAR\n  execute : BOOL := TRUE;\n  timezone : TimeTransformationRule;\n  modeDONE : BOOL;\n  modeBUSY : BOOL;\n  modeERROR : BOOL;\n  statusTime : WORD;\nEND_VAR\n\n// Initialize TimeTransformationRule parameters here\n// Call the SET_TIMEZONE instruction\nSET_TIMEZONE(\n  REQ := execute,\n  TimeZone := timezone,\n  DONE => modeDONE,\n  BUSY => modeBUSY,\n  ERROR => modeERROR,\n  STATUS => statusTime\n);\n\n// Automatic resetting of execute handled internally after DONE\n", "additional_info": "The instruction writes data internally to the CPU load memory and retains it across power failures, so calling SET_TIMEZONE again is unnecessary unless the time zone changes. It can only be used with S7-1500 CPUs starting from firmware version V1.7. The TimeTransformationRule data type must be properly configured; invalid structures cause error code 808F in STATUS. Common STATUS error codes include 7000 to 80C3 specifying job states and errors.", "generated_brief": {"functional_summary": "The SET_TIMEZONE instruction configures the CPU's local time zone and daylight saving/standard time changeover by updating the CPU's internal load memory based on a specified TimeTransformationRule.", "usage_context": "It is typically called once during system startup or whenever the time zone settings need to be changed to ensure the CPU uses correct local time information even after power cycles."}, "generated_keywords": ["set time zone", "daylight saving time adjustment", "CPU local time configuration", "TimeTransformationRule parameter", "persistent time settings"]}
{"instruction_name": "ASI_CTRL", "description": "Using the instruction \"ASI_CTRL\", the behavior of the AS-i master is controlled from the user program of the PLC. The instruction processes the command protocol automatically. It also enables parameter assignment on SIMATIC AS-i masters and reading out information data. The functions and operation of the command interface are detailed in the manual for the AS-i master. Both centrally inserted AS-i masters and distributed AS-i masters via PROFIBUS DP are supported. Combinations with PROFINET IO (e.g. IE/PB Link PN IO) are also possible.", "parameters": {"Input": [{"name": "REQ", "type": "BOOL", "description": "REQ = TRUE starts a new job unless a job is already in progress. No edge evaluation takes place."}, {"name": "LADDR", "type": "HW_IO", "description": "Hardware identifier of the AS-i master. You can obtain the address from the module properties."}, {"name": "SD", "type": "VARIANT", "description": "Send buffer. The parameter refers to a memory area in which the command is to be specified (see \"ASi commands\")."}, {"name": "RD", "type": "VARIANT", "description": "Receive buffer. This buffer is only relevant for commands which deliver answer data. The parameter refers to a memory area in which a command response is stored (see \"ASi commands\")."}], "Output": [{"name": "DONE", "type": "BOOL", "description": "DONE = TRUE: Job completed without errors."}, {"name": "BUSY", "type": "BOOL", "description": "BUSY = TRUE: Job in process."}, {"name": "ERROR", "type": "BOOL", "description": "ERROR = TRUE: Job aborted with error."}, {"name": "STATUS", "type": "DWORD", "description": "Job status / error code. See the \"STATUS parameter\" description."}], "InOut": []}, "how_to_use": "The instruction ASI_CTRL is an asynchronous function block. A job is started by setting REQ = TRUE unless a job is already running. BUSY indicates that a job is in progress. STATUS changes according to the job state: 00700100H on first call with REQ=TRUE, 00700200H on subsequent calls. Upon job completion, DONE is set if no error occurred and ERROR is set in case of an error. The parameters LADDR, SD, and RD must not change during job processing and must remain constant. The instruction cannot be interrupted and must not be called from interrupting OBs simultaneously.", "example_code": "", "additional_info": "Version V1.3 (and V1.2) of ASI_CTRL require version V1.1 of WRREC instruction. When using ASI_CTRL to send commands, no other commands may be sent simultaneously to the same AS-i master using RDREC or WRREC. Calls must not be programmed in priority classes that interrupt each other. STATUS codes provide detailed job states and error codes; interpretation is necessary for diagnostics.", "generated_brief": {"functional_summary": "The ASI_CTRL instruction controls the AS-i master from the PLC program by processing command protocols, enabling parameter assignment, and reading information data asynchronously.", "usage_context": "It is used when managing and communicating with centrally or distributed AS-i masters within industrial automation systems, including those connected via PROFIBUS DP or PROET IO."}, "generated_keywords": ["AS-i master control", "PLC command protocol", "asynchronous job processing", "parameter assignment", "PROFIBUS DP communication"]}
{"instruction_name": "Chars_TO_Strg", "description": "With the \"Chars_TO_Strg\" instruction you copy characters from an Array of CHAR or Array of BYTE to a character string of the data type STRING or from an ARRAY of WCHAR or Array of WORD to a character string of the data type WSTRING. For the copy operation only ASCII characters are valid. Specify the characters of the Array of (W)CHAR / BYTE / WORD that will be copied to a character string at the input parameter CHARS. The characters are written at the parameter STRG to a (W)STRING data type. The number of characters in the string is at least the same number as were copied from the source field. If the character string is shorter than the number of characters in the source field, the characters are written up to the maximum length of the string. If the Array of CHAR / BYTE contains a \"$00\" character or if the Array of WCHAR / WORD contains a W#16#0000 character, the copy operation is only carried out up to the corresponding position. Using the PCHARS parameter, specify the position of the source field as of which the characters will be copied. PCHARS = 0 is the default value and always specifies the lower index limit of the array even if this is negative. If an index is specified at parameter PCHARS and the index is not contained in the copy source (e.g. \"7\" at Array [0..5] of CHAR) then the instruction is not executed.", "parameters": {"Input": [{"name": "CHARS", "type": "VARIANT", "description": "Source of the copy operation. Array of (W)CHAR / BYTE / WORD from which the characters are copied."}, {"name": "PCHARS", "type": "DINT", "description": "Position in the Array of (W)CHAR / BYTE / WORD starting at which the characters are copied."}, {"name": "CNT", "type": "UINT", "description": "Number of characters to be copied. Use \"0\" to copy all characters."}], "Output": [{"name": "STRG", "type": "STRING, WSTRING", "description": "Destination of the copy operation. Character string with the (W)STRING data type. STRING supports up to 254 characters. WSTRING supports 254 characters (default) or up to 16382 characters if explicitly defined with square brackets."}], "InOut": []}, "how_to_use": "Define the source array of characters (CHAR, BYTE, WCHAR, or WORD) and specify it in CHARS. Set PCHARS to the starting index in the source array to begin copying (0 by default). Set CNT to the number of characters to copy; use 0 to copy all. The copied characters are written into STRG, a STRING or WSTRING variable. Ensure that the target string length is sufficient. Note that if CHARS contains null characters ($00 for CHAR/BYTE or W#16#0000 for WCHAR/WORD), copying stops at the null character. For S7-1200 up to Version 2.0, negative index limits in arrays are not supported, and only arrays starting at 0 or positive indices may be used.", "example_code": "VAR\n    inputArrayCHARS: ARRAY[0..9] OF CHAR;\n    pointerCHARS: DINT := 2;\n    countCHARS: UINT := 0;\n    outputSTRG: STRING[254];\nEND_VAR\n\n// Copy characters starting from index 2 to the string, copying all characters\nChars_TO_Strg(CHARS := inputArrayCHARS, PCHARS := pointerCHARS, CNT := countCHARS, STRG => outputSTRG);", "additional_info": "If PCHARS specifies an index outside the bounds of the source array, the instruction is not executed. When using WSTRING, explicitly define the length if it exceeds 254 characters (e.g., WSTRING[16382]). For S7-1200 versions prior to 2.0, arrays with negative indices are not permissible and this is not checked automatically. Only ASCII characters are copied in the operation.", "generated_brief": {"functional_summary": "The Chars_TO_Strg instruction copies characters from an array of CHAR, BYTE, WCHAR, or WORD into a STRING or WSTRING variable, handling ASCII characters and stopping on null characters if present.", "usage_context": "It is typically used in PLC programs to convert character arrays into string variables for text processing or communication tasks where string manipulation is required."}, "generated_keywords": ["character array to string conversion", "copy CHAR BYTE WCHAR WORD to STRING WSTRING", "ASCII character copying", "null-terminated string handling", "string manipulation in PLC"]}
{"instruction_name": "DataLogCreate", "description": "With the \"DataLogCreate\" instruction you create a data log. The data log is saved on the memory card or in the internal load memory in the directory \"\\DataLogs\". The amount of data that is stored in a data log is dependent on the available space on the memory card or the storage space in the internal load memory of the CPU used. The maximum size of the generated CSV file is 500,000,000 bytes for S7-1200 CPUs, 1,000,000,000 bytes for S7-1500 CPUs. You specify the maximum number of data records that is stored in a data log in the RECORDS parameter. When the specified maximum number of data records in the data log is reached, the oldest data record is overwritten. To avoid overwriting of existing data records, use the \"DataLogNewFile\" instruction. The instruction is used to create a new data log with the same structure when the number specified at the RECORDS parameter is reached (return value 1 at the STATUS parameter of the \"DataLogWrite\" instruction). The data records are then saved in the new data log. You specify the name for the data log in the NAME parameter. The data log is created in CSV (Comma Separated Value) format. With the HEADER parameter, you create an (optional) header for the data log. Once the data log is created, it is opened automatically. This means that data can be written.", "parameters": {"Input": [{"name": "REQ", "type": "BOOL", "description": "Execution of the instruction. The data log is created with a rising edge at the parameter REQ."}, {"name": "RECORDS", "type": "UDInt", "description": "Maximum number of data records in the data log. If the \"DataLogWrite\" instruction writes more records than specified in this parameter, the oldest record is overwritten."}, {"name": "FORMAT", "type": "UInt", "description": "Data format: 0: Internal (not supported), 1: CSV (Comma separated values)"}, {"name": "TIMESTAMP", "type": "UInt", "description": "Time-stamping; the extra columns in the header are automatically added if time-stamping is activated."}, {"name": "NAME", "type": "VARIANT", "description": "Name of the data log. The specified name is also used as a file name for the csv file. Restrictions apply depending on CPU type: S7-1200 - max 35 characters, allowed ASCII characters except \\ ' / \" : ; [ ] | = . * ? < >; S7-1500 - max 55 characters, allowed characters 0-9, a-z, A-Z, - and _."}], "Output": [{"name": "DONE", "type": "BOOL", "description": "Status parameter: 0 = Processing not yet complete, 1 = Processing of instruction finished successfully."}, {"name": "BUSY", "type": "BOOL", "description": "Status parameter: 0 = Processing of the instruction has not started, completed, or canceled; 1 = Processing of the instruction is in progress."}, {"name": "ERROR", "type": "BOOL", "description": "Status parameter: 0 = No error; 1 = An error occurred during execution of the instruction. Detailed information is output via the STATUS parameter."}, {"name": "STATUS", "type": "WORD", "description": "Detailed status information: Detailed error and status information is output at this parameter. It is only set for the duration of one call. To display the status, copy the STATUS parameter to a free data area."}], "InOut": [{"name": "ID", "type": "DWORD", "description": "Object ID of the data log (only output). The ID of the data log is required for further data logging instructions to address the created data log."}, {"name": "HEADER", "type": "VARIANT", "description": "Header of the data log (optional). The parameter is hidden after the instruction is added. The header is written as the first line in the CSV file."}, {"name": "DATA", "type": "VARIANT", "description": "Pointer to the data structure that is written as data record when executing the \"DataLogWrite\" instruction."}]}, "how_to_use": "Activate the data log creation by setting REQ to TRUE at a rising edge. Specify the maximum number of records with RECORDS; when this number is exceeded, the oldest data is overwritten unless a new file is created using the DataLogNewFile instruction. Choose the CSV format by setting FORMAT to 1. TIMESTAMP enables time-stamping columns. The NAME parameter sets the data log file name respecting CPU-specific restrictions. Provide optional HEADER and DATA parameters pointing to the header and data block structure, respectively. The instruction automatically opens the data log after creation, allowing data to be written.", "example_code": "VAR\n  REQ : BOOL;\n  RECORDS : UDInt := 3;\n  FORMAT : UInt := 1; // CSV\n  TIMESTAMP : UInt := 1; // System time\n  NAME : VARIANT; // Pointing to string DataLogName\n  ID : DWORD; // Data log ID output\n  HEADER : VARIANT; // Pointer to header\n  DATA : VARIANT; // Pointer to data structure\n  DONE : BOOL;\n  BUSY : BOOL;\n  ERROR : BOOL;\n  STATUS : WORD;\nEND_VAR\n\nDataLogCreate(\n  REQ := REQ,\n  RECORDS := RECORD,\n  FORMAT := FORMAT,\n  TIMESTAMP := TIMESTAMP,\n  NAME := NAME,\n  ID := ID,\n  HEADER := HEADER,\n  DATA := DATA,\n  DONE => DONE,\n  BUSY => BUSY,\n  ERROR => ERROR,\n  STATUS => STATUS\n);", "additional_info": "The HEADER parameter can be a STRING, Array of BYTE, or Array of CHAR with limitations on length. The DATA parameter points to a structure or array whose elements correspond to columns in the CSV; no nested STRUCTs allowed, arrays within are allowed with some restrictions. Maximum 256 elements in DATA are supported. Error codes provide diagnostics for invalid inputs, memory issues, file name restrictions, and system limits. The created data log is stored in the \\DataLogs directory on memory card or internal memory. To prevent overwriting, use DataLogNewFile when RECORDS limit is reached.", "generated_brief": {"functional_summary": "The DataLogCreate instruction creates and opens a CSV-formatted data log file in memory with a specified maximum number of records, optional headers, and time-stamping for storing and managing process or system data.", "usage_context": "It is used in industrial automation to initialize and manage structured data recording for monitoring, diagnostics, or historical analysis within PLC-controlled systems."}, "generated_keywords": ["create data log", "CSV data logging", "data log initialization", "record limit management", "time-stamped data logging"]}
{"instruction_name": "GetSymbolName", "description": "With the \"GetSymbolName\" instruction, you use the input parameter of a block to read out the name of a tag interconnected at the VARIABLE parameter.", "parameters": {"Input": [{"name": "VARIABLE", "type": "PARAMETER", "description": "Selection of the local interface to which you want to read out the name of the input parameter supply."}, {"name": "SIZE", "type": "DINT", "description": "Limits the number of characters output at the OUT parameter.\n- SIZE > 0: GetSymbolName returns the first SIZE characters of the name.\n- SIZE = 0: GetSymbolName returns the entire name.\n- SIZE < 0: GetSymbolName returns the last SIZE characters of the name."}], "Output": [{"name": "OUT", "type": "WSTRING", "description": "Output of the tag name of the input parameters supply"}], "InOut": []}, "how_to_use": "Specify the input parameter of the block interface on the VARIABLE parameter, using only an interface parameter, no PLC or data block tags. Use the SIZE parameter to limit the length of the returned tag name; if the name is truncated, the truncated part is indicated by the characters \"...\" at the end of the output string. The read name is output at the OUT parameter. Do not call \"GetSymbolName\" directly in an OB and avoid calling it cyclically to minimize runtime impact.", "example_code": "(* Example SCL snippet to read symbol name of inputValue with length limited to 60 characters *)\nGetSymbolName( VARIABLE := inputValue, SIZE := 60, OUT => symbolName );", "additional_info": "- \"GetSymbolName\" may not be called directly in an OB.\n- An empty string is returned if the connected tag at VARIABLE is negated.\n- Use of this instruction increases code memory and runtime; avoid frequent cyclic calls.\n- A meaningful use case is calling it during error detection or startup routines.\n- If the name is truncated due to SIZE limitation, \"...\" (unicode 16#2026) is appended.\n- SIZE parameter examples:\n  - SIZE=1 returns '...'\n  - SIZE=0 returns the full name  - Larger SIZE values return the initial characters plus \"...\" if truncated.", "generated_brief": {"functional_summary": "The GetSymbolName instruction retrieves the name of a tag connected to a specified block input parameter, optionally limiting the length of the returned name.", "usage_context": "It is typically used during error detection or startup routines to identify connected tags without impacting runtime by avoiding cyclic or direct calls in organizational blocks."}, "generated_keywords": ["read tag name", "block input parameter", "limit name length", "error detection", "startup routine"]}
{"instruction_name": "Strg_TO_Chars", "description": "With the \"Strg_TO_Chars\" instruction, you copy a character string of the data type STRING to an Array of CHAR or Array of BYTE or a character string of the data type WSTRING to an Array of WCHAR or Array of WORD. Only ASCII characters are valid for the copy process.", "parameters": {"Input": [{"name": "STRG", "type": "STRING, WSTRING", "description": "Source of the copy operation"}, {"name": "PCHARS", "type": "DINT", "description": "Position in the structure Array of (W)CHAR / BYTE / WORD starting from which the characters of the character string are written."}], "Output": [{"name": "CNT", "type": "UINT", "description": "Number of moved characters"}], "InOut": [{"name": "CHARS", "type": "VARIANT", "description": "Destination of the copy operation. Copy the characters to a structure of the Array of (W)CHAR/ BYTE/ WORD data type."}]}, "how_to_use": "Specify the source character string at STRG, set PCHARS to indicate the start position in the destination array, and provide a destination array structurally compatible with CHAR, BYTE, WCHAR, or WORD data types. The number of characters copied will be output at CNT. Ensure the destination array has at least as many elements as the number of characters to copy. When PCHARS = 0, writing begins at the lowest index of the array.", "example_code": "", "additional_info": "Only ASCII characters are valid for copying. If the destination array is smaller than the source string, characters are copied up to the max destination length. If the string contains \"$00\" or W#16#0000 characters, it has no effect on copying. For S7-1200 up to Version 2.0, only arrays with positive zero-based indices ([0..n]) are supported; negative indices are not allowed though not checked by software.", "generated_brief": {"functional_summary": "The Strg_TO_Chars instruction copies an ASCII STRING or WSTRING into a specified position within an array of CHAR, BYTE, WCHAR, or WORD data types.", "usage_context": "It is typically used in PLC programming when characters from a string need to be transferred into a byte or word array for further processing or communication."}, "generated_keywords": ["string to char array", "string copy", "ascii character transfer", "wstring to wchar array", "plc string handling"]}
{"instruction_name": "RH_CTRL", "description": "The 'RH_CTRL' instruction allows you to influence R/H systems by controlling the system state, including disabling/enabling SYNCUP, requesting STOP for primary/backup CPUs, querying system state, and managing system IP addresses.", "parameters": {"Input": [{"name": "REQ", "type": "BOOL", "description": "Control parameter Request. Enables the execution of the instruction when REQ = '1'."}, {"name": "Mode", "type": "BYTE", "description": "Select the desired action for the R/H system, with various numerical values corresponding to specific commands."}, {"name": "Submode", "type": "WORD", "description": "Hidden parameter for specific modes; otherwise specifies the hardware identifier of the PROFINET interface for certain commands."}], "Output": [{"name": "Ret_Val", "type": "INT", "description": "Error code indicating the result of the operation."}, {"name": "Busy", "type": "BOOL", "description": "Status parameter where '0' indicates execution is complete and '1' indicates execution is still in progress."}]}, "how_to_use": "Start the operation by setting REQ to '1' and selecting the appropriate mode to perform specific actions on the R/H system.", "example_code": "// Call RH_CTRL to request SYNCUP \n#RetVal := RH_CTRL(REQ := 1, Mode := 7, Submode := 0, Busy => #busy);", "additional_info": "The RH_CTRL instruction processes asynchronously. Be cautious when running in commissioning scenarios without an MRP check due to potential safety risks.", "generated_brief": {"functional_summary": "The RH_CTRL instruction manages R/H system states by enabling control actions such as SYNCUP, CPU stop requests, system state queries, and IP address management.", "usage_context": "It is typically used in industrial automation environments to asynchronously control and monitor redundancy and communication parameters of R/H systems during operation or commissioning."}, "generated_keywords": ["R/H system control", "SYNCUP management", "CPU stop request", "system state query", "IP address management"]}
{"instruction_name": "RecipeExport", "description": "Transfers recipe data from a recipe data block to a CSV file on the memory card of the CPU.", "parameters": {"Input": [{"name": "Recipe Data Block", "type": "DB", "description": "The data block containing the recipe data to be exported."}], "Output": [], "InOut": []}, "how_to_use": "Use this instruction to export recipe data to a CSV file stored on the CPU's memory card. Ensure the recipe data block is correctly populated before executing the instruction.", "example_code": "", "additional_info": "The service life of memory cards is limited. Ensure that the data block is in the correct memory area (work or load memory).", "generated_brief": {"functional_summary": "The RecipeExport instruction transfers recipe data from a specified data block to a CSV file stored on the CPU's memory card.", "usage_context": "This function is used when saving or backing up recipe configurations from the PLC to external storage for record-keeping or transfer purposes."}, "generated_keywords": ["recipe data export", "data block to CSV", "memory card storage", "recipe backup", "PLC recipe transfer"]}
{"instruction_name": "RecipeImport", "description": "Transfers recipe data from a CSV file on the memory card of the CPU to a recipe data block.", "parameters": {"Input": [{"name": "CSV File", "type": "String", "description": "The path to the CSV file from which the recipe data will be imported."}], "Output": [{"name": "Recipe Data Block", "type": "DB", "description": "The data block where the imported recipe data will be stored."}], "InOut": []}, "how_to_use": "Use this instruction to import recipe data from a CSV file into a designated recipe data block. Make sure the CSV file is formatted correctly.", "example_code": "", "additional_info": "Ensure that the delimiter used in the CSV file is not included in any character strings. Monitor possible errors during import related to delimiters.", "generated_brief": {"functional_summary": "The RecipeImport instruction transfers recipe data from a CSV file stored on the CPU memory card into a specified recipe data block.", "usage_context": "This function is used when importing and updating recipe data within a PLC program to ensure proper process control based on predefined settings."}, "generated_keywords": ["import recipe data", "CSV file transfer", "recipe data block", "PLC recipe update", "data import from memory card"]}
{"instruction_name": "ACK_FCT_WARN", "description": "You can use the \"ACK_FCT_WARN\" instruction to acknowledge the message in the diagnostic buffer that warns you about exceeding the F-cycle time. The F-cycle time is the maximum time that may pass between two F-OB calls. If the instruction at input parameter \"ACK_WARN\" detects a rising edge, the warning message is acknowledged. In all other cases it is not acknowledged.", "parameters": {"Input": [{"name": "ACK_WARN", "type": "BOOL", "description": "Acknowledgment of the warning message on rising edge"}], "Output": [], "InOut": []}, "how_to_use": "Use this instruction by providing a BOOL rising edge signal at the input parameter ACK_WARN to acknowledge the warning message related to exceeding the F-cycle time in the diagnostic buffer. Ensure the input detects a rising edge for the acknowledgment to occur.", "example_code": "", "additional_info": "More information on the F-cycle time can be found in the \"SIMATIC Safety - Configuring and Programming\" Operating Manual.", "generated_brief": {"functional_summary": "The ACK_FCT_WARN instruction acknowledges a diagnostic warning message about exceeding the F-cycle time when a rising edge is detected on the ACK_WARN input.", "usage_context": "It is typically used in PLC programs to clear warnings related to timing violations of the maximum allowed interval between consecutive F-OB calls in safety applications."}, "generated_keywords": ["acknowledge warning", "F-cycle time exceeded", "diagnostic buffer", "rising edge detection", "F-OB call timing"]}
{"instruction_name": "GetBlockName", "description": "You can use the \"GetBlockName\" instruction to read the name of the block in which the instruction is called. If the length of the block name is to be limited to a certain number of characters, specify the max. length at the SIZE parameter. If the name has been truncated, this is indicated by the character \"...\" (Unicode character 16#2026) at the end of the name. Note that this character has the length 1. The name of the block is written at the RET_VAL parameter. If the name of the block is longer than the maximum length of WSTRING, the name is truncated.", "parameters": {"Input": [{"name": "SIZE", "type": "DINT", "description": "Limits the number of characters output at the RET_VAL parameter. SIZE > 0: GetBlockName returns the first SIZE characters of the name. SIZE = 0: GetBlockName returns the entire name. SIZE < 0: GetBlockName returns the last SIZE characters of the name."}], "Output": [{"name": "RET_VAL", "type": "WSTRING", "description": "Read name of the program block"}], "InOut": []}, "how_to_use": "Use the GetBlockName instruction in the block whose name you want to read. Connect the SIZE input with an integer defining the maximum number of characters to return (0 for no limit). The block name is returned in the RET_VAL output parameter as a WSTRING. If the block name is longer than SIZE, the returned string is truncated and ends with \"...\" (Unicode character 16#2026) indicating truncation.", "example_code": "VAR\n  limitSIZE : DINT := 0;\n  outputBlockName : WSTRING;\nEND_VAR\n\nGetBlockName(\n  SIZE := limitSIZE,\n  RET_VAL => outputBlockName\n);", "additional_info": "When truncating, the \"...\" character uses length 1 in the WSTRING. SIZE parameter values control whether the first or the last characters are returned when truncation is applied Valid data types for SIZE include input, output, memory areas I, Q, M, D, L or constants.", "generated_brief": {"functional_summary": "The GetBlockName instruction retrieves the name of the program block in which it is called, optionally limiting or truncating the length of the returned name.", "usage_context": "It is used when a program needs to dynamically identify or log the name of its current block for diagnostic, monitoring, or organizational purposes."}, "generated_keywords": ["get block name", "read program block name", "block name truncation", "dynamic block identification", "retrieve block name string"]}
{"instruction_name": "GetInstanceName", "description": "You can use the 'GetInstanceName' instruction to read the name of the instance data block within a function block.", "parameters": {"Input": [{"name": "SIZE", "type": "DINT", "description": "Limits the number of characters output at the OUT parameter. SIZE > 0: GetInstanceName returns the first SIZE characters of the name. SIZE = 0: GetInstanceName returns the entire name. SIZE < 0: GetInstanceName returns the last SIZE characters of the name."}], "Output": [{"name": "OUT", "type": "WSTRING", "description": "Read name of the instance data block."}], "InOut": []}, "how_to_use": "To limit the length of the read instance name, use the SIZE parameter.", "example_code": "In the following example, you read out the name of an instance data block. Create two tags in a global data block for storing the data...", "additional_info": "The instruction 'GetInstanceName' may not be called directly in an OB. The use of GetInstanceName leads to an increased code memory requirement and runtime increase, and it is recommended not to call it cyclically.", "generated_brief": {"functional_summary": "GetInstanceName reads the name of the instance data block within a function block, optionally limiting the length of the output string.", "usage_context": "It is used when you need to retrieve and possibly truncate the instance name for identification or diagnostic purposes outside of cyclic calls to avoid increased memory and runtime overhead."}, "generated_keywords": ["read instance name", "function block instance", "limit name length", "instance data block", "non-cyclic usage"]}
{"instruction_name": "ModuleStates", "description": "You can use the \"ModuleStates\" instruction to read the status information of the modules of a PROFINET IO device or PROFIBUS DP slave. The Boolean value that is output indicates the modules to which the selected status applies. You can, for example, read which modules are currently disabled in a PROFINET IO device. Information is also displayed as to whether the status information to be read applies to at least one of the modules. The instruction can be called in a OB as well as in an interrupt OB (e.g. OB82 - diagnostic interrupt).", "parameters": {"Input": [{"name": "LADDR", "type": "HW_DEVICE", "description": "Hardware identifier of the station (see description below). You select the IO device or the DP slave at the LADDR parameter by means of the hardware identifier of the station. The hardware identifier is available either in the network view of the properties of the IO device station or DP slave station, or in the PLC tag table for the listed system constants with the data type HW_DEVICE (for an IO device) or with the data type HW_DPSLAVE (for a DP slave)."}, {"name": "MODE", "type": "UINT", "description": "Selection of module status information to be read. One of the following status information items can be read for the modules: 1: Modules are configured, 2: Modules are faulty, 3: Modules are disabled, 4: Modules exist, 5: There is a problem in the modules (e.g. maintenance demanded or recommended, not accessible, not available, error occurred)."}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Status of instruction. Possible values include: 0 (No error), 8091 (Hardware identifier of the LADDR parameter does not exist), 8092 (LADDR does not address an IO device or DP slave), 8093 (Invalid data type at the STATE parameter), 80B1 (The instruction \"ModuleStates\" is not supported by the CPU), 80B2 (The selected MODE is not supported by the used CPU), 8452 (The complete status information does not fit in the tag configured in the STATE parameter"}], "InOut": [{"name": "STATE", "type": "VARIANT", "description": "Buffer for the module status. Outputs the status of the modules selected with the MODE parameter. If the status selected using MODE applies to a module, bit 0 set to 1 if at least one module is affected. Bit n represents the module in slot n-1 (e.g., bit 3 corresponds to slot 2). Use BOOL to output only the group display bit, or an Array of BOOL (length 128 bits) to output status for all modules."}]}, "how_to_use": "Call the ModuleStates instruction cyclically or in an interrupt OB to read status information of modules in PROFINET IO devices PROFIBUS DP slaves. Pass the hardware identifier of the device in LADDR, select the status information with MODE, provide a VARIANT buffer (BOOL or Array of BOOL) for STATE, and check RET_VAL for execution status. Ensure that the STATE buffer is sufficiently sized to avoid errors.", "example_code": "(* Example to query modules existence in a PROFINET IO device *)\nVAR\n  myLADDR : HW_DEVICE; (* Hardware identifier of IO device *)\n  myMODE : UINT := 4; (* MODE=4 to check module existence *)\n  mySTATE : ARRAY[0..127] OF BOOL; (* Buffer for module status *)\n  returnValue : INT;\nEND_VAR\n\nreturnValue := ModuleStates(LADDR := myLADDR, MODE := myMODE, STATE := mySTATE);", "additional_info": "When the tag configured at STATE is checked for adequate field length, the CountOfElements instruction is called. This counts the fill elements when VARIANT points to an Array of BOOL. An Array[0..120] of BOOL results in 128 as the field length. Error code W#16#8452 is only returned when the number of actual elements plus fill elements is less than 128. Use valid data types as specified. The instruction is not supported by all CPUs.", "generated_brief": {"functional_summary": "The ModuleStates instruction reads status information about the modules of PROFINET IO devices or PROFIBUS DP slaves, providing details such as whether modules are configured, faulty, disabled, exist, or have problems via a Boolean status output.", "usage_context": "It is typically used cyclically or within interrupt OBs to monitor and diagnose the condition of device modules in industrial automation networks for maintenance or error handling purposes."}, "generated_keywords": ["read module status", "PROFINET IO device monitoring", "PROFIBUS DP slave diagnostics", "cyclic status polling", "module error detection"]}
{"instruction_name": "RTM", "description": "You can use this instruction to set, start, stop, and read out a 32-bit operating hours counter of your CPU. Ensure that the operating hours counter can also be stopped or restarted during execution of the user program, which may render the saved values incorrect.", "parameters": {"Input": [{"name": "NR", "type": "RTM", "description": "Number of the operating hours counter. Numbering starts with 0. Refer to the technical specifications for the number of operating hours counters of your CPU."}, {"name": "MODE", "type": "BYTE", "description": "Job ID:\n0: Read out (the status is then written to CQ and the current value to CV). After the operating hours counter has reached (2^31) - 1 hours, it stops at the highest value and outputs an \"Overflow\" error.\n1: start (at the last counter value)\n2: stop\n4: set to the value specified in the parameter PV\n5: set to the value specified in the parameter PV and start\n6: set to the value specified in the parameter PV and stop"}, {"name": "PV", "type": "DINT", "description": "New value for the operating hours counter"}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "If an error occurs during execution, this return value contains an error code."}, {"name": "CQ", "type": "BOOL", "description": "Status of the operating hours counter (1: running)"}, {"name": "CV", "type": "DINT", "description": "Current value of the operating hours counter"}], "InOut": []}, "how_to_use": "To use the RTM instruction, specify the operating hours counter number in NR, select the job mode in MODE according to the intended action (read, start, stop, set, etc.), and provide any new value in PV if setting or starting with a specific value is needed. Monitor RET_VAL for error codes, CQ for running status, and CV for the current counter value. Note that the operating hours counter can be stopped or restarted during program execution, which may affect saved values.", "example_code": "(* Example SCL snippet for RTM usage *)\nVAR\n    execute: BOOL;\n    comandMODE: BYTE;\n    in_processValue: DINT;\n    currentValue: DINT;\n    statusRTM: BOOL;\n    returnValue: INT;\n    counterNumber: RTM := 0; (* Operating hours counter 0 *)\nEND_VAR\n\nIF execute THEN\n    RTM(NR := counterNumber, MODE := comandMODE, PV := in_processValue, RET_VAL => returnValue, CQ => statusRTM, CV => currentValue);\n    (* Start counter with value in_processValue and then read current value by setting comandMODE to 0 *)\nEND_IF;", "additional_info": "Error codes for RET_VAL:\n0000: No error\n8080: Wrong number for operating hours counter\n8081: Negative value passed to PV\n8082: Overflow of the counter\n8091: Invalid MODE value\nRefer to GET_ERR_ID for detailed error evaluation.", "generated_brief": {"functional_summary": "The RTM instruction manages a 32-bit operating hours counter by allowing reading, starting, stopping, and setting its value in a CPU-controlled system.", "usage_context": "It is typically used in industrial automation to track and control the operating time of machines or equipment for maintenance and monitoring purposes."}, "generated_keywords": ["operating hours counter", "start stop counter", "read counter value", "set counter value", "error handling"]}
{"instruction_name": "S_MOVE", "description": "You can use this instruction to write the content of a character string (W)STRING from parameter IN to the data area that you specify at parameter OUT.", "parameters": {"Input": [{"name": "IN", "type": "STRING, WSTRING", "description": "Source string"}], "Output": [{"name": "OUT", "type": "STRING, WSTRING", "description": "Destination string"}], "InOut": []}, "how_to_use": "To use this instruction, provide a source character string to the IN parameter and specify a destination for the output string at the OUT parameter.", "example_code": "stringValueOUT := S_MOVE(stringValueIN);", "additional_info": "To copy tags of data type ARRAY, use the 'MOVE_BLK' and 'UMOVE_BLK' instructions.", "generated_brief": {"functional_summary": "The S_MOVE instruction copies the content of a source character string (STRING or WSTRING) to a specified destination string variable.", "usage_context": "It is typically used when transferring or duplicating string data within PLC programs during industrial control operations."}, "generated_keywords": ["string copy", "character string move", "S_MOVE instruction", "string data transfer", " string manipulation"]}
{"instruction_name": "GADR_LGC", "description": "You use the \"GADR_LGC\" instruction to determine the hardware identifier of a signal module. The hardware identifier is determined from the module slot and the offset in the user data address area of the module.", "parameters": {"Input": [{"name": "SUBNETID", "type": "BYTE", "description": "Area ID: 0: If the slot is located in the central module; 1 to 32: DP master system ID of the corresponding distributed I/O system if the slot is in a distributed I/O device; 100 to 115: PROFINET IO system ID of the associated field device if the slot is located in a field device on PROFINET"}, {"name": "RACK", "type": "WORD", "description": "Number of the rack, if area identifier is 0; Device number of the distributed I/O device if the area identifier > 0"}, {"name": "SLOT", "type": "WORD", "description": "Slot no."}, {"name": "SUBSLOT", "type": "BYTE", "description": "Irrelevant"}, {"name": "SUBADDR", "type": "WORD", "description": "Offset in the user data address area of the module"}], "Output": [{"name": "IOID", "type": "BYTE", "description": "The IOID output parameter is not written (always \"0\")."}, {"name": "LADDR", "type": "HW_MODULE", "description": "Hardware identifier of the module"}], "InOut": [{"name": "RET_VAL", "type": "INT", "description": "Error information"}]}, "how_to_use": "Use the \"GADR_LGC\" instruction by providing the SUBNETID, RACK, SLOT, SUBSLOT, and SUBADDR inputs to retrieve the hardware identifier of a module in LADDR. Check RET_VAL for error codes to ensure the call was successful. Note that this instruction cannot be used for modules behind gateways; instead use \"GEO2LOG\" in such cases.", "example_code": "", "additional_info": "The instruction cannot be used for modules behind gateways (e.g., IE/PB link); use the \"GEO2LOG\" instruction instead. RET_VAL returns specific error codes such as 0000 (no error), 8094 (no subnet configured with specified SUBNETID 8095 (illegal RACK value), 8096 (illegal SLOT value), 8098 (illegal SUBADDR value), and general error information. Refer to related instructions for address conversion and error handling.", "generated_brief": {"functional_summary": "The GADR_LGC instruction retrieves the hardware identifier of a signal module based on its subnet ID, rack, slot, subslot, and data address offset.", "usage_context": "It is used in PLC programs to determine module hardware identifiers within centrally or distributed I/O systems, except for modules behind gateways where a different instruction is required."}, "generated_keywords": ["hardware identifier retrieval", "module address resolution", "subnet rack slot mapping", "PLC module identification", "signal module hardware ID"]}
{"instruction_name": "GEO2LOG", "description": "You use the \"GEO2LOG\" instruction to determine hardware identifier based on slot information that you define using the system data type GEOADDR. Depending on the type of hardware you define at the parameter HWTYPE the following information is evaluated from the other parameters GEOADDR: When HWTYPE = 1 (IO system): Only IOSYSTEM is evaluated. The other parameters of GEOADDR are not taken into consideration. The hardware identifier of the IO system is output. When HWTYPE = 2 (IO device): IOSYSTEM and STATION are evaluated. The other parameters of GEOADDR are not taken into consideration. The hardware identifier of the IO device is output. With HWTYPE 4 (module): IOSYSTEM, STATION and SLOT are evaluated. The SUBSLOT parameter of GEOADDR is not taken into consideration. The hardware identifier of the module is output. With HWTYPE = 5 (submodule): All parameters of GEOADDR are evaluated. The hardware identifier of the submodule is output. The AREA parameter of the GEOADDR system data type is not evaluated.", "parameters": {"Input": [{"name": "GEOADDR", "type": "VARIANT", "description": "Pointer to the structure of the GEOADDR system data type. The system data type contains the slot information from which the hardware ID is determined."}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Output of error information."}, {"name": "LADDR", "type": "UINT / HW_ANY", "description": "Hardware identifier of the assembly or the module. The number is automatically assigned."}], "InOut": []}, "how_to_use": "To use the GEO2LOG instruction, provide a pointer to the GEOADDR structure containing the slot and hardware type information. The instruction evaluates different parts of the GEOADDR structure based on the HWTYPE parameter to determine the hardware ID. The hardware ID is output to LADDR, and any errors in parameters are indicated in RET_VAL. Note that the AREA parameter of GEOADDR is not evaluated. Typical HWTYPE values are 1 for IO system, 2 for IO device, 4 for module, and 5 for submodule. Properly initialize the GEOADDR data structure before calling the instruction.", "example_code": "VAR\n  geoAddr : GEOADDR;\n  laddr : UINT;\n  returnValue : INT;\nEND_VAR\n\n// Set the GEOADDR parameters\ngeoAddr.HWTYPE := 4;      // Module\ngeoAddr.IOSYSTEM := 0;    // Central controller\ngeoAddr.STATION := 0;     // Rack 0\ngeoAddr.SLOT := 1;        // Slot 1\ngeoAddr.SUBSLOT := 0;     // Not evaluated for HWTYPE=4\n\n// Execute GEO2LOG to get hardware ID\nGEO2LOG(GEOADDR := geoAddr, LADDR => laddr, RET_VAL => returnValue);", "additional_info": "Error codes returned in RET_VAL indicate specific invalid parameter values in GEOADDR: 0 means no error; 8091 for invalid HWTYPE; 8094 for invalid IOSYSTEM; 8095 for invalid STATION; 8096 for invalid SLOT; 8097 for invalid SUBSLOT. Display formats for error codes can be switched in the program editor. The hardware identifier output is automatically assigned by the system based on the input slot data.", "generated_brief": {"functional_summary": "The GEO2LOG instruction determines the hardware identifier based on slot and hardware type information provided in a GEOADDR structure.", "usage_context": "It is used in PLC programs to map physical IO system components, devices, modules, or submodules to their unique hardware IDs for addressing and configuration purposes."}, "generated_keywords": ["hardware identifier", "GEOADDR slot mapping", "HWTYPE evaluation", "IO system addressing", "module and submodule ID"]}
{"instruction_name": "Gen_UsrMsg", "description": "You use the 'Gen_UsrMsg' instruction to generate an alarm that is entered in the diagnostic buffer.", "parameters": {"Input": [{"name": "Mode", "type": "UInt", "description": "Parameters for selecting the status of the alarm: 1 for incoming alarm, 2 outgoing alarm."}, {"name": "TextID", "type": "UInt", "description": "ID of the text list entry that should be used for the alarm text."}, {"name": "TextListID", "type": "UInt", "description": "ID of the text list that contains text list entry."}], "Output": [{"name": "Ret_Val", "type": "Int", "description": "Error code of the instruction."}], "InOut": [{"name": "AssocValues", "type": "AssocValues", "description": "Pointer to the system data type AssocValues that allows you to define the associated values."}]}, "how_to_use": "To use this instruction, initialize the required parameters such as Mode, TextID, and TextListID appropriately. Make sure to define associated values following the specified format in the text list entry.", "example_code": "Gen_UsrMsg(\n    Mode := myMODE,\n    TextListID := 'myLIST',\n    TextID := 'myTEXT',\n    AssocValues := AssocValues,\n    RetVal => returnValue\n);", "additional_info": "The associated values are limited to a maximum of 8, and avoid using the numbers '1' or '2' for addressing associated values as they are reserved.", "generated_brief": {"functional_summary": "The Gen_UsrMsg instruction generates an alarm entry in the diagnostic buffer with specified status and associated text information.", "usage_context": "It is used in industrial control systems to create custom alarms for monitoring and diagnostics based on predefined text lists and parameterized associated values."}, "generated_keywords": ["generate alarm", "diagnostic buffer", "custom alarm", "text list entry", "associated values"]}
{"instruction_name": "GetInstancePath", "description": "You use the 'GetInstancePath' instruction to read the composed global name of the block instance within a function block. The composed global name of the block instance is the path of the complete call hierarchy when multi-instances are used.", "parameters": {"Input": [{"name": "SIZE", "type": "DINT", "description": "Limits the number of characters output at the OUT parameter. SIZE > 0: GetInstancePath returns the first SIZE characters of the name. SIZE = 0: GetInstancePath returns the entire name. SIZE < 0: GetInstancePath returns the last SIZE characters of the name."}], "Output": [{"name": "OUT", "type": "WSTRING", "description": "Read global name of the block instance. If the global name of the block instance is longer than the maximum length of WSTRING (254 characters), the name is truncated."}], "InOut": []}, "how_to_use": "Call 'GetInstancePath' in a function block to retrieve the global name of the block instance based on the size specified.", "example_code": "SIZE := 0;\nGetInstancePath(OUT := outputPath_Level4FB, SIZE := SIZE);", "additional_info": "The instruction may not be called directly in an OB, and it leads to an increased code memory requirement and runtime increase.", "generated_brief": {"functional_summary": "GetInstancePath retrieves the composed global name (full instance path) of a function block instance, optionally limited by a specified character size.", "usage_context": "It is used within function blocks to obtain the hierarchical call path of multi-instance blocks for identification or diagnostic purposes during runtime."}, "generated_keywords": ["get instance path", "function block instance name", "global block name retrieval", "hierarchical call path", "multi-instance identification"]}
{"instruction_name": "GetSymbolForReference", "description": "You use the \"GetSymbolForReference\" instruction to determine the name of an indirectly addressed object (i.e. an object that is addressed via a referencing data type). \"GetSymbolForReference\" is an instruction that works asynchronously, that is, the job execution can extend over multiple calls. You start the job execution by creating a rising edge at the 'execute' parameter. The output parameters busy, done, error and status indicate the status of the job.", "parameters": {"Input": [{"name": "execute", "type": "Bool", "description": "Control parameter: The job is started on a rising edge."}, {"name": "objectRef", "type": "Reference", "description": "Reference to the object whose name is to be determined."}, {"name": "size", "type": "DInt", "description": "If the determined name is shorter than 'symbol', 'size' has no meaning. If the determined name is longer than 'symbol', 'size' defines how the determined name is shortened: size > 0: returns the first 'size' characters of the name, followed by '...'. size = 0: returns as many characters as fit in 'symbol' followed by '...'. size < 0: returns the last (-1) * 'size' characters of the name, beginning with '...'."}], "Output": [{"name": "done", "type": "Bool", "description": "Status parameter: 0 = Job not yet started or still being executed. 1 = Job executed without errors (value displayed for one cycle only)."}, {"name": "busy", "type": "Bool", "description": "Status parameter: 1 = The job is not yet complete and a new job cannot be started. 0 = The job is complete."}, {"name": "error", "type": "Bool", "description": "Status parameter: error = 1 indicates an error occurred during processing, detailed information available in 'status'."}, {"name": "status", "type": "Int", "description": "Status of the job processing or error information."}, {"name": "reliability", "type": "Int", "description": "Reserved for future use."}], "InOut": [{"name": "symbol", "type": "WString", "description": "Determined name of the indirectly addressed object."}]}, "how_to_use": "To use the GetSymbolForReference instruction, initiate the job by setting a rising edge on the 'execute' input. Monitor the 'busy', 'done', and 'error' outputs to check the job status. The 'symbol' parameter will be updated asynchronously with the name of the referenced object once the job completes. Use the 'size' parameter to control how the symbol name is truncated if it exceeds the length of the 'symbol' buffer. Note that only references of data type 'DB_ANY' are supported on firmware version V3.1 of the S7-1500 CPUs, and DBs created with 'CREATE_DB' during runtime return an empty string as name.", "example_code": "", "additional_info": "Limitation: On firmware version V3.1 of S7-1500 CPUs, only references of data type 'DB_ANY' are permitted. When using GetSymbolForReference on a DB created at runtime with the 'CREATE_DB' instruction, an empty string is returned. Error codes and explanations include: 0x80C3 - maximum simultaneous instructions reached, 0x8231 - data block does not exist or too short, 0x8930 - symbol has zero pointer value.", "generated_brief": {"functional_summary": "The GetSymbolForReference instruction asynchronously retrieves the name of an indirectly addressed object based on its reference in a PLC program.", "usage_context": "It is used when you need to determine or display the symbolic name of a data object that is accessed via a reference, especially when handling dynamic or indirect addressing in S7-1500 CPU environments."}, "generated_keywords": ["get symbol from reference", "asynchronous symbol retrieval", "indirect addressing", "dynamic object name resolution", "PLC symbol extraction"]}
{"instruction_name": "Get_AlarmResources", "description": "You use the 'Get_AlarmResources' instruction to determine the number of alarms for which your CPU currently has sufficient memory.", "parameters": {"Input": [], "Output": [{"name": "RET_VAL", "type": "UINT", "description": "Number of currently available alarm instances. Note: This value can range from 0 to the maximum value in effect for your CPU type."}], "InOut": []}, "how_to_use": "", "example_code": "", "additional_info": "The number determined is a snapshot and may have a different value a short time later.", "generated_brief": {"functional_summary": "The 'Get_AlarmResources' instruction returns the current number of available alarm instances that the CPU can handle based on its memory capacity.", "usage_context": "It is used in PLC programs to monitor and manage alarm capacity to ensure the system does not exceed the CPU's alarm memory limits."}, "generated_keywords": ["alarm resource monitoring", "available alarm instances", "CPU alarm memory", "alarm capacity check", "PLC alarm management"]}
{"instruction_name": "LGC_GADR", "description": "You use the 'LGC_GADR' instruction to determine the module slot belonging to a hardware identifier.", "parameters": {"Input": [{"name": "IOID", "type": "BYTE", "description": "Is not evaluated."}, {"name": "LADDR", "type": "HW_MODULE", "description": "Hardware identifier of the module."}], "Output": [{"name": "AREA", "type": "BYTE", "description": "The area ID indicates how the remaining output parameters are to be interpreted: 0: Central module; 2: PROFIBUS DP."}, {"name": "RACK", "type": "WORD", "description": "Rack number based on the area ID."}, {"name": "SLOT", "type": "WORD", "description": "Slot number based on the area ID."}, {"name": "SUBADDR", "type": "WORD", "description": "Is not output (always '0')."}], "InOut": []}, "how_to_use": "", "example_code": "", "additional_info": "The 'LGC_GADR' instruction cannot be used for modules behind gateways (e.g., IE/PB link). Use the 'LOG2GEO' instruction instead.", "generated_brief": {"functional_summary": "The LGC_GADR instruction determines the module's rack and slot number based on its hardware identifier within a specified area.", "usage_context": "It is used in PLC systems to map hardware modules to their physical locations, except for modules behind gateways where LOG2GEO should be used."}, "generated_keywords": ["module slot identification", "hardware identifier mapping", "rack and slot determination", "PLC module addressing", "exclude gateway modules"]}
{"instruction_name": "LOG2GEO", "description": "You use the \"LOG2GEO\" instruction to determine the module slot belonging to a hardware identifier.", "parameters": {"Input": [{"name": "LADDR", "type": "HW_ANY", "description": "Hardware identifier of the module whose slot you want to find. The hardware ID is assigned automatically and is stored in the hardware configuration and the system constants."}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Output of error information."}], "InOut": [{"name": "GEOADDR", "type": "VARIANT", "description": "Pointer to the GEOADDR system data type. The slot information is written in the system data type GEOADDR."}]}, "how_to_use": "To use the LOG2GEO instruction, provide the hardware identifier of the desired module in the LADDR input parameter. The instruction will output the slot information in GEOADDR and return an error code in RET_VAL. Ensure that GEOADDR is correctly typed as the system data type GEOADDR. This instruction accesses hardware configuration and system constants automatically. Check RET_VAL for error codes such as 0 (no error) and 8090 (invalid LADDR).", "example_code": "(* Global data block tags *)\nladdr : HW_ANY; (* hardware ID input *)\nreturnValue : INT;  (* error output *)\ngeoAddr : VARIANT;   (* slot information in GEOADDR format *)\n\n(* In network, when execute condition is TRUE *)\nIF execute THEN\n    LOG2GEO(\n        LADDR := laddr,\n        RET_VAL => returnValue,\n        GEOADDR := geoAddr\n    );\nEND_IF;", "additional_info": "Error codes for RET_VAL include 0 meaning no error and 8090 indicating the LADDR address is invalid. The error codes are shown as integers or hexadecimal in the editor; display format can be switched. GEOADDR must be defined with the system data type GEOADDR. The instruction uses system constants and hardware configuration to resolve slot info.", "generated_brief": {"functional_summary": "The LOG2GEO instruction determines the physical slot address of a hardware module based on its hardware identifier.", "usage_context": "It is used in PLC programs to map hardware IDs to their corresponding module slots for configuration and diagnostic purposes."}, "generated_keywords": ["hardware identifier to slot mapping", "module slot determination", "LOG2GEO instruction", "PLC hardware configuration", "error code handling"]}
{"instruction_name": "LOG_GEO", "description": "You use the \"LOG_GEO\" instruction to determine the module slot belonging to a hardware identifier.", "parameters": {"Input": [{"name": "LADDR", "type": "HW_IO", "description": "Hardware identifier of the module for which the slot is to be determined."}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Error information."}, {"name": "AREA", "type": "INT", "description": "The area ID indicates how the remaining output parameters are to be interpreted (0: central device, 2: PROFIBUS DP / PROFINET IO)."}, {"name": "MASTER", "type": "INT", "description": "With AREA = 0: 0 if the slot is located in one of the racks (central device); With AREA = 2: 1 to 32 is DP master system ID or 100 to 115 is PROFINET IO system ID."}, {"name": "STATION", "type": "INT", "description": "With MASTER = 0: Number of the rack; With MASTER > 0: Station number of the field device."}, {"name": "SLOT", "type": "INT", "description": "Slot number."}, {"name": "SUBSLOT", "type": "INT", "description": "Number of the submodule."}, {"name": "OFFSET", "type": "INT", "description": "The OFFSET parameter is not output by the instruction (always \"0\")."}], "InOut": []}, "how_to_use": "", "example_code": "", "additional_info": "", "generated_brief": {"functional_summary": "The LOG_GEO instruction identifies the physical location details such as slot, subslot, and station of a hardware module based on its hardware identifier.", "usage_context": "It is typically used in industrial automation systems to map hardware modules to their physical slots for configuration, diagnostics, or maintenance purposes."}, "generated_keywords": ["module slot identification", "hardware module location", "slot and subslot mapping", "field device positioning", "industrial automation diagnostics"]}
{"instruction_name": "ATH", "description": "You use the instruction \"ATH\" to convert the ASCII character string specified at the IN input parameter into a hexadecimal number. The result of the conversion is output to the OUT output parameter. You can reference various data types using the pointer at the IN parameter (ASCII): STRING, WSTRING, CHAR, BYTE, Array of CHAR, Array of BYTE, WCHAR, Array of WCHAR, Array of WORD. For the OUT parameter (hexadecimal), you can reference: Array of CHAR, Array of BYTE, Array of WORD, STRING, BYTE, CHAR, WORD, INT, DWORD, DINT, SINT, USINT, UINT, UDINT, and additionally with S7-1500: Array of WCHAR, WSTRING, WCHAR, ULINT, LINT, LWORD. You specify the number of ASCII characters to be converted with the N parameter, with maximum of 32767 valid ASCII characters. Only digits \"0\" to \"9\", upper case letters \"A\" to \"F\", and lower case letters \"a\" to \"f\" can be interpreted; other characters convert to zeros. Since ASCII characters require 8 bits and hexadecimal digits 4 bits, the output word length is half the input word length. If there is an odd number of ASCII characters, the hexadecimal number is padded with zeros in the nibble to the right of the last converted hexadecimal number.", "parameters": {"Input": [{"name": "IN", "type": "VARIANT", "description": "Pointer to ASCII character string"}, {"name": "N", "type": "INT", "description": "Number of ASCII characters to be converted"}], "Output": [{"name": "OUT", "type": "VARIANT", "description": "Hexadecimal number"}], "InOut": []}, "how_to_use": "Initialize the IN parameter to point to the ASCII string to be converted. Set N to the number of ASCII characters you want to convert (up to 32767). ATH will convert the ASCII characters to a hexadecimal number and output it at OUT. If the number of ASCII characters is odd, the output is padded with zeros. Check the RET_VAL parameter to determine the status or errors after conversion.", "example_code": "VAR\n  asciiStr : STRING := '0a23';\n  hexOut : WORD;\n  ret : WORD;\nEND_VAR\n\nret := ATH(IN:=asciiStr, N:=4, OUT:=hexOut);", "additional_info": "RET_VAL can return codes such as 0007 for invalid character, 8182 for input buffer too small, 8120 for invalid IN format, and others. Only valid hex characters (0-9, A-F, a-f) are converted; others convert to zeros. Valid data types for IN and OUT must be respected as described. On S7-1500, additional data types for OUT are supported.", "generated_brief": {"functional_summary": "The ATH instruction converts an ASCII string representing hexadecimal digits into its corresponding hexadecimal number output.", "usage_context": "It is typically used in PLC programs to interpret ASCII-encoded hexadecimal data for processing or communication with devices requiring numeric hexadecimal formats."}, "generated_keywords": ["ASCII to hexadecimal conversion", "string to hex number", "hexadecimal parsing", "data type conversion", "PLC ASCII processing"]}
{"instruction_name": "ATTACH", "description": "You use the instruction 'ATTACH' to assign an organization block (OB) to a hardware interrupt event.", "parameters": {"Input": [{"name": "OB_NR", "type": "OB_ATT", "description": "Organization block (numbers up to 32767 are supported.)"}, {"name": "EVENT", "type": "EVENT_ATT", "description": "Hardware interrupt event to be assigned to the OB. The hardware interrupt event must first be enabled in the hardware device configuration for inputs or high-speed counters."}, {"name": "ADD", "type": "BOOL", "description": "Effects on previous assignments: ADD=0 (default): This event replaces all previous event assignments for this OB. ADD=1: This event is added to the previous event assignments for this OB."}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Status of the instruction"}], "InOut": []}, "how_to_use": "To assign a hardware interrupt OB to a hardware interrupt event, specify the event in the EVENT parameter and the organization block in the OB_NR parameter. Use the ADD parameter to control whether to replace previous assignments.", "example_code": "When the normally open contact ('start') supplies the signal state 'TRUE', the 'ATTACH' instruction is executed.", "additional_info": "The output parameter RET_VAL indicates the status of the instruction; error codes can be referenced for specific statuses.", "generated_brief": {"functional_summary": "The ATTACH instruction assigns a specific organization block (OB) to a hardware interrupt event, optionally adding to or replacing previous assignments.", "usage_context": "This instruction is used in PLC programs to link hardware interrupt events to corresponding OBs for handling hardware interrupts in industrial control systems."}, "generated_keywords": ["assign organization block", "hardware interrupt event", "OB to interrupt mapping", "event assignment control", "interrupt handling"]}
{"instruction_name": "ATTR_DB", "description": "You use the instruction \"ATTR_DB\" to obtain information about a data block (DB) located in the work memory of the CPU. The instruction determines the attributes set at the ATTRIB parameter for the DB selected. The length cannot be read out for data blocks with optimized access and data blocks that are only in load memory. In these cases, the DB_LENGTH parameter has the value \"0\". Do not apply ATTR_DB to data blocks with optimized access and activated memory reserve. Do not read out the data blocks for Motion Control with the \"ATTR_DB\" instruction. The error code 80B2 is output for this.", "parameters": {"Input": [{"name": "REQ", "type": "BOOL", "description": "REQ = 1: Request to read block attributes"}, {"name": "DB_NUMBER", "type": "DB_ANY", "description": "Number of the DB to be tested"}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Error information"}, {"name": "DB_LENGTH", "type": "UDINT", "description": "Number of data bytes which the selected DB contains. \"0\" for data blocks with optimized access and data blocks that are only in load memory."}, {"name": "ATTRIB", "type": "BYTE", "description": "DB properties:\n- Bit 0*= 0: Attribute \"Only store in load memory\" is not set.\n- Bit 0*= 1: Attribute \"Only store in load memory\" is set.\n- Bit 1 = 0: Attribute \"Data block write-protected in the device\" is not set.\n- Bit 1 = 1: Attribute \"Data block write-protected in the device\" is set.\n- If bit 0 = 1, then bit 2 is irrelevant and gets the value 1.\n- Bit 2 = 0: Retentive - The DB is regarded as retentive if at least one value has been set as retentive.\n- Bit 2 = 1: Not retentive - The complete DB is not retentive.\n- Bit 3*= 0: The DB is either in the load memory (bit 0 = 1) or in the work memory (bit 0 = 0).\n- Bit 3*= 1: The DB is generated in both the load and the work memory.\n* The relationship between bit 0 and bit 3 is explained in the parameters of the instruction \"CREATE_DB: Create data block\"."}], "InOut": []}, "how_to_use": "Enable the input REQ with the value TRUE to request reading the attributes of a specific data block identified by DB_NUMBER. Avoid using ATTR_DB on data blocks with optimized access combined with memory reserve, or for Motion Control data blocks (returns error 80B2). Evaluate the output ATTRIB byte to understand DB properties like storage location, write protection, and retentiveness. DB_LENGTH returns the size in bytes or zero for optimized/load memory DBs. Monitor RET_VAL for error codes to ensure correct DB number and valid operation.", "example_code": "VAR\n  REQ: BOOL;\n  DB_NUMBER: DB_ANY;\n  RET_VAL: INT;\n  DB_LENGTH: UDINT;\n  ATTRIB: BYTE;\nEND_VAR\n\nREQ := TRUE;\nDB_NUMBER := <DB number to check>;\nATTR_DB(\n  REQ := REQ,\n  DB_NUMBER := DB_NUMBER,\n  RET_VAL => RET_VAL,\n  DB_LENGTH => DB_LENGTH,\n  ATTRIB => ATTRIB\n);", "additional_info": "The length cannot be read for data blocks with optimized access and data blocks only in load memory (DB_LENGTH = 0). Do not apply ATTR_DB to data blocks with optimized access and activated memory reserve. Reading data blocks for Motion Control technology objects causes error 80B2. Error codes in RET_VAL can be displayed in integer or hexadecimal format; refer to program status display format settings.", "generated_brief": {"functional_summary": "The ATTR_DB instruction reads and returns the attributes and size information of a specified data block (DB) in the CPU's work memory.", "usage_context": "It is typically used to verify DB properties such as storage location, write protection, and retentiveness before performing operations on the data block in PLC programs."}, "generated_keywords": ["read data block attributes", "DB properties query", "verify data block size", "detect write protection", "check retentiveness"]}
{"instruction_name": "DeviceStates", "description": "You use the instruction \"DeviceStates\" to query specific status information for all modules in an IO system, which means either for all IO devices in a PROFINET IO system or for all DP slaves in a DP master system. The Boolean value that is output indicates the modules to which the selected status applies. For example, read out which IO devices are currently disabled in a PROFINET IO system. Information is also displayed as to whether the status information to be read applies to at least one of the IO devices or DP slaves. The instruction can be called in a cyclic OB as well as in an interrupt OB (e.g. OB82 - diagnostic interrupt).", "parameters": {"Input": [{"name": "LADDR", "type": "HW_IOSYSTEM", "description": "Hardware identifier of the PROFINET IO or DP master system. You select the PROFINET IO or DP master system at the LADDR parameter by means of the hardware identifier, which is available either in the Network view of the properties of the IO or DP master system or in the PLC tag table in the listed system constants with the data type HW_IOSYSTEM."}, {"name": "MODE", "type": "UINT", "description": "Selection of status information to be read. You can read out one of the following status information items for the entire PROFINET IO or DP master system: 1: IO devices/DP slaves are configured; 2: IO devices/DP slaves are faulty; 3: IO devices/DP slaves are disabled; 4: IO devices/DP slaves exist; 5: IO devices/DP slaves for which a problem has occurred (maintenance demanded or recommended, not accessible, not available, error occurred)."}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Status of instruction. Possible error codes include: 0 (No error), 8091 (Hardware identifier of LADDR does not exist), 8092 (LADDR does not address a PROFINET IO or DP master system), 8093 (Invalid data type at STATE parameter), 80B1 (Instruction not supported by CPU), 80B2 (MODE parameter not supported by CPU), 8452 (Complete status information does not fit in tag configured in STATE parameter)."}], "InOut": [{"name": "STATE", "type": "VARIANT", "description": "Buffer for status of the IO devices or DP slaves. The status of the IO devices/DP slaves selected with MODE is output here. Bit 0 = 1: group display indicating that the bit n of at least one IO device/DP slave is set; bit n = 1: the status selected with MODE applies to that IO device/DP slave (with PROFINET IO system, bit n corresponds to the device number; with PROFIBUS DP system, bit n corresponds to the PROFIBUS address). Use BOOL to output group display bit only or Array of BOOL to output for all devices (1024 bits for PROFINET, 128 bits for DP master)."}]}, "how_to_use": "To use the DeviceStates instruction, configure the LADDR input parameter with the hardware identifier for the PROFINET IO or DP master system. Set the MODE input parameter to select the status information to read (e.g., which devices are faulty or disabled). Prepare the STATE parameter as a VARIANT variable of type BOOL or Array of BOOL to receive status bits. The instruction can be called cyclically or within an interrupt OB like OB82. Check RET_VAL to verify that the instruction executed without errors. Note that the STATE buffer size should accommodate all expected devices to avoid error 8452.", "example_code": "VAR\n  myLADDR: HW_IOSYSTEM;\n  myMODE: UINT := 4; // Checking for existing IO devices\n  mySTATE: ARRAY[0..1023] OF BOOL;\n  returnValue: INT;\nEND_VAR\n\n// Call in cyclic OB\nDeviceStates(myLADDR, myMODE, returnValue, mySTATE);", "additional_info": "The instruction must be supported by the CPU used. Errors should be checked through RET_VAL. When configuring the STATE parameter as Array of BOOL, length must accommodate the number of devices, e.g., 1024 bits for PROFINET IO systems or 128 bits for DP master systems. For field length validation, the CountOfElements instruction is called internally. Bit 0 in STATE indicates a group status that applies to at least one IO device or DP slave.", "generated_brief": {"functional_summary": "The DeviceStates instruction queries and returns the status information of all IO devices or DP slaves within a PROFINET IO or DP master system, indicating specific conditions such as faults, disablement, or existence.", "usage_context": "This function is typically used in cyclic or interrupt OBs to monitor the health and configuration status of IO devices in industrial automation networks for diagnostics and system management."}, "generated_keywords": ["IO system status query", "PROFINET IO diagnostics", "DP master device monitoring", "module status retrieval", "cyclic and interrupt OB usage"]}
{"instruction_name": "GETIO", "description": "You use the instruction \"GETIO\" to consistently read out all inputs of a submodule of a DP standard slave/PROFINET IO device. If there was no error during the data transmission, the data that has been read is entered in the destination area indicated by INPUTS.", "parameters": {"Input": [{"name": "ID", "type": "HW_SUBMODULE", "description": "Hardware ID of the submodule"}], "Output": [{"name": "STATUS", "type": "DWORD", "description": "Error information"}, {"name": "LEN", "type": "INT", "description": "Amount of data read in bytes"}], "InOut": [{"name": "INPUTS", "type": "VARIANT", "description": "Destination area for the read data. It must be at least as long as what you have configured for the selected submodule. We recommend that you only use the data type BYTE or ARRAY of BYTE."}]}, "how_to_use": "To use the GETIO instruction, ensure the ID corresponds to a valid hardware submodule and define a sufficient length for the INPUTS area based on the defined data configuration.", "example_code": "", "additional_info": "When reading from a DP standard slave with a modular configuration, you can only access data of one component/DP identifier at the configured start address.", "generated_brief": {"functional_summary": "The GETIO instruction reads all input data from a specific hardware submodule of a DP standard slave or PROFINET IO device and stores it in a designated memory area if no transmission errors occur.", "usage_context": "It is used in industrial automation to consistently acquire input data from modular IO devices for processing within a PLC program."}, "generated_keywords": ["read submodule inputs", "DP standard slave IO", "PROFINET IO device", "input data acquisition", "hardware submodule read"]}
{"instruction_name": "HTA", "description": "You use the instruction 'HTA' to convert the hexadecimal number specified at the IN input into an ASCII character string. The result of the conversion is stored at the address specified in the OUT parameter.", "parameters": {"Input": [{"name": "IN", "type": "VARIANT", "description": "Start address of the hexadecimal digits"}, {"name": "N", "type": "UINT", "description": "Number of hexadecimal bytes to be converted"}], "Output": [{"name": "OUT", "type": "VARIANT", "description": "Address at which the result is stored."}, {"name": "RET_VAL", "type": "WORD", "description": "Error message"}], "InOut": []}, "how_to_use": "Specify the hexadecimal number at the IN parameter and the number of bytes to convert using N. The result will be written to the OUT parameter as an ASCII character string.", "example_code": "", "additional_info": "A maximum of 32767 characters are written to the ASCII character string. If the complete result of the conversion cannot be displayed in the OUT parameter, the result will only be partially written. If the address range for the result is greater than the result of the conversion, only the resulting ASCII string is written to the OUT parameter; an initialization of OUT does not take place.", "generated_brief": {"functional_summary": "The HTA instruction converts a specified hexadecimal number into its equivalent ASCII character string and stores the result at a given memory address.", "usage_context": "This function is typically used in industrial PLC programs when hexadecimal data needs to be represented or processed as readable ASCII text, such as for communication or data logging purposes."}, "generated_keywords": ["hexadecimal to ASCII conversion", "hex to ASCII string", "data format conversion", "PLC string processing", "memory address output"]}
{"instruction_name": "RDREC", "description": "You use the instruction \"RDREC\" to read the data record with the number INDEX from the module addressed using the ID. This can be a module in a central rack or a distributed module (PROFIBUS DP or PROFINET IO).", "parameters": {"Input": [{"name": "REQ", "type": "BOOL", "description": "REQ = 1: Transfer data record"}, {"name": "ID", "type": "HW_IO", "description": "Hardware identifier of the hardware module (DP/PROFINET IO). The number is assigned automatically and is stored in the properties of the module or of the interface in the hardware configuration."}, {"name": "INDEX", "type": "DINT", "description": "Data record number"}, {"name": "MLEN", "type": "UINT", "description": "Maximum length in bytes of the data record information to be read"}], "Output": [{"name": "VALID", "type": "BOOL", "description": "New data record was received and is valid."}, {"name": "BUSY", "type": "BOOL", "description": "BUSY = 1: The reading process is not yet complete."}, {"name": "ERROR", "type": "BOOL", "description": "ERROR = 1: An error occurred during the reading process."}, {"name": "STATUS", "type": "DWORD", "description": "Block status or error information"}, {"name": "LEN", "type": "UINT", "description": "Length of the read data record information"}], "InOut": [{"name": "RECORD", "type": "VARIANT", "description": "Target range for the data record read. If you are using the NREF system data type for the target range in a data block with optimized access, no values are written to the target range."}]}, "how_to_use": "\"RDREC\" is an asynchronous instruction that starts transferring the data record from the specified module when called with REQ = 1. The transfer progresses over multiple calls, with BUSY indicating the reading process status. When BUSY is FALSE, the transfer is complete. Use the VALID output to verify successful transfer, and check ERROR and STATUS for error handling. MLEN specifies the number of bytes to read; if set to 0, the full data record is transferred into RECORD.", "example_code": "", "additional_info": "The interface of the \"RDREC\" instruction is identical to the 'RDREC' FB defined in the standard \"PROFIBUS and PROFINET Guideline Communication Function Blocks on PROFIBUS DP and PROFINET IO\". When called in the SYNCUP system state of an S7-1500-R/H system, error codes 0x7001 and 0x7002 are returned until SYNCUP finishes; RDREC should be called cyclically in this state. If reading PROFINET IO data records, negative values in INDEX, MLEN, and LEN are interpreted as unsigned 16-bit integers.", "generated_brief": {"functional_summary": "The RDREC instruction asynchronously reads a specified data record from a hardware module by and managing the transfer process through input and output signals.", "usage_context": "It is used in industrial automation to retrieve configuration or diagnostic data from central or distributed modules in PROFIBUS DP or PROFINET IO networks during cyclic operation."}, "generated_keywords": ["read data record", "asynchronous data transfer", "PROFIBUS DP module", "PROFINET IO module", "hardware module communication"]}
{"instruction_name": "T_CONV", "description": "You use the instruction \"T_CONV\" to convert the data type of the IN input parameter to the data type that is output at the OUT output. You select the data formats for the conversion from the instruction boxes of the input and output.", "parameters": {"Input": [{"name": "IN", "type": "Integers, TIME, date and time*", "description": "Value to be converted; can be I, Q, M, D, L, P or constant; supported data types depend on the CPU"}], "Output": [{"name": "OUT", "type": "Integers, TIME, date and time*", "description": "Result of the conversion; can be I, Q, M, D, L, P"}], "InOut": []}, "how_to_use": "Create tags with the data types you want to convert between. Use the T_CONV instruction to convert the input value to the desired output type by selecting the appropriate data types in the input and output parameter fields of the instruction. If the input and output data types are the same, the instruction copies the input value to the output.", "example_code": "", "additional_info": "The range of supported data types depends on the CPU. Refer to the documentation for valid data types supported by S7-1200 and S7-1500 modules.", "generated_brief": {"functional_summary": "The T_CONV instruction converts a value from one data type to another within supported integer, TIME, and date/time formats.", "usage_context": "It is typically used in PLC programs to ensure data compatibility by converting between different data types needed for processing or output."}, "generated_keywords": ["data type conversion", "T_CONV instruction", "PLC data format", "input output conversion", "type compatibility"]}
{"instruction_name": "WR_DPARM", "description": "You use the instruction \"WR_DPARM\" to transfer the data record with the number RECNUM from the configuration data to the addressed module. The data record can be static or dynamic.", "parameters": {"Input": [{"name": "REQ", "type": "BOOL", "description": "REQ = 1: Write request"}, {"name": "LADDR", "type": "HW_IO", "description": "Hardware identifier of the assembly or the module (e.g. input module). The number is automatically assigned."}, {"name": "RECNUM", "type": "BYTE", "description": "Data record number"}], "Output": [{"name": "BUSY", "type": "BOOL", "description": "BUSY = 1: The writing process is not yet complete."}], "InOut": [{"name": "RET_VAL", "type": "INT", "description": "If an error occurs while the instruction is being executed, the return value contains an error code."}]}, "how_to_use": "Set REQ to TRUE (1) to start the write request of the data record specified by RECNUM to the module addressed by LADDR. Monitor BUSY to check if the writing process is ongoing (BUSY=1) or complete (BUSY=0). RET_VAL will indicate success (0000) or an error code for troubleshooting. It is important to refer to the module's product manual for valid data record numbers and structures.", "example_code": "", "additional_info": "Common RET_VAL error codes include 0000 (no error), 7001 (transfer triggered), and 80A1 (module defective or unplugged). Refer to the product manual and error code documentation for detailed troubleshooting. REQ should be reset to 0 to complete the write cycle. This instruction is typically used with distributed I/O modules. Ensure correct LADDR addressing and valid RECNUM. If errors frequently occur, check electrical interference and installation integrity.", "generated_brief": {"functional_summary": "The WR_DPARM instruction writes a specified data record from the configuration to the addressed hardware module in a PLC system.", "usage_context": "It is used when transferring or updating configuration data to distributed I/O modules during system setup or maintenance."}, "generated_keywords": ["write data record", "distributed I/O module", "configuration transfer", "data record number", "module addressing"]}
{"instruction_name": "WR_DPARM", "description": "You use the instruction \"WR_DPARM\" to transfer the data record with the number RECNUM from the configuration data to the addressed module. The data record can be static or dynamic.", "parameters": {"Input": [{"name": "REQ", "type": "BOOL", "description": "REQ = 1: Write request"}, {"name": "LADDR", "type": "HW_IO", "description": "Hardware identifier of the assembly or the module (e.g. input module). The number is automatically assigned."}, {"name": "RECNUM", "type": "BYTE", "description": "Data record number"}], "Output": [{"name": "BUSY", "type": "BOOL", "description": "BUSY = 1: The writing process is not yet complete."}], "InOut": []}, "how_to_use": "To use WR_DPARM, set REQ to 1 to initiate a write request transferring the specified data record RECNUM to the module addressed by LADDR. Monitor BUSY; it remains 1 while the operation is ongoing and returns to 0 once complete. Check RET_VAL to identify any errors during execution.", "example_code": "", "additional_info": "RET_VAL returns error codes indicating specific issues such as invalid addresses, module defects, or communication errors. Typical RET_VAL codes include 0000 for no error, 7001 for transfer triggered, 8093 for invalid LADDR, and various others related to module and DP protocol errors. For detailed error handling, refer to the product manual and handle RET_VAL accordingly.", "generated_brief": {"functional_summary": "The WR_DPARM instruction transfers a specified data record from configuration data to a designated hardware module identified by its address.", "usage_context": "It is used in industrial automation systems to update module parameters dynamically or statically during operation by initiating a write request and monitoring the process completion."}, "generated_keywords": ["data record transfer", "module parameter update", "write request", "hardware module addressing", "operation monitoring"]}
{"instruction_name": "RD_DPAR", "description": "You use the instruction to read the data record with the number INDEX of the addressed component from the configured system data. This may be a module in a central rack or a distributed component (PROFIBUS DP or PROFINET IO). The value TRUE for the output parameter VALID indicates that the data record was successfully transferred to the target range RECORD. In this case, the LEN output parameter contains the length of the read data in bytes. If an error has occurred during transfer of the data record, this is indicated by the output parameter ERROR. In this case, the output parameter STATUS contains the error information. The \"RD_DPAR\" instruction works asynchronously, that is, its execution extends over multiple calls. You start the data record transfer by calling \"RD_DPAR\" with REQ = 1. The output parameter BUSY and bytes 2 and 3 of the output parameter STATUS show the status of the job. Bytes 2 and 3 of STATUS match the output parameter RET_VAL of the instructions that operate asynchronously. The transfer of the data record is complete when the output parameter BUSY has the value FALSE.", "parameters": {"Input": [{"name": "REQ", "type": "BOOL", "description": "REQ = 1: Read request"}, {"name": "LADDR", "type": "HW_IO", "description": "Hardware identifier of the assembly or the module (e.g. input module). The number is automatically assigned."}, {"name": "INDEX", "type": "INT", "description": "Data record number"}], "Output": [{"name": "VALID", "type": "BOOL", "description": "New data record was received and is valid"}, {"name": "BUSY", "type": "BOOL", "description": "BUSY = 1: The job is not yet complete."}, {"name": "ERROR", "type": "BOOL", "description": "ERROR = 1: An error occurred during reading process."}, {"name": "STATUS", "type": "DWORD", "description": "Call ID (bytes 2 and 3) or error code. Byte 1: B#16#00, if no error. Otherwise function ID from DPV1-PDU: In the case of error for data record reading B#16#DE, in the case of error for data record writing B#16#DF. If no DPV1 protocol element is used: B#16#C0. Byte 4: Manufacturer-specific error ID extension."}, {"name": "LEN", "type": "INT", "description": "Length of the read data record information"}], "InOut": [{"name": "RECORD", "type": "VARIANT", "description": "Target range for the read data record"}]}, "how_to_use": "Call the RD_DPAR instruction with REQ set to TRUE to start the asynchronous read operation of the data record identified by INDEX from the addressed module specified byADDR. Monitor the BUSY output to determine when the operation is complete. When BUSY is FALSE, check VALID to confirm successful reading. If ERROR is TRUE, check STATUS for error details. The data record read is received in RECORD and LEN gives the length of data read. Use multiple calls to complete the asynchronous operation. Consider that STATUS bytes 2 and 3 represent the job status during the operation.", "example_code": "(* Example snippet reading data record number 128 from a module *)\nVAR\n  req : BOOL := TRUE;\n  laddr : HW_IO; (* hardware identifier assigned from module properties *)\n  index : INT := 128;\n  record : VARIANT;\n  valid : BOOL;\n  busy : BOOL;\n  error : BOOL;\n  status : DWORD;\n  len : INT;\nEND_VAR\n\nRD_DPAR(\n  REQ := req,\n  LADDR := laddr,\n  INDEX := index,\n  RECORD := record,\n  VALID => valid,\n  BUSY => busy,\n  ERROR => error,\n  STATUS => status,\n  LEN => len\n);\n\n(* Monitor busy and valid flags to handle completion and errors *)", "additional_info": "Refer to the product manual of the relevant module for information on valid data record numbers and their structure. The instruction is asynchronous and the operation status is indicated by the BUSY and STATUS outputs. Error codes can represent various issues including invalid LADDR, incorrect data record length, or module not supporting the data record. The data block structure for RECORD must match the expected format. For further details see related instructions like RD_DPARM and documentation on switching display formats for error codes.", "generated_brief": {"functional_summary": "The RD_DPAR instruction asynchronously reads a specific data record identified by INDEX from a hardware module and provides status, validity, and error information about the transfer.", "usage_context": "It is used in industrial PLC programs to retrieve configuration or status data from modules in a central rack or distributed field devices like PROFIBUS DP or PROFINET IO components."}, "generated_keywords": ["asynchronous data record read", "module data retrieval", "PROFIBUS DP PROFINET IO", "read data validity check", "PLC module status monitoring"]}
{"instruction_name": "RD_DPAR", "description": "You use the instruction to read the data record with the number INDEX of the addressed component from the configured system data. This may be a module in a central rack or a distributed component (PROFIBUS DP or PROFINET IO). The value TRUE for the output parameter VALID indicates that the data record was successfully transferred to the target range RECORD. In this case, the LEN output parameter contains the length of the read data in bytes. If an error has occurred during transfer of the data record, this is indicated by the output parameter ERROR. In this case, the output parameter STATUS contains the error information.", "parameters": {"Input": [{"name": "REQ", "type": "BOOL", "description": "REQ = 1: Read request"}, {"name": "LADDR", "type": "HW_IO", "description": "Hardware identifier of the assembly or the module (e.g. input module). The number is automatically assigned."}, {"name": "INDEX", "type": "INT", "description": "Data record number"}], "Output": [{"name": "VALID", "type": "BOOL", "description": "New data record was received and is valid"}, {"name": "BUSY", "type": "BOOL", "description": "BUSY = 1: The job is not yet complete."}, {"name": "ERROR", "type": "BOOL", "description": "ERROR = 1: An error occurred during the reading process."}, {"name": "STATUS", "type": "DWORD", "description": "Call ID (bytes 2 and 3) or error code. Byte 1: B#16#00 if no error; otherwise function ID from DPV1-PDU. Byte 4: Manufacturer-specific error ID extension."}, {"name": "LEN", "type": "INT", "description": "Length of the read data record information"}], "InOut": [{"name": "RECORD", "type": "VARIANT", "description": "Target range for the read data record"}]}, "how_to_use": "The RD_DPAR instruction works asynchronously, i.e. over multiple calls. Start the data record transfer by setting REQ = 1. During processing BUSY is TRUE and VALID is FALSE. When BUSY returns FALSE and VALID is TRUE, the data record has been successfully read into RECORD. Check ERROR and STATUS for error handling.", "example_code": "(* Example: Read data record 128 from an input module *)\nVAR\n    req : BOOL := TRUE;\n    laddr : HW_IO := '<hardware_id>'; (* Hardware address of module *)\n    index : INT := 128; (* Data record number to read *)\n    record : VARIANT; (* Target data record buffer *)\n    valid : BOOL;\n    busy : BOOL;\n    error : BOOL;\n    status : DWORD;\n    len : INT;\nEND_VAR\n\nRD_DPAR(\n    REQ := req,\n    LADDR := laddr,\n    INDEX := index,\n    RECORD := record,\n    VALID => valid,\n    BUSY => busy,\n    ERROR => error,\n    STATUS => status,\n    LEN => len\n);", "additional_info": "The STATUS parameter's bytes 2 and 3 match the RET_VAL of asynchronous instructions. The instruction requires valid hardware ID (LADDR) and data record number (INDEX). Refer to the relevant module's product manual for data record numbers and structure. The transfer is complete when BUSY is FALSE. Error codes provide diagnostic info, e.g. 8093 means invalid L.", "generated_brief": {"functional_summary": "The RD_DPAR instruction asynchronously reads a specified data record from a hardware module or distributed component into a target buffer, providing status and error information.", "usage_context": "This function is typically used in industrial control systems to retrieve configuration or diagnostic data from modules in a central rack or distributed fieldbus devices like PROFIBUS DP or PROFINET IO."}, "generated_keywords": ["asynchronous data read", "hardware module data access", "PROFIBUS DP data retrieval", "PROFINET IO status monitoring", "error handling for data transfer"]}
{"instruction_name": "RD_DPARA", "description": "You use the instruction to read the data record with the number RECNUM of a selected module from the configured system data. The read data record is entered in the target range defined by the parameter RECORD.", "parameters": {"Input": [{"name": "REQ", "type": "BOOL", "description": "REQ = 1: Read request"}, {"name": "LADDR", "type": "HW_IO", "description": "Hardware identifier of the assembly or the module (e.g. input module). The number is automatically assigned."}, {"name": "RECNUM", "type": "BYTE", "description": "Data record number"}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "If an error occurs while the instruction is being executed, the return value contains an error code. If no error occurred during the transmission, the return value distinguishes based on the length of the read data record."}, {"name": "BUSY", "type": "BOOL", "description": "BUSY = 1: The job is not yet complete."}, {"name": "RECORD", "type": "VARIANT", "description": "Target range for the data record read."}], "InOut": []}, "how_to_use": "You start the reading process by calling the instruction with REQ = 1. Ensure that the hardware is configured correctly and the data record number is valid.", "example_code": "", "additional_info": "Refer to the product manual for the relevant module for information on the data record numbers and the data record structure.", "generated_brief": {"functional_summary": "The RD_DPARA instruction reads a specific data record from a configured module in the PLC hardware and stores it in a target location.", "usage_context": "It is used when accessing module-specific configuration or system data records during PLC operation to retrieve detailed module information."}, "generated_keywords": ["read data record", "module configuration", "system data access", "hardware module", "data record retrieval"]}
{"instruction_name": "RD_DPARA", "description": "You use the instruction to read the data record with the number RECNUM of a selected module from the configured system data. The read data record is entered in the target range defined by the parameter RECORD.", "parameters": {"Input": [{"name": "REQ", "type": "BOOL", "description": "REQ = 1: Read request"}, {"": "LADDR", "type": "HW_IO", "description": "Hardware identifier of the assembly or the module (e.g. input module). The number is automatically assigned."}, {"name": "RECNUM", "type": "BYTE", "description": "Data record number"}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "If an error occurs while the instruction is being executed, the return value contains an error code. If no error occurred during the transmission, the following cases are distinguished: RET_VAL contains the length of the actually read data record in bytes if the target range is larger than the read data record. RET_VAL contains '0' if the length of the read data record is equal to the length of the target range."}, {"name": "BUSY", "type": "BOOL", "description": "BUSY = 1: The job is not yet complete."}, {"name": "RECORD", "type": "VARIANT", "description": "Target range for the data record read."}], "InOut": []}, "how_to_use": "You start the reading process by calling the instruction with REQ = 1.", "example_code": "", "additional_info": "The 'RD_DPARA' instruction works asynchronously, that is, its execution extends over multiple calls. The output parameters RET_VAL and BUSY indicate the status of the job.", "generated_brief": {"functional_summary": "The RD_DPARA instruction asynchronously reads a specified data record from a selected hardware module into a designated target range within the system data.", "usage_context": "It is used when accessing configuration or status data stored in modules of an automated system, especially when data retrieval requires handling asynchronous execution and error status."}, "generated_keywords": ["asynchronous data read", "module data record", "hardware module access", "read request", "error status handling"]}
{"instruction_name": "UPDAT_PO", "description": "You use the instruction to transfer the signal states of a process image partition of the outputs defined by configuration to the output modules. If you have specified a consistency range for the selected process image partition, corresponding data is transferred as consistent data to the respective I/O module.", "parameters": {"Input": [{"name": "PART", "type": "PIP", "description": "Number of the process image partition of the outputs to be transferred. Maximum value range (depending on the CPU): 1 <= n <= 31 (means process image partition n). Memory area: I, Q, M, D, L or constant."}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Error information. Memory area: I, Q, M, D, L, P."}, {"name": "FLADDR", "type": "WORD", "description": "Address of the first byte to cause an error if an access error has occurred. Memory area: I, Q, M, D, L, P."}], "InOut": []}, "how_to_use": "Specify the process image partition number in the PART input parameter to update the outputs defined by configuration. Call UPDAT_PO to transfer the corresponding output data to the output modules. Monitor the RET_VAL output parameter for error information and FLADDR for the address in case of access errors. Do not update outputs assigned to a process image partition simultaneously with the SYNC_PO instruction. The OB 1 process image of the outputs and process image partitions assigned to interrupt OBs are transferred by the system independently of UPDAT_PO calls.", "example_code": "VAR\n  part: PIP := 1; // Process image partition number\n  returnValue: INT;\n  errAddress: WORD;\n  updateOk: BOOL;\nEND_VAR\n\n// Update process image partition 1\nUPDAT_PO(\n    PART := part,\n    RET_VAL => returnValue,\n    FLADDR => errAddress\n);\n\nupdateOk := (returnValue = 0);", "additional_info": "Error codes returned by RET_VAL are displayed as integer or hexadecimal values in the program editor. Error codes include: 0000 (no error), 8090 (illegal PART value), 8091 (partition not defined), 8092 (partition updated by system and cannot be used), 8093 (partition update processed in another OB), 80A0 (I/O access error). For process image partitions of DP standard slaves, additional error codes from DPWR_DAT may occur if consistency areas > 32 bytes are defined.", "generated_brief": {"functional_summary": "UPDAT_PO transfers the output signal states of a specified process image partition to the configured output modules, ensuring data consistency as defined.", "usage_context": "It is used in PLC programs to explicitly update outputs for a given process image partition while monitoring for transfer errors during industrial control operations."}, "generated_keywords": ["process image partition output transfer", "update outputs", "error monitoring", "output module data consistency", "PLC output synchronization"]}
{"instruction_name": "T_ADD", "description": "You use this instruction to add the time information in the IN1 input to the time information in the IN2 input. You can query the result in the OUT output parameter. This instruction supports addition of a time period to another time period or a time.", "parameters": {"Input": [{"name": "IN1", "type": "TIME, DTL, TOD", "description": "First number to be added. It can be a TIME data type or DTL/TOD data types, depending on the context."}, {"name": "IN2", "type": "TIME", "description": "Second number to be added. This parameter must be specified in TIME format."}], "Output": [{"name": "OUT", "type": "DINT, DWORD, TIME, TOD, UDINT, DTL", "description": "Result of addition. The data type selection depends on the data types selected for the IN1 and IN2 input parameters."}]}, "how_to_use": "To use this instruction, connect the IN1 and IN2 inputs with the appropriate data types and retrieve the result from the OUT output parameter.", "example_code": "VAR\n  timeValTOD : TOD;\n  timeValTIME : TIME;\n  valueTimeResult : TOD;\nEND_VAR\nvalueTimeResult := T_ADD(IN1 := timeValTIME, IN2 := timeValTOD);", "additional_info": "Be aware of potential overflow/underflow during calculations. Check the enable output ENO to detect such conditions.", "generated_brief": {"functional_summary": "T_ADD adds two time-related values, such as TIME, DTL, or TOD types, and outputs their combined result in an appropriate data type.", "usage_context": "This function is typically used in industrial automation to calculate combined durations or timestamps by summing different time periods or time values."}, "generated_keywords": ["time addition", "time period sum", "TIME DTL TOD addition", "time value calculation", "overflow detection"]}
{"instruction_name": "DETACH", "description": "You use this instruction to cancel the existing assignment of an organization block to one or more hardware interrupt events during runtime. You enter the symbolic or numeric name of the organization block in the OB_NR parameter. This assignment to the event specified in the EVENT parameter will be canceled. If you have selected an individual hardware interrupt event at the EVENT parameter, the assignment of the OB to this hardware interrupt event is cancelled while all other currently existing assignments remain active. If you have not selected a hardware interrupt event, all the events currently assigned to this OB_NR organization block are separated.", "parameters": {"Input": [{"name": "OB_NR", "type": "OB_ATT", "description": "Organization block (numbers up to 32767 are supported.)"}, {"name": "EVENT", "type": "EVENT_ATT", "description": "Hardware interrupt event"}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Status of the instruction"}], "InOut": []}, "how_to_use": "During runtime, use the DETACH instruction to cancel an existing assignment of an organization block (OB) to one or more hardware interrupt events. Specify the OB in OB_NR and optionally specify the hardware interrupt event in EVENT. If EVENT is omitted, all event assignments for the specified OB are cancelled. Check the RET_VAL output parameter for the status of the instruction to confirm if the operation was successful or if any errors occurred.", "example_code": "\n// Example of DETACH usage in SCL for hardware interrupt OB41\n// Assuming OB41 and hardware interrupt event have been configured\nVAR\n    obNbr : OB_ATT := 41;         // OB number to detach\n    event : EVENT_ATT;            // Hardware interrupt event\n    retValDet : INT;              // Return value for status\nEND_VAR\n\n// Detach a specific hardware interrupt event from OB41\nretValDet := DETACH(OB_NR := obNbr, EVENT := event);\n\n// Detach all hardware interrupt events from OB41\nretValDet := DETACH(OB_NR := obNbr);", "additional_info": "RET_VAL error codes:\n0 - No error\n1 - No assignment exists (warning)\n8090 - OB does not exist\n8091 - OB has incorrect type\n8093 - Event does not exist\n\nError codes may be shown as integer or hexadecimal values in the program editor.", "generated_brief": {"functional_summary": "The DETACH instruction cancels the assignment of an organization block (OB) to one or more hardware interrupt events during runtime.", "usage_context": "It is used when you need to dynamically remove OB associations from hardware interrupt events in a PLC program while the system is running."}, "generated_keywords": ["cancel OB assignment", "detach hardware interrupt event", "runtime OB event removal", "hardware interrupt management", "OB event disassociation"]}
{"instruction_name": "S_CONV", "description": "You use this instruction to convert the value at the IN input to the data format you have specified in the OUT output. You decide the output format of the conversion by selecting a data type for the OUT output parameter. The following conversions are possible: Conversion of a string, Conversion of a numerical value or character to a string, Conversion of a character to a character.", "parameters": {"Input": [{"name": "IN", "type": "STRING, WSTRING, CHAR, WCHAR, USINT, UINT, UDINT, ULINT, SINT, INT, DINT, LINT, REAL, LREAL", "description": "Value to be converted"}], "Output": [{"name": "OUT", "type": "CHAR, WCHAR, USINT, UINT, UDINT, ULINT, SINT, INT, DINT, LINT, REAL, LREAL, STRING, WSTRING", "description": "Result of the conversion"}], "InOut": []}, "how_to_use": "Select the data type of the input value and the desired output data type by configuring the IN input and OUT output parameters respectively. Use this instruction to convert strings to numeric values or characters, numeric values or characters to strings, and characters to characters. Be aware that for floating-point number conversions to strings, exponential notation is not supported by S_CONV; use STRG_VAL instead for that case.", "example_code": "VAR\n  inputValueNBR : INT := 123;\n  resultSTRING : STRING(10);\nEND_VAR\n\nresultSTRING := S_CONV(IN := inputValueNBR);", "additional_info": "When converting a string to a numeric value, permitted characters include digits '0' to '9', decimal point, plus and minus signs. Leading spaces and exponential notations are ignored. When converting numeric values to strings, the first bytes of the string indicate maximum and actual length. Numeric values are output without signs except in SCL where strings show a leading sign. Padding with spaces occurs in Ladder and FBD but not in SCL. For floating-point numbers with exponential notation, use STRG_VAL instead of S_CONV.", "generated_brief": {"functional_summary": "The S_CONV instruction converts a value from one data type to another, such as between strings, numeric types, and characters, based on the configured input and output data types.", "usage_context": "It is typically used in PLC programs to transform data formats for processing, display, or communication where type compatibility is required, especially for simple conversions excluding floating-point exponential notation."}, "generated_keywords": ["data type conversion", "string to numeric", "numeric to string", "character conversion", "PLC data formatting"]}
{"instruction_name": "RIGHT", "description": "You use this instruction to extract the last L character in a character string in the input parameter IN. You specify the number of characters to be extracted in the L parameter. The extracted characters are output at the OUT output parameter in (W)STRING format.", "parameters": {"Input": [{"name": "IN", "type": "STRING, WSTRING", "description": "Character string"}, {"name": "L", "type": "BYTE, INT, SINT, USINT", "description": "Number of characters to be extracted"}], "Output": [{"name": "OUT", "type": "STRING, WSTRING", "description": "Extracted partial string"}], "InOut": []}, "how_to_use": "Initialize the instruction by setting the IN and L parameters. The OUT parameter will automatically receive the extracted string based on the value of L.", "example_code": "VAR\n inputSTRING : STRING;\n outputExtractSTRING : STRING;\n extractNumber : INT;\nEND_VAR\n\nextractNumber := 4;\noutputExtractSTRING := RIGHT(inputSTRING, extractNumber);", "additional_info": "If the number of characters to be extracted is greater than the current length of the character string, the OUT output parameter returns the input character string as a result. If L is 0 or the input is an empty string, an empty string will be returned. If L is negative, an empty string will be output.", "generated_brief": {"functional_summary": "The RIGHT instruction extracts the last L characters from a given input string and outputs this substring.", "usage_context": "It is typically used in PLC programs to retrieve specific trailing portions of text data for processing or display in industrial automation systems."}, "generated_keywords": ["extract last characters", "string manipulation", "substring extraction", "PLC string function", "retrieve trailing text"]}
{"instruction_name": "RD_SYS_T", "description": "You use this instruction to read the current date and current time-of-day (module time) of the CPU clock.", "parameters": {"Input": [], "Output": [{"name": "OUT", "type": "DTL", "description": "Date and time of CPU"}], "InOut": [{"name": "RET_VAL", "type": "INT", "description": "Status of the instruction"}]}, "how_to_use": "Interconnect the parameters of the instruction as follows. Select the DATE AND TIME data type.", "example_code": "Create two tags in a global data block for storing the data. The module time of the CPU clock is read out and displayed at output parameter OUT (\"outputTIME\"). The output parameter RET_VAL (\"returnValue\") indicates that processing took place without errors.", "additional_info": "The CPU clock interprets the module time as the coordinated universal time (UTC). The provided value does not include information about the local time zone or daylight saving time.", "generated_brief": {"functional_summary": "The RD_SYS_T instruction reads the current date and time from the CPU's internal clock in UTC format.", "usage_context": "It is typically used in PLC programs when accurate system timestamping or synchronization with the CPU time is required."}, "generated_keywords": ["read CPU date and time", "system clock access", "UTC timestamp retrieval", "PLC time synchronization", "module time reading"]}
{"instruction_name": "RD_LOC_T", "description": "You use this instruction to read the current local time from the CPU clock and output this at the OUT output. Information on the time zone and the start of daylight saving time and standard time, which you have set in the configuration of the CPU clock, is used to output the local time.", "parameters": {"Input": [], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Status of the instruction"}, {"name": "OUT", "type": "DTL", "description": "Local time"}], "InOut": []}, "how_to_use": "Create two tags in a global data block for storing the data. The OUT parameter outputs the current local time from the CPU clock, taking into account the time zone and daylight saving time settings. The RET_VAL parameter returns the status of the instruction to indicate success or specific error conditions. Use data types DT, LDT, or DTL for OUT but note DT and DTL cannot be used in input, output and bit memory areas.", "example_code": "VAR\n  outputLocTIME : DATE_AND_TIME;\n  returnValue : INT;\nEND_VAR\n\n// Call the instruction\nRD_LOC_T(\n  RET_VAL := returnValue,\n  OUT := outputLocTIME\n);", "additional_info": "Error codes for RET_VAL include 0000 (No error), 0001 (No error, local time is output as daylight saving time), 8080 (Local time cannot be read), and 8081 (Current local time is outside permissible range for the selected OUT data type). Valid ranges depend on the selected data type (DT, LDT, DTL). See relevant documentation for switching display formats for error codes.", "generated_brief": {"functional_summary": "The RD_LOC_T instruction reads the current local time from the CPU clock, considering configured time zone and daylight saving settings, and outputs it along with a status code.", "usage_context": "It is typically used in PLC programs to obtain and work with the local time for time-stamping, scheduling, or synchronization tasks within industrial control systems."}, "generated_keywords": ["read local time", "CPU clock time", "daylight saving time", "time zone adjustment", "status code output"]}
{"instruction_name": "FIND", "description": "You use this instruction to search through the character string at the IN1 input parameter for a specific character string. You specify the value to be searched for in the IN2 input parameter. The search is made from left to right. The position of the first occurrence is output in the OUT output parameter. If the search returns no match, the value \"0\" will be output in the OUT output parameter. If an invalid character is specified at the IN2 parameter or if an error occurs during processing, the value \"0\" is output at the OUT parameter.", "parameters": {"Input": [{"name": "IN1", "type": "STRING, WSTRING", "description": "String searched through"}, {"name": "IN2", "type": "STRING, WSTRING", "description": "Character string that is searched for"}], "Output": [{"name": "OUT", "type": "INT", "description": "Character position"}], "InOut": []}, "how_to_use": "To use the FIND instruction, provide the string to be searched on IN1 and the string to search for on IN2. The instruction searches from left to right for the first occurrence of the IN2 string within IN1 and outputs the position in OUT. If no match occurs or an invalid character is in IN2, OUT will be 0.", "example_code": "VAR\n  inputSTRING : STRING;\n  STRINGsearchedFor : STRING;\n  returnPosition : INT;\nEND_VAR\n\n// Example usage\ninputSTRING := 'Example4aString';\nSTRINGsearchedFor := '4a';\nreturnPosition := FIND(IN1 := inputSTRING, IN2 := STRINGsearchedFor);", "additional_info": "Valid data types are STRING and WSTRING for inputs IN1 and IN2. The OUT parameter returns an INT representing the position of the first match or 0 if none is found or in case of error.", "generated_brief": {"functional_summary": "The FIND instruction searches for the first occurrence of a specified substring within a given string and returns its position or 0 if not found or invalid.", "usage_context": "It is typically used in PLC programs to locate specific text patterns within strings for conditional logic or data processing tasks."}, "generated_keywords": ["string search", "substring position", "find substring", "text pattern matching", "character string lookup"]}
{"instruction_name": "WR_SYS_T", "description": "You use this instruction to set the date and time-of-day (module time) of the CPU clock. Enter the date and time-of-day at the input parameter IN. The value must be in the following range: With DT: min. DT#1990-01-01-0:0:0, max. DT#2089-12-31-23:59:59.999; With LDT: min. LDT#1970-01-01-0:0:0.000000000, max. LDT#2200-12-31-23:59:59.999999999; With DTL: min. DTL#1970-01-01-00:00:00.0, max. DTL#2200-12-31-23:59:59.999999999. You can query whether errors have occurred during execution of the instruction in the RET_VAL output parameter. The \"WR_SYS_T\" instruction is not used to pass information about the local time zone or daylight saving time.", "parameters": {"Input": [{"name": "IN", "type": "DT, DTL, LDT", "description": "Date and time input at which the CPU clock module time is set. Must be within specific minimum and maximum ranges depending on the type."}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Status of the instruction execution. Indicates whether errors occurred during the setting of date and time."}], "InOut": []}, "how_to_use": "Set the date and time-of-day of the CPU clock by providing a valid date-time value at the IN parameter within the allowed ranges. Monitor the RET_VAL output parameter to check for errors during execution. This instruction sets the module time in UTC; it does not handle local time zones or daylight saving time.", "example_code": "(* Example to set CPU clock date and time using WR_SYS_T with DATE AND TIME type *)\nVAR\n  inputTIME : DATE_AND_TIME;\n  returnValueT : INT;\n  execute : BOOL;\nEND_VAR\n\nIF execute THEN\n  WR_SYS_T(IN := inputTIME, RET_VAL => returnValueT);\nEND_IF;", "additional_info": "The CPU clock module time is always interpreted as coordinated universal time (UTC) without local time zone or daylight saving time. Error codes are returned via RET_VAL, indicating specific issues with date or time values, such as invalid month, day, or nanosecond. Data types and DTL cannot be used with input, output, or bit memory areas. When using DT, milliseconds are not transferred to the CPU.", "generated_brief": {"functional_summary": "The WR_SYS_T instruction sets the CPU clock's date and time to a specified value in UTC within defined valid ranges.", "usage_context": "It is used in PLC programs when synchronizing or updating the system time of the CPU clock without considering local time zones or daylight saving adjustments."}, "generated_keywords": ["set CPU clock time", "synchronize system time", "UTC date and time input", "monitor execution errors", "PLC time setting instruction"]}
{"instruction_name": "T_DIFF", "description": "You use this instruction to subtract the time information in the IN2 input parameter from the time information in the IN1 input parameter. The result is sent at output parameter OUT. If the time information at the IN2 input parameter is greater than the time information at the IN1 input parameter, the result is output as a negative at the OUT output parameter. If the result of the subtraction is outside the TIME number range, the enable output ENO is = \"0\". Depending on the data types used, you get either a truncated result or \"0\" (0:00). If you select the minuend and subtrahend parameters of the DTL data type, the result has the TIME data type. It may not be greater than 24 days, otherwise the enable output ENO = \"0\" and the result is \"0\". If you select the minuend and subtrahend parameters of the LDT data type, this restriction is avoided.", "parameters": {"Input": [{"name": "IN1", "type": "DTL, DATE, TOD", "description": "Minuend"}, {"name": "IN2", "type": "DTL, DATE, TOD", "description": "Subtrahend"}], "Output": [{"name": "OUT", "type": "TIME, INT", "description": "Difference of input parameters"}], "InOut": []}, "how_to_use": "Use the T_DIFF instruction to subtract two time values, where IN1 is the minuend and IN2 is the subtrahend. The difference appears at the OUT output. When using the DTL data type for inputs, the result is TIME and must not exceed 24 days. If you need to use an INT for the output in SCL, extend the instruction name to T_DIFF_INT to change the OUT parameter type accordingly.", "example_code": "(* Calculate difference between two TOD values *)\nVAR\n  todvalue1 : TOD;\n  todvalue2 : TOD;\n  timevalueDIFF : TIME;\nEND_VAR\n\n// Subtract todvalue2 from todvalue1\nT_DIFF(\n  IN1 := todvalue1,\n  IN2 := todvalue2,\n  OUT := timevalueDIFF\n);", "additional_info": "If the subtraction result exceeds the TIME range, ENO is set to 0 and the result is either truncated or zero. Using LDT as input types avoids the 24-day limitation. The instruction supports inputs as constants or from memory areas I, Q, M, D, L or P.", "generated_brief": {"functional_summary": "The T_DIFF instruction subtracts one time value (IN2) from another (IN1) and outputs the time difference, handling various time data types with range and sign considerations.", "usage_context": "It is typically used in industrial automation to calculate elapsed time or time intervals between two timestamps for control and monitoring processes."}, "generated_keywords": ["time difference calculation", "subtract time values", "time interval measurement", "time data type handling", "elapsed time computation"]}
{"instruction_name": "T_SUB", "description": "You use this instruction to subtract the time information in the IN2 input parameter from the time information in the IN1 input parameter. You can query the difference at the OUT output parameter. You can subtract the following formats: subtraction of a time period from another time period (e.g. TIME - TIME resulting in TIME), and subtraction of a time period from a time (e.g. DTL - TIME resulting in DTL). You decide the formats of the values in the IN1 input parameter and the OUT output parameter by selecting the data types for the input and output parameters of the instruction. Note: Overflow/underflow conditions may occur during calculation and can be detected by evaluating the enable output ENO.", "parameters": {"Input": [{"name": "IN1", "type": "TIME", "description": "Minuend. Memory area: I, Q, M, D, L, P or constant. For the subtraction of a time period from another time period."}, {"name": "IN2", "type": "TIME", "description": "Subtrahend. Memory area: I, Q, M, D, L, P or constant. For the subtraction of a time period from another time period."}, {"name": "IN1", "type": "DTL, TOD", "description": "Minuend. Memory area: I, Q, M, D, L, P or constant. For the subtraction of a time period from a time. For LTIME at IN2, only LTOD, LDT or DTL are used."}, {"name": "IN2", "type": "TIME", "description": "Subtrahend. Memory area: I, Q, M, D, L, P or constant. For the subtraction of a time period from a time."}], "Output": [{"name": "OUT", "type": "DINT, DWORD, TIME, TOD, UDINT", "description": "Result of subtraction. Memory area: I, Q, M, D, L, P. For subtraction of a time period from another time period."}, {"name": "OUT", "type": "DTL, DINT, DWORD, TIME, TOD, UDINT", "description": "Result of subtraction. Memory area: I, Q, M, D, L, P. For subtraction of a time period from a time."}], "InOut": []}, "how_to_use": "Select the data types of the input parameters (IN1 and IN2) corresponding to the type of time values you want to subtract (either time periods or time values). Connect IN1 to the minuend and IN2 to the subtrahend. The result appears at the OUT output parameter in the data type you specify. Monitor the enable output ENO to detect overflow or underflow during the operation.", "example_code": "VAR\n  value1TOD : TOD; // Time of day\n  value2Time : TIME; // Time period\n  value1MINvalue2 : TOD; // Result of subtraction\nEND_VAR\n\n// Subtract time period from time of day\nvalue1MINvalue2 := T_SUB(value1TOD, value2Time);", "additional_info": "When subtracting, take care that overflow or underflow may occur if the result exceeds the largest or smallest possible values. Use the ENO output to detect this condition. The data types of the inputs and output must be compatible according to the supported conversions. For LTIME inputs in IN2, only LTOD, LDT or DTL are valid for IN1.", "generated_brief": {"functional_summary": "The T_SUB instruction subtracts one time value or time period from another, returning the difference in a specified time-related data type.", "usage_context": "It is used in PLC programs to calculate time intervals or adjust time values by subtracting durations, commonly for time-based control and sequencing tasks."}, "generated_keywords": ["time subtraction", "time period difference", "time value calculation", "overflow detection", "PLC time arithmetic"]}
