{"instruction_name": "DIS_AIRT", "description": "You use \"DIS_AIRT\" to delay the processing of interrupt OBs whose priority are higher than the priority of the current organization block. You can call \"DIS_AIRT\" multiple times in an organization block. The \"DIS_AIRT\" calls are counted by the operating system. Processing is delayed more and more each time \"DIS_AIRT\" is executed. To cancel a delay, you must execute the \"EN_AIRT\" instruction. The processing delay applies until the number of executions of \"EN_AIRT\" matches the number of calls of \"DIS_AIRT\" or the current OB has been worked through.", "parameters": {"Input": [], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Number of delays"}], "InOut": []}, "how_to_use": "Call DIS_AIRT within an organization block to delay processing of higher priority interrupt OBs. Each call increases the delay count. To clear delays, call EN_AIRT the same number of times. The RET_VAL output returns the current count of delays.", "example_code": "", "additional_info": "RET_VAL shows the number of processing delays (number of DIS_AIRT calls) after the instruction is completed. Use EN_AIRT to clear the delays. Valid RET_VAL data types include I, Q, M, D, L memory areas.", "generated_brief": {"functional_summary": "DIS_AIRT delays the processing of higher priority interrupt organization blocks by increasing a delay count each time it is called until the delay is cleared using EN_AIRT.", "usage_context": "It is used within an organization block to temporarily postpone the handling of higher priority interrupts during critical processing in a PLC program."}, "generated_keywords": ["delay_interrupt_processing", "interrupt_priority_management", "defer_higher_priority_OB", "interrupt_delay_count", "EN_AIRT_delay_cancellation"]}
{"instruction_name": "EN_AIRT", "description": "You use \"EN_AIRT\" to enable processing of organization blocks when interrupts occur that have been delayed by the \"DIS_AIRT\" instruction. When \"EN_AIRT\" is executed, you cancel a processing delay that was registered by the operating system when \"DIS_AIRT\" was called. To cancel all delays, the number of \"EN_AIRT\" executions must be equal to the number of \"DIS_AIRT\" calls.", "parameters": {"Input": [], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Number of configured delays. It shows the number of processing delays that are not yet enabled after the instruction is completed. A value of 0 means that interrupt handling is enabled again."}], "InOut": []}, "how_to_use": "Call EN_AIRT to cancel interrupt processing delays previously activated by DIS_AIRT. The number of EN_AIRT calls must match the number of DIS_AIRT calls to fully enable interrupt processing again. Check RET_VAL after execution to determine the remaining delayed interrupts. If RET_VAL is 0, all delays are canceled.", "example_code": "", "additional_info": "If the function is called again when interrupt processing is already enabled, an error code 8080 is returned. Other general error codes may be returned and can be analyzed using GET_ERR_ID. Valid RET_VAL parameter data locations include I, Q, M, D, L.", "generated_brief": {"functional_summary": "EN_AIRT re-enables processing of delayed interrupt organization blocks by canceling delays caused by prior DIS_AIRT.", "usage_context": "It is used when interrupt processing needs to be safely resumed being temporarily disabled in a PLC program, ensuring all delays are cleared by matching the number of EN_AIRT calls to DIS_A calls."}, "generated_keywords": ["enable interrupt processing", "cancel interrupt delay", "interrupt delay counter", "DIS_AIRT delay cancellation", "interrupt processing resume"]}
{"instruction_name": "EN_IRT", "description": "You use the instruction to enable the processing of new interrupts and asynchronous error events that you have previously disabled with the \"DIS_IRT\" instruction. This means that if an interrupt event occurs, the CPU operating system reacts in one of the following ways: It calls an interrupt OB or asynchronous error OB, or it triggers the specified reaction if an interrupt OB or asynchronous error OB is not programmed.", "parameters": {"Input": [{"name": "MODE", "type": "BYTE", "description": "Specifies which interrupts and asynchronous error events will be enabled."}, {"name": "OB_NR", "type": "", "description": "OB number."}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "If an error occurs while the instruction is being executed, the return value contains an error code."}], "InOut": []}, "how_to_use": "Use the EN_IRT instruction to re-enable processing of interrupts and asynchronous error events after they have been disabled by DIS_IRT. Configure the MODE parameter to specify which interrupts to enable: 0 to enable all except programming errors and Motion Control OBs, 1 to enable all events belonging to a specified interrupt class (e.g. 10 for Time-of-day interrupts), or 2 to enable events of a specific interrupt by its OB number specified in OB_NR. Check the RET_VAL output for error codes during execution.", "example_code": "", "additional_info": "Valid MODE values and their meanings: 0 - all except programming error and direct I/O access errors; 1 - enable specific interrupt class (10, 20, 30, 40, 50, 60, 70, 80); 2 - enable specific interrupt by OB number. Error codes include 0000 (no error), 8090 (invalid OB_NR), 8091 (invalid MODE). See also GET_ERR_ID instruction for general error information.", "generated_brief": {"functional_summary": "The EN_IRT instruction enables the processing of new interrupts and asynchronous error events that were previously disabled, based on specified mode and OB number parameters.", "usage_context": "It is used in PLC programs to re-enable interrupt handling after being disabled by DIS_IRT, allowing the CPU to respond to specific or all interrupt events during operation."}, "generated_keywords": ["enable interrupts", "asynchronous error events", "interrupt handling", "interrupt reactivation", "PLC interrupt control"]}
{"instruction_name": "SET_CINT", "description": "You use this instruction to set the parameters for a cyclic interrupt OB. The start time for a cyclic interrupt OB is generated from the respective time interval of the OB and the phase offset.", "parameters": {"Input": [{"name": "OB_NR", "type": "OB_CYCLIC", "description": "OB number (<32768)"}, {"name": "CYCLE", "type": "UDINT", "description": "Time interval in microseconds"}, {"name": "PHASE", "type": "UDINT", "description": "Phase offset in microseconds"}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Status of the instruction"}], "InOut": []}, "how_to_use": "To use the SET_CINT instruction, provide the OB number, cycle time in microseconds, and the phase offset in microseconds. If the configuration is not valid, monitor the RET_VAL for status.", "example_code": "", "additional_info": "If the OB does not exist or if the time interval used is not supported, a corresponding error alarm is output in the RET_VAL parameter.", "generated_brief": {"functional_summary": "The SET_CINT instruction configures the timing parameters, including the cycle time and phase offset, for a cyclic interrupt OB in a PLC system.", "usage_context": "It is used when precise periodic execution of cyclic interrupt OBs is needed in industrial control applications to ensure timely and synchronized task scheduling."}, "generated_keywords": ["cyclic interrupt configuration", "OB timing parameters", "cycle time setup", "phase offset adjustment", "periodic task scheduling"]}
{"instruction_name": "TIME_TCK", "description": "With the 'TIME_TCK' instruction, you read a time counter which counts the ms in which the CPU is in RUN. The time counter counts from 0 to max. 2147483647 ms. In the case of an overflow, counting restarts from 0. The time scale and the accuracy amount to 1 ms. The time counter is only influenced by the operating modes of the CPU. You can, for example, use it to measure the duration of processes by differentiation of the results of two 'TIME_TCK' calls. The instruction does not provide any error information.", "parameters": {"Input": [], "Output": [{"name": "RET_VAL", "type": "TIME", "description": "The RET_VAL parameter contains the read time counter in the range from 0 to 2^31 -1 ms."}], "InOut": []}, "how_to_use": "To use the 'TIME_TCK' instruction, you must create a tag for storing the data in a global data block and interconnect the parameters properly.", "example_code": "VAR\n    outputCPUtimer : TIME;\nEND_VAR\noutputCPUtimer := TIME_TCK();", "additional_info": "The time counter is constantly updated in Startup and RUN modes. It is stopped in STOP mode and deleted on Warm restart.", "generated_brief": {"functional_summary": "The TIME_TCK instruction reads a millisecond time counter that measures CPU runtime while in Run mode, resetting upon overflow or warm restart.", "usage_context": "It is typically used to measure process durations by comparing time counter values at different points during program execution."}, "generated_keywords": ["read CPU runtime", "millisecond time counter", "process duration measurement", "overflow reset", "run mode timer"]}
{"instruction_name": "LEN", "description": "You use the instruction 'LEN' to query the current length of the character string specified at the IN input parameter. This is output as numerical value at the output par OUT. An empty string ('') has the length zero.", "parameters": {"Input": [{"name": "IN", "type": "STRING, WSTRING", "description": "Character string"}], "Output": [{"name": "OUT", "type": "INT", "description": "Number of valid characters"}], "InOut": []}, "how_to_use": "To use the LEN instruction, specify the character string at the IN parameter and the result will be provided at the OUT parameter as the number of valid characters.", "example_code": "stringLengthOUT := LEN(inputSTRING);", "additional_info": "If errors occur during processing of the instruction, the value '0' is output at the OUT parameter.", "generated_brief": {"functional_summary": "The LEN instruction returns the length of a given character string as an integer value.", "usage_context": "It is used in PLC programs to determine the number of characters in a string for processing or validation purposes."}, "generated_keywords": ["string length", "character count", "string processing", "string validation", "LEN instruction"]}
{"instruction_name": "T_COMBINE", "description": "The instruction combines the value of a date with the value of a time, resulting in a combined date and time value.", "parameters": {"Input": [{"name": "IN1", "type": "DATE", "description": "Input tag of the date. Use a value between 1990-01-01 and 2089-12-31 for the data type DATE (this is not checked)."}, {"name": "IN2", "type": "TOD, LTOD", "description": "Input tag of the time."}], "Output": [{"name": "OUT", "type": "DTL", "description": "Return value of the date and time."}], "InOut": []}, "how_to_use": "When you drag the instruction 'T_COMBINE' from the 'Instructions' task card to the SCL programming window, the internal instruction CONCAT_DATE_TOD or CONCAT_DATE_LTOD is displayed there.", "example_code": "", "additional_info": "Create three tags in a global data block for storing the data. The date ('valueDATE') is expanded by the specification of the time of day ('valueTOD') and the return value is displayed at output parameter OUT ('combTIME').", "generated_brief": {"functional_summary": "T_COMBINE merges a separate date value and time value into a single combined date-time value.", "usage_context": "It is typically used in PLC programs to construct complete timestamps from individual date and time inputs for event logging or time-based control."}, "generated_keywords": ["combine date and time", "merge date-time values", "timestamp creation", "date and time input", "DTL output"]}
{"instruction_name": "CONCAT", "description": "You use the instruction 'CONCAT' to combine the character string at the IN1 input parameter with the character string at the IN2 input parameter. The result is output at the OUT output parameter in (W)STRING format. If the resulting character string is longer than the tag specified in the OUT output parameter, then the resulting character string will be limited to the available length.", "parameters": {"Input": [{"name": "IN1", "type": "STRING, WSTRING", "description": "Character string"}, {"name": "IN2", "type": "STRING, WSTRING", "description": "Character string"}], "Output": [{"name": "OUT", "type": "STRING, WSTRING", "description": "Resulting character string"}], "InOut": []}, "how_to_use": "You can extend the 'CONCAT' instruction with additional inputs. The first input must be 'IN1' and must be followed consecutively, such as 'IN2', 'IN3', up to 'IN32'.", "example_code": "CONCAT(IN1 := string_1, IN2 := string_2, … IN32 := string_32)", "additional_info": "If errors occur during processing of the instruction and it is possible to write the OUT output parameter, an empty string will be output.", "generated_brief": {"functional_summary": "The CONCAT instruction combines multiple input character strings into a single concatenated string, truncating if the result exceeds the output length limit.", "usage_context": "It is typically used in PLC programming when concatenating strings for display, communication, or data processing within industrial control systems."}, "generated_keywords": ["string concatenation", "combine character strings", "PLC string operation", "truncate output string", "multi-input concat"]}
{"instruction_name": "LEFT", "description": "You use the instruction 'LEFT' to extract a partial string beginning with the first character of the string at the IN input parameter. You specify the number of characters to be extracted in the L parameter. The extracted characters are output at the OUT output parameter in (W)STRING format.", "parameters": {"Input": [{"name": "IN", "type": "STRING, WSTRING", "description": "Character string"}, {"name": "L", "type": "BYTE, INT, SINT, USINT", "description": "Number of characters to be extracted"}], "Output": [{"name": "OUT", "type": "STRING, WSTRING", "description": "Extracted partial string"}], "InOut": []}, "how_to_use": "Connect the 'IN' parameter with the input string and set the 'L' parameter to the number of characters you want to extract.", "example_code": "VAR\n    inputSTRING : STRING;\n    outputExtractSTRING : STRING;\n    extractNumber : INT := 4;\nEND_VAR\noutputExtractSTRING := LEFT(inputSTRING, extractNumber);", "additional_info": "If the number of characters to be extracted is greater than the current length of the character string, the OUT output parameter returns the input character string as a result. If the L parameter contains the value '0' or the input value is an empty string, an empty string will be returned. If the value in the L parameter is negative, an empty string will be output.", "generated_brief": {"functional_summary": "The LEFT instruction extracts a substring from the beginning of a given string based on the specified number of characters.", "usage_context": "It is typically used in PLC programs to parse or manipulate strings by retrieving a fixed number of leading characters from input strings."}, "generated_keywords": ["string extraction", "substring from start", "fixed length substring", "string parsing", "character count extraction"]}
{"instruction_name": "DP_TOPOL", "description": "You use the instruction to trigger the topology determination for a selected DP master system. Calling the instruction will address all diagnostics repeaters on a DP master system. Topology determination is the prerequisite for the detailed display of the error location if line errors occur. After configuration and after every change to the physical configuration of a DP master system, you must repeat the topology determination with \"DP_TOPOL\". Changes to the physical configuration include changes in line lengths, adding or removing stations or components with repeater function, and changing station addresses. \"DP_TOPOL\" is an asynchronous instruction. Processing takes place across several calls. You start determining the bus topology by calling \"DP_TOPOL\" with REQ=1. If you want to cancel the process, call \"DP_TOPOL\" with R=1. The output parameters RET_VAL and BUSY indicate the status of the job.", "parameters": {"Input": [{"name": "REQ", "type": "BOOL", "description": "REQ=1: Trigger topology determination"}, {"name": "R", "type": "BOOL", "description": "R=1: Cancel topology determination"}, {"name": "DP_ID", "type": "HW_IOSYSTEM", "description": "DP master system ID of those master systems for which the topology will be determined"}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "If an error occurs while the instruction is being executed, the return value contains an error code."}, {"name": "BUSY", "type": "BOOL", "description": "BUSY=1: Topology determination is not yet complete."}, {"name": "DPR", "type": "BYTE", "description": "PROFIBUS address of the diagnostics repeater reporting the error."}, {"name": "DPRI", "type": "BYTE", "description": "Measuring segment diagnostics repeater reporting the error: Bit 0 = 1: Temporary faults on segment DP2; Bit 1 = 1: Permanent faults on segment DP2; Bit 4 = 1: Temporary faults on segment DP3; Bit 5 = 1: Permanent faults on segment DP3"}], "InOut": []}, "_to_use": "Call DP_TOPOL with REQ=1 and the appropriate DP_ID to start bus topology determination. The process is asynchronous and can take several minutes. If needed, call DP_TOPOL again monitor progress or cancel with R=1. Reset the instruction by calling it with REQ=0 and R=1 before repeating topology determination after an error. Monitor RET_VAL for error codes and BUSY for completion status. Use DPR and DPRI outputs to identify errors reported by diagnostics repeaters.", "example_code": "", "additional_info": "Only one DP master system topology can be determined at a time. If DP_TOPOL is called again with the same DP_ID on an ongoing job, RET_VAL = W#16#7002 is returned indicating a follow-up call. Calling with a different DP_ID when a job is active is rejected. RET_VAL codes differentiate temporary and permanent errors; temporary errors may resolve without user action and require repeated calls. Permanent errors require user intervention before retrying. Determining topology may take several minutes.", "generated_brief": {"functional_summary": "DP_TOPOL triggers and manages the asynchronous determination of the physical topology for a selected PROFIBUS DP master system to facilitate detailed diagnostics of line errors.", "usage_context": "It is used after configuring or physically modifying a DP master system to identify network layout changes and diagnose communication faults via repeaters."}, "generated_keywords": ["topology determination", "DP master system", "asynchronous diagnostic", "bus configuration update", "error location detection"]}
{"instruction_name": "DELETE", "description": "You use this instruction to delete a portion of the character string in the IN input parameter. With the P parameter, you specify the position of the first character to be deleted. You specify the number of characters to be deleted in the L parameter. The remaining partial character string is output at the OUT output parameter in (W)STRING format.\n\nNote the following rules when executing the instruction:\n- If the value in the P parameter is less than or equals zero, an empty character string will be output in the OUT output parameter.\n- If the value in the P parameter is greater than the current length of the character string in the IN input, the input character string will be returned in the OUT output parameter.\n- If the value in the L parameter equals zero, the input character string will be returned in the OUT output parameter.\n- If the number of characters to be deleted at the L parameter is greater than the length of the character string at the IN input parameter, the characters starting at the position specified by the P parameter are deleted. The string resulting from this is output.\n- If the value in the L parameter is negative, an empty character string will be output.\n\nIf errors occur during processing of the instruction and it is possible to write the OUT output parameter, an empty string will be output.", "parameters": {"Input": [{"name": "IN", "type": "STRING, WSTRING", "description": "Character string"}, {"name": "L", "type": "BYTE, INT, SINT, USINT", "description": "Number of characters to be deleted"}, {"name": "P", "type": "BYTE, INT, SINT, USINT", "description": "Position of first character to be deleted"}], "Output": [{"name": "OUT", "type": "STRING, WSTRING", "description": "Resulting character string"}], "InOut": []}, "how_to_use": "Connect the parameters as follows: specify the character string to modify on IN input, specify the starting position of deletion on P input, specify the number of characters to delete on L input. The modified string is available at the OUT output. Note the rules on input values (e.g., if P<=0 output is empty string, if L=0 output is full string, etc.).", "example_code": "(* Global Data Block items: *)\nVAR_GLOBAL\n  inputSTRING : STRING[80];\n  startingPoint : INT;\n  deleteNumber : INT;\n  outputResidualSTRING : STRING[80];\nEND_VAR\n\n(* Example usage *)\ninputSTRING := 'Siemens PLC Programming';\nstartingPoint := 3;\ndeleteNumber := 4;\n\noutputResidualSTRING := DELETE(IN := inputSTRING, P := startingPoint, L := deleteNumber);", "additional_info": "If errors occur during execution and the OUT parameter can be written, an empty string will be output. This instruction supports both STRING and WSTRING data types for input and output.", "generated_brief": {"functional_summary": "The DELETE instruction removes a specified number of characters from a given position within an input character string and outputs the resulting modified string.", "usage_context": "It is typically used in PLC programming to manipulate and process strings, such as editing messages or data fields dynamically during automation tasks."}, "generated_keywords": ["string deletion", "character removal", "substring manipulation", "PLC string processing", "dynamic string editing"]}
{"instruction_name": "INSERT", "description": "You use this instruction to insert the character string in the IN2 input parameter to the character string in the IN1 input parameter. With the P parameter, you specify the position of the character starting at which the characters are inserted. The result is output at the OUT output parameter in (W)STRING format. Note the following rules when executing the instruction: If the value in the P parameter exceeds the current length of the character string in the IN1 input parameter, the character string of the IN2 input parameter will be appended to the character string of the IN1 input parameter. If the value in the P parameter is zero, the character string of the IN1 input parameter will be appended to the character string of the IN2 input parameter. If the value in the P parameter is negative, an empty character string will be output in the OUT output parameter. If the resulting character string is longer than the tag specified in the OUT output parameter, the resulting character string will be limited to the available length.", "parameters": {"Input": [{"name": "IN1", "type": "STRING, WSTRING", "description": "Character string"}, {"name": "IN2", "type": "STRING, WSTRING", "description": "String to insert"}, {"name": "P", "type": "BYTE, INT, SINT, USINT", "description": "Insert position"}], "Output": [{"name": "OUT", "type": "STRING, WSTRING", "description": "Resulting character string"}], "InOut": []}, "how_to_use": "Initialize the parameters IN1 and IN2 with the character strings to be combined. Set the parameter P to specify the insertion position: if P is greater than the length of IN1, IN2 is appended to IN1; if P is zero, IN1 is appended to IN2; if P is negative, OUT will be empty. The combined result is stored in OUT. Ensure OUT has sufficient length to store the resulting string as it will be truncated if overflow occurs.", "example_code": "VAR\n  input1_STRING : STRING[20];\n  input2_STRING : STRING[20];\n  startingPoint : INT;\n  outputStrg1AndStrg2 : STRING[40];\nEND_VAR\n\ninput1_STRING := 'ABCDE';\ninput2_STRING := '123';\nstartingPoint := 3;\n\nINSERT(IN1 := input1_STRING, IN2 := input2_STRING, P := startingPoint, OUT => outputStrg1AndStrg2);", "additional_info": "When specifying the P parameter, be mindful of its value relative to IN1's length to control the insertion behavior. The instruction supports both STRING and WSTRING data types. If the output exceeds the allocated length of the OUT parameter, the result will be truncated.", "generated_brief": {"functional_summary": "The INSERT instruction inserts one character string into another at a specified position, producing a combined string as output.", "usage_context": "It is used in PLC programming when dynamically modifying or combining strings based on position within industrial control applications."}, "generated_keywords": ["string insertion", "character string combine", "dynamic string modification", "position-based string insert", "PLC string operation"]}
{"instruction_name": "REPLACE", "description": "You use this instruction to replace a portion of the character string in the IN1 input with the character string in the IN2 input parameter. You specify the position of the first character to be replaced in the P parameter. You specify the number of characters to be replaced in the L parameter. The result is output at the OUT output parameter in (W)STRING format.", "parameters": {"Input": [{"name": "IN1", "type": "STRING, WSTRING", "description": "String with characters to be replaced."}, {"name": "IN2", "type": "STRING, WSTRING", "description": "String with characters to be inserted."}, {"name": "L", "type": "BYTE, INT, SINT, USINT", "description": "Number of characters to be replaced"}, {"name": "P", "type": "BYTE, INT, SINT, USINT", "description": "Position of first character to be replaced"}], "Output": [{"name": "OUT", "type": "STRING, WSTRING", "description": "Resulting character string"}], "InOut": []}, "how_to_use": "Set the input IN1 as the original string, IN2 as the string to insert, P as the starting position for replacement (1-based index), and L as the number of characters to replace. If P is less than or equal to zero or L is less than zero, OUT will be an empty string. If P exceeds the length of IN1, IN2 is appended. If L is zero, the instruction inserts IN2 at position P without replacement. The resulting string is stored in OUT, truncated if necessary to fit the allocated size.", "example_code": "VAR\n  input1_STRING : STRING[20];\n  input2_STRING : STRING[20];\n  startingPoint : INT;\n  replaceNumber : INT;\n  outputNewSTRING : STRING[40];\nEND_VAR\n\ninput1_STRING := 'Siemens PLC Example';\ninput2_STRING := 'Test';\nstartingPoint := 3;\nreplaceNumber := 2;\n\noutputNewSTRING := REPLACE(IN1 := input1_STRING, IN2 := input2_STRING, P := startingPoint, L := replaceNumber);", "additional_info": "If the resulting string length exceeds the OUT parameter's length, it will be truncated. If L equals zero, REPLACE behaves like an INSERT instruction. When P is less than or equal to zero or L less than zero, the output is an empty string.", "generated_brief": {"functional_summary": "The REPLACE instruction modifies a specified portion of an input string by replacing it with another string starting at a given position and for a defined length, outputting the resulting string.", "usage_context": "It is used in PLC programs when dynamic editing of string data is required, such as inserting or substituting parts of strings for text processing and communication tasks."}, "generated_keywords": ["string replacement", "substring editing", "string insertion", "character position", "string manipulation"]}
{"instruction_name": "PE_Measurement_Value_RSP", "description": "The auxiliary block \"PE_Measurement_Value_RSP\" generates the response to the command Get_measurement_values. In the response, return the values of the requested measurements.", "parameters": {"Input": [{"name": "PE_I_DEV_NEW", "type": "BOOL", "description": "The parameter must be interconnected with the output parameter of the \"PE_I_DEV\" instruction. The auxiliary block is processed if the parameter value is set to \"1\"."}, {"name": "CMD", "type": "INT", "description": "Service-Request-ID of the PROFIenergy command. The parameter must be interconnected with the CMD output parameter of the \"PE_I_DEV\" instruction."}, {"name": "CMD_MODIFIER", "type": "INT", "description": "PROFIenergy sub-command (evaluated only if CMD=3, or CMD=16). The parameter must be interconnected with the CMD_MODIFIER output parameter of the \"PE_I_DEV\" instruction."}, {"name": "Count", "type": "BYTE", "description": "Number of measured values (Measurement_Values)."}, {"name": "Measurement_Values", "type": "VARIANT", "description": "Pointer to the array with the measured values (Measurement_IDs). For information on the structure of the array in accordance with the PROFIenergy profile, see PI Command \"Query_Measurement\" - \"Get_Measurement_values\"."}], "Output": [{"name": "ERROR", "type": "BOOL", "description": "\"0\": No error; \"1\": Error occurred."}, {"name": "STATUS", "type": "WORD", "description": "\"0\": No error; \"0x80B1\": Error in VARIANT setting, e.g. incorrect range"}], "InOut": [{"name": "ACTIVATE", "type": "BOOL", "description": "The instruction copies the input parameters to the DATA_ERROR_RSP data area at a rising edge at input ACTIVATE. The parameter is then reset by the instruction. The parameter must be set within 10 seconds after a rising edge is detected at parameter NEW of the \"PE_I_DEV\" instruction."}, {"name": "VALID", "type": "BOOL", "description": "The parameter must be interconnected with the VALID input of the \"PE_I_DEV\" instruction. The auxiliary block sets the parameter once the response data for the PROFIenergy controller is available and ready for transmission."}, {"name": "DATA_ERRORRSP", "type": "VARIANT", "description": "Pointer on the data area in which the response data is stored. The parameter is identical to the pointer for DATA_ERRORRSP of the \"PE_I_DEV\" instruction. The data area contains the complete PROFIenergy frame. Minimum length: 244 bytes"}]}, "how_to_use": "Set the input parameters appropriately, ensuring that PE_I_DEV_NEW is set to '1' to process the auxiliary block. ACTIVATE must receive a rising edge signal and be set within 10 seconds after the NEW parameter of 'PE_I_DEV' is detected. The block will then copy input data to DATA_ERRORRSP and update VALID when the response data is ready.", "example_code": "", "additional_info": "The DATA_ERRORRSP data area must have a minimum length of 244 bytes to contain the complete PROFIenergy frame. Input parameters must be interconnected with corresponding outputs or inputs of the 'PE_I_DEV' instruction. Refer to related PI Commands for array structure details.", "generated_brief": {"functional_summary": "The PE_Measurement_Value_RSP instruction generates and prepares the response containing requested measurement values for the PROFIenergy Get_measurement_values command.", "usage_context": "It is used in PROFIenergy-enabled PLC systems to send measurement data responses following a command, ensuring communication conformity within energy management processes."}, "generated_keywords": ["PROFIenergy measurement response", "Get_measurement_values command", "measurement data transmission", "auxiliary block activation", "energy management communication"]}
{"instruction_name": "QRY_CINT", "description": "The instruction QRY_CINT returns the following parameters of a cyclic interrupt OB: Cycle time, Phase offset, Status of the cyclic interrupt (enabled, delayed, expired, etc.). The cyclic interrupt OB is identified using the OB_NR parameter. The values of the queried cyclic interrupt parameters correspond to those at the time the \"QRY_CINT\" instruction is executed.", "parameters": {"Input": [{"name": "OB_NR", "type": "OB_CYCLIC (INT)", "description": "OB number (<32768) or symbolic addressing via the name of the OB (e.g. OB_MyOB)"}], "Output": [{"name": "CYCLE", "type": "UDINT", "description": "Cycle time in microseconds"}, {"name": "PHASE", "type": "UDINT", "description": "Phase offset"}, {"name": "STATUS", "type": "WORD", "description": "Status of the cyclic interrupt: Bit 0 to bit 4 represent status flags (enabled, delayed, expired, etc.), other bits always \"0\""}], "InOut": [{"name": "RET_VAL", "type": "INT", "description": "Status of the instruction, error codes if applicable"}]}, "how_to_use": "Use QRY_CINT to query the status parameters of a specified cyclic interrupt OB identified by OB_NR. Pass the OB number or symbolic name as the input. Read returned values for cycle time (CYCLE), phase offset (PHASE), and interrupt status (STATUS). Check RET_VAL for execution success or error codes.", "example_code": "", "additional_info": "STATUS bits 0-4 have specific meanings: bit 1 indicates enabled or delayed, bit 2 indicates enabled or expired, bit 4 indicates existence of the OB. On error, RET_VAL contains an error code and STATUS is set to 0. Possible error codes include 0 (no error), 8090 (OB does not exist or wrong type), and 80B2 (no result assigned to OB).", "generated_brief": {"functional_summary": "QRY_CINT retrieves the cycle time, phase offset, and current status flags of a specified cyclic interrupt OB in a PLC system.", "usage_context": "It is used when monitoring or diagnosing the configuration and state of cyclic interrupts during the operation of industrial automation processes."}, "generated_keywords": ["query cyclic interrupt", "cyclic interrupt status", "cyclic interrupt timing", "OB number identification", "interrupt status flags"]}
{"instruction_name": "UPDAT_PI", "description": "With the instruction, you update a partial image partition of the inputs defined in the configuration.", "parameters": {"Input": [{"name": "PART", "type": "PIP", "description": "Number of the process image partition of the inputs to be updated. Maximum value range (depending on the CPU): 1 <= n <= 31 (means process image partition n)."}], "Output": [{"name": "FLADDR", "type": "WORD", "description": "Address of the first byte to cause an error if an access error has occurred."}], "InOut": []}, "how_to_use": "The specified process image partition is updated when the instruction 'UPDAT_PI' is called. Ensure that the process image partition is not assigned to an interrupt OB and that it is not being updated by the system.", "example_code": "PART := 1;\nUPDAT_PI(PART, RET_VAL, FLADDR);\nIF RET_VAL = 16#0000 THEN\n    updateOk := TRUE;\nEND_IF;", "additional_info": "You must not perform a simultaneous update with the 'SYNC_PI' instruction. If using for process image partitions of DP standard slaves, the error codes of the 'DPRD_DAT' instruction may also apply.", "generated_brief": {"functional_summary": "The UPDAT_PI instruction updates a specified partial image partition of the PLC input process image based on the configuration.", "usage_context": "It is typically used when an application needs to refresh a defined input partition safely without conflicts, ensuring that the partition is not being updated by interrupts or system processes."}, "generated_keywords": ["update process image partition", "partial input refresh", "process image synchronization", "input partition update", "PLC input image management"]}
{"instruction_name": "MID", "description": "You use this instruction to extract a portion of the character string in the IN input parameter. With the P parameter, you specify the position of the first character to be extracted. With the L parameter, you define the length of the character string to be extracted. The extracted partial character string is output to the OUT output parameter. Note the following rules when executing the instruction: If the number of characters to be extracted exceeds the current length of the character string in the IN input parameter, a partial character string will be output. The partial character string starts at the P character string and is continued until the end of the character string. If the character position specified in the P parameter falls outside the current character string length in the IN input parameter, an empty character string will be output in the OUT output parameter. If the value of the P or L parameter equals zero or is negative, an empty character string will be output in the OUT output parameter. If errors occur during processing of the instruction and it is possible to write the OUT output parameter, an empty string will be output.", "parameters": {"Input": [{"name": "IN", "type": "STRING, WSTRING", "description": "Character string"}, {"name": "L", "type": "BYTE, INT, SINT, USINT", "description": "Length of the string to be extracted"}, {"name": "P", "type": "BYTE, INT, SINT, USINT", "description": "Position of the first character to be extracted (first character = 1)"}], "Output": [{"name": "OUT", "type": "STRING, WSTRING", "description": "Extracted partial string"}], "InOut": []}, "how_to_use": "Use the MID instruction to extract a substring from the IN parameter starting at position P for length L. Ensure that the positions and lengths are valid; if they exceed or are zero/negative, the result is an empty string. This instruction gracefully handles errors by outputting an empty string if extraction is impossible.", "example_code": "VAR\n  inputSTRING : STRING := 'ExampleString';\n  outputExtractSTRING : STRING;\n  startingPoint : INT := 3;\n  extractNumber : INT := 4;\nEND_VAR\n\n// Extract 4 characters starting from the 3rd character\noutputExtractSTRING := MID(IN := inputSTRING, P := startingPoint, L := extractNumber);", "additional_info": "If the requested length surpasses the input string length from the start position, MID returns the substring from the start position to the end of the input string. If start position or length are zero or negative, or if start position is beyond the string end, an empty string is returned.", "generated_brief": {"functional_summary": "The MID instruction extracts a substring from a given string starting at a specified position for a specified length, returning an empty string if parameters are invalid or out of range.", "usage_context": "This function is typically used in PLC programming to isolate specific parts of text data for processing, such as parsing inputs or preparing data for display or logging."}, "generated_keywords": ["string extraction", "substring", "character position", "string length", "text parsing"]}
{"instruction_name": "LOG2MOD", "description": "You use the \"LOG2MOD\" instruction to determine the hardware identifier for an IO (sub)module from the addressing of STEP 7 5.5 SPx (IO data address or diagnostic address).\nThe hardware identifier is used at the LADDR input parameter for addressing of various instructions. Convert the addressing parameters from STEP 7 5.5 SPx by calling \"LOG2MOD\" beforehand.", "parameters": {"Input": [{"name": "IOID", "type": "BYTE", "description": "Identifier of the address area as in STEP 7 5.5 SPx:\n- B#16#00: Bit15 of ADDR specifies whether an input (Bit15=0) or output address (Bit15=1) exists.\n- B#16#54= Peripheral input (PI)\n- B#16#55= Peripheral output (PQ)"}, {"name": "ADDR", "type": "WORD", "description": "Logical address of the IO data of the module as offset (corresponding addressing in STEP 7 5.5 SPx) or diagnostic address."}], "Output": [{"name": "HWID", "type": "HW_IO", "description": "Determined hardware identifier of the IO (sub)module."}], "InOut": [], "Return": [{"name": "RET_VAL", "type": "INT", "description": "Error code of the instruction."}]}, "how_to_use": "Call LOG2MOD with IOID and ADDR parameters that correspond to the STEP 7 5.5 SPx addressing method. The output HWID can then be used for further addressing of instructions. Check RET_VAL for errors, where 0 means no error, and 8093 means invalid address or IOID value.", "example_code": "", "additional_info": "Error codes:\n- 0: No error occurred.\n- 8093: Specified address is not used by any hardware components or specified IOID parameter value is invalid.\nThe error codes may be displayed as integer or hexadecimal in the program editor. Refer to 'Switching display formats in the program status' for details.", "generated_brief": {"functional_summary": "The LOG2MOD instruction converts STEP 7 5.5 SPx IO data or diagnostic addresses into a hardware identifier for the corresponding IO (sub)module.", "usage_context": "It is used when precise hardware addressing is required for further instruction calls in PLC programs based on STEP 7 5.5 SPx addressing schemes."}, "generated_keywords": ["hardware identifier conversion", "IO module addressing", "STEP 7 5.5 SPx address translation", "LOG2MOD instruction", "PLC IO addressing"]}
{"instruction_name": "DELETE_DB", "description": "You use the instruction \"DELETE_DB\" to delete a data block (DB) that was created from the user program by calling the instruction \"CREATE_DB\". If the data block was not created with \"CREATE_DB\", the error code W#16#80B5 is output at the RET_VAL parameter. The selected data block is not deleted immediately, but rather at the cycle control point after execution of the cycle OB. The \"DELETE_DB\" instruction works asynchronously. Processing takes place across several calls. You start the interrupt transfer by calling the instruction with REQ = 1. Output parameter BUS and bytes 2 and 3 of output parameter RET_VAL show the status of the job. When the output parameter BUSY has the value FALSE, the deletion of the data block is completed.", "parameters": {"Input": [{"name": "REQ", "type": "BOOL", "description": "REQ =1: Request to delete the DB with the number in the DB_NUMBER parameter"}, {"name": "DB_NUMBER", "type": "UINT", "description": "Number of the DB to be deleted"}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Error information (see \"RET_VAL parameter\")"}, {"name": "BUSY", "type": "BOOL", "description": "BUSY =1: The process is not yet complete."}], "InOut": []}, "how_to_use": "Call DELETE_DB with REQ set to TRUE and DB_NUMBER set to the data block number to delete. The deletion process is asynchronous; monitor BUSY output to track progress. When BUSY becomes FALSE, the deletion is complete. Check RET_VAL for any error codes indicating issues such as invalid DB number or DB not created with CREATE_DB. Deletion occurs at the cycle control point after the cycle OB execution. This instruction is only supported on SIMATIC S7-1500R/H-CPUs from firmware version V3.0 onward.", "example_code": "", "additional_info": "If the DB was not created using CREATE_DB, RET_VAL outputs error code W#16#80B5. Other possible error codes include invalid DB number (80A1), DB does not exist (80B1), write-protected memory card (80B4), insufficient load memory (80BB), and temporary resource bottleneck (80C3). The instruction is asynchronous and spans multiple calls. The deletion is not immediate but takes effect after OB cycle execution.", "generated_brief": {"functional_summary": "DELETE_DB asynchronously deletes a user-created data block (DB) from memory after the program cycle completes, providing status and error feedback.", "usage_context": "It is used in SIMATIC S7-1500R/H CPUs to manage and free memory by removing dynamically created data blocks when they are no longer needed."}, "generated_keywords": ["delete data block", "asynchronous deletion", "dynamic DB management", "SIMATIC S7-1500R/H", "memory release"]}
{"instruction_name": "READ_DBL", "description": "With the instruction, you copy a DB or an area of a DB in load memory (Micro Memory Card) to the data area of a destination DB. The destination data block must be runtime-relevant, which means it must not be created with the Only store in load memory attribute. The content of the load memory is not changed during the copy process.", "parameters": {"Input": [{"name": "REQ", "type": "BOOL", "description": "REQ = 1: Read request"}, {"name": "SRCBLK", "type": "VARIANT", "description": "Pointer to data block in the load memory that is to be read from"}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Error information"}, {"name": "BUSY", "type": "BOOL", "description": "BUSY = 1: The reading process is not yet complete."}, {"name": "DSTBLK", "type": "VARIANT", "description": "Pointer to the data block in the work memory that is written to"}], "InOut": []}, "how_to_use": "You start the job by calling 'READ_DBL' with REQ = 1. Ensure data consistency by not changing the destination area during execution.", "example_code": "If (execute) THEN\n    READ_DBL(REQ:=1, SRCBLK:='SourceDB_LoadMemory', DSTBLK:='TargetDB');\nEND_IF;", "additional_info": "The instruction is processed asynchronously and is not suitable for frequent (or cyclic) reading. Only one job can be processed simultaneously, and you may receive error code W#16#80C3 if the maximum number of active instructions is reached.", "generated_brief": {"functional_summary": "READ_DBL copies data from a data block stored in load memory to a runtime-relevant destination data block in work memory asynchronously without altering the source content.", "usage_context": "It is used to read configuration or parameter data from load memory into runtime memory when data consistency must be maintained and only one read operation occurs at a time."}, "generated_keywords": ["asynchronous data block read", "load memory to work memory", "runtime-relevant data copying", "single active read operation", "data consistency during read"]}
{"instruction_name": "WRIT_DBL", "description": "The instruction \"WRIT_DBL\" is used to transfer the contents of a DB or a DB area from the work memory to a DB or a DB area in the load memory (Micro Memory Card). The source DB must be runtime-relevant, which means it must not be created with the Only store in load memory attribute. The instruction works asynchronously, processing extends over multiple calls and is started by calling \"WRIT_DBL\" with REQ=1. The output parameters RET_VAL and BUSY indicate the status of the job.", "parameters": {"Input": [{"name": "REQ", "type": "BOOL", "description": "REQ = 1: Write request"}, {"name": "SRCBLK", "type": "VARIANT", "description": "Pointer to the DB the work memory that is to be read from. Restrictions: For BOOL type, length must be divisible by 8; for STRING type, length must be 1; source and destination blocks must have the same block access (both optimized or both non-optimized); when optimized access is used, STRUCT data type must not be used."}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Error information returned by the instruction. Various error codes indicate success, errors, or states."}, {"name": "BUSY", "type": "BOOL", "description": "BUSY = 1: The writing process is not yet complete."}, {"name": "DSTBLK", "type": "VARIANT", "description": "Pointer to the data block in the load memory that is written to."}], "InOut": []}, "how_to_use": "Initialize the instruction by setting REQ=1 to start the asynchronous write operation from a work-memory DB to a load-memory DB. Monitor the BUSY output to determine when the operation completes (BUSY=0). Check RET_VAL for error status. Ensure that source and destination DB blocks meet the requirements, such as matching block access type and valid VARIANT pointer lengths. Do not change the source range while BUSY is TRUE. Use carefully because frequent writes to the load memory can exceed memory card write limits.", "example_code": "VAR\n  execute : BOOL;\n  returnValue : INT;\n  busyFlag : BOOL;\n  SLI_srcDB_WRIT_DBL : ARRAY[0..9] OF INT; // example source array\n  SLI_dstDB_WRIT_DBL : ARRAY[0..9] OF INT; // destination in load memory\nEND_VAR\n\n// Usage in code\nIF execute THEN\n  WRIT_DBL(REQ:=TRUE, SRCBLK:=SLI_srcDB_WRIT_DBL, RET_VAL=>returnValue, BUSY=>busyFlag, DSTBLK=>SLI_dstDB_WRIT_DBL);\nEND_IF;\n\n// Monitor busyFlag and returnValue for completion and error handling", "additional_info": "Use of \"WRIT_DBL\" with S7-1500R/H-CPUs is supported only from firmware version V3.0. Start values changed by \"WRIT_DBL\" are lost when performing \"Upload from device\". Initial online/offline differences for S7-1200 FW V2.0/V2.1 may cause symbol status inconsistencies until reconnecting online. Changing the source range during execution (when BUSY=TRUE) is not allowed. Writing a DB created by an instruction does not change the user program checksum, but writing a loaded DB changes the checksum. \"WRIT_DBL\" is not suitable for frequent or cyclical writing due to the memory card write access limits.", "generated_brief": {"functional_summary": "WRIT_DBL asynchronously transfers data from a runtime-relevant work memory data block to a load memory data block on a Micro Memory Card, indicating the operation status via output parameters.", "usage_context": "It is used when updating or backing up data from system RAM to persistent load memory in PLCs, particularly for preserving data across power cycles while monitoring write progress and errors."}, "generated_keywords": ["asynchronous data write", "work memory to load memory", "data block transfer", "Micro Memory Card", "write status monitoring"]}
{"instruction_name": "READ_DBL", "description": "The \"READ_DBL\" instruction is used to transfer the contents of a DB or a DB area from the load memory to a DB or a DB area in the work memory. It is generally used to verify successful transfer of data written by \"WRIT_DBL\". The parameters SRCBLK and DSTBLK define the source in load memory and the destination in work memory respectively, and the output RET_VAL indicates processing status.", "parameters": {"Input": [{"name": "SRCBLK", "type": "VARIANT", "description": "Pointer to the DB or DB area in the load memory that is to be read from."}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Error return value that indicates the status of the read operation."}, {"name": "DSTBLK", "type": "VARIANT", "description": "Pointer to the DB or DB area in the work memory where the data is to be written."}], "InOut": []}, "how_to_use": "Use \"READ_DBL\" to read data asynchronously from a load memory DB to a work memory DB after a successful \"WRIT_DBL\" operation. Connect SRCBLK to the DB in load memory and DSTBLK to the destination DB in work memory. Check RET_VAL for errors and use to confirm data consistency.", "example_code": "", "additional_info": "Typically used following a \"WRIT_DBL\" to verify or read back the transferred data. The operation is asynchronous similar to \"WRIT_DBL\".", "generated_brief": {"functional_summary": "READ_DBL transfers data from a data block in load memory to a data block in work memory and provides a status indicating success or failure.", "usage_context": "It is typically used after a WRIT_D operation to asynchronously verify and confirm that data has been correctly written by reading it back into work memory."}, "generated_keywords": ["read data block", "load memory to work memory", "asynchronous data transfer", "data verification", "read after write"]}
{"instruction_name": "MAX_LEN", "description": "The MAX_LEN instruction determines the maximum length of the character string specified at the IN input parameter. This maximum length is output as a numerical value at the OUT parameter. If errors occur during processing of the instruction, the value \"0\" is output at the OUT parameter. Note that MAX_LEN does not check the character string at the IN parameter.", "parameters": {"Input": [{"name": "IN", "type": "STRING, WSTRING", "description": "Character string whose maximum length is to be determined."}], "Output": [{"name": "OUT", "type": "INT, DINT", "description": "Maximum number of characters of the specified character string."}], "InOut": []}, "how_to_use": "Provide the string variable as the IN parameter to the MAX_LEN instruction. The instruction returns the defined maximum length of the string (i.e., the maximum capacity, not the current length) at the OUT parameter. The string type can be either STRING or WSTRING. Ensure to handle the case when OUT returns 0 indicating an error.", "example_code": "VAR\n  inputSTRING : STRING[20];n  stringMLengthOUT : INT;\nEND_VAR\n\nstringMLengthOUT := MAX_LEN(IN := inputSTRING);", "additional_info": "The MAX_LEN instruction only reads the maximum length defined for the string; it does not validate the content of the string. To read the current number of valid characters in the string, use the LEN instruction instead.", "generated_brief": {"functional_summary": "The MAX_LEN instruction returns the maximum defined capacity of a given STRING or WSTRING variable as a numerical value.", "usage_context": "It is used when determining the allocated size of a string variable to manage memory or buffer limits in PLC programs."}, "generated_keywords": ["maximum string length", "string capacity", "STRING WSTRING size", "string buffer limit", "MAX_LEN instruction"]}
{"instruction_name": "RD_LGADR", "description": "Based on the hardware identifier, you can determine the IO addresses of a module, a central submodule or a submodule for PNIO and DP slaves with the \"RD_LGADR\" instruction.", "parameters": {"Input": [{"name": "IOID", "type": "BYTE", "description": "Is not evaluated"}, {"name": "LADDR", "type": "HW_ANY", "description": "Hardware identifier of the module or the submodule."}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Error information"}, {"name": "PEADDR", "type": "ANY", "description": "Field for the PI addresses with the Array of WORD data type. Note: The field has to lie in the non-optimized memory area."}, {"name": "PECOUNT", "type": "INT", "description": "Number of returned PI addresses"}, {"name": "PAADDR", "type": "ANY", "description": "Field for the PQ addresses with the Array of WORD data type. Note: The field has to lie in the non-optimized memory area."}, {"name": "PACOUNT", "type": "INT", "description": "Number of returned PQ addresses"}], "InOut": []}, "how_to_use": "Specify the hardware ID of the submodule at the LADDR parameter. The instruction writes the addresses to PEADDR (inputs) and PAADDR (outputs) in ascending order, using arrays of WORD type. The number of addresses is output at PECOUNT (inputs) and PACOUNT (outputs). For input modules, only PEADDR and PECOUNT are written; for output modules, PAADDR and PACOUNT are written. The address fields must be in a non-optimized memory area. Note that only the returned number of addresses (PECOUNT or PACOUNT) should be evaluated, as earlier calls may have left data in the arrays. When using packed addresses of an ET200, the first module returns all addresses, others output zeros and possibly error codes.", "example_code": "", "additional_info": "Error codes returned via RET_VAL include: 0x0000 (no error), 0x8090 (invalid hardware identifier), 0x80A0/0x80A1 (array elements not WORD type in PEADDR/PAADDR), 0x80A2/0x80A3 (array too small to hold all addresses). See also GET_ERR_ID instruction for general error handling.", "generated_brief": {"functional_summary": "The RD_LGADR instruction retrieves the input and output module IO addresses and their counts based on a given hardware identifier for PNIO and DP slave modules.", "usage_context": "It is used in PLC programs to determine the precise IO address mapping of modules or submodules for accurate data exchange in industrial automation systems."}, "generated_keywords": ["read IO addresses", "module hardware identifier", "PNIO DP slave address mapping", "input output address retrieval", "PLC module address determination"]}
{"instruction_name": "CTRL_PTO", "description": "The \"CTRL_PTO\" instruction makes a pulse sequence available to you with a preset frequency. For this you do not require an axis DB of a technological object.", "parameters": {"Input": [{"name": "REQ", "type": "BOOL", "description": "REQ=1: Sets the frequency of the pulse generator to the value of FREQUENCY. REQ=1 and FREQUENCY=0: Deactivates the pulse generator. REQ=0: No change at pulse generator."}, {"name": "PTO", "type": "HW_PTO", "description": "Hardware identifier of the pulse generator. This can be taken from the properties of the pulse generator in the device view or the list of system constants."}, {"name": "FREQUENCY", "type": "UDINT", "description": "Frequency of the pulse sequence to be output in Hz."}], "Output": [{"name": "DONE", "type": "BOOL", "description": "Status parameter with the following values: 0: Job not yet started or still in progress. 1: Job completed without error."}, {"name": "BUSY", "type": "BOOL", "description": "Processing status. Since the S7-1200 enables the pulse generator when the \"CTRL_PTO\" instruction is executed, BUSY always has the value FALSE with the S7-1200."}, {"name": "ERROR", "type": "BOOL", "description": "Status parameter: 0: No error. 1: An error occurred during execution of the instruction."}, {"name": "STATUS", "type": "WORD", "description": "Status of the instruction indicating error codes: 0 (No error), 8090 (Pulse generator already in use), 8091 (Frequency range exceeded), 80A1 (PTO param invalid hardware ID), 80D0 (Pulse generator not activated or no PTO property)."}], "InOut": []}, "how_to_use": "Activate a pulse generator in the hardware configuration and select the signal type. Specify the hardware pulse generator identifier at the PTO parameter, set REQ to TRUE to start or stop the pulse output by setting FREQUENCY. Monitor DONE, BUSY, ERROR, and STATUS outputs for execution status and errors. Note that only one pulse generator can be used at a time, and PWM/PTO outputs should not be accessed via the process image or forced signals.", "example_code": "", "additional_info": "At any one time a pulse generator can only be used by one instruction. Digital inputs and outputs used for PWM and PTO cannot be forced or controlled via the force table or watch table. PTO/PWM outputs should not be used in the process image due to update rate differences. Use the STATUS output to check specific error codes for troubleshooting.", "generated_brief": {"functional_summary": "The CTRL_PTO instruction controls a hardware pulse generator by outputting a pulse sequence at a specified frequency without requiring an axis data block.", "usage_context": "It is typically used in industrial automation to generate precise pulse sequences for hardware devices when direct axis control is unnecessary or unavailable."}, "generated_keywords": ["pulse generator control", "hardware PTO output", "frequency pulse sequence", "industrial automation pulse", "non-axis pulse generation"]}
{"instruction_name": "CTRL_PWM", "description": "The \"CTRL_PWM\" instruction is used to enable and disable a pulse output supported by the CPU using the software. When the bit in the ENABLE input of the instruction is set, the pulse output is enabled. If ENABLE has a value of TRUE the pulse generator will generate a pulse with the properties defined in the device configuration. When the bit in the ENABLE input is reset or the CPU changes to STOP, the pulse output is disabled and no more pulses are generated. BUSY always has the value of FALSE for S7-1200 since S7-1200 activates the pulse generator if the instruction \"CTRL_PWM\" is executed. When the EN enable input has signal state \"1\" and no errors have occurred during execution of the instruction, the enable output ENO is set.", "parameters": {"Input": [{"name": "PWM", "type": "HW_PWM", "description": "Hardware ID of the pulse generator. The hardware ID can be found in the properties of the pulse generator in the Device view. The hardware IDs of the pulse generators are also listed in the system constants."}, {"name": "ENABLE", "type": "BOOL", "description": "The pulse output is enabled when ENABLE = TRUE and disabled when ENABLE = FALSE."}], "Output": [{"": "BUS", "type": "BOOL", "description": "Processing status"}, {"name": "STATUS", "type": "WORD", "description": "Status of the instruction (contains error codes such as 0 for no errors, 80A1 for invalid hardware ID, 80D0 if pulse generator with specified hardware ID is not activated)."}], "InOut": []}, "how_to_use": "Activate the specified pulse generator in the hardware configuration prior to using the instruction by enabling \"Activate this pulse generator\" under 'Pulse generators (PTO/PWM)' in device properties. The pulse generator parameters (except pulse duration) must be set in the device configuration and CPU must be in STOP mode for changes to take effect. The instruction enables the pulse generator when ENABLE input is TRUE and disables it when FALSE or when CPU goes to STOP. BUSY output is FALSE on S7-1200 CPUs. Use the output STATUS for monitoring execution and errors.", "example_code": "", "additional_info": "Digital inputs and outputs assigned for PWM/PTO cannot be forced via the force table. Do not use PWM/PTO outputs in the process image since the update rate of the process image is slower than the actual PWM signals, and will not reflect the real signal flow. Pulse duration and cycle time parameters can be changed at runtime by writing to the output byte addresses assigned to the pulse generator in the device configuration if enabled in pulse options.", "generated_brief": {"functional_summary": "The CTRL_PWM instruction enables or disables a hardware pulse-width modulation (PWM) output in the CPU based on a boolean enable input while providing status information.", "usage_context": "It is used in industrial automation to control PWM outputs for tasks such as motor speed control or other pulse-driven devices by activating configured hardware pulse generators at runtime."}, "generated_keywords": ["enable disable PWM output", "hardware pulse generator control", "PWM status monitoring", "industrial automation pulse control", "CPU pulse output management"]}
{"instruction_name": "FileReadC", "description": "The \"FileReadC\" instruction is used to read data from a file located on the memory card and write it to a destination area on the CPU. You specify the file by entering its name and complete path. Enable reading from the file using the REQ control parameter. The output parameters Done, Busy, Error and Status indicate the status of the job.", "parameters": {"Input": [{"name": "REQ", "type": "BOOL", "description": "Control parameter Request. Enables reading a file from the memory card with a rising edge."}, {"name": "Name", "type": "STRING", "description": "Name of the file to be read including complete path."}, {"name": "Offset", "type": "UDINT", "description": "Byte offset after which the file is to be read."}, {"name": "Length", "type": "UDINT", "description": "Length of the area to be read in bytes. Length = 0 means that the maximum possible number of data items per call is read (for a S7-1500-CPU, 32 KB or the size of theData\" parameter)."}], "Output": [{"name": "Done", "type": "BOOL", "description": "1: The instruction has been executed successfully. The information read has been transferred to the \"Data\" parameter."}, {"name": "Busy", "type": "BOOL", "description": "Status parameter. 0: Execution of the instruction completed or not yet started. 1: Execution of the instruction not yet complete."}, {"name": "Error", "type": "BOOL", "description": "Status parameter. 0: No error. 1: An error occurred during execution of the instruction. Detailed information is output via the \"Status\" parameter."}, {"name": "Status", "type": "WORD", "description": "Error code."}, {"name": "ResultLength", "type": "UDINT", "description": "Length of data read in bytes."}], "InOut": [{"name": "Data", "type": "VARIANT", "description": "Destination area for data read. Permitted data types: BYTE and Array of BYTE."}]}, "how_to_use": "Call the FileReadC instruction with a rising edge on REQ. Specify the file path and name in 'Name' parameter, set the 'Offset' and 'Length' to read the desired byte range. Manage calls multiple times if data to read exceeds device-specific segment size (e.g. 32 KB on S7-1500). Check 'Busy' while reading is ongoing and 'Done' when finished. Handle errors by checking 'Error' and 'Status'.", "example_code": "", "additional_info": "File path and name must follow specific rules: max 55 characters; permitted characters 0-9, a-z, A-Z, -, _; only one dot '.' allowed; path must not start with '/', '\\' or '.'; path must not contain '..'. Maximum read length is 16 MB. Reading happens asynchronously across multiple calls if needed. Only access the data after the last call completes. Detailed error codes provide guidance on faults such as invalid paths, data area issues, and access violations.", "generated_brief": {"functional_summary": "The FileReadC instruction reads data asynchronously from a specified file on the memory card into a designated CPU memory area, providing status feedback through control signals.", "usage_context": "It is typically used in industrial automation to retrieve file data stored on memory cards for processing or monitoring within a PLC program."}, "generated_keywords": ["asynchronous file read", "memory card file access", "PLC file data transfer", "read file with offset and length", "file read status monitoring"]}
{"instruction_name": "FileWriteC", "description": "The 'FileWriteC' instruction is used to write data located in a source area on the CPU to a file located in the 'UserFiles' folder on the memory card. You specify this file by entering its name and complete path. If the file does not exist, it is created by the CPU in the 'UserFiles' folder.", "parameters": {"Input": [{"name": "REQ", "type": "BOOL", "description": "Control parameter Request. Enables writing a file on the memory card with a rising edge."}, {"name": "Name", "type": "STRING", "description": "Name of the file to be written including the complete path."}, {"name": "Offset", "type": "UDINT", "description": "Byte offset from which the file is to be written."}, {"name": "Length", "type": "UDINT", "description": "Length of the area to be written in bytes. 'Length' = 0 means that the entire source area specified with the 'Data' parameter is written."}], "Output": [{"name": "Done", "type": "BOOL", "description": "1: The instruction has been executed successfully."}, {"name": "Busy", "type": "BOOL", "description": "Status parameter. 0: Execution of the instruction completed or not yet started. 1: Execution of the instruction not yet complete."}, {"name": "Error", "type": "BOOL", "description": "Status parameter. 0: No error. 1: An error occurred during execution of the instruction."}, {"name": "Status", "type": "WORD", "description": "Error code."}, {"name": "ResultLength", "type": "UDINT", "description": "Length of data written in bytes."}], "InOut": [{"name": "Data", "type": "VARIANT", "description": "Source area. Permitted data types: BYTE and Array of BYTE."}]}, "how_to_use": "Start processing with a rising edge at the parameter 'REQ'.", "example_code": "", "additional_info": "You can write up to 16 MB by executing 'FileWriteC'; the data is written segment by segment. Ensure 'Offset' + 'Length' <= 16 MB.", "generated_brief": {"functional_summary": "The FileWriteC instruction writes data from the CPU's memory to a specified file on the memory card, creating the file if it does not exist.", "usage_context": "It is typically used to save process data or logs to persistent storage in industrial automation systems for later retrieval or."}, "generated_keywords": ["file write", "memory card storage", "data logging", "persistent file creation", "CPU to file transfer"]}
{"instruction_name": "GEN_DIAG", "description": "The \"GEN_DIAG\" instruction generates diagnostics information for hardware components from other manufacturers for use in TIA Portal diagnostics. The GSD(GSDL/GSDML) file supplied by the manufacturer must first be installed before the instruction can be used. The instruction generates all diagnostic events (including those for maintenance).", "parameters": {"Input": [{"name": "LADDR", "type": "HW_ANY", "description": "Identification number of the hardware component."}, {"name": "MODE", "type": "UINT", "description": "Selection of incoming/outgoing information:\n1: The diagnostic event specified is an incoming event\n2: The diagnostic event specified is an outgoing event\n3: All diagnostic events are outgoing. There are therefore no hardware component faults (green diagnostics symbol). The DiagEvent parameter is not evaluated when MODE = 3."}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Status of instruction / error message."}], "InOut": [{"name": "DiagEvent", "type": "DiagnosticDetail", "description": "Specifies the diagnostic event. When a tag is defined at the DiagEvent parameter, the DiagnosticDetail structure is created automatically in the local interface of the block."}]}, "how_to_use": "Install the GSD(GSDL/GSDML) file supplied by the manufacturer before using GEN_DIAG. Use the LADDR parameter to specify the hardware component, the MODE parameter to specify the event direction, and the DiagEvent parameter to define the diagnostic event using the DiagnosticDetail structure. RET_VAL is used to check for errors. Diagnostics information is provided synchronously.", "example_code": "", "additional_info": "Failsafe-specific error messages are not valid and cause error code 80A1. The instruction checks for failsafe-specific diagnostics information and returns an error if found. Diagnostics information transfer and alarm output are asynchronous. RET_VAL error codes include: 0 (No error), 8080 (Unsupported MODE value), 8090 (Hardware component ID not available), 8091 (Diagnostics information cannot be generated), 80A (Invalid or inconsistent DiagEvent content or failsafe info), 80A4 (Hardware component cannot be accessed), 80C1 (Insufficient resources for parallel execution).", "generated_brief": {"functional_summary": "The GEN_DIAG instruction generates diagnostic information for third-party hardware components in TIA Portal using manufacturer-supplied GSD files, reporting all diagnostic events including maintenance alerts.", "usage_context": "It is used in industrial automation systems to monitor and diagnose hardware faults or status by specifying component IDs and event types synchronously within PLC programs."}, "generated_keywords": ["hardware diagnostics", "third-party component monitoring", "GSD file integration", "diagnostic event generation", "TIA Portal diagnostics"]}
{"instruction_name": "GET_DIAG", "description": "The \"GET_DIAG\" instruction is used to read the diagnostic information of a hardware component. The hardware component is selected with the parameter LADDR. With the MODE parameter, you select which diagnostic information is read. The S7-1200 CPU ignores the parameter LADDR when MODE=0.", "parameters": {"Input": [{"name": "MODE", "type": "UINT", "description": "Use the MODE parameter to select which diagnostics data is output."}, {"name": "LADDR", "type": "HW_ANY (UINT)", "description": "Hardware ID of the hardware component"}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Status of the instruction"}, {"name": "CNT_DIAG", "type": "UINT", "description": "Reserved (always \"0\")."}], "InOut": [{"name": "DIAG", "type": "VARIANT", "description": "Diagnostic information corresponds to the selected mode."}, {"name": "DETAIL", "type": "VARIANT", "description": "Parameter is hidden. Do not use this parameter!"}]}, "how_to_use": "Select the hardware component by providing its hardware ID via the LADDR parameter. Choose the diagnostic mode via the MODE parameter: 0 for supported diagnostic modes as DWORD (LADDR ignored in S7-1200), 1 for diagnostic status of the addressed hardware component returned in a DIS structure, 2 for diagnostics of subordinate components returned in a DNN structure. Provide variables of appropriate data types (DIS or DNN) for DIAG parameter depending on MODE. Check RET_VAL for the status of the instruction call.", "example_code": "VAR\n  myLADDR : HW_ANY := 52; // Hardware ID of CPUExecUnit\n  diagMODE : UINT := 1;\n  myDIAG : DIS;\n  returnValue : INT;\n  CountDiagDetails : UINT;\nEND_VAR\n\nGET_DIAG(MODE := diagMODE, LADDR := myLADDR, RET_VAL => returnValue, CNT_DIAG => CountDiagDetails, DIAG => myDIAG, DETAIL => );", "additional_info": "For MODE=0, CNT_DIAG is always 0 and LADDR is ignored on S7-1200 CPUs. DIS and DNN are system data types used for detailed diagnostics output in MODE 1 and MODE 2 respectively. RET_VAL error codes include 0 (no error), 8080 (unsupported MODE), 8081/8082 (type not supported for DIAG/DETAIL), 8090 (LADDR does not exist), and 80C1 (insufficient resources for parallel execution). When using DIS structure, bits in ComponentStateDetail indicate detailed status information. Example: To check a specific diagnostic bit, address it using ComponentStateDetail.%X3. In diagnostics of an IO device, reading mode 1 reads the device's self-diagnostics while mode 2 reads subordinate module diagnostics.", "generated_brief": {"functional_summary": "The GET_DIAG instruction reads diagnostic information from a specified hardware component using a selected mode to determine the type of diagnostic data retrieved.", "usage_context": "It is used in PLC programs to monitor and troubleshoot hardware components by accessing their diagnostic status and detailed error information during operation."}, "generated_keywords": ["read hardware diagnostics", "diagnostic mode selection", "hardware component status", "PLC diagnostic instruction", "GET_DIAG instruction"]}
{"instruction_name": "GET_DIAG", "description": "The \"GET_DIAG\" instruction is used to read the diagnostic information of a hardware component. The hardware component is selected with the parameter LADDR. With the MODE parameter, you select which diagnostic information is read. The S7-1200 CPU ignores the parameter LADDR when MODE=0.", "parameters": {"Input": [{"name": "MODE", "type": "UINT", "description": "Use the MODE parameter to select which diagnostics data is output. Can be I, Q, M, D, L or constant."}, {"name": "LADDR", "type": "HW_ANY (UINT)", "description": "Hardware ID of the hardware component. Can be I, Q, M, L or constant."}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Status of the instruction. Can be I, Q, M, D, L."}, {"name": "CNT_DIAG", "type": "UINT", "description": "Reserved (always \"0\"). Can be I, Q, M, D, L."}], "InOut": [{"name": "DIAG", "type": "VARIANT", "description": "Diagnostic information corresponds to the selected mode."}, {"name": "DETAIL", "type": "VARIANT", "description": "Parameter is hidden. Do not use this parameter!"}]}, "how_to_use": "Select the hardware component with LADDR and diagnostic mode with MODE. MODE=0 returns supported diagnostic info bits, MODE=1 returns diagnostic status of the addressed hardware component (structure DIS), MODE=2 returns status of subordinate components (structure DNN). Initialize DIAG variable with the corresponding structure type (DIS or DNN) based on MODE. Check RET_VAL for errors and CNT_DIAG indicates reserved output (always 0). The DETAIL parameter is hidden and should not be used.", "example_code": "VAR\n  myDIAG : DIS;\n  myLADDR : UINT := 52; // Hardware ID for CPUExecUnit\n  diagMODE : UINT := 1;\n  returnValue : INT;\n  CountDiagDetails : UINT;\nEND_VAR\n\nGET_DIAG(\n  MODE:= diagMODE,\n  LADDR:= myLADDR,\n  RET_VAL=> returnValue,\n  CNT_DIAG=> CountDiagDetails,\n  DIAG:= myDIAG\n);", "additional_info": "RET_VAL possible error codes include 0 (no error), 8080 (unsupported MODE), 8081 (DIAG parameter type not supported with MODE), 8082 (DETAIL parameter type not supported with MODE), 8090 (LADDR does not exist), 80C1 (insufficient resources for parallel execution). For standard CPUs, use LADDR = 52 for determining OperatingState with MODE=1. For R/H systems, use LADDR 65147 or 65347 for CPU redundant control and 34 for system state. The diagnostic data structures DIS and DNN must be predefined in your project when using MODE 1 and 2 respectively.", "generated_brief": {"functional_summary": "The GET_DIAG instruction reads diagnostic information from a specified hardware component based on the selected mode and hardware ID parameters.", "usage_context": "It is used in industrial PLC programs to monitor and retrieve status or diagnostic data from hardware components for troubleshooting and system health monitoring."}, "generated_keywords": ["read diagnostic information", "hardware component diagnostics", "diagnostic mode selection", "PLC hardware monitoring", "error status retrieval"]}
{"instruction_name": "IO2MOD", "description": "The \"IO2MOD\" instruction determines the hardware identifier of the module from an IO address (I, Q, PI, PQ) of a module.\nEnter the IO address at the ADDR parameter.\n- If a series of IO addresses is used at this parameter, only the first address is evaluated to determine the hardware identifier.\n- If the first address is correctly specified, the length for the address specification at the ADDR parameter is of no significance.\n- If an address area is used that encompasses several modules or unused addresses, the hardware identifier of the first module can also be determined.\n- If no IO address of a module is specified at parameter ADDR, the error code 8090 is output at parameter RET_VAL.", "parameters": {"Input": [{"name": "ADDR", "type": "VARIANT", "description": "IO address (I, Q, PI, PQ) within a module. Make sure that slice access is not used for the parameter ADDR. If this is the case, incorrect values are output at the LADDR parameter."}], "Output": [{"name": "LADDR", "type": "HW_IO", "description": "Determined hardware identifier (logical address) of the IO module."}], "InOut": []}, "how_to_use": "Provide the IO address at the ADDR parameter to determine the hardware identifier of the corresponding module. Ensure not to use slice access on ADDR to avoid incorrect results. The instruction evaluates only the first IO address if multiple addresses are provided. Check the RET_VAL output parameter to verify successful execution or error conditions.", "example_code": "VAR\n    SLI_IOtest : VARIANT;\n    ioLaddr : HW_IO;\n    returnValue : INT;\n    execute : BOOL;\nEND_VAR\n\nIF execute THEN\n    IO2MOD(ADDR := SLI_IOtest, LADDR => ioLaddr, RET_VAL => returnValue);\nEND_IF;", "additional_info": "Error codes returned in RET_VAL include 0 (no error), 8090 (IO address at ADDR not used by any hardware component), and 8092 (invalid data type used at ADDR). In SCL programming, use symbolic tag names or absolute addresses in the process image instead of direct I/O access IDs like \"%QWx:P\".", "generated_brief": {"functional_summary": "The IO2MOD instruction determines the hardware identifier (logical address) of an IO module based on a provided IO address within that module.", "usage_context": "This function is typically used in PLC programs to map IO addresses to their corresponding physical modules for hardware identification and diagnostics."}, "generated_keywords": ["hardware identifier", "IO address mapping", "module identification", "PLC IO module", "logical address determination"]}
{"instruction_name": "JOIN", "description": "The \"JOIN\" instruction connects multiple strings into an array. It converts multiple strings into a single one using different formats (CSV or FSR) and delimiters for individual strings and the end of the concatenated string.", "parameters": {"Input": [{"name": "Mode", "type": "DWORD", "description": "Specifies how the merger to string is performed, including format selection (CSV or FSR) and whether an additional delimiter character is added at the end."}, {"name": "RecSeparator", "type": "VARIANT", "description": "Delimiter character for the source strings. In CSV format, used as delimiter between strings; in FSR format, used as fill character."}, {"name": "EndSeparator", "type": "VARIANT", "description": "Delimiter character to be written at the end of the characters if bit 3 = 1 is set in Mode parameter."}, {"name": "SrcStruct", "type": "VARIANT", "description": "Pointer to the source strings. Can be Array of STRING, Array of WSTRING or structures containing exclusively STRING or WSTRING data types."}, {"name": "Count", "type": "UDINT", "description": "Number of source strings to join. Only applies if SrcStruct is Array of (W)STRING. Ignored otherwise."}], "Output": [{"name": "Ret_Val", "type": "INT", "description": "Status of the instruction execution with error codes indicating success or specific errors."}], "InOut": [{"name": "DestArray", "type": "VARIANT", "description": "Array of CHAR or WCHAR where the joined string is written. Length should be set based on the source strings' length."}, {"name": "Position", "type": "UDINT", "description": "Index position in DestArray where the conversion writing starts and completes, enabling filling of the array in parts."}]}, "how_to_use": "Set the Mode parameter to choose CSV or FSR format and whether to add an additional delimiter at the end. Specify source strings in SrcStruct as an array or structure of strings. Use Count to limit number of strings if applicable. Choose appropriate delimiter characters for RecSeparator and EndSeparator, ensuring they do not conflict. Provide a DestArray that is sized to hold the result. Position specifies the index within DestArray where writing begins. Monitor Ret_Val for execution status and error handling.", "example_code": "", "additional_info": "Mode parameter bits: Bit 0 selects CSV (0) or FSR (1) format; Bit 3 selects whether to write an end delimiter. Error codes in Ret_Val specify issues like unsupported Mode, invalid source strings, buffer overflow, or mismatching data types. When using FSR format, if source string is longer than reserved space, it is truncated; if shorter, space filled with fill character. Use delimiters carefully to avoid conflicts especially if reversing the conversion with SPLIT instruction.", "generated_brief": {"functional_summary": "The JOIN instruction concatenates multiple strings into a single string array using specified formats (CSV or FSR) and delimiters, allowing controlled string merging with optional end delimiters.", "usage_context": "This function is typically used in PLC programs to combine multiple string variables into one formatted string for data logging, communication, or further processing in industrial automation systems."}, "generated_keywords": ["string concatenation", "string array join", "CSV FSR formatting", "delimiter specification", "PLC string merging"]}
{"instruction_name": "PE_WOL", "description": "The \"PE_WOL\" instruction sends the PROFIenergy commands \"Start_Pause\" and \"End_Pause\" to multiple PROFIenergy-enabled devices in the PROFINET I/O systems. Multiple PE devices can be coordinated via the instruction provided that the PE devices support the \"Wake on LAN\" function over a UDP connection. The \"PE_WOL\" instruction can only be executed on a CPU with an integrated Ethernet interface. This CPU should be able to load blocks with a size of approx. 400 KB. If this CPU is connected via an Ethernet CP, it is not possible to use the block with PROFINET I/O systems. The instruction \"PE_WOL\" is executed asynchronously. The \"PE_WOL\" instruction only supports devices with a device number lower than 256. Devices with a higher device number are not taken into account.", "parameters": {"Input": [{"name": "COM_RST", "type": "BOOL", "description": "Resets the block and performs a re-initialization. As long as True is set here, the initialization is started but not yet fully completed. Only the falling edge continues the initialization and switches to the normal operating mode after initialization."}, {"name": "START", "type": "BOOL", "description": "A rising edge performs a \"CmdStartPause\" PROFIenergy command for all detected devices that support this function."}, {"name": "", "type": "BOOL", "description": "A rising edge performs a \"CmdEndPause\" PROFIenergy command for all detected devices that support this function."}], "Output": [{"name": "STATUS", "type": "DWORD", "description": "Status/error number for the current status of the instruction (see \"STATUS parameter\")."}], "InOut": [{"name": "PENERGY", "type": "PE_PLUS", "description": "Pointer to the user DB that contains the database for processing multiple devices."}]}, "how_to_use": "Initialize the \"PE_WOL\" instruction by setting the COM_RST input to true and then to false to start initialization. Use the START and END input bits with rising edges to send the PROFIenergy commands \"CmdStartPause\" and \"CmdEndPause\" respectively to all recognized PROFIenergy-capable devices in the PROFINET I/O system. The data block referenced by PENERGY must be properly initialized with device and connection data before operation. The instruction processes commands asynchronously, allowing multiple devices to be managed. Only one command is executed at a time based on priority: CmdStartPause highest, CmdEndPause second, CmdUpdateStatus lowest. At least one CPU cycle with the Update bit cleared must occur between command updates to ensure proper edge detection.", "example_code": "", "additional_info": "The instruction requires a CPU with an integrated Ethernet interface capable of loading approx. 400 KB blocks; cannot be used via an Ethernet CP PROFINET I/O. Only devices with device numbers <256 are supported. The user data block (PENERGY, type PE_PLUS) must contain at minimum the PROFINET I/O system ID, Wake on LAN connection data and port, plus device-specific parameters such as PauseTime and EnableSleep. The instruction operates asynchronously. Multiple commands queued are processed in order regardless of success or error states. The status output parameter reports error and current status codes.", "generated_brief": {"functional_summary": "The PE_WOL instruction asynchronously sends PROFIenergy Start_Pause and End_Pause commands via Wake on LAN to multiple PROFIenergy-enabled devices within a PROFINET I/O system using a CPU with an integrated Ethernet interface.", "usage_context": "It is used to coordinate energy management commands among PROFIenergy-capable devices in industrial automation systems to control device power states during operation pauses."}, "generated_keywords": ["PROFIenergy commands", "Wake on LAN", "PROFINET I/O system", "energy management", "asynchronous device control"]}
{"instruction_name": "RD_ADDR", "description": "The \"RD_ADDR\" instruction determines the length and the start address of the inputs or outputs based on the hardware identifier of a sub(module). Use the LADDR parameter to select the input or output module based on the hardware identifier. In the case of an input module the determined values are output at the PIADDR and PIC parameters. In the case of an output module the determined values are output at the PQADDR and PQCOUNT parameters. The PIADDR and PQADDR parameters each contain the start address of the I/O addresses of the module. The PICOUNT and PQCOUNT parameters each contain the number of bytes of the inputs or outputs (1 byte for 8 inputs/outputs, 2 bytes for 16 inputs/outputs).", "parameters": {"Input": [{"name": "LADDR", "type": "HW_IO", "description": "Hardware identifier of the (sub)module."}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Error code of the instruction."}, {"name": "PIADDR", "type": "UDINT", "description": "Start address of the input module."}, {"name": "PICOUNT", "type": "UINT", "description": "Number of bytes of the inputs."}, {"name": "PQADDR", "type": "UDINT", "description": "Start address of the output module."}, {"name": "PQCOUNT", "type": "UINT", "description": "Number of bytes of the outputs."}], "InOut": []}, "how_to_use": "Provide the hardware identifier of the input or output module in the LADDR parameter. When the instruction executes, it determines the start address and the byte length of the input or output module. For input modules, use PIADDR and PICOUNT the start address and length. For output modules, use PQADDR and PQCOUNT. Check the RET_VAL parameter for error codes to ensure the module was identified correctly.", "example_code": "VAR\n    readLaddr : HW_IO;\n    readRetVal : INT;\n    piAddr : UDINT;\n    piCount : UINT;\n    executeRead : BOOL;\nEND_VAR\n\nIF executeRead THEN\n    RD_ADDR(\n        LADDR:=readLaddr,\n        RET_VAL=>readRetVal,\n        PIADDR=>piAddr,\n        PICOUNT=>piCount,\n        PQADDR=>,\n        PQCOUNT=>\n    );\nEND_IF;", "additional_info": "When using packed addresses of an ET200, the first module of the pack group returns all addresses. For other modules, PIADDR and PQADDR may return zero for PROFINET and PROFIBUS (with an additional error code W#16#8090). PICOUNT and PQCOUNT return 0 for these modules. The RET_VAL parameter returns error codes such as 0 for no error and 8090 if the hardware identifier is invalid.", "generated_brief": {"functional_summary": "The RD_ADDR instruction retrieves the start address and byte length of input or output modules based on their hardware identifier.", "usage_context": "It is used in PLC programs to dynamically identify and access the I/O addresses and sizes of connected modules for communication and control purposes."}, "generated_keywords": ["read module address", "input output length", "hardware identifier", "IO address retrieval", "PLC IO configuration"]}
{"instruction_name": "RH_GetPrimaryID", "description": "The \"RH_GetPrimaryID\" instruction is used to determine the redundancy ID of the primary CPU. You can use this instruction in all system states even if the pairing of the two R or H CPUs has not yet been performed.", "parameters": {"Input": [], "Output": [{"name": "Ret_Val", "type": "INT", "description": "Return value containing the redundancy ID of the primary CPU or error code."}], "InOut": []}, "how_to_use": "Use the instruction to retrieve the redundancy ID of the primary CPU in a redundant setup. It can be used at any system state, even before pairing of redundant CPUs. Check the Ret_Val output to determine the primary CPU or to detect errors.", "example_code": "", "additional_info": "The Ret_Val can have values such as 1 or 2 indicating the primary CPU ID, or error codes like 8091 if the CPU does not support this instruction. Error codes are displayed as integer or hexadecimal in the program editor; you can switch display formats via program status settings.", "generated_brief": {"functional_summary": "The RH_GetPrimaryID instruction retrieves the redundancy ID of the primary CPU in a redundant control system.", "usage_context": "It is used in all system states to identify the primary CPU before or after pairing in redundant CPU configurations and to detect related errors."}, "generated_keywords": ["redundancy ID retrieval", "primary CPU identification", "redundant CPU system", "error code detection", "system state independent"]}
{"instruction_name": "Random", "description": "The 'Random' instruction is used to generate a 32-bit random number.", "parameters": {"Input": [], "Output": [{"name": "Ret_Val", "type": "UDINT", "description": "32-bit random number"}], "InOut": []}, "how_to_use": "", "example_code": "", "additional_info": "The 'Random' instruction does not provide any error information.", "generated_brief": {"functional_summary": "The 'Random' instruction generates a 32-bit unsigned random number output.", "usage_context": "It is typically used in PLC programs when a random value is needed for processes such as testing, simulations, or creating variability in control logic."}, "generated_keywords": ["generate random number", "32-bit random value", "unsigned integer output", "random generation", "PLC random instruction"]}
{"instruction_name": "RecipeExport", "description": "The \"RecipeExport\" instruction exports the recipe data from a data block to a CSV file in the load memory.\nWith S7-1500 CPUs, the DB that is to be exported can be located either in the work memory or in the load memory. If the data block is in both the work memory and the load memory, the values from the work memory are exported. For S7-1200 CPUs, the DB to be exported must be present in the load memory.\nThe CSV file is created in the load memory. For S7-1500 CPUs, this is the memory card; for S7-1200 CPUs the internal or external load memory (if a memory card is present).\nDuring the export, the CSV file is created in the \"Recipes\" folder in the main directory of the load memory. The name of the data block is used as file name of the created CSV file. If a CSV file with an identical name already exists, it is overwritten during the export.\nEach recipe data record generates a line in the CSV file. These lines have the following structure:\n- The first line contains the \"Index\" entry and the name of the recipe components.\n- Each additional line contains the number of the recipe data record (index) and the associated components.\nThe maximum size of a data record is 5000 bytes; if exceeded, error code W#16#8092 is returned. The same 5000 byte restriction applies to the size of the header. If the header size exceeds 5000 bytes, S7-1500 CPUs export it up to 5000 bytes and continue with the first recipe data record. S7-1200 CPUs reject the export entirely with error W#16#8092.\nS7-1200 CPUs also the number of columns to 255 (excluding the index column).\nIf the recipe DB with standard access has too many components (e.g. two ARRAYs and one structure), only the first ARRAY is exported and STATUS is set to W#16#0000.", "parameters": {"Input": [{"name": "REQ", "type": "BOOL", "description": "Control parameter REQUEST: Activates the export on a rising edge."}], "Output": [{"name": "DONE", "type": "BOOL", "description": "Status parameter: 0 = Job not yet started or still executing; 1 = Job executed without errors."}, {"name": "BUSY", "type": "BOOL", "description": "Status parameter: 0 = Instruction not executed; 1 = Instruction executed."}, {"name": "ERROR", "type": "BOOL", "description": "Status parameter: 0 = Neither warning nor error; 1 = An error has occurred, STATUS supplies detailed information."}, {"name": "STATUS", "type": "WORD", "description": "Status parameter providing detailed status and error codes."}], "InOut": [{"name": "RECIPE_DB", "type": "VARIANT", "description": "Pointer to the recipe data block located in data memory. The data block structure must follow recipe DB requirements."}]}, "how_to_use": "Trigger the export by setting REQ to TRUE with a rising edge. BUSY is set during export. When done, DONE is set to TRUE and BUSY resets to FALSE. Monitor ERROR and STATUS for error conditions. The CSV file is saved in the 'Recipes' folder in the load memory. Ensure the recipe DB complies with size and structure limitations, especially for S7-1200 CPUs. If the data record or header exceeds 5000 bytes, the export may fail or be partial depending on CPU type.", "example_code": "", "additional_info": "Error codes include:\n- 0: No error\n- 7000: No job processing active\n- 7001: Job started (BUSY=1, DONE=0)\n- 7002: Instruction already active\n- 8090: Invalid characters in CSV file name\n- 8091: Nested structure or column count >255 on S7-1200\n- 8092: Data structure too large\n- 80B3: Insufficient memory\n- 80B4: Memory card write-protected\n- 80B6: Recipe DB not activated (S7-1200 specific)\n- 80C0: CSV file locked temporarily\n- 80C1: Recipe DB temporarily disabled\n- 80C3: Too few resources\n- 8624: RECIPE_DB points to impermissible area\n- 8652: Insufficient tag at RECIPE_DB\nFurthermore, if a CSV file with the same name exists, it will be overwritten. The instruction handles export asynchronously and must not be retriggered while BUSY is set.", "generated_brief": {"functional_summary": "The RecipeExport instruction exports recipe data from a data block to a CSV file stored in the load memory, allowing structured recipe data to be saved externally for further use or backup.", "usage_context": "It is typically used in industrial automation systems to export and backup recipe configurations from PLCs, particularly in S7-1200 and S7-1500 CPUs, ensuring recipe data can be transferred or archived reliably."}, "generated_keywords": ["recipe export", "CSV file generation", "data block export", "load memory storage", "PLC recipe backup"]}
{"instruction_name": "RecipeImport", "description": "The \"RecipeImport\" instruction imports the recipe data from a CSV file of the load memory into the data block at the RECIPE_DB parameter. For S7-1500 CPUs, the CSV file is on the memory card; for S7-1200 CPUs, it is in the internal or external load memory (if a memory card is present). The values in the data block are overwritten in the process. With S7-1500 CPUs, the DB to which the recipe data is to be imported can be located either in the work memory or in the load memory. If it is in both the work memory and the load memory, the values are imported to the data block located in the work memory. For S7-1200 CPUs, the DB into which the recipe data is to be imported must be located in the load memory. The recipe is only maintained permanently if it is imported to a load memory DB. If it is imported to a work memory DB but you need it permanently, you must transfer the recipe to a load memory DB after the import with the help of the WRIT_DBL instruction. Note the following when importing the CSV file: The CSV file must be located in the \"Recipes\" directory of the load memory; the name of the CSV file must match the name of the data block at the RECIPE_DB parameter; each line of the CSV file corresponds to one recipe data record with the first line as a header which is ignored during import; the first value in each line is the index number of the recipe, which must be in ascending order without gaps; the CSV file must not contain more recipe data records than provided for in the data block; if a value does not fit the associated data type, the import is rejected (strings truncated if too long, BOOL type accepted differently on S7-1500 and S7-1200); DATE_AND_TIME values outside permissible range default to default value; if the recipe DB is a DB with standard access and more components than permitted, data is only imported into the first ARRAY and STATUS set to W#16#0000.", "parameters": {"Input": [{"name": "REQ", "type": "BOOL", "description": "Control parameter REQUEST: Activates the import on a positive edge."}], "Output": [{"name": "DONE", "type": "BOOL", "description": "Status parameter. 0: Job not yet started or still executing. 1: Job executed without errors."}, {"name": "BUSY", "type": "BOOL", "description": "Status parameter. 0: The instruction is not executed. 1: The instruction is executed."}, {"name": "ERROR", "type": "BOOL", "description": "Status parameter. 0: Neither warning nor error. 1: An error has occurred, STATUS supplies detailed information on the type of error."}, {"name": "STATUS", "type": "WORD", "description": "Status parameter. Provides detailed error codes."}], "InOut": [{"name": "RECIPE_DB", "type": "VARIANT", "description": "Pointer to the recipe data block. For information on the structure of the data block, refer to the Structure of a recipe DB."}]}, "how_to_use": "Activate the import process by setting REQ parameter to TRUE on a positive edge. Monitor the BUSY parameter to know when the import is in progress (BUSY=1) and when it completes (BUSY=0 and DONE=1 In case of errors during import, ERROR is set and STATUS contains a detailed error code. Ensure the CSV file is correctly named and placed in the 'Recipes' directory of the load memory. After import to a work memory DB, use WRIT_DBL to persist the recipe data to load memory if permanent maintenance is required.", "example_code": "", "additional_info": "Status error codes provide detailed diagnostic information, e.g., 8090 for invalid characters in the filename, 80B0 for non-continuous or invalid indexing in the CSV, 8092 for no matching CSV file, among others. The CSV file's first line is a header and ignored during import. Indexes in the CSV must be continuous and ascending without gaps. Data type mismatches or data exceeding limits will cause import failure or warnings. The recipe DB must be correctly structured to match the CSV content.", "generated_brief": {"functional_summary": "The RecipeImport instruction imports recipe data from a CSV file stored in the load memory into a specified recipe data block in the PLC, overwriting its current values.", "usage_context": "It is typically used in industrial automation to load predefined process parameters or configurations from external files into the PLC for production or process control purposes."}, "generated_keywords": ["Recipe import", "CSV file load", "Data block update", "Load memory access", "PLC recipe management"]}
{"instruction_name": "SPLIT", "description": "The \"SPLIT\" instruction converts an array (Array of CHAR / WCHAR) into several separate strings (Array of STRING / WSTRING or structure).", "parameters": {"Input": [{"name": "Mode", "type": "DWord", "description": "Specifies how the split into multiple strings is performed. The first bit selects CSV or FSR format, other bits specify behavior for additional characters, counting EndSeparator, and handling unwritten strings."}, {"name": "RecSeparator", "type": "Variant", "description": "Delimiter or fill character. With CSV: character used to separate individual strings. With FSR: fill character used in the array."}, {"name": "EndSeparator", "type": "Variant", "description": "Delimiter used to define the end of the total string in the array to be read. Reading stops at this delimiter with higher priority than RecSeparator."}, {"name": "SrcArray", "type": "Variant", "description": "Pointer to the array to be read (Array of CHAR/WCHAR)."}], "Output": [{"name": "Count", "type": "UDInt", "description": "Number of strings that were found. Only valid if DestStruct is an Array of STRING; otherwise, 0 is output."}, {"name": "Ret_Val", "type": "Int", "description": "Result of instruction execution / error code."}], "InOut": [{"name": "DestStruct", "type": "Variant", "description": "Structure which includes the converted strings (Array of STRING / WSTRING)."}, {"name": "Position", "type": "UDInt", "description": "Position from which the array is to be read at the SrcArray parameter and updated to indicate where conversion completed."}]}, "how_to_use": "Specify the source array in SrcArray, select the format with the Mode parameter (bit 0: CSV or FSR), define the delimiters with RecSeparator and EndSeparator and specify the destination strings structure in DestStruct. Use Position for tracking reading progress for subsequent calls. The instruction splits the source array into separate strings based on the selected format and delimiters. Pay attention to matching data types across SrcArray, delimiters, and DestStruct. The Ret_Val parameter indicates success or various error codes.", "example_code": "(* Example of SPLIT with CSV format and Mode=2#10 *)\nVAR\n  SrcArray : ARRAY[1..50] OF CHAR := '1963,Miller,John,Roadname';\n  DestArray : ARRAY[1..4] OF STRING[14];\n  Mode : DWORD := 2#10; (* CSV format, ignore extra characters *)\n  RecSeparator : CHAR := ',';\n  EndSeparator : CHAR := '#';\n  Position : UDINT := 0;\n  Count : UDINT;\n  Ret_Val : INT;\nEND_VAR\n\nRet_Val := SPLIT(\n  Mode := Mode,\n  RecSeparator := RecSeparator,\n  EndSeparator := EndSeparator,\n  SrcArray := SrcArray,\n  DestStruct := DestArray,\n  Position := Position,\n  Count => Count\n);", "additional_info": "The data types of SrcArray (CHAR or WCHAR), RecSeparator, EndSeparator, and DestStruct (STRING or WSTRING) must be compatible to avoid error code 80B4. The Mode parameter bits control: bit 0 for CSV/FSR, bit 1 for handling additional characters, bit 3 for counting EndSeparator in Position, and bit 4 for setting unused strings length to 0. Error codes provide details on issues like missing separators, invalid data types, or out-of-range positions.", "generated_brief": {"functional_summary": "The SPLIT instruction parses an array of CHAR or WCHAR characters into multiple separate strings based on specified delimiters and formats.", "usage_context": "It is typically used in PLC programs to extract individual strings from a combined character array, such as CSV data, for further processing or control logic."}, "generated_keywords": ["array split", "string parsing", "delimiter-based extraction", "CSV and FSR format", "character array to strings"]}
{"instruction_name": "STRG_VAL", "description": "The 'STRG_VAL' instruction converts a character string to an integer or a floating-point number.", "parameters": {"Input": [{"name": "IN", "type": "STRING, WSTRING", "description": "Number string to be converted. Must contain permitted characters."}, {"name": "FORMAT", "type": "WORD", "description": "Input format of the characters. Defines how the characters of the string are interpreted."}, {"name": "P", "type": "UINT", "description": "Reference to the first character to be converted. The first character = 1."}], "Output": [{"name": "OUT", "type": "USINT, SINT, UINT, INT, UDINT, DINT, REAL, LREAL", "description": "Result of the conversion."}], "InOut": []}, "how_to_use": "Specify the character string to convert in the IN parameter, select the desired output data type in the OUT parameter, and reference the starting character in the P parameter.", "example_code": "string inputSTRING := '123.45';\nREAL outputVAL;\nVAR\n   FORMAT : WORD := W#16#0000; // Decimal fraction\n   P : UINT := 1; // Start at first character\nEND_VAR\nSTRG_VAL(IN := inputSTRING, FORMAT := FORMAT, P := P, OUT := outputVAL);", "additional_info": "Permitted characters for the conversion are digits '0' to '9', the decimal point/comma, notations 'E' and 'e', and plus/minus characters. Conversion is canceled if an invalid character is found.", "generated_brief": {"functional_summary": "The STRG_VAL instruction converts a character string representing a number into an integer or floating-point numeric value.", "usage_context": " is used in PLC programs when numeric data is received or stored as strings and must be converted for arithmetic processing or control logic."}, "generated_keywords": ["string to number conversion", "character string parsing", "numeric string conversion", "integer and floating-point conversion", "PLC string to numeric"]}
{"instruction_name": "SYNC_PI", "description": "The 'SYNC_PI' is used to update the process image partition of inputs in isochronous mode. A user program linked to a DP cycle or PN send cycle uses this instruction to update input data acquired in a process image partition of the inputs isochronously and consistently.", "parameters": {"Input": [{"name": "PART", "type": "PIP", "description": "Number of the process image partition of the inputs to be updated isochronously."}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Error information."}, {"name": "FLADDR", "type": "WORD", "description": "Address of the first byte to cause an error if an access error has occurred."}], "InOut": []}, "how_to_use": "Call the 'SYNC_PI' instruction within OBs 61, 62, 63, or 64 while ensuring the affected process image partition is assigned to the OB in the hardware configuration.", "example_code": "", "additional_info": "The 'SYNC_PI' instruction is interruptible and must not be used simultaneously with the 'UPDAT_PI' instruction for the same process image partition.", "generated_brief": {"functional_summary": "The 'SYNC_PI' instruction updates a specified process image partition of input data isochronously and consistently within a user program.", "usage_context": "It is used within OBs 61 to 64 during DP or PN communication cycles to ensure synchronized input data updates assigned to the hardware configuration."}, "generated_keywords": ["process image partition update", "isochronous input synchronization", "DP PN cycle input update", "OB 61 to 64 usage", "input error detection"]}
{"instruction_name": "VAL_STRG", "description": "The 'VAL_STRG' instruction is used to convert a numerical value into a character string.", "parameters": {"Input": [{"name": "IN", "type": "USINT, SINT, UINT, INT, UDINT, DINT, REAL, LREAL", "description": "Value to be converted."}, {"name": "SIZE", "type": "USINT", "description": "Number of character positions."}, {"name": "PREC", "type": "USINT", "description": "Number of decimal places."}, {"name": "FORMAT", "type": "WORD", "description": "Output format of the characters."}], "Output": [{"name": "OUT", "type": "STRING, WSTRING", "description": "Result of the conversion."}], "InOut": [{"name": "P", "type": "UINT", "description": "Character starting at which the result is written."}]}, "how_to_use": "Specify the numerical value in the IN parameter and configure the sizes and formats as needed. Ensure that all parameters are set correctly to avoid conversion errors.", "example_code": "", "additional_info": "The values in the FORMAT parameter are only relevant if the IN parameter has data type REAL or LREAL. If SIZE is set to 0, all necessary characters are written starting from position P.", "generated_brief": {"functional_summary": "The VAL_STRG instruction converts various numerical data types into a formatted character string output.", "usage_context": "It is typically used in PLC programs when displaying or logging numerical values as readable text with specific formatting requirements."}, "generated_keywords": ["numeric to string conversion", "formatted string output", "data type conversion", "decimal precision formatting", "character string generation"]}
{"instruction_name": "PE_Get_Mode_RSP", "description": "The auxiliary block \"PE_Get_Mode_RSP\" generates the response to the command Get_Mode. The response frame contains the time, performance, or energy data of an energy-saving mode.", "parameters": {"Input": [{"name": "PE_I_DEV_NEW", "type": "BOOL", "description": "The parameter must be interconnected with the NEW output parameter of the \"PE_I_DEV\" instruction. The auxiliary block is processed if the parameter value is set to \"1\"."}, {"name": "CMD", "type": "INT", "description": "Service-Request-ID of the PROFIenergy command. The parameter must be interconnected with the CMD output parameter of the \"PE_I_DEV\" instruction."}, {"name": "CMD_MODIFIER", "type": "INT", "description": "PROFIenergy sub-command (evaluated only if CMD=3, or CMD=16). The parameter must be interconnected with the CMD_MODIFIER output parameter of the \"PE_I_DEV\" instruction."}, {"name": "PE_Mode_ID", "type": "BYTE", "description": "ID of the energy-saving mode currently enabled."}, {"name": "PE_Mode_Attributes", "type": "BYTE", "description": "Additional information regarding energy saving mode"}, {"name": "Time_min_Pause", "type": "DWORD", "description": "Minimum pause duration for this PE energy-saving mode. This is the sum of the following three parameters: Time_to_Pause, Time_to_operate, Time_min_length_of_stay."}, {"name": "Time_to_Pause", "type": "DWORD", "description": "Time between the edge at the START parameter (see \"PE_I_DEV\") and the requested PE energy-saving mode being reached."}, {"name": "Time_to_Operate", "type": "DWORD", "description": "Maximum switch-on time to \"PE_ready_to_operate\". The \"Time_to_operate\" parameter can be used directly for the relevant calculations. The value may be a static maximum, or be calculated dynamically by the PE entity."}, {"name": "Time_min_Lenght_of_stay", "type": "DWORD", "description": "Minimum dwell time of the PE entity in this PE mode."}, {"name": "Time_max_Lenght_of_stay", "type": "DWORD", "description": "Maximum dwell time of the PE entity in this PE mode."}, {"name": "Mode_Power_Consumption", "type": "DWORD", "description": "Energy consumption in the current PE mode in [kW]."}, {"name": "Energy_Consum_to_Pause", "type": "DWORD", "description": "Energy consumption from \"PE_ready_to_operate\" to the current PE mode in [kWh]."}, {"name": "Energy_Consum_to_operate", "type": "DWORD", "description": "Energy consumption from the current PE mode to \"PE_ready_to_operate\" in [kWh]."}], "Output": [{"name": "ERROR", "type": "BOOL", "description": "\"0\": No error; \"1\": Error occurred."}, {"name": "STATUS", "type": "WORD", "description": "\"0\": No error; \"0x80B1\": Error in VARIANT setting, e.g. incorrect range"}], "InOut": [{"name": "ACTIVATE", "type": "BOOL", "description": "The instruction copies the input parameters to the DATA_ERROR_RSP data area at a rising edge at input ACTIVATE. The parameter is then reset by the instruction. The parameter must be set within 10 seconds after a rising edge is detected at parameter NEW of the \"PE_I_DEV\" instruction."}, {"name": "VALID", "type": "BOOL", "description": "The parameter must be interconnected with the VALID input of the \"PE_I_DEV\" instruction. The auxiliary block sets the parameter once the response data for the PROFIenergy controller is available and ready for transmission."}, {"name": "DATA_ERRORRSP", "type": "VARIANT", "description": "Pointer on the data area in which the response data is stored. The parameter is identical to the pointer for DATA_ERRORRSP of the \"PE_I_DEV\" instruction. The addressed data area contains the complete PROFIenergy frame. Minimum length: 244 bytes"}]}, "how_to_use": "Use the PE_Get_Mode_RSP auxiliary block to generate the response frame for the Get_Mode command. Connect input parameters such as PE_I_DEV_NEW, CMD, CMD_MODIFIER, and others as specified. Set the ACTIVATE parameter on a rising edge to copy input parameters to the data area. Ensure ACTIVATE is set within 10 seconds after NEW of PE_I_DEV is detected. Monitor VALID to know when response data is ready and check ERROR and STATUS outputs for error handling.", "example_code": "", "additional_info": "All parameters must be mapped to the specified memory areas (I, Q, M, D, L, or constant) as permitted. The DATA_ERRORRSP data area pointed to by DATA_ERRORRSP must have a minimum length of 244 bytes. Pay attention to the timing requirement for ACTIVATE parameter setting to ensure proper processing.", "generated_brief": {"functional_summary": "The PE_Get_Mode_RSP instruction generates a response frame containing time, performance, and energy data for the current energy-saving mode upon receiving a Get_Mode command.", "usage_context": "This function is used within PROFIenergy-enabled systems to provide detailed status and energy consumption information in response to a Get_Mode request, ensuring timely and accurate communication with the energy-saving controller."}, "generated_keywords": ["PROFIenergy response", "Get_Mode command", "energy-saving mode data", "response frame generation", "energy consumption reporting"]}
{"instruction_name": "PE_Identify_RSP", "description": "The auxiliary block \"PE_Identify_RSP\" generates the response to the command PE_Identify. In the response to the command, specify which PROFIenergy commands are supported. Please note that PE_IDENTIFY is itself a PE command and has to be included in the response.", "parameters": {"Input": [{"name": "PE_I_DEV_NEW", "type": "BOOL", "description": "The parameter must be interconnected with the NEW output parameter of the \"PE_I_DEV\" instruction. The auxiliary block is processed if the parameter value is set to \"1\"."}, {"name": "CMD", "type": "INT", "description": "Service-Request-ID of the PROFIenergy command. The parameter must be interconnected with the CMD output parameter of the \"PE_I_DEV\" instruction."}, {"name": "Start_Pause", "type": "BOOL", "description": "One parameter for each of the relevant PROFIenergy commands: 0: PE command is not supported; 1: PE command is supported"}, {"name": "End_Pause", "type": "BOOL", "description": ""}, {"name": "Query_Modes", "type": "BOOL", "description": ""}, {"name": "PEM_Status", "type": "BOOL", "description": ""}, {"name": "PE_Identify", "type": "BOOL", "description": ""}, {"name": "Query_Measurement", "type": "BOOL", "description": ""}], "Output": [{"name": "ERROR", "type": "BOOL", "description": "\"0\": No error; \"1\": Error occurred."}, {"name": "STATUS", "type": "WORD", "description": "\"0\": No error; \"0x80B1\": Error in VARIANT setting, e.g. incorrect range"}], "InOut": [{"name": "ACTIVATE", "type": "BOOL", "description": "The instruction copies the input parameters to the DATA_ERROR_RSP data area at a rising edge at input ACTIVATE. The parameter is then reset by the instruction. The parameter must be set within 10 seconds after a rising edge is detected at parameter NEW of the \"PE_I_DEV\" instruction."}, {"name": "VALID", "type": "BOOL", "description": "The parameter must be interconnected with the VALID input of the \"PE_I_DEV\" instruction. The auxiliary block sets the parameter once the response data for the PROFIenergy controller is available and ready for transmission."}, {"name": "DATA_ERRORRSP", "type": "VARIANT", "description": "Pointer on the data area in which the response data is stored. The parameter is identical to the pointer for DATA_ERRORRSP of the \"PE_I_DEV\" instruction. The addressed data area contains the complete PROFIenergy frame. Minimum length: 244 bytes"}]}, "how_to_use": "Connect the inputs to the outputs of the PE_I_DEV instruction as specified. The auxiliary block processes the inputs when PE_I_DEV_NEW is set to true (1). Activate the response by setting ACTIVATE high within 10 seconds after the NEW signal is detected at PE_I_DEV. Monitor VALID to confirm that the response is ready and check and STATUS outputs for error handling.", "example_code": "", "additional_info": "Data types must be valid and compatible. The DATA_ERRORRSP area must have a minimum length of 244 bytes to store the PROFIenergy frame. PE_IDENTIFY command must always be included in the response.", "generated_brief": {"functional_summary": "The PE_Identify_RSP instruction generates and prepares the response data indicating which PROFIenergy commands, including PE_IDENTIFY, are supported in reply to the PE_Identify command.", "usage_context": "It is typically used within PROFIenergy-enabled automation systems to respond to identification requests by the PROFIenergy controller, ensuring proper communication and command support acknowledgment."}, "generated_keywords": ["PROFIenergy response generation", "PE_Identify command handling", "Command support indication", "PROFIenergy controller communication", "Response data preparation"]}
{"instruction_name": "PE_Measurement_List_RSP", "description": "The auxiliary block \"PE_Measurement_List_RSP\" generates the response to the command Get_measurement_list. In the response, specify which measured values (Measurement-IDs) are supported.", "parameters": {"Input": [{"name": "PE_I_DEV_NEW", "type": "BOOL", "description": "The parameter must be interconnected with the NEW output parameter of the \"PE_I_DEV\" instruction. The auxiliary block is processed if the parameter value is set to \"1\"."}, {"name": "CMD", "type": "INT", "description": "Service-Request-ID of the PROFIenergy command. The parameter must be interconnected with the CMD output parameter of the \"PE_I_DEV\" instruction."}, {"name": "CMD_MODIFIER", "type": "INT", "description": "PROFIenergy sub-command (evaluated only if CMD=3, or CMD=16). The parameter must be interconnected with the CMD_MODIFIER output parameter of the \"PE_I_DEV\" instruction."}, {"name": "Count", "type": "BYTE", "description": "Number of measured values supported (measurement IDs)"}, {"name": "Measurement", "type": "VARIANT", "description": "Pointer to the array with the Measurement_IDs supported. For information on the structure of the array in accordance with the PROFIenergy profile, see: PI Command \"Query_Measurement\" - \"Get_Measurement_list\"."}], "Output": [{"name": "ERROR", "type": "BOOL", "description": "\"0\": No error; \"1\": Error occurred."}, {"name": "STATUS", "type": "WORD", "description": "\"0\": No error; \"0x80B1\": Error in VARIANT setting, e.g. incorrect range"}], "InOut": [{"name": "ACTIVATE", "type": "BOOL", "description": "The instruction copies the input parameters to the DATA_ERROR_RSP data area at a rising edge at input ACTIVATE. The parameter is then reset by the instruction. The parameter must be set within 10 seconds after a rising edge is detected at parameter NEW of the \"PE_I_DEV\" instruction."}, {"name": "VALID", "type": "BOOL", "description": "The parameter must be interconnected with the VALID input of the \"PE_I_DEV\" instruction. The auxiliary block sets the parameter once the response data for the PROFIenergy controller is available and ready for transmission."}, {"name": "DATA_ERRORRSP", "type": "VARIANT", "description": "Pointer on the data area in which the response data is stored. The parameter is identical to the pointer for DATA_ERRORRSP of the \"PE_I_DEV\" instruction. The addressed data area contains complete PROFIenergy frame. Minimum length: 244 bytes"}]}, "how_to_use": "Connect the input parameters as specified, especially those linked to the \"PE_I_DEV\" instruction's outputs. Set the ACTIVATE input TRUE within 10 seconds after the NEW signal is set. The block processes the inputs and writes the response data to the DATA_ERRORRSP area, setting VALID to indicate readiness. Monitor STATUS and ERROR outputs for error handling.", "example_code": "", "additional_info": "Ensure that the DATA_ERRORRSP area is allocated with at least 244 bytes to store the PROFIenergy frame. The Measurement_List array must comply with the PROFIenergy profile structure. The ACTIVATE input triggers data processing on its rising edge and is reset automatically. Data types must follow the allowed data types for PLC memory areas.", "generated_brief": {"functional_summary": "The PE_Measurement_List_RSP instruction generates and sends a response listing the supported measured values (Measurement-IDs) for a PROFIenergy Get_measurement_list command.", "usage_context": "It is used within PROFIenergy-enabled PLC applications to provide measurement capability information to energy management controllers following a measurement list request."}, "generated_keywords": ["PROFIenergy measurement response", "Get_measurement_list handling", "Measurement-IDs supported listing", "PE_I_DEV integration", "Energy data response generation"]}
{"instruction_name": "PE_PEM_Status_RSP", "description": "The auxiliary block \"PE_PEM_Status_RSP\" generates the response to the command PEM_Status.", "parameters": {"Input": [{"name": "PE_I_DEV_NEW", "type": "BOOL", "description": "The parameter must be interconnected with the NEW output parameter of the \"PE_I_DEV\" instruction. The auxiliary block is processed if the parameter value is set to \"1\"."}, {"name": "CMD", "type": "INT", "description": "Service-Request-ID of the PROFIenergy command. The parameter must be interconnected with the CMD output parameter of the \"PE_I_DEV\" instruction."}, {"name": "PE_MODE_ID_Source", "type": "BYTE", "description": "Source and Destination for PEM_STATUS.\nValues:\n0x00: PE_POWER_OFF\n0x01 – 0xFE: manufacturer-specific\n0xFF: PE_READY_TO_OPERATE"}, {"name": "PE_MODE_ID_Destination", "type": "BYTE", "description": ""}, {"name": "Time_to_Operate", "type": "DWORD", "description": "Maximum switch-on time to \"PE_ready_to_operate\". Time_to_operate can be used directly for the relevant calculations. The value may be a static maximum, or be calculated dynamically by the PE entity."}, {"name": "Remaining_time_to_destination", "type": "DWORD", "description": "Optional: Time remaining until the requested PE mode. Dynamic value or static maximum value"}, {"name": "Mode_Power_Consumption", "type": "DWORD", "description": "Energy consumption in the current PE mode in [kW]."}, {"name": "Energy_Consumption_to_Destination", "type": "DWORD", "description": "Energy consumption in the time until the requested PE mode in [kW]."}, {"name": "Energy_Consumption_to_operate", "type": "DWORD", "description": "Energy consumption from the current PE mode to \"PE_ready_to_operate\" in [kWh]."}], "Output": [{"name": "ERROR", "type": "BOOL", "description": "\"0\": No error\n\"1\": Error occurred."}, {"name": "STATUS", "type": "WORD", "description": "\"0\": No error\n\"0x80B1\": Error in VARIANT setting, e.g. incorrect range"}], "InOut": [{"name": "ACTIVATE", "type": "BOOL", "description": "The instruction copies the input parameters to the DATA_ERROR_RSP data area at a rising edge at input ACTIVATE. The parameter is then reset by the instruction. The parameter must be set within 10 seconds after a rising edge is detected at parameter NEW of the \"PE_I_DEV\" instruction."}, {"name": "VALID", "type": "BOOL", "description": "The parameter must be interconnected with the VALID input of the \"PE_I_DEV\" instruction. The auxiliary block sets the parameter once the response data for the PROFIenergy controller is available and ready for transmission."}, {"name": "DATA_ERRORRSP", "type": "VARIANT", "description": "Pointer on the data area in which the response data is stored. The parameter is identical to the pointer for DATA_ERRORRSP of the \"PE_I_DEV\" instruction. The addressed data area contains the complete PROFIenergy frame. Minimum length: 244 bytes"}]}, "how_to_use": "Set the input parameters accordingly, ensuring PE_I_DEV_NEW is set to 1 to process the auxiliary block. Trigger the instruction by a rising edge on ACTIVATE within 10 seconds after the NEW parameter from PE_I_DEV is set. Monitor VALID to confirm response data availability and check ERROR and STATUS outputs for error handling. DATA_ERRORRSP must point to a sufficient data area (minimum 244 bytes) for storing the response frame.", "example_code": "", "additional_info": "If the time period parameters Time_to_Operate or Remaining_time_to_destination are unlimited, specify 0xFFFFFFFF. Use 0x00 to specify zero time period. If no energy consumption value is defined, set it to 0.0. Valid memory areas for most parameters include I, Q, M, D, L or constants.", "generated_brief": {"functional_summary": "The PE_PEM_Status_RSP instruction generates and stores the PROFIenergy response to a PEM_Status command based on various input parameters including mode IDs, timing, and energy consumption.", "usage_context": "It is used in industrial automation systems to communicate energy mode status responses to a PROFIenergy controller after receiving a status request, enabling energy management and monitoring within a specified timing sequence."}, "generated_keywords": ["PROFIenergy response", "PEM_Status command", "energy mode status", "timing and energy consumption", "auxiliary block activation"]}
{"instruction_name": "ASI_CTRL", "description": "The command interface allows the controller and AS-i master to exchange parameter assignment and information data. These commands provide the complete functionality of the M4 master profile of the AS-i master specifications and enable the AS-i master to be completely configured from the controller.", "parameters": {"Input": [{"name": "SD", "type": "ANY", "description": "Start address of the send buffer that contains the command number and job data."}, {"name": "LEN_SD", "type": "INT", "description": "Length in bytes of the send buffer area."}, {"name": "RD", "type": "ANY", "description": "Start address of the receive buffer for receiving response data (virtual buffer may be used if no response is expected)."}, {"name": "LEN_RD", "type": "INT", "description": "Length in bytes of the receive buffer area. Must be sufficient to avoid overwriting neighboring memory areas."}], "Output": [{"name": "STATUS", "type": "INT", "description": "Status information about the execution of the command."}], "InOut": []}, "how_to_use": "Prepare the send buffer according to the command structure with the command number at byte q+0 and the job data in subsequent bytes. The receive buffer must be allocated with sufficient length according to the command. Call the ASI_CTRL instruction to send the command and receive the response. For certain commands (39H, 41H, 42H, 43H, 44H), the receive buffer must be 221 bytes long. Consult the AS-i master documentation for command-specific parameters and expected response lengths.", "example_code": "", "additional_info": "If the receive buffer length is too short, neighboring memory areas may be overwritten regardless of the length parameter specified in the ANY pointer of RD. The required buffer length for each command can be found in the command description of the AS-i master manual. Command 77H can be used to re-initialize the AS-i master command interface, terminating any ongoing command processing.", "generated_brief": {"functional_summary": "The ASI_CTRL instruction enables communication between the PLC controller and the AS-i master by sending command data and receiving corresponding responses for parameter assignment and control functions.", "usage_context": "This function is used when configuring or controlling the AS-i master module from a PLC to manage AS-i network operations and parameters within an industrial automation system."}, "generated_keywords": ["AS-i master communication", "parameter assignment", "command interface", "send and receive buffers", "PLC to AS-i configuration"]}
{"instruction_name": "GEO_LOG", "description": "The corresponding module slot of a signal module is known. Use the \"GEO_LOG\" instruction to determine the corresponding hardware identifier of the module from this.", "parameters": {"Input": [{"name": "MASTER", "type": "INT", "description": "Area ID: 0, if the slot is located in a centralized configuration; 1 to 32: DP master system ID of the associated field device if the slot is located in a field device on PROFIBUS; 100 to 115: PROFINET IO system ID of the associated field device if the slot is located in a field device on PROFINET"}, {"name": "STATION", "type": "INT", "description": "If MASTER = 0: Number of the rack; If MASTER > 0: Station number of the field device"}, {"name": "SLOT", "type": "INT", "description": "Slot number"}, {"name": "SUBSLOT", "type": "INT", "description": "Number of the submodule. If no submodule exists or can be inserted SUBSLOT must have the value \"0\"."}], "Output": [{"name": "LADDR", "type": "HW_IO", "description": "Hardware identifier of the module"}], "InOut": [], "Return": [{"name": "RET_VAL", "type": "INT", "description": "Error information"}]}, "how_to_use": "Initialize the input parameters MASTER, STATION, SLOT, and SUBSLOT to specify the module slot of the signal module. Call the GEO_LOG instruction to obtain the hardware identifier of the module in LADDR. Check RET_VAL for error to validate correct execution.", "example_code": "", "additional_info": "RET_VAL error codes include: 0000 - No error occurred; 8094 - No subnet was configured with the specified SUBNETID; 8095 - Illegal value for STATION parameter; 8096 - Illegal value for SLOT parameter; 8097 - Illegal value for SUBSLOT parameter. For general error information, see GET_ERR_ID. Refer to \"Switching display formats in the program status\" and \"Instructions for address conversion (S7-1200, S7-1500)\" for additional guidance.", "generated_brief": {"functional_summary": "The GEO_LOG instruction converts a specified module slot address into the corresponding hardware identifier of the signal module.", "usage_context": "It is typically used in PLC programs to identify the physical hardware module based on its location in centralized, PROFIBUS, or PROFINET configurations for addressing and control purposes."}, "generated_keywords": ["module slot to hardware ID", "signal module identification", "PROFIBUS PROFINET addressing", "hardware identifier conversion", "PLC module addressing"]}
{"instruction_name": "CAN_TINT", "description": "The instruction \"CAN_TINT\" is used to delete the start date and time of a specified time-of-day interrupt organization block. This deactivates the time-of-day interrupt, and the organization block is no longer called.", "parameters": {"Input": [{"name": "OB_NR", "type": "OB_TOD", "description": "Number of the time-of-day interrupt OB, whose starting date and time-of-day are to be deleted."}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "If an error occurs while the instruction is being executed, the actual parameter of RET_VAL contains an error code."}], "InOut": []}, "how_to_use": "Use CAN_TINT to delete the start date/time of a time-of-day interrupt OB to deactivate it. To reuse the time-of-day interrupt, reset the start time with SET_TINTL or SET_TINT, then reactivate it either by calling ACT_TINT (if the ACTIVE parameter was false) or by setting ACTIVE=true directly in SET_TINTL.", "example_code": "", "additional_info": "Error codes returned via RET_VAL include: 0000 (no error), 8090 (error in OB_NR parameter), 80A0 (no starting date/time-of-day defined). For general error info, refer to GET_ERR_ID. Data types for OB_NR can be I, Q, M, D, L or constant; for RET_VAL I, Q, M, D, L. See the overview of valid data types for more information.", "generated_brief": {"functional_summary": "The CAN_TINT instruction deletes the start date and time of a specified time-of-day interrupt organization block, effectively deactivating the interrupt.", "usage_context": "It is used in PLC programs to deactivate scheduled time-of-day interrupts when they are no longer needed or must be reset."}, "generated_keywords": ["delete start time-of-day interrupt", "deactivate time-of-day interrupt", "time-of-day interrupt OB", "reset interrupt start time", "PLC interrupt management"]}
{"instruction_name": "Program_Alarm", "description": "The instruction 'Generate program alarm with associated values' monitors a signal and on a signal change at the parameter SIG generates a program alarm. An incoming program alarm is generated with a signal change from 0 to 1 and an outgoing program alarm is generated with a signal change from 1 to 0. The program alarm is triggered synchronously to program execution.", "parameters": {"Input": [{"name": "SIG", "type": "BOOL", "description": "The signal to be monitored. Positive signal edge generates an incoming program alarm; negative signal edge generates an outgoing program alarm."}, {"name": "TIMESTAMP", "type": "LDT", "description": "This parameter is used to assign an alarm a time stamp. The time value must be specified in system time (i.e. UTC). If not assigned, the system time of the CPU will be used."}, {"name": "SD_i", "type": "VARIANT", "description": "i-th associated value (1 ≤ i ≤ 10). You can use binary numbers, integers, floating-point numbers, or character strings as associated values."}], "Output": [{"name": "Error", "type": "BOOL", "description": "Status parameter Error. Error = TRUE indicates that an error has occurred during processing."}, {"name": "Status", "type": "WORD", "description": "Status parameter Status. Displays error information."}], "InOut": []}, "how_to_use": "Call the instruction only in a function block (FB). The block is processed synchronously. An alarm is triggered as soon as the block is exited.", "example_code": "Create one tag in a global data block for storing the signal value to be monitored. The instruction is called in a function block. Interconnect the parameters of the instruction as required.", "additional_info": "Make sure the total size of associated values does not exceed 512 bytes, with 400 bytes reserved for specific text fields. The instruction needs to be called in a function block, and proper error handling should be implemented.", "generated_brief": {"functional_summary": "The Program_Alarm instruction monitors a boolean signal for rising or falling edges to generate corresponding incoming or outgoing program alarms with associated values and an optional timestamp.", "usage_context": "It is typically used within function blocks in PLC programs to synchronously trigger alarms during program execution whenever monitored signals change state."}, "generated_keywords": ["program alarm generation", "signal edge detection", "function block usage", "alarm with timestamp", "associated alarm values"]}
{"instruction_name": "PE_CMD", "description": "The instruction 'PE_CMD' is used in the PE controller to start or terminate a pause in the energy-saving mode in the PE entity. Additional information and energy measurements are also read out from a PE entity using 'PE_CMD'.", "parameters": {"Input": [{"name": "REQ", "type": "BOOL", "description": "Starts transferring the PE command upon a positive edge."}, {"name": "ID", "type": "HW_SUBMODULE", "description": "Address of the PE entity. Use the hardware ID of the head module for a PROFINET IO device."}, {"name": "CMD", "type": "BYTE", "description": "Service-Request-ID of the PROenergy command in accordance with the PROFIenergy profile."}, {"name": "CMD_MODIFIER", "type": "BYTE", "description": "PROFIenergy sub-command (only when CMD=3 or CMD=16)."}, {"name": "CMD_PARA", "type": "VARIANT", "description": "Parameters for the PE commands: Get mode: PE_mode_ID; Get measurement values: List of Measurement_Ids."}, {"name": "CMD_PARA_LEN", "type": "INT", "description": "The actual length of the command parameters (<= length defined in CMD_PARA; is verified by the instruction)."}, {"name": "CMD_DATA_STRUCTURE_IDENTIFIER_RQ", "type": "BYTE", "description": "Value of the Data Structure Identifier from the standard."}], "Output": [{"name": "VALID", "type": "BOOL", "description": "Command successfully sent."}, {"name": "BUSY", "type": "BOOL", "description": "Command still being processed."}, {"name": "ERROR", "type": "BOOL", "description": "Error occurred during processing."}, {"name": "STATUS", "type": "DWORD", "description": "Block status / error number."}], "InOut": [{"name": "RESPONSE_DATA", "type": "VARIANT", "description": "PROFIenergy information. May be complete response frame including block header, depending on the command."}]}, "how_to_use": "Initialize the 'RESPONSE_DATA' area before calling 'PE_CMD'.", "example_code": "", "additional_info": "Commands are transferred without plausibility test. Ensure the buffer for 'RESPONSE_DATA' is cleared before each call.", "generated_brief": {"functional_summary": "The PE_CMD instruction sends and manages PROFIenergy commands to start or stop energy-saving pauses and retrieve energy measurements from a PE entity in a PE controller.", "usage_context": "It is typically used in industrial automation to control and monitor energy-saving modes and gather energy data from PROFIenergy-compatible devices."}, "generated_keywords": ["PROFIenergy command", "energy-saving mode control", "PE entity communication", "energy measurement retrieval", "pause start and terminate"]}
{"instruction_name": "PE_DS3_Write_ET200S", "description": "The instruction \"PE_DS3_Write_ET200S\" sends basic settings for power module switching behavior to the ET 200S. The switching behavior of up to 8 slots in the ET 200S (e.g. for power modules) is defined with this instruction. This instruction is not part of the PROIenergy profile but instead supplements SIMATIC-specific functions.", "parameters": {"Input": [{"name": "ENABLE", "type": "BOOL", "description": "A positive edge triggers the transfer of the data record. Transfer the data record again following voltage OFF/ON."}, {"name": "ID", "type": "HW_SUBMODULE", "description": "Address of the ET 200S. Accept the address from the hardware configuration."}, {"name": "SLOT_NO_X", "type": "INT", "description": "Slot number of switchable power module X."}, {"name": "FUNC_X", "type": "INT", "description": "Function of the module in this slot. Use the parameter FUNC_X to define the switching behavior of the PM-E (power module of the ET 200S): FALSE - With \"PAUSE_START\": No effect on PM-E and PM-E remains on; With \"PAUSE_STOP\": Switches PM-E back on. TRUE - With \"PAUSE_START\": Switches PM-E off; With \"PAUSE_STOP\": Switches PM-E back on."}], "Output": [{"name": "BUSY", "type": "BOOL", "description": "Transfer not yet complete."}, {"name": "DONE", "type": "BOOL", "description": "Transfer completed without errors."}, {"name": "ERROR", "type": "BOOL", "description": "Transfer completed with error."}, {"name": "STATUS", "type": "DWORD", "description": "Error number (see STATUS parameter of the instruction \"PE_Start_End\")."}], "InOut": []}, "how_to_use": "Use ENABLE to trigger the data transfer of the configured power module settings to the ET 200S. Provide the ET 200S address via ID. Specify slot numbers and functions for each switchable power module slot using SLOT_NO_X and FUNC_X respectively. Monitor BUSY, DONE, ERROR and STATUS outputs to handle the transfer state and errors.", "example_code": "", "additional_info": "This instruction supplements SIMATIC-specific functions and is not part of the PROIenergy profile. Valid data types for parameters are I, Q, M, D, L, P or constant as applicable.", "generated_brief": {"functional_summary": "The PE_DS3_Write_ET200S instruction configures and transfers power module switching behaviors for up to 8 slots in the ET 200S device.", "usage_context": "It is used when defining or updating the switching behavior settings of power modules in an ET 200S distributed I/O system within SIMATIC automation environments."}, "generated_keywords": ["ET 200S power module configuration", "power module switching behavior", "SIMATIC ET 200S data transfer", "slot function assignment", "power module communication"]}
{"instruction_name": "PE_START_END", "description": "The instruction \"PE_START_END\" is used to start and exit the energy-saving mode of a specified PE entity (e.g. ET 200S). It is used in the PE controller, preferably when only field devices from which energy data does not need to be read out are connected to the corresponding PE devices. The energy-saving modes are configured in the user program of the PE controller. On completion, the PE entity reports its current energy-saving mode and outputs this data at parameter PE_MODE_ID. The instruction sends a PROFIenergy command internally as a write job via WRREC, waits for acknowledgment that is read every 100 ms via RDREC, and repeats the read job for up to 10 seconds until acknowledgment is received. The response data is also read with RDREC.", "parameters": {"Input": [{"name": "START", "type": "BOOL", "description": "Transmitting the PE command \"Start_Pause\" to the PE entity with the address set at parameter ID."}, {"name": "END", "type": "BOOL", "description": "Transmitting the PE command \"End_Pause\" to the PE entity with the address set at parameter ID."}, {"name": "ID", "type": "HW_SUBMODULE", "description": "Address of the PE entity. Use the hardware ID of the head module for a PROFINET IO device, derived from system constants of the assigned IO controller. For I-devices, use the hardware identifier of a transfer area."}, {"name": "PAUSE_TIME", "type": "TIME", "description": "Planned pause duration. Range: T#1MS to T#24D20H31M23S647MS. Start value: T#0MS."}], "Output": [{"name": "VALID", "type": "BOOL", "description": "PE command successfully sent."}, {"name": "BUSY", "type": "BOOL", "description": "PE command still being processed."}, {"name": "ERROR", "type": "BOOL", "description": "Error occurred during processing. The error message is output at the STATUS parameter."}, {"name": "STATUS", "type": "DWORD", "description": "Block status / error number providing detailed error information."}, {"name": "PE_MODE_ID", "type": "BYTE", "description": "Identification number of energy-saving mode (energy-saving level for the duration of the pause)."}], "InOut": []}, "how_to_use": "Invoke PE_START_END with the START input to command the PE entity to enter energy-saving mode and with END to exit it. Set ID to the hardware address of the PE entity. Set PAUSE_TIME to the planned pause duration. The instruction manages internal communication using WRREC and RDREC for PROFIenergy commands. Monitor VALID, BUSY, and ERROR outputs to track command status. Consider that ET 200S requires a minimum pause duration of 10 seconds; shorter pauses will keep power modules on. The module remains off after the pause until END is commanded to prevent undesired peak loads.", "example_code": "", "additional_info": "The STATUS output can be interpreted as an array of four BYTEs providing detailed error descriptions, including causes of errors (Function_Num), location (Error_Decode), and error IDs (Error_Code_1, Error_Code_2). Errors from RDREC and WRREC instructions used internally are also reported here. The minimum pause duration must be greater than the sum of times to switch to and from energy-saving mode. The module does not automatically switch on at the end of the pause.", "generated_brief": {"functional_summary": "PE_START_END controls the entry and exit of energy-saving mode for a specified PE entity by sending PROFIenergy commands and managing communication status signals.", "usage_context": "It is used in PE controllers to pause and resume energy consumption for field devices like ET 200S during planned downtimes or low-demand periods to optimize energy usage."}, "generated_keywords": ["energy-saving mode control", "PE entity pause and resume", "PROFIenergy command", "PE controller device management", "energy consumption optimization"]}
{"instruction_name": "SET_TINT", "description": "The instruction \"SET_TINT\" is used to set the start data and time of the time-of-day interrupt organization blocks from the user program, without having to make settings in the hardware configuration. Enter the number of the time-of-day interrupt-OBs at the parameter OB_NR for which you would like to set the start date and the time-of-day. Use the parameter SDT and PERIOD to specify when and how often the time-of-day interrupt OB should be called: One-time call: Enter the date and the time-of-day at the parameter SDT. Use the value \"0\" at parameter PERIOD. Repeated call: Enter the date and the time-of-day of the first call at the parameter SDT. Use the parameter PERIOD to define the time interval in which subsequent calls of the OBs should take place. Observe the following when setting the start date and start time: The date and the time-of-day specification at the parameter SDT refers to the system time. The seconds and milliseconds specification is ignored and set to \"0\" at the start time. Only the starting date days 1, 2, ... 28 are possible if you want to specify a monthly time-of-day interrupt OBs. This restriction prevents skipping the monthly call (e.g. 30-day months or in February). The setting \"end of the month\" (W#16#2001) can be used at the parameter PERIOD as an alternative to the 29th 30th and the 31st of the month. After setting the time-of-day interrupt with \"SET_TINT\" it still must be activated with the instruction \"ACT_TINT\".", "parameters": {"Input": [{"name": "OB_NR", "type": "OB_TOD", "description": "Number of the time-of-day interrupt OBs. The numbers 10 to 17 are available for the time-of-day interrupt OBs. An OB number starting with 123 can also be assigned as an alternative. The OB number is displayed in the program block folder and in the system constants."}, {"name": "SDT", "type": "DT", "description": "Start date and start time."}, {"name": "PERIOD", "type": "WORD", "description": "Execution intervals from the starting point SDT to: W#16#0000 single execution, W#16#0201 = once every minute, W#16#0401 = once hourly, W#16#1001 = once daily, W#16#1201 = once weekly, W#16#1401 = once monthly, W#16#1801 = once yearly, W#16#2001 = at month's end."}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "If an error occurs while the instruction is being executed, the actual parameter of RET_VAL contains an error code."}], "InOut": []}, "how_to_use": "Call SET_TINT supplying the OB_NR for the desired time-of-day interrupt OB. Specify the start date and time in SDT (system time, seconds and milliseconds ignored) and set the PERIOD to define how often the OB shall be called (single or repeated with specified intervals). Ensure that for monthly settings only start dates 1 to 28 are used or PERIOD equals end of month (W#16#2001). After setting, activate the time-of-day interrupt with ACT_TINT instruction.", "example_code": "", "additional_info": "Error codes returned in RET_VAL include 0000 for no error, 8090 for invalid OB_NR, 8091 for invalid SDT, 8092 for incorrect PERIOD, and 80A1 if start time is in the past when PERIOD is single execution (W#16#0000). The seconds and milliseconds in SDT are ignored and defaulted to zero. Use ACT_TINT to enable the time-of-day interrupt after setting it.", "generated_brief": {"functional_summary": "The SET_TINT instruction configures the start date, time, and recurrence interval of a time-of-day interrupt organization block (OB) in a PLC program without hardware configuration changes.", "usage_context": "It is used when precise scheduling of time-of-day interrupts is needed for periodic or one-time execution of tasks within industrial automation systems."}, "generated_keywords": ["set time-of-day interrupt", "configure start date and time", "schedule periodic OB execution", "time-of-day interrupt setup", "recurrence interval configuration"]}
{"instruction_name": "SET_TINTL", "description": "The instruction \"SET_TINTL\" is used to set the start data and time of the time-of-day interrupt organization blocks from the user program, without having to make settings in the hardware configuration. Use the parameter OB_NR to enter the number of the time-of-day interrupt-OBs to set the start date and time-of-day. Parameters SDT and specify when and how often the interrupt OB is called (one-time call with PERIOD=0, repeated calls with PERIOD defining the interval). LOCAL selects whether the time is local or system time. ACTIVATE determines when settings are applied: immediately (true) or after calling ACT_TINT (false). The seconds and milliseconds in SDT are ignored (set to 0). Only days 1..28 can be specified for monthly interrupts; W#16#2001 can be used to specify 'end of the month' alternative. Special considerations exist for daylight saving time changeover. RET_VAL returns an error code if execution fails.", "parameters": {"Input": [{"name": "OB_NR", "type": "OB_TOD", "description": "Number of the time-of-day interrupt OBs. Numbers 10 to 17 are available; alternatively, OB numbers starting with 123 can be assigned. Can be I, Q, M, D, L or constant."}, {"name": "SDT", "type": "DTL", "description": "Start date and start time. Can be D, L or constant."}, {"name": "LOCAL", "type": "BOOL", "description": "Select whether to use local time (true) or system time (false). Can be I, Q, M, D, L or constant."}, {"name": "PERIOD", "type": "WORD", "description": "Execution intervals from starting point SDT. Supported values: W#16#0000 single execution; W#16#0201 once every minute; W#16#0401 once hourly; W#16#1001 once daily; W#16#1201 once weekly; W#16#1401 once monthly; W#16#1801 once yearly; W#16#2001 at month's end. Can be I, Q, M, D, L or constant."}, {"name": "ACTIVATE", "type": "BOOL", "description": "Specify when the settings are applied: true means settings are applied immediately; false means settings are applied only after calling ACT_TINT. Can be I, Q, M, D, L or constant."}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Return value indicating success or error code if an error occurs during execution. Can be I, Q, M, D, L."}], "InOut": []}, "how_to_use": "Call the SET_TINTL instruction with the OB_NR identifying the time-of-day interrupt OB, specify the start date/time in SDT, and set PERIOD to define the frequency. Use LOCAL to select time reference, ACTIVATE to apply settings immediately or delay until ACT_TINT is called. Handle errors via RET_VAL. Note that seconds and milliseconds in SDT are ignored. For monthly intervals, use only days 1 to 28 or W#16#2001 to specify end of month. Consider daylight saving time changes when setting local time.", "example_code": "", "additional_info": "RET_VAL error codes include 0000 (no error), 8090 (invalid OB_NR), 8091 (invalid SDT), 8092 (incorrect PERIOD), 80A1 (start time in the past for single execution). Time-of-day interrupt OB numbers range from 10 to 17 or with prefix 123. For daylight saving time changes, special handling may be necessary to avoid errors. Settings at SDT and PERIOD correspond the properties of time-of-day interrupt OBs.", "generated_brief": {"functional_summary": "The SET_TINTL instruction configures the start date, time, and execution interval for time-of-day interrupt organization blocks in a PLC program without hardware configuration changes.", "usage_context": "It is used to schedule and manage time-based interrupts for automated tasks in industrial control systems, allowing dynamic adjustments to timing settings during runtime."}, "generated_keywords": ["set time-of-day interrupt", "configure start date and time", "time-of-day OB scheduling", "interrupt interval configuration", "dynamic timer setting"]}
{"instruction_name": "SYNC_PO", "description": "The instruction 'SYNC_PO' is used to update a process image partition of outputs in isochronous mode. An application program linked to a DP cycle or a PN send cycle can use this instruction for the consistent isochronous transfer of the computed output data of a process image partition from outputs to the I/O devices.", "parameters": {"Input": [{"name": "PART", "type": "PIP", "description": "Number of the process image partition of the outputs to be updated isochronously."}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "If an error occurs while the instruction is being executed, the return value contains an error code."}, {"name": "FLADDR", "type": "WORD", "description": "Address of the first byte that has caused the error."}], "InOut": []}, "how_to_use": "The 'SYNC_PO' instruction is interruptible and should only be called in OBs 61, 62, 63 and 64. Ensure you have assigned the affected process image partition to the associated OB in the HW configuration.", "example_code": "", "additional_info": "A process image partition that you update with 'SYNC_PO' must not be updated simultaneously with the 'UPDAT_PO' instruction.", "generated_brief": {"functional_summary": "The SYNC_PO instruction updates a specified process image partition of outputs isochronously, ensuring consistent transfer of output data from the PLC to I/O devices during DP or PN communication cycles.", "usage_context": "It is used within specific interrupt OBs (61-64) to synchronize output data updates in applications requiring precise timing, and must not be mixed with UPDAT_PO for the same partition."}, "generated_keywords": ["isochronous output update", "process image partition", "DP PN cycle synchronization", "interruptible OB call", "SYNC_PO instruction"]}
{"instruction_name": "WRREC", "description": "The instruction \"WRREC\" is used to transfer the RECORD data record to the component addressed using ID. This can be a module in a central rack or a distributed component (PROFIBUS DP or PROFINET IO).", "parameters": {"Input": [{"name": "REQ", "type": "BOOL", "description": "REQ = 1: Transfer data record"}, {"name": "ID", "type": "HW_IO", "description": "ID number of the hardware component (DP/PROFINET IO). The number is assigned automatically and is stored in the properties of the component or of the interface in the hardware configuration."}, {"name": "INDEX", "type": "DINT", "description": "Data record number"}, {"name": "LEN", "type": "UINT", "description": "Maximum length of the data record to be transferred in bytes"}], "Output": [{"name": "DONE", "type": "BOOL", "description": "Data record was transferred"}, {"name": "BUSY", "type": "BOOL", "description": "BUSY = 1: The writing process is not yet complete."}, {"name": "ERROR", "type": "BOOL", "description": "ERROR = 1: An error occurred during the writing process."}, {"name": "STATUS", "type": "DWORD", "description": "Block status or error information"}], "InOut": [{"name": "RECORD", "type": "VARIANT", "description": "Data record"}]}, "how_to_use": "The WRREC instruction is asynchronous and must be called with REQ = 1 to start the data record transfer. The same value must be assigned to the RECORD and LEN parameters for all calls belonging to the same transfer job. The transfer is complete when BUSY becomes FALSE. Error and status information are provided through ERROR and STATUS outputs. When using WRREC in SYNCUP system state of S7-1500-R/H systems, cyclic calls are required due to dynamic behavior.", "example_code": "", "additional_info": "Use only the hardware identifier (HW ID) of the module for the ID parameter, which can be found in system constants. For PROFINET IO, negative values in INDEX and LEN are interpreted as unsigned 16-bit integers. The interface is identical to the WRREC FB in the 'PROFIBUS and PROFINET Guideline Communication Function Blocks'. Status codes provide detailed error information. No implicit type conversion in STL; use valid data types shown in parameter tooltips.", "generated_brief": {"functional_summary": "The WRREC instruction transfers a specified data record asynchronously to a targeted hardware component identified by its hardware ID.", "usage_context": "It is used in industrial automation to send configuration or operational data to central or distributed modules over communication buses like PROFIBUS DP or PROFINET IO."}, "generated_keywords": ["asynchronous data transfer", "hardware module communication", "PROFIBUS DP", "PROFINET IO", "record writing instruction"]}
{"instruction_name": "WR_LOC_T", "description": "The instruction \"WR_LOC_T\" is used to set the date and time of the CPU clock. Enter the date and time-of-day as local time at the input parameter LOCTIME. The value must be in the following range: With DTL: min. DTL#1970-01-01-00:00:00.0, max. DTL#2200-12-31 23:59:59.999999999; With LDT: min. LDT#1970-01-01-0:0:0.000000000, max. LDT#2200-12-31 23:59:59.999999999. The gran of the time information for local time and system time is product-specific and is at least one millisecond. Input values at the LOCTIME parameter which are less than those supported by the CPU are rounded up during system time calculation. You can query whether errors have occurred during execution of the instruction in the RET_VAL output parameter.", "parameters": {"Input": [{"name": "LOCTIME", "type": "DTL", "description": "Local time. Data type DTL cannot be used for the memory areas: input, output and bit memory."}, {"name": "DST", "type": "BOOL", "description": "Daylight Saving Time. Is only evaluated during the \"double hour\" at changeover to standard time. TRUE = daylight saving time (first hour), FALSE = standard time (second hour)."}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Error message indicating status or error codes during execution (see \"RET_VAL parameter\")."}], "InOut": []}, "how_to_use": "To use WR_LOC_T, provide the local time to set via the LOCTIME input parameter in DTL format (or LDT where allowed), ensuring the value is within the valid range. Use the DST boolean input to specify daylight saving time status only during the changeover (the \"double hour\" between 2 AM and 3 AM). Execute the instruction when the local time should update. Check RET_VAL to ensure no errors occurred. Values outside the valid time range or invalid times during time changes produce error codes. The data type DTL cannot be used with input, output, or bit memory areas.", "example_code": "VAR\n  execute: BOOL;\n  inputLocTIME: DTL;\n  dstValue: BOOL;\n  returnValue: INT;\nEND_VAR\n\nIF execute THEN\n  WR_LOC_T(LOCTIME := inputLocTIME, DST := dstValue, RET_VAL => returnValue);\nEND_IF;", "additional_info": "The DST parameter is relevant only during the 'double hour' at the changeover from daylight saving to standard time to distinguish between the repeated hour. During the changeover from standard to daylight saving time, times in the missing hour produce error code W#16#8089. The RET_VAL output reflects detailed error codes such as invalid values in date or time bytes. The instruction affects the CPU clock. Verification of correct time setting can be done via CPU display or the RD_LOC_T instruction.", "generated_brief": {"functional_summary": "WR_LOC_T sets the CPU clock's local date and time, allowing specification of daylight saving status during the hour changeover, and provides error feedback via a return value.", "usage_context": "It is used in industrial control systems when precise synchronization of the CPU clock to local time is required, especially around daylight saving time transitions."}, "generated_keywords": ["set CPU local time", "date and time synchronization", "daylight saving time adjustment", "CPU clock configuration", "error handling in time setting"]}
{"instruction_name": "S_COMP", "description": "The instruction compares the contents of two tags in the (W)STRING format and outputs the result of the comparison as a return value. The tags that are to be compared will be interconnected at the IN1 and IN2 inputs.", "parameters": {"Input": [{"name": "IN1", "type": "STRING, WSTRING*", "description": "Input tag in the STRING / WSTRING format."}, {"name": "IN2", "type": "STRING, WSTRING*", "description": "Input tag in the STRING / WSTRING format."}], "Output": [{"name": "OUT", "type": "BOOL", "description": "Result of comparison."}], "InOut": []}, "how_to_use": "Use the instruction box to select the comparison condition. If the comparison condition (for example, greater than or equal to) is satisfied, the signal state is set to '1' at the output parameter OUT.", "example_code": "stringvalue1 := 'example1';\nstringvalue2 := 'example2';\nresult := S_COMP(IN1 := stringvalue1, IN2 := stringvalue2, condition := 'EQ');", "additional_info": "The characters are compared by their ASCII code. The first character to be different decides the result of the comparison.", "generated_brief": {"functional_summary": "S_COMP compares two STRING or W tags based on a specified condition and outputs a BOOL indicating whether the comparison is true.", "usage_context": "It is typically used in PLC programs to perform string comparisons for control logic decisions such as equality or ordering based on ASCII values."}, "generated_keywords": ["string comparison", "WSTRING compare", "ASCII-based comparison", "boolean output", "PLC string logic"]}
{"instruction_name": "GEO2LOG", "description": "Determine hardware identifier from slot", "parameters": {"Input": [], "Output": [], "InOut": []}, "how_to_use": "", "example_code": "", "additional_info": "", "generated_brief": {"functional_summary": "The GEO2LOG instruction determines the hardware identifier associated with a given slot in a PLC system.", "usage_context": "It is used to map physical slot locations to their corresponding hardware IDs for hardware configuration and diagnostics."}, "generated_keywords": ["hardware identifier", "slot mapping", "hardware configuration", "diagnostics", "PLC slot identification"]}
{"instruction_name": "LOG2GEO", "description": "Determine slot from hardware identifier", "parameters": {"Input": [], "Output": [], "InOut": []}, "how_to_use": "", "example_code": "", "additional_info": "", "generated_brief": {"functional_summary": "The LOG2GEO instruction determines the slot number corresponding to a given hardware identifier.", "usage_context": "It is used in PLC systems to map hardware identifiers to their physical slot positions for configuration or diagnostics."}, "generated_keywords": ["hardware identifier mapping", "slot determination", "PLC hardware slot", "hardware to slot mapping", "slot number retrieval"]}
{"instruction_name": "LOG2MOD", "description": "Determine the hardware identifier from addressing of STEP 7 V5.5 SPx", "parameters": {"Input": [], "Output": [], "InOut": []}, "how_to_use": "", "example_code": "", "additional_info": "", "generated_brief": {"functional_summary": "LOG2MOD determines the hardware identifier based on the addressing scheme used in STEP 7 V5.5 SPx.", "usage_context": "It is used in industrial automation projects to map hardware addresses to their corresponding identifiers within the STEP 7 programming environment."}, "generated_keywords": ["hardware identifier", "addressing", "STEP 7", "module mapping", "industrial automation"]}
{"instruction_name": "IO2MOD", "description": "Determine hardware identifier from an IO address", "parameters": {"Input": [], "Output": [], "InOut": []}, "how_to_use": "", "example_code": "", "additional_info": "", "generated_brief": {"functional_summary": "The IO2MOD instruction determines the hardware module identifier associated a given IO address.", "usage_context": "It is typically used in PLC programs to map IO addresses to specific hardware modules for accurate hardware configuration and diagnostics."}, "generated_keywords": ["hardware module identification", "IO address mapping", "PLC IO configuration", "hardware diagnostics", "module address resolution"]}
{"instruction_name": "RD_ADDR", "description": "Determine IO addresses from the hardware identifier", "parameters": {"Input": [], "Output": [], "InOut": []}, "how_to_use": "", "example_code": "", "additional_info": "", "generated_brief": {"functional_summary": "The RD_ADDR instruction retrieves the I/O addresses corresponding to a given hardware identifier.", "usage_context": "This function is typically used in PLC programs to map hardware components to their specific I/O addresses for control and monitoring purposes."}, "generated_keywords": ["read IO address", "hardware identifier mapping", "address retrieval", "PLC IO mapping", "hardware to address"]}
{"instruction_name": "GEO_LOG", "description": "Determine hardware identifier from slot", "parameters": {"Input": [], "Output": [], "InOut": []}, "how_to_use": "", "example_code": "", "additional_info": "Supported in addition for migrated projects", "generated_brief": {"functional_summary": "The GEO_LOG instruction determines the hardware identifier based on the slot position within a system.", "usage_context": "It is used in migrated industrial automation projects to map hardware components to their physical locations for configuration or diagnostics."}, "generated_keywords": ["hardware identifier", "slot position", "component mapping", "system configuration", "diagnostics"]}
{"instruction_name": "LOG_GEO", "description": "Determine slot from hardware identifier", "parameters": {"Input": [], "Output": [], "InOut": []}, "how_to_use": "", "example_code": "", "additional_info": "Supported in addition for migrated projects", "generated_brief": {"functional_summary": "LOG_GEO determines the slot number associated with a specific hardware identifier in a control system.", "usage_context": "It is typically used in migrated projects to map hardware identifiers to their corresponding slot locations for system organization and troubleshooting."}, "generated_keywords": ["determine slot", "hardware identifier", "slot mapping", "migrated projects", "system troubleshooting"]}
{"instruction_name": "RD_LGADR", "description": "Determine IO addresses from the hardware identifier", "parameters": {"Input": [], "Output": [], "InOut": []}, "how_to_use": "", "example_code": "", "additional_info": "Supported in addition for migrated projects", "generated_brief": {"functional_summary": "The RD_LGADR instruction determines the IO addresses corresponding to a given hardware identifier.", "usage_context": "It is typically used in migrated projects to map hardware identifiers to their associated IO addresses for proper device communication."}, "generated_keywords": ["IO address determination", "hardware identifier mapping", "migrated project support", "device communication setup"]}
{"instruction_name": "GADR_LGC", "description": "Determine hardware identifier from slot and offset in the user data address area", "parameters": {"Input": [], "Output": [], "InOut": []}, "how_to_use": "", "example_code": "", "additional_info": "Supported in addition for migrated projects", "generated_brief": {"functional_summary": "GADR_LGC determines the hardware identifier based on the slot and offset within the user data address area.", "usage_context": "It is used in migrated PLC projects to map logical addresses to physical hardware components for control and diagnostics."}, "generated_keywords": ["hardware identifier determination", "slot and offset mapping", "user data address", "logical to physical address mapping", "migrated projects support"]}
{"instruction_name": "LGC_GADR", "description": "Determine slot from hardware identifier", "parameters": {"Input": [], "Output": [], "InOut": []}, "how_to_use": "", "example_code": "", "additional_info": "Supported in addition for migrated projects", "generated_brief": {"functional_summary": "LGC_GADR is a PLC instruction that determines the slot number from a given hardware identifier.", "usage_context": "It is typically used in migrated projects to map hardware identifiers to their corresponding slots within an industrial control system."}, "generated_keywords": ["determine slot number", "hardware identifier mapping", "PLC instruction", "migrated projects support", "hardware slot determination"]}
{"instruction_name": "T_COMP", "description": "This instruction is used to compare the contents of two tags of the \"Timers\" or \"Date and time\" data type. The instruction supports the comparison of the following data types: DATE, TIME, LTIME, TOD (TIME_OF_DAY), LTOD (LTIME_OF_DAY), DT (DATE_AND_TIME), LDT (DATE_AND_LTIME), DTL, S5Time. The data types must be the same length and format to carry out the comparison. The comparison result is output at the OUT parameter as a return value. For this purpose, the parameter OUT is set to \"1\" if the condition used for the comparison is satisfied. The following comparison options are available: EQ (time is the same), NE (time is not the same), GE (time at IN1 is greater or equal to time at IN2), LE (time at IN1 is smaller or equal to time at IN2), GT (time at IN1 is greater than time at IN2), LT (time at IN1 is smaller than time at IN2).", "parameters": {"Input": [{"name": "IN1", "type": "DATE, TIME, LTIME, TOD, LTOD, DT, LDT, DTL, S5Time", "description": "First value to be compared."}, {"name": "IN2", "type": "DATE, TIME, LTIME, TOD, LTOD, DT, LDT, DTL, S5Time", "description": "Second value to be compared."}], "Output": [{"name": "OUT", "type": "BOOL", "description": "Return value that is set to \"1\" if the comparison condition is fulfilled."}], "InOut": []}, "how_to_use": "Create tags of compatible date/time or timer data types (such as LTIME). Use the T_COMP instruction by connecting two time values to IN1 and IN2, and select a comparison option (e.g., GE for greater or equal). The result of the comparison will be available on the OUT parameter as a BOOL. Ensure that input data types match in length and format to carry out proper comparisons.", "example_code": "(* Example: Compare two LTIME values using the GE (Greater or Equal) comparison option *)\nVAR\n    timeValue1: LTIME;\n    timeValue2: LTIME;\n    value1GEvalue2: BOOL;\nEND_VAR\n\nvalue1GEvalue2 := T_COMP(IN1 := timeValue1, IN2 := timeValue2, OP := GE);", "additional_info": "The input data types must be the same length and format. The OUT parameter is a BOOL indicating whether the comparison condition is true (1) or false (0). Valid data types include DATE, TIME, LTIME, TOD, LTOD, DT, LDT, DTL, and S5Time.", "generated_brief": {"functional_summary": "The T_COMP instruction compares two date or time values of the same data type according to a specified condition and outputs a boolean indicating if the condition is met.", "usage_context": "It is typically used in PLC programs to evaluate timing or date-related conditions for control logic based on timer or date/time tag comparisons."}, "generated_keywords": ["time comparison", "date and time comparison", "timer value comparison", "boolean output", "PLC timing logic"]}
{"instruction_name": "GetSymbolPath", "description": "Use the instruction \"GetSymbolPath\" to read the names of the parameters transferred at the beginning of a call path and passed via multiple block calls.", "parameters": {"Input": [{"name": "VARIABLE", "type": "PARAMETER", "description": "Selection of the formal parameter for which you want to read out the name of the corresponding actual parameter at the beginning of the call path."}, {"name": "SIZE", "type": "DINT", "description": "Limits the number of characters output at the OUT parameter. SIZE > 0: GetSymbolPath returns the first SIZE characters of the name. SIZE = 0: GetSymbolPath returns the entire name. SIZE < 0: GetSymbolPath returns the last SIZE characters of the name."}], "Output": [{"name": "OUT", "type": "WSTRING", "description": "Output of the tag name of the input parameters supply."}], "InOut": []}, "how_to_use": "Specify the formal parameter at VARIABLE to read the name of the actual parameter passed at the beginning of the call path. Use SIZE to limit the output length of the tag name. Note that if the name is truncated, the character \"...\" (Unicode 16#2026) is appended to indicate truncation. It is not allowed to call GetSymbolPath directly in an OB and calling it cyclically is discouraged due to runtime overhead. Typical usage scenarios include error detection or startup routines.", "example_code": "(* FB_Level_1 is called from OB1, FB_Level_2 is called from FB_Level_1. GetSymbolPath is executed in FB_Level_2 to read the name of the parameter passed to REQ2. *)\nVAR\n  OUT : WSTRING;\nEND_VAR\n\nGetSymbolPath(VARIABLE := REQ2, SIZE := 0, OUT => OUT);", "additional_info": "Calling GetSymbolPath increases code memory usage and runtime depending on the frequency of calls and the number of blocks in the call stack at the time of the call. It should not be used in cyclic calls to avoid performance penalties. If a data block tag is used for input parameters, the output includes the DB name and access path to the structured tag; if a PLC tag is used, the PLC tag name is output; if a constant is used, this constant is output.", "generated_brief": {"functional_summary": "GetSymbolPath reads and returns the name of the actual parameter passed at the start of a call path corresponding to a specified formal parameter in PLC block calls.", "usage_context": "It is typically used for error detection or startup routines to identify input parameters without being called cyclically or in organizational blocks to avoid performance overhead."}, "generated_keywords": ["read parameter name", "call path parameter", "symbol path retrieval", "error detection", "startup routines"]}
{"instruction_name": "Get_AlarmState", "description": "Use the instruction \"Output alarm status\" to output the alarm status of a program alarm. The output of the alarm status always refers to a program alarm that was created using the instruction \"Generate program alarm with associated values\". The program alarm is selected with the Alarm input parameter. Specify the instance DB of the instruction \"Generate program alarm with associated values\" at the parameter Alarm. The alarm status is returned in a byte via the AlarmState output parameter. The meaning of the individual bits is shown in the documentation. The execution status of the instruction is shown with the output parameters Error and STATUS.", "parameters": {"Input": [{"name": "Alarm", "type": "ALARM_BASE", "description": "Instance of the instruction \"Generate program alarm with associated values\". Alarm.Messagetype can be Alarm_AP, Notify_AP, or Inforeport_AP. Signal states of bits Ac and Ag vary based on the type and status of the alarm."}], "Output": [{"name": "AlarmState", "type": "BYTE", "description": "Status of the alarm as a bit array."}, {"name": "Error", "type": "BOOL", "description": "Status parameter: 0 = No error, 1 = An error occurred during execution of the instruction."}, {"name": "STATUS", "type": "WORD", "description": "Status parameter providing detailed execution status. The parameter is only set for the duration of one call and should be copied to a free data area to be displayed."}], "InOut": []}, "how_to_use": "Call the instruction with the Alarm parameter set to the instance of the \"Generate program alarm with associated values\" instruction. Monitor the AlarmState output to determine the status of the alarm. Use the Error and STATUS outputs to verify correct execution and check for errors.", "example_code": "FUNCTION_BLOCK FB_AlarmStatus\nVAR_INPUT\n    Alarm : ALARM_BASE; // Instance of Generate program alarm with associated values\nEND_VAR\nVAR_OUTPUT\n    AlarmState : BYTE;\n    Error : BOOL;\n    STATUS : WORD;\nEND_VAR\n// Call the instruction\nGet_AlarmState(ALARM:=Alarm, AlarmState=>AlarmState, Error=>Error, STATUS=>STATUS);\nEND_FUNCTION_BLOCK", "additional_info": "The STATUS output parameter provides error codes such as 8001 (Invalid static alarm instance), 8002 (Invalid alarm ID), and 8003 (No active alarms within the alarm class). These codes should be used to diagnose issues. The AlarmState bits correspond to different alarm statuses: Incoming, Outgoing, and Acknowledged. If the alarm is not active, bit S always has the signal state 0.", "generated_brief": {"functional_summary": "The Get_AlarmState instruction retrieves the current status of a program alarm instance as a bit-encoded byte along with execution error information.", "usage_context": "It is used in industrial PLC programs to monitor and verify the condition and execution status of alarms generated by the system for fault detection and process management."}, "generated_keywords": ["alarm status retrieval", "program alarm monitoring", "alarm error diagnosis", "alarm state byte output", "PLC alarm instruction"]}
{"instruction_name": "SET_TIMEZONE", "description": "Use the instruction \"SET_TIMEZONE\" to set the parameter for the local time zone and the daylight saving / standard time changeover. The settings which are carried out with the instruction \"SET_TIMEZONE\" correspond with the settings for the time-of-day in the properties of the CPU. Define the corresponding parameters in the system data type TimeTransformationRule for execution of the instruction \"SET_TIMEZONE\". The local time is calculated based on the system time using the settings for the time zone and the daylight saving / standard time changeover. The system time of the CPU is the UTC time. The system time is used exclusively for communication within the system.", "parameters": {"Input": [{"name": "REQ", "type": "BOOL", "description": "S7-1200: The function is executed on a positive edge of REQ. S7-1500 and version of SET_TIMEZONE < V2.0: When REQ=1, the function is executed. S7-1500 and version of SET_TIMEZONE >= V2.0: The function is executed on a positive edge of REQ. The execution of the function means that the transfer of the time zone and writing of the load memory are started."}, {"name": "TimeZone", "type": "TimeTransformationRule", "description": "You interconnect the TimeTransformationRule system data type at parameter TimeZone."}], "Output": [{"name": "DONE", "type": "BOOL", "description": "Status parameter: 0: Job not yet started or still in progress; 1: Job completed without error"}, {"name": "BUSY", "type": "BOOL", "description": "Status parameter: 0: Job not yet started or already completed; 1: Job not yet completed. A new job cannot be started."}, {"name": "ERROR", "type": "BOOL", "description": "Status parameter: 0: No error; 1: Error occurred"}, {"name": "STATUS", "type": "WORD", "description": "Detailed error and status information is output at the parameter STATUS. The parameter is only set for the duration of one call. To display the status, you should therefore copy the STATUS parameter to a free data area."}], "InOut": []}, "how_to_use": "Call the instruction once every time the time zone has to be changed, for example in a startup OB. When the input parameter REQ returns TRUE, the data is transferred and the CPU internal load memory is updated to reflect the new time zone settings, applying even after power failure. The instruction is level-triggered or edge-triggered depending on CPU and firmware version. After successful processing, REQ is automatically reset to FALSE. Monitor BUSY, DONE, ERROR, and STATUS outputs to check execution status.", "example_code": "VAR\n  execute : BOOL := TRUE;\n  timezone : TimeTransformationRule;\n  modeDONE : BOOL;\n  modeBUSY : BOOL;\n  modeERROR : BOOL;\n  statusTime : WORD;\nEND_VAR\n\n// Initialize TimeTransformationRule parameters here\n// Call the SET_TIMEZONE instruction\nSET_TIMEZONE(\n  REQ := execute,\n  TimeZone := timezone,\n  DONE => modeDONE,\n  BUSY => modeBUSY,\n  ERROR => modeERROR,\n  STATUS => statusTime\n);\n\n// Automatic resetting of execute handled internally after DONE\n", "additional_info": "The instruction writes data internally to the CPU load memory and retains it across power failures, so calling SET_TIMEZONE again is unnecessary unless the time zone changes. It can only be used with S7-1500 CPUs starting from firmware version V1.7. The TimeTransformationRule data type must be properly configured; invalid structures cause error code 808F in STATUS. Common STATUS error codes include 7000 to 80C3 specifying job states and errors.", "generated_brief": {"functional_summary": "The SET_TIMEZONE instruction configures the CPU's local time zone and daylight saving/standard time changeover by updating the CPU's internal load memory based on a specified TimeTransformationRule.", "usage_context": "It is typically called once during system startup or whenever the time zone settings need to be changed to ensure the CPU uses correct local time information even after power cycles."}, "generated_keywords": ["set time zone", "daylight saving time adjustment", "CPU local time configuration", "TimeTransformationRule parameter", "persistent time settings"]}
{"instruction_name": "ASI_CTRL", "description": "Using the instruction \"ASI_CTRL\", the behavior of the AS-i master is controlled from the user program of the PLC. The instruction processes the command protocol automatically. It also enables parameter assignment on SIMATIC AS-i masters and reading out information data. The functions and operation of the command interface are detailed in the manual for the AS-i master. Both centrally inserted AS-i masters and distributed AS-i masters via PROFIBUS DP are supported. Combinations with PROFINET IO (e.g. IE/PB Link PN IO) are also possible.", "parameters": {"Input": [{"name": "REQ", "type": "BOOL", "description": "REQ = TRUE starts a new job unless a job is already in progress. No edge evaluation takes place."}, {"name": "LADDR", "type": "HW_IO", "description": "Hardware identifier of the AS-i master. You can obtain the address from the module properties."}, {"name": "SD", "type": "VARIANT", "description": "Send buffer. The parameter refers to a memory area in which the command is to be specified (see \"ASi commands\")."}, {"name": "RD", "type": "VARIANT", "description": "Receive buffer. This buffer is only relevant for commands which deliver answer data. The parameter refers to a memory area in which a command response is stored (see \"ASi commands\")."}], "Output": [{"name": "DONE", "type": "BOOL", "description": "DONE = TRUE: Job completed without errors."}, {"name": "BUSY", "type": "BOOL", "description": "BUSY = TRUE: Job in process."}, {"name": "ERROR", "type": "BOOL", "description": "ERROR = TRUE: Job aborted with error."}, {"name": "STATUS", "type": "DWORD", "description": "Job status / error code. See the \"STATUS parameter\" description."}], "InOut": []}, "how_to_use": "The instruction ASI_CTRL is an asynchronous function block. A job is started by setting REQ = TRUE unless a job is already running. BUSY indicates that a job is in progress. STATUS changes according to the job state: 00700100H on first call with REQ=TRUE, 00700200H on subsequent calls. Upon job completion, DONE is set if no error occurred and ERROR is set in case of an error. The parameters LADDR, SD, and RD must not change during job processing and must remain constant. The instruction cannot be interrupted and must not be called from interrupting OBs simultaneously.", "example_code": "", "additional_info": "Version V1.3 (and V1.2) of ASI_CTRL require version V1.1 of WRREC instruction. When using ASI_CTRL to send commands, no other commands may be sent simultaneously to the same AS-i master using RDREC or WRREC. Calls must not be programmed in priority classes that interrupt each other. STATUS codes provide detailed job states and error codes; interpretation is necessary for diagnostics.", "generated_brief": {"functional_summary": "The ASI_CTRL instruction controls the AS-i master from the PLC program by processing command protocols, enabling parameter assignment, and reading information data asynchronously.", "usage_context": "It is used when managing and communicating with centrally or distributed AS-i masters within industrial automation systems, including those connected via PROFIBUS DP or PROET IO."}, "generated_keywords": ["AS-i master control", "PLC command protocol", "asynchronous job processing", "parameter assignment", "PROFIBUS DP communication"]}
{"instruction_name": "Chars_TO_Strg", "description": "With the \"Chars_TO_Strg\" instruction you copy characters from an Array of CHAR or Array of BYTE to a character string of the data type STRING or from an ARRAY of WCHAR or Array of WORD to a character string of the data type WSTRING. For the copy operation only ASCII characters are valid. Specify the characters of the Array of (W)CHAR / BYTE / WORD that will be copied to a character string at the input parameter CHARS. The characters are written at the parameter STRG to a (W)STRING data type. The number of characters in the string is at least the same number as were copied from the source field. If the character string is shorter than the number of characters in the source field, the characters are written up to the maximum length of the string. If the Array of CHAR / BYTE contains a \"$00\" character or if the Array of WCHAR / WORD contains a W#16#0000 character, the copy operation is only carried out up to the corresponding position. Using the PCHARS parameter, specify the position of the source field as of which the characters will be copied. PCHARS = 0 is the default value and always specifies the lower index limit of the array even if this is negative. If an index is specified at parameter PCHARS and the index is not contained in the copy source (e.g. \"7\" at Array [0..5] of CHAR) then the instruction is not executed.", "parameters": {"Input": [{"name": "CHARS", "type": "VARIANT", "description": "Source of the copy operation. Array of (W)CHAR / BYTE / WORD from which the characters are copied."}, {"name": "PCHARS", "type": "DINT", "description": "Position in the Array of (W)CHAR / BYTE / WORD starting at which the characters are copied."}, {"name": "CNT", "type": "UINT", "description": "Number of characters to be copied. Use \"0\" to copy all characters."}], "Output": [{"name": "STRG", "type": "STRING, WSTRING", "description": "Destination of the copy operation. Character string with the (W)STRING data type. STRING supports up to 254 characters. WSTRING supports 254 characters (default) or up to 16382 characters if explicitly defined with square brackets."}], "InOut": []}, "how_to_use": "Define the source array of characters (CHAR, BYTE, WCHAR, or WORD) and specify it in CHARS. Set PCHARS to the starting index in the source array to begin copying (0 by default). Set CNT to the number of characters to copy; use 0 to copy all. The copied characters are written into STRG, a STRING or WSTRING variable. Ensure that the target string length is sufficient. Note that if CHARS contains null characters ($00 for CHAR/BYTE or W#16#0000 for WCHAR/WORD), copying stops at the null character. For S7-1200 up to Version 2.0, negative index limits in arrays are not supported, and only arrays starting at 0 or positive indices may be used.", "example_code": "VAR\n    inputArrayCHARS: ARRAY[0..9] OF CHAR;\n    pointerCHARS: DINT := 2;\n    countCHARS: UINT := 0;\n    outputSTRG: STRING[254];\nEND_VAR\n\n// Copy characters starting from index 2 to the string, copying all characters\nChars_TO_Strg(CHARS := inputArrayCHARS, PCHARS := pointerCHARS, CNT := countCHARS, STRG => outputSTRG);", "additional_info": "If PCHARS specifies an index outside the bounds of the source array, the instruction is not executed. When using WSTRING, explicitly define the length if it exceeds 254 characters (e.g., WSTRING[16382]). For S7-1200 versions prior to 2.0, arrays with negative indices are not permissible and this is not checked automatically. Only ASCII characters are copied in the operation.", "generated_brief": {"functional_summary": "The Chars_TO_Strg instruction copies characters from an array of CHAR, BYTE, WCHAR, or WORD into a STRING or WSTRING variable, handling ASCII characters and stopping on null characters if present.", "usage_context": "It is typically used in PLC programs to convert character arrays into string variables for text processing or communication tasks where string manipulation is required."}, "generated_keywords": ["character array to string conversion", "copy CHAR BYTE WCHAR WORD to STRING WSTRING", "ASCII character copying", "null-terminated string handling", "string manipulation in PLC"]}
{"instruction_name": "DataLogCreate", "description": "With the \"DataLogCreate\" instruction you create a data log. The data log is saved on the memory card or in the internal load memory in the directory \"\\DataLogs\". The amount of data that is stored in a data log is dependent on the available space on the memory card or the storage space in the internal load memory of the CPU used. The maximum size of the generated CSV file is 500,000,000 bytes for S7-1200 CPUs, 1,000,000,000 bytes for S7-1500 CPUs. You specify the maximum number of data records that is stored in a data log in the RECORDS parameter. When the specified maximum number of data records in the data log is reached, the oldest data record is overwritten. To avoid overwriting of existing data records, use the \"DataLogNewFile\" instruction. The instruction is used to create a new data log with the same structure when the number specified at the RECORDS parameter is reached (return value 1 at the STATUS parameter of the \"DataLogWrite\" instruction). The data records are then saved in the new data log. You specify the name for the data log in the NAME parameter. The data log is created in CSV (Comma Separated Value) format. With the HEADER parameter, you create an (optional) header for the data log. Once the data log is created, it is opened automatically. This means that data can be written.", "parameters": {"Input": [{"name": "REQ", "type": "BOOL", "description": "Execution of the instruction. The data log is created with a rising edge at the parameter REQ."}, {"name": "RECORDS", "type": "UDInt", "description": "Maximum number of data records in the data log. If the \"DataLogWrite\" instruction writes more records than specified in this parameter, the oldest record is overwritten."}, {"name": "FORMAT", "type": "UInt", "description": "Data format: 0: Internal (not supported), 1: CSV (Comma separated values)"}, {"name": "TIMESTAMP", "type": "UInt", "description": "Time-stamping; the extra columns in the header are automatically added if time-stamping is activated."}, {"name": "NAME", "type": "VARIANT", "description": "Name of the data log. The specified name is also used as a file name for the csv file. Restrictions apply depending on CPU type: S7-1200 - max 35 characters, allowed ASCII characters except \\ ' / \" : ; [ ] | = . * ? < >; S7-1500 - max 55 characters, allowed characters 0-9, a-z, A-Z, - and _."}], "Output": [{"name": "DONE", "type": "BOOL", "description": "Status parameter: 0 = Processing not yet complete, 1 = Processing of instruction finished successfully."}, {"name": "BUSY", "type": "BOOL", "description": "Status parameter: 0 = Processing of the instruction has not started, completed, or canceled; 1 = Processing of the instruction is in progress."}, {"name": "ERROR", "type": "BOOL", "description": "Status parameter: 0 = No error; 1 = An error occurred during execution of the instruction. Detailed information is output via the STATUS parameter."}, {"name": "STATUS", "type": "WORD", "description": "Detailed status information: Detailed error and status information is output at this parameter. It is only set for the duration of one call. To display the status, copy the STATUS parameter to a free data area."}], "InOut": [{"name": "ID", "type": "DWORD", "description": "Object ID of the data log (only output). The ID of the data log is required for further data logging instructions to address the created data log."}, {"name": "HEADER", "type": "VARIANT", "description": "Header of the data log (optional). The parameter is hidden after the instruction is added. The header is written as the first line in the CSV file."}, {"name": "DATA", "type": "VARIANT", "description": "Pointer to the data structure that is written as data record when executing the \"DataLogWrite\" instruction."}]}, "how_to_use": "Activate the data log creation by setting REQ to TRUE at a rising edge. Specify the maximum number of records with RECORDS; when this number is exceeded, the oldest data is overwritten unless a new file is created using the DataLogNewFile instruction. Choose the CSV format by setting FORMAT to 1. TIMESTAMP enables time-stamping columns. The NAME parameter sets the data log file name respecting CPU-specific restrictions. Provide optional HEADER and DATA parameters pointing to the header and data block structure, respectively. The instruction automatically opens the data log after creation, allowing data to be written.", "example_code": "VAR\n  REQ : BOOL;\n  RECORDS : UDInt := 3;\n  FORMAT : UInt := 1; // CSV\n  TIMESTAMP : UInt := 1; // System time\n  NAME : VARIANT; // Pointing to string DataLogName\n  ID : DWORD; // Data log ID output\n  HEADER : VARIANT; // Pointer to header\n  DATA : VARIANT; // Pointer to data structure\n  DONE : BOOL;\n  BUSY : BOOL;\n  ERROR : BOOL;\n  STATUS : WORD;\nEND_VAR\n\nDataLogCreate(\n  REQ := REQ,\n  RECORDS := RECORD,\n  FORMAT := FORMAT,\n  TIMESTAMP := TIMESTAMP,\n  NAME := NAME,\n  ID := ID,\n  HEADER := HEADER,\n  DATA := DATA,\n  DONE => DONE,\n  BUSY => BUSY,\n  ERROR => ERROR,\n  STATUS => STATUS\n);", "additional_info": "The HEADER parameter can be a STRING, Array of BYTE, or Array of CHAR with limitations on length. The DATA parameter points to a structure or array whose elements correspond to columns in the CSV; no nested STRUCTs allowed, arrays within are allowed with some restrictions. Maximum 256 elements in DATA are supported. Error codes provide diagnostics for invalid inputs, memory issues, file name restrictions, and system limits. The created data log is stored in the \\DataLogs directory on memory card or internal memory. To prevent overwriting, use DataLogNewFile when RECORDS limit is reached.", "generated_brief": {"functional_summary": "The DataLogCreate instruction creates and opens a CSV-formatted data log file in memory with a specified maximum number of records, optional headers, and time-stamping for storing and managing process or system data.", "usage_context": "It is used in industrial automation to initialize and manage structured data recording for monitoring, diagnostics, or historical analysis within PLC-controlled systems."}, "generated_keywords": ["create data log", "CSV data logging", "data log initialization", "record limit management", "time-stamped data logging"]}
{"instruction_name": "GetSymbolName", "description": "With the \"GetSymbolName\" instruction, you use the input parameter of a block to read out the name of a tag interconnected at the VARIABLE parameter.", "parameters": {"Input": [{"name": "VARIABLE", "type": "PARAMETER", "description": "Selection of the local interface to which you want to read out the name of the input parameter supply."}, {"name": "SIZE", "type": "DINT", "description": "Limits the number of characters output at the OUT parameter.\n- SIZE > 0: GetSymbolName returns the first SIZE characters of the name.\n- SIZE = 0: GetSymbolName returns the entire name.\n- SIZE < 0: GetSymbolName returns the last SIZE characters of the name."}], "Output": [{"name": "OUT", "type": "WSTRING", "description": "Output of the tag name of the input parameters supply"}], "InOut": []}, "how_to_use": "Specify the input parameter of the block interface on the VARIABLE parameter, using only an interface parameter, no PLC or data block tags. Use the SIZE parameter to limit the length of the returned tag name; if the name is truncated, the truncated part is indicated by the characters \"...\" at the end of the output string. The read name is output at the OUT parameter. Do not call \"GetSymbolName\" directly in an OB and avoid calling it cyclically to minimize runtime impact.", "example_code": "(* Example SCL snippet to read symbol name of inputValue with length limited to 60 characters *)\nGetSymbolName( VARIABLE := inputValue, SIZE := 60, OUT => symbolName );", "additional_info": "- \"GetSymbolName\" may not be called directly in an OB.\n- An empty string is returned if the connected tag at VARIABLE is negated.\n- Use of this instruction increases code memory and runtime; avoid frequent cyclic calls.\n- A meaningful use case is calling it during error detection or startup routines.\n- If the name is truncated due to SIZE limitation, \"...\" (unicode 16#2026) is appended.\n- SIZE parameter examples:\n  - SIZE=1 returns '...'\n  - SIZE=0 returns the full name  - Larger SIZE values return the initial characters plus \"...\" if truncated.", "generated_brief": {"functional_summary": "The GetSymbolName instruction retrieves the name of a tag connected to a specified block input parameter, optionally limiting the length of the returned name.", "usage_context": "It is typically used during error detection or startup routines to identify connected tags without impacting runtime by avoiding cyclic or direct calls in organizational blocks."}, "generated_keywords": ["read tag name", "block input parameter", "limit name length", "error detection", "startup routine"]}
{"instruction_name": "Strg_TO_Chars", "description": "With the \"Strg_TO_Chars\" instruction, you copy a character string of the data type STRING to an Array of CHAR or Array of BYTE or a character string of the data type WSTRING to an Array of WCHAR or Array of WORD. Only ASCII characters are valid for the copy process.", "parameters": {"Input": [{"name": "STRG", "type": "STRING, WSTRING", "description": "Source of the copy operation"}, {"name": "PCHARS", "type": "DINT", "description": "Position in the structure Array of (W)CHAR / BYTE / WORD starting from which the characters of the character string are written."}], "Output": [{"name": "CNT", "type": "UINT", "description": "Number of moved characters"}], "InOut": [{"name": "CHARS", "type": "VARIANT", "description": "Destination of the copy operation. Copy the characters to a structure of the Array of (W)CHAR/ BYTE/ WORD data type."}]}, "how_to_use": "Specify the source character string at STRG, set PCHARS to indicate the start position in the destination array, and provide a destination array structurally compatible with CHAR, BYTE, WCHAR, or WORD data types. The number of characters copied will be output at CNT. Ensure the destination array has at least as many elements as the number of characters to copy. When PCHARS = 0, writing begins at the lowest index of the array.", "example_code": "", "additional_info": "Only ASCII characters are valid for copying. If the destination array is smaller than the source string, characters are copied up to the max destination length. If the string contains \"$00\" or W#16#0000 characters, it has no effect on copying. For S7-1200 up to Version 2.0, only arrays with positive zero-based indices ([0..n]) are supported; negative indices are not allowed though not checked by software.", "generated_brief": {"functional_summary": "The Strg_TO_Chars instruction copies an ASCII STRING or WSTRING into a specified position within an array of CHAR, BYTE, WCHAR, or WORD data types.", "usage_context": "It is typically used in PLC programming when characters from a string need to be transferred into a byte or word array for further processing or communication."}, "generated_keywords": ["string to char array", "string copy", "ascii character transfer", "wstring to wchar array", "plc string handling"]}
{"instruction_name": "RH_CTRL", "description": "The 'RH_CTRL' instruction allows you to influence R/H systems by controlling the system state, including disabling/enabling SYNCUP, requesting STOP for primary/backup CPUs, querying system state, and managing system IP addresses.", "parameters": {"Input": [{"name": "REQ", "type": "BOOL", "description": "Control parameter Request. Enables the execution of the instruction when REQ = '1'."}, {"name": "Mode", "type": "BYTE", "description": "Select the desired action for the R/H system, with various numerical values corresponding to specific commands."}, {"name": "Submode", "type": "WORD", "description": "Hidden parameter for specific modes; otherwise specifies the hardware identifier of the PROFINET interface for certain commands."}], "Output": [{"name": "Ret_Val", "type": "INT", "description": "Error code indicating the result of the operation."}, {"name": "Busy", "type": "BOOL", "description": "Status parameter where '0' indicates execution is complete and '1' indicates execution is still in progress."}]}, "how_to_use": "Start the operation by setting REQ to '1' and selecting the appropriate mode to perform specific actions on the R/H system.", "example_code": "// Call RH_CTRL to request SYNCUP \n#RetVal := RH_CTRL(REQ := 1, Mode := 7, Submode := 0, Busy => #busy);", "additional_info": "The RH_CTRL instruction processes asynchronously. Be cautious when running in commissioning scenarios without an MRP check due to potential safety risks.", "generated_brief": {"functional_summary": "The RH_CTRL instruction manages R/H system states by enabling control actions such as SYNCUP, CPU stop requests, system state queries, and IP address management.", "usage_context": "It is typically used in industrial automation environments to asynchronously control and monitor redundancy and communication parameters of R/H systems during operation or commissioning."}, "generated_keywords": ["R/H system control", "SYNCUP management", "CPU stop request", "system state query", "IP address management"]}
{"instruction_name": "RecipeExport", "description": "Transfers recipe data from a recipe data block to a CSV file on the memory card of the CPU.", "parameters": {"Input": [{"name": "Recipe Data Block", "type": "DB", "description": "The data block containing the recipe data to be exported."}], "Output": [], "InOut": []}, "how_to_use": "Use this instruction to export recipe data to a CSV file stored on the CPU's memory card. Ensure the recipe data block is correctly populated before executing the instruction.", "example_code": "", "additional_info": "The service life of memory cards is limited. Ensure that the data block is in the correct memory area (work or load memory).", "generated_brief": {"functional_summary": "The RecipeExport instruction transfers recipe data from a specified data block to a CSV file stored on the CPU's memory card.", "usage_context": "This function is used when saving or backing up recipe configurations from the PLC to external storage for record-keeping or transfer purposes."}, "generated_keywords": ["recipe data export", "data block to CSV", "memory card storage", "recipe backup", "PLC recipe transfer"]}
{"instruction_name": "RecipeImport", "description": "Transfers recipe data from a CSV file on the memory card of the CPU to a recipe data block.", "parameters": {"Input": [{"name": "CSV File", "type": "String", "description": "The path to the CSV file from which the recipe data will be imported."}], "Output": [{"name": "Recipe Data Block", "type": "DB", "description": "The data block where the imported recipe data will be stored."}], "InOut": []}, "how_to_use": "Use this instruction to import recipe data from a CSV file into a designated recipe data block. Make sure the CSV file is formatted correctly.", "example_code": "", "additional_info": "Ensure that the delimiter used in the CSV file is not included in any character strings. Monitor possible errors during import related to delimiters.", "generated_brief": {"functional_summary": "The RecipeImport instruction transfers recipe data from a CSV file stored on the CPU memory card into a specified recipe data block.", "usage_context": "This function is used when importing and updating recipe data within a PLC program to ensure proper process control based on predefined settings."}, "generated_keywords": ["import recipe data", "CSV file transfer", "recipe data block", "PLC recipe update", "data import from memory card"]}
{"instruction_name": "ACK_FCT_WARN", "description": "You can use the \"ACK_FCT_WARN\" instruction to acknowledge the message in the diagnostic buffer that warns you about exceeding the F-cycle time. The F-cycle time is the maximum time that may pass between two F-OB calls. If the instruction at input parameter \"ACK_WARN\" detects a rising edge, the warning message is acknowledged. In all other cases it is not acknowledged.", "parameters": {"Input": [{"name": "ACK_WARN", "type": "BOOL", "description": "Acknowledgment of the warning message on rising edge"}], "Output": [], "InOut": []}, "how_to_use": "Use this instruction by providing a BOOL rising edge signal at the input parameter ACK_WARN to acknowledge the warning message related to exceeding the F-cycle time in the diagnostic buffer. Ensure the input detects a rising edge for the acknowledgment to occur.", "example_code": "", "additional_info": "More information on the F-cycle time can be found in the \"SIMATIC Safety - Configuring and Programming\" Operating Manual.", "generated_brief": {"functional_summary": "The ACK_FCT_WARN instruction acknowledges a diagnostic warning message about exceeding the F-cycle time when a rising edge is detected on the ACK_WARN input.", "usage_context": "It is typically used in PLC programs to clear warnings related to timing violations of the maximum allowed interval between consecutive F-OB calls in safety applications."}, "generated_keywords": ["acknowledge warning", "F-cycle time exceeded", "diagnostic buffer", "rising edge detection", "F-OB call timing"]}
{"instruction_name": "GetBlockName", "description": "You can use the \"GetBlockName\" instruction to read the name of the block in which the instruction is called. If the length of the block name is to be limited to a certain number of characters, specify the max. length at the SIZE parameter. If the name has been truncated, this is indicated by the character \"...\" (Unicode character 16#2026) at the end of the name. Note that this character has the length 1. The name of the block is written at the RET_VAL parameter. If the name of the block is longer than the maximum length of WSTRING, the name is truncated.", "parameters": {"Input": [{"name": "SIZE", "type": "DINT", "description": "Limits the number of characters output at the RET_VAL parameter. SIZE > 0: GetBlockName returns the first SIZE characters of the name. SIZE = 0: GetBlockName returns the entire name. SIZE < 0: GetBlockName returns the last SIZE characters of the name."}], "Output": [{"name": "RET_VAL", "type": "WSTRING", "description": "Read name of the program block"}], "InOut": []}, "how_to_use": "Use the GetBlockName instruction in the block whose name you want to read. Connect the SIZE input with an integer defining the maximum number of characters to return (0 for no limit). The block name is returned in the RET_VAL output parameter as a WSTRING. If the block name is longer than SIZE, the returned string is truncated and ends with \"...\" (Unicode character 16#2026) indicating truncation.", "example_code": "VAR\n  limitSIZE : DINT := 0;\n  outputBlockName : WSTRING;\nEND_VAR\n\nGetBlockName(\n  SIZE := limitSIZE,\n  RET_VAL => outputBlockName\n);", "additional_info": "When truncating, the \"...\" character uses length 1 in the WSTRING. SIZE parameter values control whether the first or the last characters are returned when truncation is applied Valid data types for SIZE include input, output, memory areas I, Q, M, D, L or constants.", "generated_brief": {"functional_summary": "The GetBlockName instruction retrieves the name of the program block in which it is called, optionally limiting or truncating the length of the returned name.", "usage_context": "It is used when a program needs to dynamically identify or log the name of its current block for diagnostic, monitoring, or organizational purposes."}, "generated_keywords": ["get block name", "read program block name", "block name truncation", "dynamic block identification", "retrieve block name string"]}
{"instruction_name": "GetInstanceName", "description": "You can use the 'GetInstanceName' instruction to read the name of the instance data block within a function block.", "parameters": {"Input": [{"name": "SIZE", "type": "DINT", "description": "Limits the number of characters output at the OUT parameter. SIZE > 0: GetInstanceName returns the first SIZE characters of the name. SIZE = 0: GetInstanceName returns the entire name. SIZE < 0: GetInstanceName returns the last SIZE characters of the name."}], "Output": [{"name": "OUT", "type": "WSTRING", "description": "Read name of the instance data block."}], "InOut": []}, "how_to_use": "To limit the length of the read instance name, use the SIZE parameter.", "example_code": "In the following example, you read out the name of an instance data block. Create two tags in a global data block for storing the data...", "additional_info": "The instruction 'GetInstanceName' may not be called directly in an OB. The use of GetInstanceName leads to an increased code memory requirement and runtime increase, and it is recommended not to call it cyclically.", "generated_brief": {"functional_summary": "GetInstanceName reads the name of the instance data block within a function block, optionally limiting the length of the output string.", "usage_context": "It is used when you need to retrieve and possibly truncate the instance name for identification or diagnostic purposes outside of cyclic calls to avoid increased memory and runtime overhead."}, "generated_keywords": ["read instance name", "function block instance", "limit name length", "instance data block", "non-cyclic usage"]}
{"instruction_name": "ModuleStates", "description": "You can use the \"ModuleStates\" instruction to read the status information of the modules of a PROFINET IO device or PROFIBUS DP slave. The Boolean value that is output indicates the modules to which the selected status applies. You can, for example, read which modules are currently disabled in a PROFINET IO device. Information is also displayed as to whether the status information to be read applies to at least one of the modules. The instruction can be called in a OB as well as in an interrupt OB (e.g. OB82 - diagnostic interrupt).", "parameters": {"Input": [{"name": "LADDR", "type": "HW_DEVICE", "description": "Hardware identifier of the station (see description below). You select the IO device or the DP slave at the LADDR parameter by means of the hardware identifier of the station. The hardware identifier is available either in the network view of the properties of the IO device station or DP slave station, or in the PLC tag table for the listed system constants with the data type HW_DEVICE (for an IO device) or with the data type HW_DPSLAVE (for a DP slave)."}, {"name": "MODE", "type": "UINT", "description": "Selection of module status information to be read. One of the following status information items can be read for the modules: 1: Modules are configured, 2: Modules are faulty, 3: Modules are disabled, 4: Modules exist, 5: There is a problem in the modules (e.g. maintenance demanded or recommended, not accessible, not available, error occurred)."}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Status of instruction. Possible values include: 0 (No error), 8091 (Hardware identifier of the LADDR parameter does not exist), 8092 (LADDR does not address an IO device or DP slave), 8093 (Invalid data type at the STATE parameter), 80B1 (The instruction \"ModuleStates\" is not supported by the CPU), 80B2 (The selected MODE is not supported by the used CPU), 8452 (The complete status information does not fit in the tag configured in the STATE parameter"}], "InOut": [{"name": "STATE", "type": "VARIANT", "description": "Buffer for the module status. Outputs the status of the modules selected with the MODE parameter. If the status selected using MODE applies to a module, bit 0 set to 1 if at least one module is affected. Bit n represents the module in slot n-1 (e.g., bit 3 corresponds to slot 2). Use BOOL to output only the group display bit, or an Array of BOOL (length 128 bits) to output status for all modules."}]}, "how_to_use": "Call the ModuleStates instruction cyclically or in an interrupt OB to read status information of modules in PROFINET IO devices PROFIBUS DP slaves. Pass the hardware identifier of the device in LADDR, select the status information with MODE, provide a VARIANT buffer (BOOL or Array of BOOL) for STATE, and check RET_VAL for execution status. Ensure that the STATE buffer is sufficiently sized to avoid errors.", "example_code": "(* Example to query modules existence in a PROFINET IO device *)\nVAR\n  myLADDR : HW_DEVICE; (* Hardware identifier of IO device *)\n  myMODE : UINT := 4; (* MODE=4 to check module existence *)\n  mySTATE : ARRAY[0..127] OF BOOL; (* Buffer for module status *)\n  returnValue : INT;\nEND_VAR\n\nreturnValue := ModuleStates(LADDR := myLADDR, MODE := myMODE, STATE := mySTATE);", "additional_info": "When the tag configured at STATE is checked for adequate field length, the CountOfElements instruction is called. This counts the fill elements when VARIANT points to an Array of BOOL. An Array[0..120] of BOOL results in 128 as the field length. Error code W#16#8452 is only returned when the number of actual elements plus fill elements is less than 128. Use valid data types as specified. The instruction is not supported by all CPUs.", "generated_brief": {"functional_summary": "The ModuleStates instruction reads status information about the modules of PROFINET IO devices or PROFIBUS DP slaves, providing details such as whether modules are configured, faulty, disabled, exist, or have problems via a Boolean status output.", "usage_context": "It is typically used cyclically or within interrupt OBs to monitor and diagnose the condition of device modules in industrial automation networks for maintenance or error handling purposes."}, "generated_keywords": ["read module status", "PROFINET IO device monitoring", "PROFIBUS DP slave diagnostics", "cyclic status polling", "module error detection"]}
{"instruction_name": "RTM", "description": "You can use this instruction to set, start, stop, and read out a 32-bit operating hours counter of your CPU. Ensure that the operating hours counter can also be stopped or restarted during execution of the user program, which may render the saved values incorrect.", "parameters": {"Input": [{"name": "NR", "type": "RTM", "description": "Number of the operating hours counter. Numbering starts with 0. Refer to the technical specifications for the number of operating hours counters of your CPU."}, {"name": "MODE", "type": "BYTE", "description": "Job ID:\n0: Read out (the status is then written to CQ and the current value to CV). After the operating hours counter has reached (2^31) - 1 hours, it stops at the highest value and outputs an \"Overflow\" error.\n1: start (at the last counter value)\n2: stop\n4: set to the value specified in the parameter PV\n5: set to the value specified in the parameter PV and start\n6: set to the value specified in the parameter PV and stop"}, {"name": "PV", "type": "DINT", "description": "New value for the operating hours counter"}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "If an error occurs during execution, this return value contains an error code."}, {"name": "CQ", "type": "BOOL", "description": "Status of the operating hours counter (1: running)"}, {"name": "CV", "type": "DINT", "description": "Current value of the operating hours counter"}], "InOut": []}, "how_to_use": "To use the RTM instruction, specify the operating hours counter number in NR, select the job mode in MODE according to the intended action (read, start, stop, set, etc.), and provide any new value in PV if setting or starting with a specific value is needed. Monitor RET_VAL for error codes, CQ for running status, and CV for the current counter value. Note that the operating hours counter can be stopped or restarted during program execution, which may affect saved values.", "example_code": "(* Example SCL snippet for RTM usage *)\nVAR\n    execute: BOOL;\n    comandMODE: BYTE;\n    in_processValue: DINT;\n    currentValue: DINT;\n    statusRTM: BOOL;\n    returnValue: INT;\n    counterNumber: RTM := 0; (* Operating hours counter 0 *)\nEND_VAR\n\nIF execute THEN\n    RTM(NR := counterNumber, MODE := comandMODE, PV := in_processValue, RET_VAL => returnValue, CQ => statusRTM, CV => currentValue);\n    (* Start counter with value in_processValue and then read current value by setting comandMODE to 0 *)\nEND_IF;", "additional_info": "Error codes for RET_VAL:\n0000: No error\n8080: Wrong number for operating hours counter\n8081: Negative value passed to PV\n8082: Overflow of the counter\n8091: Invalid MODE value\nRefer to GET_ERR_ID for detailed error evaluation.", "generated_brief": {"functional_summary": "The RTM instruction manages a 32-bit operating hours counter by allowing reading, starting, stopping, and setting its value in a CPU-controlled system.", "usage_context": "It is typically used in industrial automation to track and control the operating time of machines or equipment for maintenance and monitoring purposes."}, "generated_keywords": ["operating hours counter", "start stop counter", "read counter value", "set counter value", "error handling"]}
{"instruction_name": "S_MOVE", "description": "You can use this instruction to write the content of a character string (W)STRING from parameter IN to the data area that you specify at parameter OUT.", "parameters": {"Input": [{"name": "IN", "type": "STRING, WSTRING", "description": "Source string"}], "Output": [{"name": "OUT", "type": "STRING, WSTRING", "description": "Destination string"}], "InOut": []}, "how_to_use": "To use this instruction, provide a source character string to the IN parameter and specify a destination for the output string at the OUT parameter.", "example_code": "stringValueOUT := S_MOVE(stringValueIN);", "additional_info": "To copy tags of data type ARRAY, use the 'MOVE_BLK' and 'UMOVE_BLK' instructions.", "generated_brief": {"functional_summary": "The S_MOVE instruction copies the content of a source character string (STRING or WSTRING) to a specified destination string variable.", "usage_context": "It is typically used when transferring or duplicating string data within PLC programs during industrial control operations."}, "generated_keywords": ["string copy", "character string move", "S_MOVE instruction", "string data transfer", " string manipulation"]}
{"instruction_name": "GADR_LGC", "description": "You use the \"GADR_LGC\" instruction to determine the hardware identifier of a signal module. The hardware identifier is determined from the module slot and the offset in the user data address area of the module.", "parameters": {"Input": [{"name": "SUBNETID", "type": "BYTE", "description": "Area ID: 0: If the slot is located in the central module; 1 to 32: DP master system ID of the corresponding distributed I/O system if the slot is in a distributed I/O device; 100 to 115: PROFINET IO system ID of the associated field device if the slot is located in a field device on PROFINET"}, {"name": "RACK", "type": "WORD", "description": "Number of the rack, if area identifier is 0; Device number of the distributed I/O device if the area identifier > 0"}, {"name": "SLOT", "type": "WORD", "description": "Slot no."}, {"name": "SUBSLOT", "type": "BYTE", "description": "Irrelevant"}, {"name": "SUBADDR", "type": "WORD", "description": "Offset in the user data address area of the module"}], "Output": [{"name": "IOID", "type": "BYTE", "description": "The IOID output parameter is not written (always \"0\")."}, {"name": "LADDR", "type": "HW_MODULE", "description": "Hardware identifier of the module"}], "InOut": [{"name": "RET_VAL", "type": "INT", "description": "Error information"}]}, "how_to_use": "Use the \"GADR_LGC\" instruction by providing the SUBNETID, RACK, SLOT, SUBSLOT, and SUBADDR inputs to retrieve the hardware identifier of a module in LADDR. Check RET_VAL for error codes to ensure the call was successful. Note that this instruction cannot be used for modules behind gateways; instead use \"GEO2LOG\" in such cases.", "example_code": "", "additional_info": "The instruction cannot be used for modules behind gateways (e.g., IE/PB link); use the \"GEO2LOG\" instruction instead. RET_VAL returns specific error codes such as 0000 (no error), 8094 (no subnet configured with specified SUBNETID 8095 (illegal RACK value), 8096 (illegal SLOT value), 8098 (illegal SUBADDR value), and general error information. Refer to related instructions for address conversion and error handling.", "generated_brief": {"functional_summary": "The GADR_LGC instruction retrieves the hardware identifier of a signal module based on its subnet ID, rack, slot, subslot, and data address offset.", "usage_context": "It is used in PLC programs to determine module hardware identifiers within centrally or distributed I/O systems, except for modules behind gateways where a different instruction is required."}, "generated_keywords": ["hardware identifier retrieval", "module address resolution", "subnet rack slot mapping", "PLC module identification", "signal module hardware ID"]}
{"instruction_name": "GEO2LOG", "description": "You use the \"GEO2LOG\" instruction to determine hardware identifier based on slot information that you define using the system data type GEOADDR. Depending on the type of hardware you define at the parameter HWTYPE the following information is evaluated from the other parameters GEOADDR: When HWTYPE = 1 (IO system): Only IOSYSTEM is evaluated. The other parameters of GEOADDR are not taken into consideration. The hardware identifier of the IO system is output. When HWTYPE = 2 (IO device): IOSYSTEM and STATION are evaluated. The other parameters of GEOADDR are not taken into consideration. The hardware identifier of the IO device is output. With HWTYPE 4 (module): IOSYSTEM, STATION and SLOT are evaluated. The SUBSLOT parameter of GEOADDR is not taken into consideration. The hardware identifier of the module is output. With HWTYPE = 5 (submodule): All parameters of GEOADDR are evaluated. The hardware identifier of the submodule is output. The AREA parameter of the GEOADDR system data type is not evaluated.", "parameters": {"Input": [{"name": "GEOADDR", "type": "VARIANT", "description": "Pointer to the structure of the GEOADDR system data type. The system data type contains the slot information from which the hardware ID is determined."}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Output of error information."}, {"name": "LADDR", "type": "UINT / HW_ANY", "description": "Hardware identifier of the assembly or the module. The number is automatically assigned."}], "InOut": []}, "how_to_use": "To use the GEO2LOG instruction, provide a pointer to the GEOADDR structure containing the slot and hardware type information. The instruction evaluates different parts of the GEOADDR structure based on the HWTYPE parameter to determine the hardware ID. The hardware ID is output to LADDR, and any errors in parameters are indicated in RET_VAL. Note that the AREA parameter of GEOADDR is not evaluated. Typical HWTYPE values are 1 for IO system, 2 for IO device, 4 for module, and 5 for submodule. Properly initialize the GEOADDR data structure before calling the instruction.", "example_code": "VAR\n  geoAddr : GEOADDR;\n  laddr : UINT;\n  returnValue : INT;\nEND_VAR\n\n// Set the GEOADDR parameters\ngeoAddr.HWTYPE := 4;      // Module\ngeoAddr.IOSYSTEM := 0;    // Central controller\ngeoAddr.STATION := 0;     // Rack 0\ngeoAddr.SLOT := 1;        // Slot 1\ngeoAddr.SUBSLOT := 0;     // Not evaluated for HWTYPE=4\n\n// Execute GEO2LOG to get hardware ID\nGEO2LOG(GEOADDR := geoAddr, LADDR => laddr, RET_VAL => returnValue);", "additional_info": "Error codes returned in RET_VAL indicate specific invalid parameter values in GEOADDR: 0 means no error; 8091 for invalid HWTYPE; 8094 for invalid IOSYSTEM; 8095 for invalid STATION; 8096 for invalid SLOT; 8097 for invalid SUBSLOT. Display formats for error codes can be switched in the program editor. The hardware identifier output is automatically assigned by the system based on the input slot data.", "generated_brief": {"functional_summary": "The GEO2LOG instruction determines the hardware identifier based on slot and hardware type information provided in a GEOADDR structure.", "usage_context": "It is used in PLC programs to map physical IO system components, devices, modules, or submodules to their unique hardware IDs for addressing and configuration purposes."}, "generated_keywords": ["hardware identifier", "GEOADDR slot mapping", "HWTYPE evaluation", "IO system addressing", "module and submodule ID"]}
{"instruction_name": "Gen_UsrMsg", "description": "You use the 'Gen_UsrMsg' instruction to generate an alarm that is entered in the diagnostic buffer.", "parameters": {"Input": [{"name": "Mode", "type": "UInt", "description": "Parameters for selecting the status of the alarm: 1 for incoming alarm, 2 outgoing alarm."}, {"name": "TextID", "type": "UInt", "description": "ID of the text list entry that should be used for the alarm text."}, {"name": "TextListID", "type": "UInt", "description": "ID of the text list that contains text list entry."}], "Output": [{"name": "Ret_Val", "type": "Int", "description": "Error code of the instruction."}], "InOut": [{"name": "AssocValues", "type": "AssocValues", "description": "Pointer to the system data type AssocValues that allows you to define the associated values."}]}, "how_to_use": "To use this instruction, initialize the required parameters such as Mode, TextID, and TextListID appropriately. Make sure to define associated values following the specified format in the text list entry.", "example_code": "Gen_UsrMsg(\n    Mode := myMODE,\n    TextListID := 'myLIST',\n    TextID := 'myTEXT',\n    AssocValues := AssocValues,\n    RetVal => returnValue\n);", "additional_info": "The associated values are limited to a maximum of 8, and avoid using the numbers '1' or '2' for addressing associated values as they are reserved.", "generated_brief": {"functional_summary": "The Gen_UsrMsg instruction generates an alarm entry in the diagnostic buffer with specified status and associated text information.", "usage_context": "It is used in industrial control systems to create custom alarms for monitoring and diagnostics based on predefined text lists and parameterized associated values."}, "generated_keywords": ["generate alarm", "diagnostic buffer", "custom alarm", "text list entry", "associated values"]}
{"instruction_name": "GetInstancePath", "description": "You use the 'GetInstancePath' instruction to read the composed global name of the block instance within a function block. The composed global name of the block instance is the path of the complete call hierarchy when multi-instances are used.", "parameters": {"Input": [{"name": "SIZE", "type": "DINT", "description": "Limits the number of characters output at the OUT parameter. SIZE > 0: GetInstancePath returns the first SIZE characters of the name. SIZE = 0: GetInstancePath returns the entire name. SIZE < 0: GetInstancePath returns the last SIZE characters of the name."}], "Output": [{"name": "OUT", "type": "WSTRING", "description": "Read global name of the block instance. If the global name of the block instance is longer than the maximum length of WSTRING (254 characters), the name is truncated."}], "InOut": []}, "how_to_use": "Call 'GetInstancePath' in a function block to retrieve the global name of the block instance based on the size specified.", "example_code": "SIZE := 0;\nGetInstancePath(OUT := outputPath_Level4FB, SIZE := SIZE);", "additional_info": "The instruction may not be called directly in an OB, and it leads to an increased code memory requirement and runtime increase.", "generated_brief": {"functional_summary": "GetInstancePath retrieves the composed global name (full instance path) of a function block instance, optionally limited by a specified character size.", "usage_context": "It is used within function blocks to obtain the hierarchical call path of multi-instance blocks for identification or diagnostic purposes during runtime."}, "generated_keywords": ["get instance path", "function block instance name", "global block name retrieval", "hierarchical call path", "multi-instance identification"]}
{"instruction_name": "GetSymbolForReference", "description": "You use the \"GetSymbolForReference\" instruction to determine the name of an indirectly addressed object (i.e. an object that is addressed via a referencing data type). \"GetSymbolForReference\" is an instruction that works asynchronously, that is, the job execution can extend over multiple calls. You start the job execution by creating a rising edge at the 'execute' parameter. The output parameters busy, done, error and status indicate the status of the job.", "parameters": {"Input": [{"name": "execute", "type": "Bool", "description": "Control parameter: The job is started on a rising edge."}, {"name": "objectRef", "type": "Reference", "description": "Reference to the object whose name is to be determined."}, {"name": "size", "type": "DInt", "description": "If the determined name is shorter than 'symbol', 'size' has no meaning. If the determined name is longer than 'symbol', 'size' defines how the determined name is shortened: size > 0: returns the first 'size' characters of the name, followed by '...'. size = 0: returns as many characters as fit in 'symbol' followed by '...'. size < 0: returns the last (-1) * 'size' characters of the name, beginning with '...'."}], "Output": [{"name": "done", "type": "Bool", "description": "Status parameter: 0 = Job not yet started or still being executed. 1 = Job executed without errors (value displayed for one cycle only)."}, {"name": "busy", "type": "Bool", "description": "Status parameter: 1 = The job is not yet complete and a new job cannot be started. 0 = The job is complete."}, {"name": "error", "type": "Bool", "description": "Status parameter: error = 1 indicates an error occurred during processing, detailed information available in 'status'."}, {"name": "status", "type": "Int", "description": "Status of the job processing or error information."}, {"name": "reliability", "type": "Int", "description": "Reserved for future use."}], "InOut": [{"name": "symbol", "type": "WString", "description": "Determined name of the indirectly addressed object."}]}, "how_to_use": "To use the GetSymbolForReference instruction, initiate the job by setting a rising edge on the 'execute' input. Monitor the 'busy', 'done', and 'error' outputs to check the job status. The 'symbol' parameter will be updated asynchronously with the name of the referenced object once the job completes. Use the 'size' parameter to control how the symbol name is truncated if it exceeds the length of the 'symbol' buffer. Note that only references of data type 'DB_ANY' are supported on firmware version V3.1 of the S7-1500 CPUs, and DBs created with 'CREATE_DB' during runtime return an empty string as name.", "example_code": "", "additional_info": "Limitation: On firmware version V3.1 of S7-1500 CPUs, only references of data type 'DB_ANY' are permitted. When using GetSymbolForReference on a DB created at runtime with the 'CREATE_DB' instruction, an empty string is returned. Error codes and explanations include: 0x80C3 - maximum simultaneous instructions reached, 0x8231 - data block does not exist or too short, 0x8930 - symbol has zero pointer value.", "generated_brief": {"functional_summary": "The GetSymbolForReference instruction asynchronously retrieves the name of an indirectly addressed object based on its reference in a PLC program.", "usage_context": "It is used when you need to determine or display the symbolic name of a data object that is accessed via a reference, especially when handling dynamic or indirect addressing in S7-1500 CPU environments."}, "generated_keywords": ["get symbol from reference", "asynchronous symbol retrieval", "indirect addressing", "dynamic object name resolution", "PLC symbol extraction"]}
{"instruction_name": "Get_AlarmResources", "description": "You use the 'Get_AlarmResources' instruction to determine the number of alarms for which your CPU currently has sufficient memory.", "parameters": {"Input": [], "Output": [{"name": "RET_VAL", "type": "UINT", "description": "Number of currently available alarm instances. Note: This value can range from 0 to the maximum value in effect for your CPU type."}], "InOut": []}, "how_to_use": "", "example_code": "", "additional_info": "The number determined is a snapshot and may have a different value a short time later.", "generated_brief": {"functional_summary": "The 'Get_AlarmResources' instruction returns the current number of available alarm instances that the CPU can handle based on its memory capacity.", "usage_context": "It is used in PLC programs to monitor and manage alarm capacity to ensure the system does not exceed the CPU's alarm memory limits."}, "generated_keywords": ["alarm resource monitoring", "available alarm instances", "CPU alarm memory", "alarm capacity check", "PLC alarm management"]}
{"instruction_name": "LGC_GADR", "description": "You use the 'LGC_GADR' instruction to determine the module slot belonging to a hardware identifier.", "parameters": {"Input": [{"name": "IOID", "type": "BYTE", "description": "Is not evaluated."}, {"name": "LADDR", "type": "HW_MODULE", "description": "Hardware identifier of the module."}], "Output": [{"name": "AREA", "type": "BYTE", "description": "The area ID indicates how the remaining output parameters are to be interpreted: 0: Central module; 2: PROFIBUS DP."}, {"name": "RACK", "type": "WORD", "description": "Rack number based on the area ID."}, {"name": "SLOT", "type": "WORD", "description": "Slot number based on the area ID."}, {"name": "SUBADDR", "type": "WORD", "description": "Is not output (always '0')."}], "InOut": []}, "how_to_use": "", "example_code": "", "additional_info": "The 'LGC_GADR' instruction cannot be used for modules behind gateways (e.g., IE/PB link). Use the 'LOG2GEO' instruction instead.", "generated_brief": {"functional_summary": "The LGC_GADR instruction determines the module's rack and slot number based on its hardware identifier within a specified area.", "usage_context": "It is used in PLC systems to map hardware modules to their physical locations, except for modules behind gateways where LOG2GEO should be used."}, "generated_keywords": ["module slot identification", "hardware identifier mapping", "rack and slot determination", "PLC module addressing", "exclude gateway modules"]}
{"instruction_name": "LOG2GEO", "description": "You use the \"LOG2GEO\" instruction to determine the module slot belonging to a hardware identifier.", "parameters": {"Input": [{"name": "LADDR", "type": "HW_ANY", "description": "Hardware identifier of the module whose slot you want to find. The hardware ID is assigned automatically and is stored in the hardware configuration and the system constants."}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Output of error information."}], "InOut": [{"name": "GEOADDR", "type": "VARIANT", "description": "Pointer to the GEOADDR system data type. The slot information is written in the system data type GEOADDR."}]}, "how_to_use": "To use the LOG2GEO instruction, provide the hardware identifier of the desired module in the LADDR input parameter. The instruction will output the slot information in GEOADDR and return an error code in RET_VAL. Ensure that GEOADDR is correctly typed as the system data type GEOADDR. This instruction accesses hardware configuration and system constants automatically. Check RET_VAL for error codes such as 0 (no error) and 8090 (invalid LADDR).", "example_code": "(* Global data block tags *)\nladdr : HW_ANY; (* hardware ID input *)\nreturnValue : INT;  (* error output *)\ngeoAddr : VARIANT;   (* slot information in GEOADDR format *)\n\n(* In network, when execute condition is TRUE *)\nIF execute THEN\n    LOG2GEO(\n        LADDR := laddr,\n        RET_VAL => returnValue,\n        GEOADDR := geoAddr\n    );\nEND_IF;", "additional_info": "Error codes for RET_VAL include 0 meaning no error and 8090 indicating the LADDR address is invalid. The error codes are shown as integers or hexadecimal in the editor; display format can be switched. GEOADDR must be defined with the system data type GEOADDR. The instruction uses system constants and hardware configuration to resolve slot info.", "generated_brief": {"functional_summary": "The LOG2GEO instruction determines the physical slot address of a hardware module based on its hardware identifier.", "usage_context": "It is used in PLC programs to map hardware IDs to their corresponding module slots for configuration and diagnostic purposes."}, "generated_keywords": ["hardware identifier to slot mapping", "module slot determination", "LOG2GEO instruction", "PLC hardware configuration", "error code handling"]}
{"instruction_name": "LOG_GEO", "description": "You use the \"LOG_GEO\" instruction to determine the module slot belonging to a hardware identifier.", "parameters": {"Input": [{"name": "LADDR", "type": "HW_IO", "description": "Hardware identifier of the module for which the slot is to be determined."}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Error information."}, {"name": "AREA", "type": "INT", "description": "The area ID indicates how the remaining output parameters are to be interpreted (0: central device, 2: PROFIBUS DP / PROFINET IO)."}, {"name": "MASTER", "type": "INT", "description": "With AREA = 0: 0 if the slot is located in one of the racks (central device); With AREA = 2: 1 to 32 is DP master system ID or 100 to 115 is PROFINET IO system ID."}, {"name": "STATION", "type": "INT", "description": "With MASTER = 0: Number of the rack; With MASTER > 0: Station number of the field device."}, {"name": "SLOT", "type": "INT", "description": "Slot number."}, {"name": "SUBSLOT", "type": "INT", "description": "Number of the submodule."}, {"name": "OFFSET", "type": "INT", "description": "The OFFSET parameter is not output by the instruction (always \"0\")."}], "InOut": []}, "how_to_use": "", "example_code": "", "additional_info": "", "generated_brief": {"functional_summary": "The LOG_GEO instruction identifies the physical location details such as slot, subslot, and station of a hardware module based on its hardware identifier.", "usage_context": "It is typically used in industrial automation systems to map hardware modules to their physical slots for configuration, diagnostics, or maintenance purposes."}, "generated_keywords": ["module slot identification", "hardware module location", "slot and subslot mapping", "field device positioning", "industrial automation diagnostics"]}
{"instruction_name": "ATH", "description": "You use the instruction \"ATH\" to convert the ASCII character string specified at the IN input parameter into a hexadecimal number. The result of the conversion is output to the OUT output parameter. You can reference various data types using the pointer at the IN parameter (ASCII): STRING, WSTRING, CHAR, BYTE, Array of CHAR, Array of BYTE, WCHAR, Array of WCHAR, Array of WORD. For the OUT parameter (hexadecimal), you can reference: Array of CHAR, Array of BYTE, Array of WORD, STRING, BYTE, CHAR, WORD, INT, DWORD, DINT, SINT, USINT, UINT, UDINT, and additionally with S7-1500: Array of WCHAR, WSTRING, WCHAR, ULINT, LINT, LWORD. You specify the number of ASCII characters to be converted with the N parameter, with maximum of 32767 valid ASCII characters. Only digits \"0\" to \"9\", upper case letters \"A\" to \"F\", and lower case letters \"a\" to \"f\" can be interpreted; other characters convert to zeros. Since ASCII characters require 8 bits and hexadecimal digits 4 bits, the output word length is half the input word length. If there is an odd number of ASCII characters, the hexadecimal number is padded with zeros in the nibble to the right of the last converted hexadecimal number.", "parameters": {"Input": [{"name": "IN", "type": "VARIANT", "description": "Pointer to ASCII character string"}, {"name": "N", "type": "INT", "description": "Number of ASCII characters to be converted"}], "Output": [{"name": "OUT", "type": "VARIANT", "description": "Hexadecimal number"}], "InOut": []}, "how_to_use": "Initialize the IN parameter to point to the ASCII string to be converted. Set N to the number of ASCII characters you want to convert (up to 32767). ATH will convert the ASCII characters to a hexadecimal number and output it at OUT. If the number of ASCII characters is odd, the output is padded with zeros. Check the RET_VAL parameter to determine the status or errors after conversion.", "example_code": "VAR\n  asciiStr : STRING := '0a23';\n  hexOut : WORD;\n  ret : WORD;\nEND_VAR\n\nret := ATH(IN:=asciiStr, N:=4, OUT:=hexOut);", "additional_info": "RET_VAL can return codes such as 0007 for invalid character, 8182 for input buffer too small, 8120 for invalid IN format, and others. Only valid hex characters (0-9, A-F, a-f) are converted; others convert to zeros. Valid data types for IN and OUT must be respected as described. On S7-1500, additional data types for OUT are supported.", "generated_brief": {"functional_summary": "The ATH instruction converts an ASCII string representing hexadecimal digits into its corresponding hexadecimal number output.", "usage_context": "It is typically used in PLC programs to interpret ASCII-encoded hexadecimal data for processing or communication with devices requiring numeric hexadecimal formats."}, "generated_keywords": ["ASCII to hexadecimal conversion", "string to hex number", "hexadecimal parsing", "data type conversion", "PLC ASCII processing"]}
{"instruction_name": "ATTACH", "description": "You use the instruction 'ATTACH' to assign an organization block (OB) to a hardware interrupt event.", "parameters": {"Input": [{"name": "OB_NR", "type": "OB_ATT", "description": "Organization block (numbers up to 32767 are supported.)"}, {"name": "EVENT", "type": "EVENT_ATT", "description": "Hardware interrupt event to be assigned to the OB. The hardware interrupt event must first be enabled in the hardware device configuration for inputs or high-speed counters."}, {"name": "ADD", "type": "BOOL", "description": "Effects on previous assignments: ADD=0 (default): This event replaces all previous event assignments for this OB. ADD=1: This event is added to the previous event assignments for this OB."}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Status of the instruction"}], "InOut": []}, "how_to_use": "To assign a hardware interrupt OB to a hardware interrupt event, specify the event in the EVENT parameter and the organization block in the OB_NR parameter. Use the ADD parameter to control whether to replace previous assignments.", "example_code": "When the normally open contact ('start') supplies the signal state 'TRUE', the 'ATTACH' instruction is executed.", "additional_info": "The output parameter RET_VAL indicates the status of the instruction; error codes can be referenced for specific statuses.", "generated_brief": {"functional_summary": "The ATTACH instruction assigns a specific organization block (OB) to a hardware interrupt event, optionally adding to or replacing previous assignments.", "usage_context": "This instruction is used in PLC programs to link hardware interrupt events to corresponding OBs for handling hardware interrupts in industrial control systems."}, "generated_keywords": ["assign organization block", "hardware interrupt event", "OB to interrupt mapping", "event assignment control", "interrupt handling"]}
{"instruction_name": "ATTR_DB", "description": "You use the instruction \"ATTR_DB\" to obtain information about a data block (DB) located in the work memory of the CPU. The instruction determines the attributes set at the ATTRIB parameter for the DB selected. The length cannot be read out for data blocks with optimized access and data blocks that are only in load memory. In these cases, the DB_LENGTH parameter has the value \"0\". Do not apply ATTR_DB to data blocks with optimized access and activated memory reserve. Do not read out the data blocks for Motion Control with the \"ATTR_DB\" instruction. The error code 80B2 is output for this.", "parameters": {"Input": [{"name": "REQ", "type": "BOOL", "description": "REQ = 1: Request to read block attributes"}, {"name": "DB_NUMBER", "type": "DB_ANY", "description": "Number of the DB to be tested"}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Error information"}, {"name": "DB_LENGTH", "type": "UDINT", "description": "Number of data bytes which the selected DB contains. \"0\" for data blocks with optimized access and data blocks that are only in load memory."}, {"name": "ATTRIB", "type": "BYTE", "description": "DB properties:\n- Bit 0*= 0: Attribute \"Only store in load memory\" is not set.\n- Bit 0*= 1: Attribute \"Only store in load memory\" is set.\n- Bit 1 = 0: Attribute \"Data block write-protected in the device\" is not set.\n- Bit 1 = 1: Attribute \"Data block write-protected in the device\" is set.\n- If bit 0 = 1, then bit 2 is irrelevant and gets the value 1.\n- Bit 2 = 0: Retentive - The DB is regarded as retentive if at least one value has been set as retentive.\n- Bit 2 = 1: Not retentive - The complete DB is not retentive.\n- Bit 3*= 0: The DB is either in the load memory (bit 0 = 1) or in the work memory (bit 0 = 0).\n- Bit 3*= 1: The DB is generated in both the load and the work memory.\n* The relationship between bit 0 and bit 3 is explained in the parameters of the instruction \"CREATE_DB: Create data block\"."}], "InOut": []}, "how_to_use": "Enable the input REQ with the value TRUE to request reading the attributes of a specific data block identified by DB_NUMBER. Avoid using ATTR_DB on data blocks with optimized access combined with memory reserve, or for Motion Control data blocks (returns error 80B2). Evaluate the output ATTRIB byte to understand DB properties like storage location, write protection, and retentiveness. DB_LENGTH returns the size in bytes or zero for optimized/load memory DBs. Monitor RET_VAL for error codes to ensure correct DB number and valid operation.", "example_code": "VAR\n  REQ: BOOL;\n  DB_NUMBER: DB_ANY;\n  RET_VAL: INT;\n  DB_LENGTH: UDINT;\n  ATTRIB: BYTE;\nEND_VAR\n\nREQ := TRUE;\nDB_NUMBER := <DB number to check>;\nATTR_DB(\n  REQ := REQ,\n  DB_NUMBER := DB_NUMBER,\n  RET_VAL => RET_VAL,\n  DB_LENGTH => DB_LENGTH,\n  ATTRIB => ATTRIB\n);", "additional_info": "The length cannot be read for data blocks with optimized access and data blocks only in load memory (DB_LENGTH = 0). Do not apply ATTR_DB to data blocks with optimized access and activated memory reserve. Reading data blocks for Motion Control technology objects causes error 80B2. Error codes in RET_VAL can be displayed in integer or hexadecimal format; refer to program status display format settings.", "generated_brief": {"functional_summary": "The ATTR_DB instruction reads and returns the attributes and size information of a specified data block (DB) in the CPU's work memory.", "usage_context": "It is typically used to verify DB properties such as storage location, write protection, and retentiveness before performing operations on the data block in PLC programs."}, "generated_keywords": ["read data block attributes", "DB properties query", "verify data block size", "detect write protection", "check retentiveness"]}
{"instruction_name": "DeviceStates", "description": "You use the instruction \"DeviceStates\" to query specific status information for all modules in an IO system, which means either for all IO devices in a PROFINET IO system or for all DP slaves in a DP master system. The Boolean value that is output indicates the modules to which the selected status applies. For example, read out which IO devices are currently disabled in a PROFINET IO system. Information is also displayed as to whether the status information to be read applies to at least one of the IO devices or DP slaves. The instruction can be called in a cyclic OB as well as in an interrupt OB (e.g. OB82 - diagnostic interrupt).", "parameters": {"Input": [{"name": "LADDR", "type": "HW_IOSYSTEM", "description": "Hardware identifier of the PROFINET IO or DP master system. You select the PROFINET IO or DP master system at the LADDR parameter by means of the hardware identifier, which is available either in the Network view of the properties of the IO or DP master system or in the PLC tag table in the listed system constants with the data type HW_IOSYSTEM."}, {"name": "MODE", "type": "UINT", "description": "Selection of status information to be read. You can read out one of the following status information items for the entire PROFINET IO or DP master system: 1: IO devices/DP slaves are configured; 2: IO devices/DP slaves are faulty; 3: IO devices/DP slaves are disabled; 4: IO devices/DP slaves exist; 5: IO devices/DP slaves for which a problem has occurred (maintenance demanded or recommended, not accessible, not available, error occurred)."}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Status of instruction. Possible error codes include: 0 (No error), 8091 (Hardware identifier of LADDR does not exist), 8092 (LADDR does not address a PROFINET IO or DP master system), 8093 (Invalid data type at STATE parameter), 80B1 (Instruction not supported by CPU), 80B2 (MODE parameter not supported by CPU), 8452 (Complete status information does not fit in tag configured in STATE parameter)."}], "InOut": [{"name": "STATE", "type": "VARIANT", "description": "Buffer for status of the IO devices or DP slaves. The status of the IO devices/DP slaves selected with MODE is output here. Bit 0 = 1: group display indicating that the bit n of at least one IO device/DP slave is set; bit n = 1: the status selected with MODE applies to that IO device/DP slave (with PROFINET IO system, bit n corresponds to the device number; with PROFIBUS DP system, bit n corresponds to the PROFIBUS address). Use BOOL to output group display bit only or Array of BOOL to output for all devices (1024 bits for PROFINET, 128 bits for DP master)."}]}, "how_to_use": "To use the DeviceStates instruction, configure the LADDR input parameter with the hardware identifier for the PROFINET IO or DP master system. Set the MODE input parameter to select the status information to read (e.g., which devices are faulty or disabled). Prepare the STATE parameter as a VARIANT variable of type BOOL or Array of BOOL to receive status bits. The instruction can be called cyclically or within an interrupt OB like OB82. Check RET_VAL to verify that the instruction executed without errors. Note that the STATE buffer size should accommodate all expected devices to avoid error 8452.", "example_code": "VAR\n  myLADDR: HW_IOSYSTEM;\n  myMODE: UINT := 4; // Checking for existing IO devices\n  mySTATE: ARRAY[0..1023] OF BOOL;\n  returnValue: INT;\nEND_VAR\n\n// Call in cyclic OB\nDeviceStates(myLADDR, myMODE, returnValue, mySTATE);", "additional_info": "The instruction must be supported by the CPU used. Errors should be checked through RET_VAL. When configuring the STATE parameter as Array of BOOL, length must accommodate the number of devices, e.g., 1024 bits for PROFINET IO systems or 128 bits for DP master systems. For field length validation, the CountOfElements instruction is called internally. Bit 0 in STATE indicates a group status that applies to at least one IO device or DP slave.", "generated_brief": {"functional_summary": "The DeviceStates instruction queries and returns the status information of all IO devices or DP slaves within a PROFINET IO or DP master system, indicating specific conditions such as faults, disablement, or existence.", "usage_context": "This function is typically used in cyclic or interrupt OBs to monitor the health and configuration status of IO devices in industrial automation networks for diagnostics and system management."}, "generated_keywords": ["IO system status query", "PROFINET IO diagnostics", "DP master device monitoring", "module status retrieval", "cyclic and interrupt OB usage"]}
{"instruction_name": "GETIO", "description": "You use the instruction \"GETIO\" to consistently read out all inputs of a submodule of a DP standard slave/PROFINET IO device. If there was no error during the data transmission, the data that has been read is entered in the destination area indicated by INPUTS.", "parameters": {"Input": [{"name": "ID", "type": "HW_SUBMODULE", "description": "Hardware ID of the submodule"}], "Output": [{"name": "STATUS", "type": "DWORD", "description": "Error information"}, {"name": "LEN", "type": "INT", "description": "Amount of data read in bytes"}], "InOut": [{"name": "INPUTS", "type": "VARIANT", "description": "Destination area for the read data. It must be at least as long as what you have configured for the selected submodule. We recommend that you only use the data type BYTE or ARRAY of BYTE."}]}, "how_to_use": "To use the GETIO instruction, ensure the ID corresponds to a valid hardware submodule and define a sufficient length for the INPUTS area based on the defined data configuration.", "example_code": "", "additional_info": "When reading from a DP standard slave with a modular configuration, you can only access data of one component/DP identifier at the configured start address.", "generated_brief": {"functional_summary": "The GETIO instruction reads all input data from a specific hardware submodule of a DP standard slave or PROFINET IO device and stores it in a designated memory area if no transmission errors occur.", "usage_context": "It is used in industrial automation to consistently acquire input data from modular IO devices for processing within a PLC program."}, "generated_keywords": ["read submodule inputs", "DP standard slave IO", "PROFINET IO device", "input data acquisition", "hardware submodule read"]}
{"instruction_name": "HTA", "description": "You use the instruction 'HTA' to convert the hexadecimal number specified at the IN input into an ASCII character string. The result of the conversion is stored at the address specified in the OUT parameter.", "parameters": {"Input": [{"name": "IN", "type": "VARIANT", "description": "Start address of the hexadecimal digits"}, {"name": "N", "type": "UINT", "description": "Number of hexadecimal bytes to be converted"}], "Output": [{"name": "OUT", "type": "VARIANT", "description": "Address at which the result is stored."}, {"name": "RET_VAL", "type": "WORD", "description": "Error message"}], "InOut": []}, "how_to_use": "Specify the hexadecimal number at the IN parameter and the number of bytes to convert using N. The result will be written to the OUT parameter as an ASCII character string.", "example_code": "", "additional_info": "A maximum of 32767 characters are written to the ASCII character string. If the complete result of the conversion cannot be displayed in the OUT parameter, the result will only be partially written. If the address range for the result is greater than the result of the conversion, only the resulting ASCII string is written to the OUT parameter; an initialization of OUT does not take place.", "generated_brief": {"functional_summary": "The HTA instruction converts a specified hexadecimal number into its equivalent ASCII character string and stores the result at a given memory address.", "usage_context": "This function is typically used in industrial PLC programs when hexadecimal data needs to be represented or processed as readable ASCII text, such as for communication or data logging purposes."}, "generated_keywords": ["hexadecimal to ASCII conversion", "hex to ASCII string", "data format conversion", "PLC string processing", "memory address output"]}
{"instruction_name": "RDREC", "description": "You use the instruction \"RDREC\" to read the data record with the number INDEX from the module addressed using the ID. This can be a module in a central rack or a distributed module (PROFIBUS DP or PROFINET IO).", "parameters": {"Input": [{"name": "REQ", "type": "BOOL", "description": "REQ = 1: Transfer data record"}, {"name": "ID", "type": "HW_IO", "description": "Hardware identifier of the hardware module (DP/PROFINET IO). The number is assigned automatically and is stored in the properties of the module or of the interface in the hardware configuration."}, {"name": "INDEX", "type": "DINT", "description": "Data record number"}, {"name": "MLEN", "type": "UINT", "description": "Maximum length in bytes of the data record information to be read"}], "Output": [{"name": "VALID", "type": "BOOL", "description": "New data record was received and is valid."}, {"name": "BUSY", "type": "BOOL", "description": "BUSY = 1: The reading process is not yet complete."}, {"name": "ERROR", "type": "BOOL", "description": "ERROR = 1: An error occurred during the reading process."}, {"name": "STATUS", "type": "DWORD", "description": "Block status or error information"}, {"name": "LEN", "type": "UINT", "description": "Length of the read data record information"}], "InOut": [{"name": "RECORD", "type": "VARIANT", "description": "Target range for the data record read. If you are using the NREF system data type for the target range in a data block with optimized access, no values are written to the target range."}]}, "how_to_use": "\"RDREC\" is an asynchronous instruction that starts transferring the data record from the specified module when called with REQ = 1. The transfer progresses over multiple calls, with BUSY indicating the reading process status. When BUSY is FALSE, the transfer is complete. Use the VALID output to verify successful transfer, and check ERROR and STATUS for error handling. MLEN specifies the number of bytes to read; if set to 0, the full data record is transferred into RECORD.", "example_code": "", "additional_info": "The interface of the \"RDREC\" instruction is identical to the 'RDREC' FB defined in the standard \"PROFIBUS and PROFINET Guideline Communication Function Blocks on PROFIBUS DP and PROFINET IO\". When called in the SYNCUP system state of an S7-1500-R/H system, error codes 0x7001 and 0x7002 are returned until SYNCUP finishes; RDREC should be called cyclically in this state. If reading PROFINET IO data records, negative values in INDEX, MLEN, and LEN are interpreted as unsigned 16-bit integers.", "generated_brief": {"functional_summary": "The RDREC instruction asynchronously reads a specified data record from a hardware module by and managing the transfer process through input and output signals.", "usage_context": "It is used in industrial automation to retrieve configuration or diagnostic data from central or distributed modules in PROFIBUS DP or PROFINET IO networks during cyclic operation."}, "generated_keywords": ["read data record", "asynchronous data transfer", "PROFIBUS DP module", "PROFINET IO module", "hardware module communication"]}
{"instruction_name": "T_CONV", "description": "You use the instruction \"T_CONV\" to convert the data type of the IN input parameter to the data type that is output at the OUT output. You select the data formats for the conversion from the instruction boxes of the input and output.", "parameters": {"Input": [{"name": "IN", "type": "Integers, TIME, date and time*", "description": "Value to be converted; can be I, Q, M, D, L, P or constant; supported data types depend on the CPU"}], "Output": [{"name": "OUT", "type": "Integers, TIME, date and time*", "description": "Result of the conversion; can be I, Q, M, D, L, P"}], "InOut": []}, "how_to_use": "Create tags with the data types you want to convert between. Use the T_CONV instruction to convert the input value to the desired output type by selecting the appropriate data types in the input and output parameter fields of the instruction. If the input and output data types are the same, the instruction copies the input value to the output.", "example_code": "", "additional_info": "The range of supported data types depends on the CPU. Refer to the documentation for valid data types supported by S7-1200 and S7-1500 modules.", "generated_brief": {"functional_summary": "The T_CONV instruction converts a value from one data type to another within supported integer, TIME, and date/time formats.", "usage_context": "It is typically used in PLC programs to ensure data compatibility by converting between different data types needed for processing or output."}, "generated_keywords": ["data type conversion", "T_CONV instruction", "PLC data format", "input output conversion", "type compatibility"]}
{"instruction_name": "WR_DPARM", "description": "You use the instruction \"WR_DPARM\" to transfer the data record with the number RECNUM from the configuration data to the addressed module. The data record can be static or dynamic.", "parameters": {"Input": [{"name": "REQ", "type": "BOOL", "description": "REQ = 1: Write request"}, {"name": "LADDR", "type": "HW_IO", "description": "Hardware identifier of the assembly or the module (e.g. input module). The number is automatically assigned."}, {"name": "RECNUM", "type": "BYTE", "description": "Data record number"}], "Output": [{"name": "BUSY", "type": "BOOL", "description": "BUSY = 1: The writing process is not yet complete."}], "InOut": [{"name": "RET_VAL", "type": "INT", "description": "If an error occurs while the instruction is being executed, the return value contains an error code."}]}, "how_to_use": "Set REQ to TRUE (1) to start the write request of the data record specified by RECNUM to the module addressed by LADDR. Monitor BUSY to check if the writing process is ongoing (BUSY=1) or complete (BUSY=0). RET_VAL will indicate success (0000) or an error code for troubleshooting. It is important to refer to the module's product manual for valid data record numbers and structures.", "example_code": "", "additional_info": "Common RET_VAL error codes include 0000 (no error), 7001 (transfer triggered), and 80A1 (module defective or unplugged). Refer to the product manual and error code documentation for detailed troubleshooting. REQ should be reset to 0 to complete the write cycle. This instruction is typically used with distributed I/O modules. Ensure correct LADDR addressing and valid RECNUM. If errors frequently occur, check electrical interference and installation integrity.", "generated_brief": {"functional_summary": "The WR_DPARM instruction writes a specified data record from the configuration to the addressed hardware module in a PLC system.", "usage_context": "It is used when transferring or updating configuration data to distributed I/O modules during system setup or maintenance."}, "generated_keywords": ["write data record", "distributed I/O module", "configuration transfer", "data record number", "module addressing"]}
{"instruction_name": "WR_DPARM", "description": "You use the instruction \"WR_DPARM\" to transfer the data record with the number RECNUM from the configuration data to the addressed module. The data record can be static or dynamic.", "parameters": {"Input": [{"name": "REQ", "type": "BOOL", "description": "REQ = 1: Write request"}, {"name": "LADDR", "type": "HW_IO", "description": "Hardware identifier of the assembly or the module (e.g. input module). The number is automatically assigned."}, {"name": "RECNUM", "type": "BYTE", "description": "Data record number"}], "Output": [{"name": "BUSY", "type": "BOOL", "description": "BUSY = 1: The writing process is not yet complete."}], "InOut": []}, "how_to_use": "To use WR_DPARM, set REQ to 1 to initiate a write request transferring the specified data record RECNUM to the module addressed by LADDR. Monitor BUSY; it remains 1 while the operation is ongoing and returns to 0 once complete. Check RET_VAL to identify any errors during execution.", "example_code": "", "additional_info": "RET_VAL returns error codes indicating specific issues such as invalid addresses, module defects, or communication errors. Typical RET_VAL codes include 0000 for no error, 7001 for transfer triggered, 8093 for invalid LADDR, and various others related to module and DP protocol errors. For detailed error handling, refer to the product manual and handle RET_VAL accordingly.", "generated_brief": {"functional_summary": "The WR_DPARM instruction transfers a specified data record from configuration data to a designated hardware module identified by its address.", "usage_context": "It is used in industrial automation systems to update module parameters dynamically or statically during operation by initiating a write request and monitoring the process completion."}, "generated_keywords": ["data record transfer", "module parameter update", "write request", "hardware module addressing", "operation monitoring"]}
{"instruction_name": "RD_DPAR", "description": "You use the instruction to read the data record with the number INDEX of the addressed component from the configured system data. This may be a module in a central rack or a distributed component (PROFIBUS DP or PROFINET IO). The value TRUE for the output parameter VALID indicates that the data record was successfully transferred to the target range RECORD. In this case, the LEN output parameter contains the length of the read data in bytes. If an error has occurred during transfer of the data record, this is indicated by the output parameter ERROR. In this case, the output parameter STATUS contains the error information. The \"RD_DPAR\" instruction works asynchronously, that is, its execution extends over multiple calls. You start the data record transfer by calling \"RD_DPAR\" with REQ = 1. The output parameter BUSY and bytes 2 and 3 of the output parameter STATUS show the status of the job. Bytes 2 and 3 of STATUS match the output parameter RET_VAL of the instructions that operate asynchronously. The transfer of the data record is complete when the output parameter BUSY has the value FALSE.", "parameters": {"Input": [{"name": "REQ", "type": "BOOL", "description": "REQ = 1: Read request"}, {"name": "LADDR", "type": "HW_IO", "description": "Hardware identifier of the assembly or the module (e.g. input module). The number is automatically assigned."}, {"name": "INDEX", "type": "INT", "description": "Data record number"}], "Output": [{"name": "VALID", "type": "BOOL", "description": "New data record was received and is valid"}, {"name": "BUSY", "type": "BOOL", "description": "BUSY = 1: The job is not yet complete."}, {"name": "ERROR", "type": "BOOL", "description": "ERROR = 1: An error occurred during reading process."}, {"name": "STATUS", "type": "DWORD", "description": "Call ID (bytes 2 and 3) or error code. Byte 1: B#16#00, if no error. Otherwise function ID from DPV1-PDU: In the case of error for data record reading B#16#DE, in the case of error for data record writing B#16#DF. If no DPV1 protocol element is used: B#16#C0. Byte 4: Manufacturer-specific error ID extension."}, {"name": "LEN", "type": "INT", "description": "Length of the read data record information"}], "InOut": [{"name": "RECORD", "type": "VARIANT", "description": "Target range for the read data record"}]}, "how_to_use": "Call the RD_DPAR instruction with REQ set to TRUE to start the asynchronous read operation of the data record identified by INDEX from the addressed module specified byADDR. Monitor the BUSY output to determine when the operation is complete. When BUSY is FALSE, check VALID to confirm successful reading. If ERROR is TRUE, check STATUS for error details. The data record read is received in RECORD and LEN gives the length of data read. Use multiple calls to complete the asynchronous operation. Consider that STATUS bytes 2 and 3 represent the job status during the operation.", "example_code": "(* Example snippet reading data record number 128 from a module *)\nVAR\n  req : BOOL := TRUE;\n  laddr : HW_IO; (* hardware identifier assigned from module properties *)\n  index : INT := 128;\n  record : VARIANT;\n  valid : BOOL;\n  busy : BOOL;\n  error : BOOL;\n  status : DWORD;\n  len : INT;\nEND_VAR\n\nRD_DPAR(\n  REQ := req,\n  LADDR := laddr,\n  INDEX := index,\n  RECORD := record,\n  VALID => valid,\n  BUSY => busy,\n  ERROR => error,\n  STATUS => status,\n  LEN => len\n);\n\n(* Monitor busy and valid flags to handle completion and errors *)", "additional_info": "Refer to the product manual of the relevant module for information on valid data record numbers and their structure. The instruction is asynchronous and the operation status is indicated by the BUSY and STATUS outputs. Error codes can represent various issues including invalid LADDR, incorrect data record length, or module not supporting the data record. The data block structure for RECORD must match the expected format. For further details see related instructions like RD_DPARM and documentation on switching display formats for error codes.", "generated_brief": {"functional_summary": "The RD_DPAR instruction asynchronously reads a specific data record identified by INDEX from a hardware module and provides status, validity, and error information about the transfer.", "usage_context": "It is used in industrial PLC programs to retrieve configuration or status data from modules in a central rack or distributed field devices like PROFIBUS DP or PROFINET IO components."}, "generated_keywords": ["asynchronous data record read", "module data retrieval", "PROFIBUS DP PROFINET IO", "read data validity check", "PLC module status monitoring"]}
{"instruction_name": "RD_DPAR", "description": "You use the instruction to read the data record with the number INDEX of the addressed component from the configured system data. This may be a module in a central rack or a distributed component (PROFIBUS DP or PROFINET IO). The value TRUE for the output parameter VALID indicates that the data record was successfully transferred to the target range RECORD. In this case, the LEN output parameter contains the length of the read data in bytes. If an error has occurred during transfer of the data record, this is indicated by the output parameter ERROR. In this case, the output parameter STATUS contains the error information.", "parameters": {"Input": [{"name": "REQ", "type": "BOOL", "description": "REQ = 1: Read request"}, {"name": "LADDR", "type": "HW_IO", "description": "Hardware identifier of the assembly or the module (e.g. input module). The number is automatically assigned."}, {"name": "INDEX", "type": "INT", "description": "Data record number"}], "Output": [{"name": "VALID", "type": "BOOL", "description": "New data record was received and is valid"}, {"name": "BUSY", "type": "BOOL", "description": "BUSY = 1: The job is not yet complete."}, {"name": "ERROR", "type": "BOOL", "description": "ERROR = 1: An error occurred during the reading process."}, {"name": "STATUS", "type": "DWORD", "description": "Call ID (bytes 2 and 3) or error code. Byte 1: B#16#00 if no error; otherwise function ID from DPV1-PDU. Byte 4: Manufacturer-specific error ID extension."}, {"name": "LEN", "type": "INT", "description": "Length of the read data record information"}], "InOut": [{"name": "RECORD", "type": "VARIANT", "description": "Target range for the read data record"}]}, "how_to_use": "The RD_DPAR instruction works asynchronously, i.e. over multiple calls. Start the data record transfer by setting REQ = 1. During processing BUSY is TRUE and VALID is FALSE. When BUSY returns FALSE and VALID is TRUE, the data record has been successfully read into RECORD. Check ERROR and STATUS for error handling.", "example_code": "(* Example: Read data record 128 from an input module *)\nVAR\n    req : BOOL := TRUE;\n    laddr : HW_IO := '<hardware_id>'; (* Hardware address of module *)\n    index : INT := 128; (* Data record number to read *)\n    record : VARIANT; (* Target data record buffer *)\n    valid : BOOL;\n    busy : BOOL;\n    error : BOOL;\n    status : DWORD;\n    len : INT;\nEND_VAR\n\nRD_DPAR(\n    REQ := req,\n    LADDR := laddr,\n    INDEX := index,\n    RECORD := record,\n    VALID => valid,\n    BUSY => busy,\n    ERROR => error,\n    STATUS => status,\n    LEN => len\n);", "additional_info": "The STATUS parameter's bytes 2 and 3 match the RET_VAL of asynchronous instructions. The instruction requires valid hardware ID (LADDR) and data record number (INDEX). Refer to the relevant module's product manual for data record numbers and structure. The transfer is complete when BUSY is FALSE. Error codes provide diagnostic info, e.g. 8093 means invalid L.", "generated_brief": {"functional_summary": "The RD_DPAR instruction asynchronously reads a specified data record from a hardware module or distributed component into a target buffer, providing status and error information.", "usage_context": "This function is typically used in industrial control systems to retrieve configuration or diagnostic data from modules in a central rack or distributed fieldbus devices like PROFIBUS DP or PROFINET IO."}, "generated_keywords": ["asynchronous data read", "hardware module data access", "PROFIBUS DP data retrieval", "PROFINET IO status monitoring", "error handling for data transfer"]}
{"instruction_name": "RD_DPARA", "description": "You use the instruction to read the data record with the number RECNUM of a selected module from the configured system data. The read data record is entered in the target range defined by the parameter RECORD.", "parameters": {"Input": [{"name": "REQ", "type": "BOOL", "description": "REQ = 1: Read request"}, {"name": "LADDR", "type": "HW_IO", "description": "Hardware identifier of the assembly or the module (e.g. input module). The number is automatically assigned."}, {"name": "RECNUM", "type": "BYTE", "description": "Data record number"}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "If an error occurs while the instruction is being executed, the return value contains an error code. If no error occurred during the transmission, the return value distinguishes based on the length of the read data record."}, {"name": "BUSY", "type": "BOOL", "description": "BUSY = 1: The job is not yet complete."}, {"name": "RECORD", "type": "VARIANT", "description": "Target range for the data record read."}], "InOut": []}, "how_to_use": "You start the reading process by calling the instruction with REQ = 1. Ensure that the hardware is configured correctly and the data record number is valid.", "example_code": "", "additional_info": "Refer to the product manual for the relevant module for information on the data record numbers and the data record structure.", "generated_brief": {"functional_summary": "The RD_DPARA instruction reads a specific data record from a configured module in the PLC hardware and stores it in a target location.", "usage_context": "It is used when accessing module-specific configuration or system data records during PLC operation to retrieve detailed module information."}, "generated_keywords": ["read data record", "module configuration", "system data access", "hardware module", "data record retrieval"]}
{"instruction_name": "RD_DPARA", "description": "You use the instruction to read the data record with the number RECNUM of a selected module from the configured system data. The read data record is entered in the target range defined by the parameter RECORD.", "parameters": {"Input": [{"name": "REQ", "type": "BOOL", "description": "REQ = 1: Read request"}, {"": "LADDR", "type": "HW_IO", "description": "Hardware identifier of the assembly or the module (e.g. input module). The number is automatically assigned."}, {"name": "RECNUM", "type": "BYTE", "description": "Data record number"}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "If an error occurs while the instruction is being executed, the return value contains an error code. If no error occurred during the transmission, the following cases are distinguished: RET_VAL contains the length of the actually read data record in bytes if the target range is larger than the read data record. RET_VAL contains '0' if the length of the read data record is equal to the length of the target range."}, {"name": "BUSY", "type": "BOOL", "description": "BUSY = 1: The job is not yet complete."}, {"name": "RECORD", "type": "VARIANT", "description": "Target range for the data record read."}], "InOut": []}, "how_to_use": "You start the reading process by calling the instruction with REQ = 1.", "example_code": "", "additional_info": "The 'RD_DPARA' instruction works asynchronously, that is, its execution extends over multiple calls. The output parameters RET_VAL and BUSY indicate the status of the job.", "generated_brief": {"functional_summary": "The RD_DPARA instruction asynchronously reads a specified data record from a selected hardware module into a designated target range within the system data.", "usage_context": "It is used when accessing configuration or status data stored in modules of an automated system, especially when data retrieval requires handling asynchronous execution and error status."}, "generated_keywords": ["asynchronous data read", "module data record", "hardware module access", "read request", "error status handling"]}
{"instruction_name": "UPDAT_PO", "description": "You use the instruction to transfer the signal states of a process image partition of the outputs defined by configuration to the output modules. If you have specified a consistency range for the selected process image partition, corresponding data is transferred as consistent data to the respective I/O module.", "parameters": {"Input": [{"name": "PART", "type": "PIP", "description": "Number of the process image partition of the outputs to be transferred. Maximum value range (depending on the CPU): 1 <= n <= 31 (means process image partition n). Memory area: I, Q, M, D, L or constant."}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Error information. Memory area: I, Q, M, D, L, P."}, {"name": "FLADDR", "type": "WORD", "description": "Address of the first byte to cause an error if an access error has occurred. Memory area: I, Q, M, D, L, P."}], "InOut": []}, "how_to_use": "Specify the process image partition number in the PART input parameter to update the outputs defined by configuration. Call UPDAT_PO to transfer the corresponding output data to the output modules. Monitor the RET_VAL output parameter for error information and FLADDR for the address in case of access errors. Do not update outputs assigned to a process image partition simultaneously with the SYNC_PO instruction. The OB 1 process image of the outputs and process image partitions assigned to interrupt OBs are transferred by the system independently of UPDAT_PO calls.", "example_code": "VAR\n  part: PIP := 1; // Process image partition number\n  returnValue: INT;\n  errAddress: WORD;\n  updateOk: BOOL;\nEND_VAR\n\n// Update process image partition 1\nUPDAT_PO(\n    PART := part,\n    RET_VAL => returnValue,\n    FLADDR => errAddress\n);\n\nupdateOk := (returnValue = 0);", "additional_info": "Error codes returned by RET_VAL are displayed as integer or hexadecimal values in the program editor. Error codes include: 0000 (no error), 8090 (illegal PART value), 8091 (partition not defined), 8092 (partition updated by system and cannot be used), 8093 (partition update processed in another OB), 80A0 (I/O access error). For process image partitions of DP standard slaves, additional error codes from DPWR_DAT may occur if consistency areas > 32 bytes are defined.", "generated_brief": {"functional_summary": "UPDAT_PO transfers the output signal states of a specified process image partition to the configured output modules, ensuring data consistency as defined.", "usage_context": "It is used in PLC programs to explicitly update outputs for a given process image partition while monitoring for transfer errors during industrial control operations."}, "generated_keywords": ["process image partition output transfer", "update outputs", "error monitoring", "output module data consistency", "PLC output synchronization"]}
{"instruction_name": "T_ADD", "description": "You use this instruction to add the time information in the IN1 input to the time information in the IN2 input. You can query the result in the OUT output parameter. This instruction supports addition of a time period to another time period or a time.", "parameters": {"Input": [{"name": "IN1", "type": "TIME, DTL, TOD", "description": "First number to be added. It can be a TIME data type or DTL/TOD data types, depending on the context."}, {"name": "IN2", "type": "TIME", "description": "Second number to be added. This parameter must be specified in TIME format."}], "Output": [{"name": "OUT", "type": "DINT, DWORD, TIME, TOD, UDINT, DTL", "description": "Result of addition. The data type selection depends on the data types selected for the IN1 and IN2 input parameters."}]}, "how_to_use": "To use this instruction, connect the IN1 and IN2 inputs with the appropriate data types and retrieve the result from the OUT output parameter.", "example_code": "VAR\n  timeValTOD : TOD;\n  timeValTIME : TIME;\n  valueTimeResult : TOD;\nEND_VAR\nvalueTimeResult := T_ADD(IN1 := timeValTIME, IN2 := timeValTOD);", "additional_info": "Be aware of potential overflow/underflow during calculations. Check the enable output ENO to detect such conditions.", "generated_brief": {"functional_summary": "T_ADD adds two time-related values, such as TIME, DTL, or TOD types, and outputs their combined result in an appropriate data type.", "usage_context": "This function is typically used in industrial automation to calculate combined durations or timestamps by summing different time periods or time values."}, "generated_keywords": ["time addition", "time period sum", "TIME DTL TOD addition", "time value calculation", "overflow detection"]}
{"instruction_name": "DETACH", "description": "You use this instruction to cancel the existing assignment of an organization block to one or more hardware interrupt events during runtime. You enter the symbolic or numeric name of the organization block in the OB_NR parameter. This assignment to the event specified in the EVENT parameter will be canceled. If you have selected an individual hardware interrupt event at the EVENT parameter, the assignment of the OB to this hardware interrupt event is cancelled while all other currently existing assignments remain active. If you have not selected a hardware interrupt event, all the events currently assigned to this OB_NR organization block are separated.", "parameters": {"Input": [{"name": "OB_NR", "type": "OB_ATT", "description": "Organization block (numbers up to 32767 are supported.)"}, {"name": "EVENT", "type": "EVENT_ATT", "description": "Hardware interrupt event"}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Status of the instruction"}], "InOut": []}, "how_to_use": "During runtime, use the DETACH instruction to cancel an existing assignment of an organization block (OB) to one or more hardware interrupt events. Specify the OB in OB_NR and optionally specify the hardware interrupt event in EVENT. If EVENT is omitted, all event assignments for the specified OB are cancelled. Check the RET_VAL output parameter for the status of the instruction to confirm if the operation was successful or if any errors occurred.", "example_code": "\n// Example of DETACH usage in SCL for hardware interrupt OB41\n// Assuming OB41 and hardware interrupt event have been configured\nVAR\n    obNbr : OB_ATT := 41;         // OB number to detach\n    event : EVENT_ATT;            // Hardware interrupt event\n    retValDet : INT;              // Return value for status\nEND_VAR\n\n// Detach a specific hardware interrupt event from OB41\nretValDet := DETACH(OB_NR := obNbr, EVENT := event);\n\n// Detach all hardware interrupt events from OB41\nretValDet := DETACH(OB_NR := obNbr);", "additional_info": "RET_VAL error codes:\n0 - No error\n1 - No assignment exists (warning)\n8090 - OB does not exist\n8091 - OB has incorrect type\n8093 - Event does not exist\n\nError codes may be shown as integer or hexadecimal values in the program editor.", "generated_brief": {"functional_summary": "The DETACH instruction cancels the assignment of an organization block (OB) to one or more hardware interrupt events during runtime.", "usage_context": "It is used when you need to dynamically remove OB associations from hardware interrupt events in a PLC program while the system is running."}, "generated_keywords": ["cancel OB assignment", "detach hardware interrupt event", "runtime OB event removal", "hardware interrupt management", "OB event disassociation"]}
{"instruction_name": "S_CONV", "description": "You use this instruction to convert the value at the IN input to the data format you have specified in the OUT output. You decide the output format of the conversion by selecting a data type for the OUT output parameter. The following conversions are possible: Conversion of a string, Conversion of a numerical value or character to a string, Conversion of a character to a character.", "parameters": {"Input": [{"name": "IN", "type": "STRING, WSTRING, CHAR, WCHAR, USINT, UINT, UDINT, ULINT, SINT, INT, DINT, LINT, REAL, LREAL", "description": "Value to be converted"}], "Output": [{"name": "OUT", "type": "CHAR, WCHAR, USINT, UINT, UDINT, ULINT, SINT, INT, DINT, LINT, REAL, LREAL, STRING, WSTRING", "description": "Result of the conversion"}], "InOut": []}, "how_to_use": "Select the data type of the input value and the desired output data type by configuring the IN input and OUT output parameters respectively. Use this instruction to convert strings to numeric values or characters, numeric values or characters to strings, and characters to characters. Be aware that for floating-point number conversions to strings, exponential notation is not supported by S_CONV; use STRG_VAL instead for that case.", "example_code": "VAR\n  inputValueNBR : INT := 123;\n  resultSTRING : STRING(10);\nEND_VAR\n\nresultSTRING := S_CONV(IN := inputValueNBR);", "additional_info": "When converting a string to a numeric value, permitted characters include digits '0' to '9', decimal point, plus and minus signs. Leading spaces and exponential notations are ignored. When converting numeric values to strings, the first bytes of the string indicate maximum and actual length. Numeric values are output without signs except in SCL where strings show a leading sign. Padding with spaces occurs in Ladder and FBD but not in SCL. For floating-point numbers with exponential notation, use STRG_VAL instead of S_CONV.", "generated_brief": {"functional_summary": "The S_CONV instruction converts a value from one data type to another, such as between strings, numeric types, and characters, based on the configured input and output data types.", "usage_context": "It is typically used in PLC programs to transform data formats for processing, display, or communication where type compatibility is required, especially for simple conversions excluding floating-point exponential notation."}, "generated_keywords": ["data type conversion", "string to numeric", "numeric to string", "character conversion", "PLC data formatting"]}
{"instruction_name": "RIGHT", "description": "You use this instruction to extract the last L character in a character string in the input parameter IN. You specify the number of characters to be extracted in the L parameter. The extracted characters are output at the OUT output parameter in (W)STRING format.", "parameters": {"Input": [{"name": "IN", "type": "STRING, WSTRING", "description": "Character string"}, {"name": "L", "type": "BYTE, INT, SINT, USINT", "description": "Number of characters to be extracted"}], "Output": [{"name": "OUT", "type": "STRING, WSTRING", "description": "Extracted partial string"}], "InOut": []}, "how_to_use": "Initialize the instruction by setting the IN and L parameters. The OUT parameter will automatically receive the extracted string based on the value of L.", "example_code": "VAR\n inputSTRING : STRING;\n outputExtractSTRING : STRING;\n extractNumber : INT;\nEND_VAR\n\nextractNumber := 4;\noutputExtractSTRING := RIGHT(inputSTRING, extractNumber);", "additional_info": "If the number of characters to be extracted is greater than the current length of the character string, the OUT output parameter returns the input character string as a result. If L is 0 or the input is an empty string, an empty string will be returned. If L is negative, an empty string will be output.", "generated_brief": {"functional_summary": "The RIGHT instruction extracts the last L characters from a given input string and outputs this substring.", "usage_context": "It is typically used in PLC programs to retrieve specific trailing portions of text data for processing or display in industrial automation systems."}, "generated_keywords": ["extract last characters", "string manipulation", "substring extraction", "PLC string function", "retrieve trailing text"]}
{"instruction_name": "RD_SYS_T", "description": "You use this instruction to read the current date and current time-of-day (module time) of the CPU clock.", "parameters": {"Input": [], "Output": [{"name": "OUT", "type": "DTL", "description": "Date and time of CPU"}], "InOut": [{"name": "RET_VAL", "type": "INT", "description": "Status of the instruction"}]}, "how_to_use": "Interconnect the parameters of the instruction as follows. Select the DATE AND TIME data type.", "example_code": "Create two tags in a global data block for storing the data. The module time of the CPU clock is read out and displayed at output parameter OUT (\"outputTIME\"). The output parameter RET_VAL (\"returnValue\") indicates that processing took place without errors.", "additional_info": "The CPU clock interprets the module time as the coordinated universal time (UTC). The provided value does not include information about the local time zone or daylight saving time.", "generated_brief": {"functional_summary": "The RD_SYS_T instruction reads the current date and time from the CPU's internal clock in UTC format.", "usage_context": "It is typically used in PLC programs when accurate system timestamping or synchronization with the CPU time is required."}, "generated_keywords": ["read CPU date and time", "system clock access", "UTC timestamp retrieval", "PLC time synchronization", "module time reading"]}
{"instruction_name": "RD_LOC_T", "description": "You use this instruction to read the current local time from the CPU clock and output this at the OUT output. Information on the time zone and the start of daylight saving time and standard time, which you have set in the configuration of the CPU clock, is used to output the local time.", "parameters": {"Input": [], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Status of the instruction"}, {"name": "OUT", "type": "DTL", "description": "Local time"}], "InOut": []}, "how_to_use": "Create two tags in a global data block for storing the data. The OUT parameter outputs the current local time from the CPU clock, taking into account the time zone and daylight saving time settings. The RET_VAL parameter returns the status of the instruction to indicate success or specific error conditions. Use data types DT, LDT, or DTL for OUT but note DT and DTL cannot be used in input, output and bit memory areas.", "example_code": "VAR\n  outputLocTIME : DATE_AND_TIME;\n  returnValue : INT;\nEND_VAR\n\n// Call the instruction\nRD_LOC_T(\n  RET_VAL := returnValue,\n  OUT := outputLocTIME\n);", "additional_info": "Error codes for RET_VAL include 0000 (No error), 0001 (No error, local time is output as daylight saving time), 8080 (Local time cannot be read), and 8081 (Current local time is outside permissible range for the selected OUT data type). Valid ranges depend on the selected data type (DT, LDT, DTL). See relevant documentation for switching display formats for error codes.", "generated_brief": {"functional_summary": "The RD_LOC_T instruction reads the current local time from the CPU clock, considering configured time zone and daylight saving settings, and outputs it along with a status code.", "usage_context": "It is typically used in PLC programs to obtain and work with the local time for time-stamping, scheduling, or synchronization tasks within industrial control systems."}, "generated_keywords": ["read local time", "CPU clock time", "daylight saving time", "time zone adjustment", "status code output"]}
{"instruction_name": "FIND", "description": "You use this instruction to search through the character string at the IN1 input parameter for a specific character string. You specify the value to be searched for in the IN2 input parameter. The search is made from left to right. The position of the first occurrence is output in the OUT output parameter. If the search returns no match, the value \"0\" will be output in the OUT output parameter. If an invalid character is specified at the IN2 parameter or if an error occurs during processing, the value \"0\" is output at the OUT parameter.", "parameters": {"Input": [{"name": "IN1", "type": "STRING, WSTRING", "description": "String searched through"}, {"name": "IN2", "type": "STRING, WSTRING", "description": "Character string that is searched for"}], "Output": [{"name": "OUT", "type": "INT", "description": "Character position"}], "InOut": []}, "how_to_use": "To use the FIND instruction, provide the string to be searched on IN1 and the string to search for on IN2. The instruction searches from left to right for the first occurrence of the IN2 string within IN1 and outputs the position in OUT. If no match occurs or an invalid character is in IN2, OUT will be 0.", "example_code": "VAR\n  inputSTRING : STRING;\n  STRINGsearchedFor : STRING;\n  returnPosition : INT;\nEND_VAR\n\n// Example usage\ninputSTRING := 'Example4aString';\nSTRINGsearchedFor := '4a';\nreturnPosition := FIND(IN1 := inputSTRING, IN2 := STRINGsearchedFor);", "additional_info": "Valid data types are STRING and WSTRING for inputs IN1 and IN2. The OUT parameter returns an INT representing the position of the first match or 0 if none is found or in case of error.", "generated_brief": {"functional_summary": "The FIND instruction searches for the first occurrence of a specified substring within a given string and returns its position or 0 if not found or invalid.", "usage_context": "It is typically used in PLC programs to locate specific text patterns within strings for conditional logic or data processing tasks."}, "generated_keywords": ["string search", "substring position", "find substring", "text pattern matching", "character string lookup"]}
{"instruction_name": "WR_SYS_T", "description": "You use this instruction to set the date and time-of-day (module time) of the CPU clock. Enter the date and time-of-day at the input parameter IN. The value must be in the following range: With DT: min. DT#1990-01-01-0:0:0, max. DT#2089-12-31-23:59:59.999; With LDT: min. LDT#1970-01-01-0:0:0.000000000, max. LDT#2200-12-31-23:59:59.999999999; With DTL: min. DTL#1970-01-01-00:00:00.0, max. DTL#2200-12-31-23:59:59.999999999. You can query whether errors have occurred during execution of the instruction in the RET_VAL output parameter. The \"WR_SYS_T\" instruction is not used to pass information about the local time zone or daylight saving time.", "parameters": {"Input": [{"name": "IN", "type": "DT, DTL, LDT", "description": "Date and time input at which the CPU clock module time is set. Must be within specific minimum and maximum ranges depending on the type."}], "Output": [{"name": "RET_VAL", "type": "INT", "description": "Status of the instruction execution. Indicates whether errors occurred during the setting of date and time."}], "InOut": []}, "how_to_use": "Set the date and time-of-day of the CPU clock by providing a valid date-time value at the IN parameter within the allowed ranges. Monitor the RET_VAL output parameter to check for errors during execution. This instruction sets the module time in UTC; it does not handle local time zones or daylight saving time.", "example_code": "(* Example to set CPU clock date and time using WR_SYS_T with DATE AND TIME type *)\nVAR\n  inputTIME : DATE_AND_TIME;\n  returnValueT : INT;\n  execute : BOOL;\nEND_VAR\n\nIF execute THEN\n  WR_SYS_T(IN := inputTIME, RET_VAL => returnValueT);\nEND_IF;", "additional_info": "The CPU clock module time is always interpreted as coordinated universal time (UTC) without local time zone or daylight saving time. Error codes are returned via RET_VAL, indicating specific issues with date or time values, such as invalid month, day, or nanosecond. Data types and DTL cannot be used with input, output, or bit memory areas. When using DT, milliseconds are not transferred to the CPU.", "generated_brief": {"functional_summary": "The WR_SYS_T instruction sets the CPU clock's date and time to a specified value in UTC within defined valid ranges.", "usage_context": "It is used in PLC programs when synchronizing or updating the system time of the CPU clock without considering local time zones or daylight saving adjustments."}, "generated_keywords": ["set CPU clock time", "synchronize system time", "UTC date and time input", "monitor execution errors", "PLC time setting instruction"]}
{"instruction_name": "T_DIFF", "description": "You use this instruction to subtract the time information in the IN2 input parameter from the time information in the IN1 input parameter. The result is sent at output parameter OUT. If the time information at the IN2 input parameter is greater than the time information at the IN1 input parameter, the result is output as a negative at the OUT output parameter. If the result of the subtraction is outside the TIME number range, the enable output ENO is = \"0\". Depending on the data types used, you get either a truncated result or \"0\" (0:00). If you select the minuend and subtrahend parameters of the DTL data type, the result has the TIME data type. It may not be greater than 24 days, otherwise the enable output ENO = \"0\" and the result is \"0\". If you select the minuend and subtrahend parameters of the LDT data type, this restriction is avoided.", "parameters": {"Input": [{"name": "IN1", "type": "DTL, DATE, TOD", "description": "Minuend"}, {"name": "IN2", "type": "DTL, DATE, TOD", "description": "Subtrahend"}], "Output": [{"name": "OUT", "type": "TIME, INT", "description": "Difference of input parameters"}], "InOut": []}, "how_to_use": "Use the T_DIFF instruction to subtract two time values, where IN1 is the minuend and IN2 is the subtrahend. The difference appears at the OUT output. When using the DTL data type for inputs, the result is TIME and must not exceed 24 days. If you need to use an INT for the output in SCL, extend the instruction name to T_DIFF_INT to change the OUT parameter type accordingly.", "example_code": "(* Calculate difference between two TOD values *)\nVAR\n  todvalue1 : TOD;\n  todvalue2 : TOD;\n  timevalueDIFF : TIME;\nEND_VAR\n\n// Subtract todvalue2 from todvalue1\nT_DIFF(\n  IN1 := todvalue1,\n  IN2 := todvalue2,\n  OUT := timevalueDIFF\n);", "additional_info": "If the subtraction result exceeds the TIME range, ENO is set to 0 and the result is either truncated or zero. Using LDT as input types avoids the 24-day limitation. The instruction supports inputs as constants or from memory areas I, Q, M, D, L or P.", "generated_brief": {"functional_summary": "The T_DIFF instruction subtracts one time value (IN2) from another (IN1) and outputs the time difference, handling various time data types with range and sign considerations.", "usage_context": "It is typically used in industrial automation to calculate elapsed time or time intervals between two timestamps for control and monitoring processes."}, "generated_keywords": ["time difference calculation", "subtract time values", "time interval measurement", "time data type handling", "elapsed time computation"]}
{"instruction_name": "T_SUB", "description": "You use this instruction to subtract the time information in the IN2 input parameter from the time information in the IN1 input parameter. You can query the difference at the OUT output parameter. You can subtract the following formats: subtraction of a time period from another time period (e.g. TIME - TIME resulting in TIME), and subtraction of a time period from a time (e.g. DTL - TIME resulting in DTL). You decide the formats of the values in the IN1 input parameter and the OUT output parameter by selecting the data types for the input and output parameters of the instruction. Note: Overflow/underflow conditions may occur during calculation and can be detected by evaluating the enable output ENO.", "parameters": {"Input": [{"name": "IN1", "type": "TIME", "description": "Minuend. Memory area: I, Q, M, D, L, P or constant. For the subtraction of a time period from another time period."}, {"name": "IN2", "type": "TIME", "description": "Subtrahend. Memory area: I, Q, M, D, L, P or constant. For the subtraction of a time period from another time period."}, {"name": "IN1", "type": "DTL, TOD", "description": "Minuend. Memory area: I, Q, M, D, L, P or constant. For the subtraction of a time period from a time. For LTIME at IN2, only LTOD, LDT or DTL are used."}, {"name": "IN2", "type": "TIME", "description": "Subtrahend. Memory area: I, Q, M, D, L, P or constant. For the subtraction of a time period from a time."}], "Output": [{"name": "OUT", "type": "DINT, DWORD, TIME, TOD, UDINT", "description": "Result of subtraction. Memory area: I, Q, M, D, L, P. For subtraction of a time period from another time period."}, {"name": "OUT", "type": "DTL, DINT, DWORD, TIME, TOD, UDINT", "description": "Result of subtraction. Memory area: I, Q, M, D, L, P. For subtraction of a time period from a time."}], "InOut": []}, "how_to_use": "Select the data types of the input parameters (IN1 and IN2) corresponding to the type of time values you want to subtract (either time periods or time values). Connect IN1 to the minuend and IN2 to the subtrahend. The result appears at the OUT output parameter in the data type you specify. Monitor the enable output ENO to detect overflow or underflow during the operation.", "example_code": "VAR\n  value1TOD : TOD; // Time of day\n  value2Time : TIME; // Time period\n  value1MINvalue2 : TOD; // Result of subtraction\nEND_VAR\n\n// Subtract time period from time of day\nvalue1MINvalue2 := T_SUB(value1TOD, value2Time);", "additional_info": "When subtracting, take care that overflow or underflow may occur if the result exceeds the largest or smallest possible values. Use the ENO output to detect this condition. The data types of the inputs and output must be compatible according to the supported conversions. For LTIME inputs in IN2, only LTOD, LDT or DTL are valid for IN1.", "generated_brief": {"functional_summary": "The T_SUB instruction subtracts one time value or time period from another, returning the difference in a specified time-related data type.", "usage_context": "It is used in PLC programs to calculate time intervals or adjust time values by subtracting durations, commonly for time-based control and sequencing tasks."}, "generated_keywords": ["time subtraction", "time period difference", "time value calculation", "overflow detection", "PLC time arithmetic"]}
