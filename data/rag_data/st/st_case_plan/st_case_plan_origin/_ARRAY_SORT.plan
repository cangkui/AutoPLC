{"variables": [], "instructions": [], "planning": "- 概述\n这段代码实现了一个名为 `_ARRAY_SORT` 的函数，用于对实数数组进行排序。它使用了 **快速排序（QuickSort）** 的非递归版本，通过显式维护一个栈来模拟递归过程。快速排序的核心思想是通过选择一个“基准值”（pivot），将数组分为两部分，一部分小于基准值，另一部分大于基准值，然后递归地对这两部分进行排序。该函数通过栈来管理待排序的子数组范围，从而避免了递归调用。\n\n- 变量定义\n代码中定义了以下几类变量：\n - **输入变量**：`PT` 是指向实数数组的指针，`SIZE` 是数组的大小。\n - **内部变量**：包括栈计数器 `stack_count`、栈 `stack`、子数组的起始和结束索引 `links` 和 `rechts`、基准值 `pivot`、两个循环变量 `i` 和 `j`、两个标志变量 `ende_innen` 和 `ende_aussen` 用于控制循环，以及一个临时变量 `tmp` 用于交换数组元素。\n\n- 主逻辑部分\n-- REGION 初始化\n    - 将 `links` 初始化为 1，表示数组的起始索引。\n    - 将 `rechts` 初始化为 `SHR(size, 2)`，即数组大小右移 2 位（相当于除以 4），表示数组的结束索引。\n    - 将 `stack_count` 初始化为 1，表示栈的当前深度。\n    - 将 `ende_aussen` 初始化为 `FALSE`，表示外部循环未结束。\n\n-- REGION 外部循环（WHILE NOT ende_aussen）\n    外部循环用于处理待排序的子数组范围。循环的核心逻辑如下：\n    - 如果 `links < rechts`，表示当前子数组范围有效，执行以下操作：\n        1. 选择基准值 `pivot`，通常是子数组的中间元素（`PT^[SHR(rechts+links,1)]`）。\n        2. 初始化 `i` 和 `j`，分别指向子数组的起始和结束位置。\n        3. 进入内部循环（REPEAT...UNTIL ende_innen），通过移动 `i` 和 `j` 来找到需要交换的元素。\n        4. 如果 `i >= j`，表示子数组已经分割完成，退出内部循环。\n        5. 否则，交换 `PT^[i]` 和 `PT^[j]` 的值。\n        6. 将当前子数组的结束索引 `rechts` 压入栈中。\n        7. 如果栈未满（`stack_count < 32`），增加栈深度；否则，结束外部循环并返回 `FALSE` 表示排序失败。\n        8. 更新 `rechts` 为 `MAX(links, i-1)`，继续处理左半部分。\n    - 如果 `links >= rechts`，表示当前子数组范围无效，执行以下操作：\n        1. 如果栈深度为 1，结束外部循环。\n        2. 否则，从栈中弹出上一个子数组的结束索引，更新 `links` 和 `rechts`，继续处理右半部分。\n\n-- REGION 结束逻辑\n    - 如果外部循环正常结束，返回 `TRUE` 表示排序成功。\n\n- 总结\n该函数通过非递归的方式实现了快速排序算法，使用栈来管理待排序的子数组范围。它能够高效地对实数数组进行排序，但由于栈的大小限制（32），如果数组过大或递归深度过深，可能会导致栈溢出并返回 `FALSE`。因此，该函数适用于中等大小的数组排序。", "name": "_ARRAY_SORT"}