{"variables": [], "instructions": [], "planning": "- 概述\n该功能块 `FT_Profile` 实现了一个基于时间曲线的值生成器。它根据输入的时间点和对应的值，生成一个随时间变化的输出值 `Y`。功能块还支持缩放因子 `K` 和偏移量 `O`，并可以监控运行状态和经过的时间。\n\n- 变量定义\n代码中定义了以下几类变量：\n - 输入变量：缩放因子 `K`、偏移量 `O`、时间缩放因子 `M`、使能信号 `E`、初始值 `value_0` 和多个时间点及其对应的值（如 `time_1` 和 `value_1` 等）。\n - 输出变量：当前输出值 `Y`、运行状态 `RUN`、经过的时间 `ET`。\n - 内部变量：当前时间 `tx`、使能信号的上升沿检测 `edge`、状态机状态 `state`、时间点 `ta` 和 `tb`、初始时间 `t0`、临时值 `temp`、当前段起始值 `va` 和结束值 `vb`。\n\n- - 主逻辑部分\n-- REGION 初始化与使能检测\n   - 首先，获取当前时间 `tx`，并将其转换为 `TIME` 类型。这是通过调用 `T_PLC_MS()` 函数获取当前毫秒数，再通过 `DWORD_TO_TIME` 转换为 `TIME` 类型。\n   - 如果使能信号 `E` 为真且检测到上升沿（即 `E` 从假变为真），则初始化功能块：\n     - 设置运行状态 `RUN` 为真，表示功能块开始运行。\n     - 重置经过的时间 `ET` 为 0，表示计时开始。\n     - 记录初始时间 `t0` 和当前时间 `ta`，用于后续计算经过的时间。\n     - 计算第一个时间段的长度 `tb`，使用 `multime` 函数将输入的时间 `time_1` 乘以缩放因子 `M`。\n     - 设置当前段的起始值 `va` 为 `value_0`，结束值 `vb` 为 `value_1`。\n     - 设置临时值 `temp` 为初始值 `value_0`，这是输出值 `Y` 的初始值。\n     - 将状态机状态 `state` 设置为 1，表示进入第一个时间段。\n   - 更新使能信号的上升沿检测 `edge`，用于下一次循环中检测 `E` 的上升沿。\n\n-- REGION 状态机与值计算\n   - 如果功能块处于运行状态 (`RUN` 为真)，则根据当前状态 `state` 执行相应的逻辑：\n     - **状态 1**：\n       - 检查当前时间 `tx` 是否超过了第一个时间段的结束时间 `tb`。\n       - 如果超过了，则更新 `ta` 为 `ta + tb`，表示进入下一个时间段。\n       - 计算下一个时间段的长度 `tb`，使用 `multime` 函数将 `time_2 - time_1` 乘以缩放因子 `M`。\n       - 更新当前段的起始值 `va` 为 `value_1`，结束值 `vb` 为 `value_2`。\n       - 设置临时值 `temp` 为 `value_1`。\n       - 将状态机状态 `state` 设置为 2，表示进入第二个时间段。\n       - 如果未超过，则根据当前时间 `tx` 计算临时值 `temp`，使用线性插值公式：`temp = ((vb - va) * TIME_TO_REAL(tx - ta) / TIME_TO_REAL(tb) + va)`。\n     - **状态 2**：\n       - 检查当前时间 `tx` 是否超过了第二个时间段的结束时间 `tb`。\n       - 如果超过了，则更新 `ta` 为 `ta + tb`。\n       - 计算下一个时间段的长度 `tb`，使用 `multime` 函数将 `time_3 - time_2` 乘以缩放因子 `M`。\n       - 更新当前段的起始值 `va` 为 `value_2`，结束值 `vb` 为 `value_3`。\n       - 设置临时值 `temp` 为 `value_2`。\n       - 将状态机状态 `state` 设置为 3，表示进入第三个时间段。\n       - 如果未超过，则计算临时值 `temp`，使用线性插值公式。\n     - **状态 3**：\n       - 检查当前时间 `tx` 是否超过了第三个时间段的结束时间 `tb`。\n       - 如果超过了，则更新 `ta` 为 `ta + tb`。\n       - 计算下一个时间段的长度 `tb`，使用 `multime` 函数将 `time_10 - time_3` 乘以缩放因子 `M`。\n       - 更新当前段的起始值 `va` 为 `value_3`，结束值 `vb` 为 `value_10`。\n       - 设置临时值 `temp` 为 `value_3`。\n       - 将状态机状态 `state` 设置为 4，表示进入第四个时间段。\n       - 如果未超过，则计算临时值 `temp`，使用线性插值公式。\n     - **状态 4**：\n       - 检查当前时间 `tx` 是否超过了第四个时间段的结束时间 `tb`。\n       - 如果超过了，则更新 `ta` 为 `ta + tb`。\n       - 计算下一个时间段的长度 `tb`，使用 `multime` 函数将 `time_11 - time_10` 乘以缩放因子 `M`。\n       - 更新当前段的起始值 `va` 为 `value_10`，结束值 `vb` 为 `value_11`。\n       - 设置临时值 `temp` 为 `value_10`。\n       - 根据使能信号 `E` 的状态决定是否切换到下一个状态：如果 `E` 为真，则进入状态 5；否则，进入状态 6。\n       - 如果未超过，则计算临时值 `temp`，使用线性插值公式。\n     - **状态 5**：\n       - 如果使能信号 `E` 为真，则更新 `ta` 为当前时间 `tx`，表示暂停计时。\n       - 如果 `E` 为假，则将状态机状态 `state` 设置为 6，表示继续运行。\n     - **状态 6**：\n       - 检查当前时间 `tx` 是否超过了第五个时间段的结束时间 `tb`。\n       - 如果超过了，则更新 `ta` 为 `ta + tb`。\n       - 计算下一个时间段的长度 `tb`，使用 `multime` 函数将 `time_12 - time_11` 乘以缩放因子 `M`。\n       - 更新当前段的起始值 `va` 为 `value_11`，结束值 `vb` 为 `value_12`。\n       - 设置临时值 `temp` 为 `value_11`。\n       - 将状态机状态 `state` 设置为 7，表示进入第六个时间段。\n       - 如果未超过，则计算临时值 `temp`，使用线性插值公式。\n     - **状态 7**：\n       - 检查当前时间 `tx` 是否超过了第六个时间段的结束时间 `tb`。\n       - 如果超过了，则更新 `ta` 为 `ta + tb`。\n       - 计算下一个时间段的长度 `tb`，使用 `multime` 函数将 `time_13 - time_12` 乘以缩放因子 `M`。\n       - 更新当前段的起始值 `va` 为 `value_12`，结束值 `vb` 为 `value_13`。\n       - 设置临时值 `temp` 为 `value_12`。\n       - 将状态机状态 `state` 设置为 8，表示进入最后一个时间段。\n       - 如果未超过，则计算临时值 `temp`，使用线性插值公式。\n     - **状态 8**：\n       - 检查当前时间 `tx` 是否超过了最后一个时间段的结束时间 `tb`。\n       - 如果超过了，则设置临时值 `temp` 为 `value_13`，表示曲线生成完成。\n       - 将运行状态 `RUN` 设置为假，表示功能块停止运行。\n       - 如果未超过，则计算临时值 `temp`，使用线性插值公式。\n   - 最终，将 `temp` 乘以缩放因子 `K` 并加上偏移量 `O`，得到输出值 `Y`，同时更新经过的时间 `ET` 为 `tx - t0`。", "name": "FT_Profile"}