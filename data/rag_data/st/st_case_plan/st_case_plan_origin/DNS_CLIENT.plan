{"variables": [], "instructions": [], "planning": "- 概述\n  这段代码定义了一个名为 `DNS_CLIENT` 的功能块，用于通过 DNS 协议解析域名并获取对应的 IP 地址。它通过状态机控制 DNS 查询的流程，包括发送 DNS 请求、接收响应、解析响应等步骤。该功能块支持输入域名和 DNS 服务器 IP 地址，并输出解析到的 IP 地址、完成标志和错误信息。\n\n- 变量定义\n  代码中定义了以下几类变量：\n  - 输入输出变量：`IP_C`（IP 控制结构）、`S_BUF`（发送缓冲区）、`R_BUF`（接收缓冲区）。\n  - 输入变量：`ACTIVATE`（激活标志）、`DOMAIN`（域名）、`IP4_DNS`（DNS 服务器 IP 地址）。\n  - 输出变量：`IP4`（解析到的 IP 地址）、`DONE`（完成标志）、`ERROR`（错误代码）。\n  - 内部变量：`IP_FIFO`（IP FIFO 结构）、`ip_state`（IP 状态）、`ip_id`（IP ID）、`i`（循环计数器）、`state`（状态机状态）、`domain_copy`（域名副本）、`activate_last`（上一个激活状态）、`url_length`（域名长度）、`char`（字符）、`char_count`（字符计数器）、`tid`（事务 ID）、`anc`（应答计数器）、`x`（临时字节）、`rr_stop`（资源记录停止标志）、`ttl_last`（最后 TTL 值）、`ttl_tmp`（临时 TTL 值）。\n\n- - 主逻辑部分\n  主逻辑部分通过状态机（`state` 变量）控制 DNS 查询的流程。以下是每个状态的详细处理逻辑：\n\n  -- **状态 00**：\n     - 检查 `ACTIVATE` 输入是否为真且上一个状态为假（`activate_last` 为假）。\n     - 如果条件满足，表示需要启动 DNS 查询，初始化 `DONE` 和 `ERROR` 为默认值（`FALSE` 和 `0`），并将状态跳转到 **状态 05**。\n     - 这是状态机的入口点，用于启动 DNS 查询流程。\n\n  -- **状态 05**：\n     - 尝试将输入的 `DOMAIN` 直接解码为 IP 地址（通过 `IP4_DECODE` 函数）。\n     - 如果解码成功（`IP4 > 0`），表示域名已经是有效的 IP 地址，无需进一步查询，直接设置 `DONE` 为 `TRUE`，并跳转回 **状态 00**。\n     - 如果解码失败，表示需要向 DNS 服务器发起查询，初始化 `ip_state` 为 1，`ttl_last` 为 0，并拷贝 `DOMAIN` 到 `domain_copy`，然后跳转到 **状态 10**。\n\n  -- **状态 10**：\n     - 检查 `ip_state` 是否为 3，表示 IP 层已经准备好发送 DNS 查询请求。\n     - 计算域名长度（`url_length`）并初始化发送缓冲区 `S_BUF`，填充 DNS 查询报文：\n       - 设置事务 ID（`tid`）并递增。\n       - 设置查询标志位（`BYTE#16#01` 表示标准查询）。\n       - 将域名转换为 DNS 报文格式（将域名中的每个部分长度和字符填充到缓冲区）。\n       - 设置查询类型（`BYTE#01` 表示 A 记录查询）和查询类（`BYTE#01` 表示 Internet 类）。\n     - 配置 IP 控制结构 `IP_C`：\n       - 设置目标端口为 53（DNS 服务端口）。\n       - 设置目标 IP 为 `IP4_DNS`（DNS 服务器 IP）。\n       - 启用 IP 层发送功能（`C_ENABLE := TRUE`）。\n     - 设置发送缓冲区大小并清空接收缓冲区，然后跳转到 **状态 30**。\n\n  -- **状态 30**：\n     - 检查 `IP_C.ERROR` 是否有错误。如果有错误，设置 `ERROR` 为错误代码，并跳转到 **状态 99**（错误处理状态）。\n     - 如果没有错误，检查是否接收到有效的 DNS 响应：\n       - 检查接收缓冲区 `R_BUF` 的事务 ID 是否与发送的 `tid` 匹配。\n       - 检查接收缓冲区大小是否足够（至少 34 字节加上域名长度）。\n     - 如果响应有效，解析 DNS 响应头中的错误代码（`R_BUF.BUFFER[3]` 的低 4 位）：\n       - 如果错误代码为 0（无错误），获取应答记录数（`anc`），并跳转到 **状态 40**。\n       - 如果有错误，跳转到 **状态 99**。\n\n  -- **状态 40**：\n     - 处理 DNS 响应中的资源记录（Resource Records）：\n       - 遍历接收缓冲区 `R_BUF`，跳过域名部分（通过检查字节值是否为 `BYTE#63` 或 `BYTE#0`）。\n       - 如果记录类型为 A 记录（`BYTE#1`）且类为 Internet 类（`BYTE#1`），解析记录的 TTL 值（`ttl_tmp`）和 IP 地址（`IP4`）。\n       - 如果当前记录的 TTL 值大于 `ttl_last`，更新 `ttl_last` 和 `IP4`。\n     - 如果所有应答记录处理完毕且 `IP4` 有效（`IP4 > 0`），设置 `DONE` 为 `TRUE`，表示查询成功。\n     - 如果 `IP4` 无效，设置 `ERROR` 为 255（表示未找到有效 IP 地址）。\n     - 跳转到 **状态 99**。\n\n  -- **状态 99**：\n     - 重置接收缓冲区大小（`R_BUF.SIZE := 0`），表示接收缓冲区已处理完毕。\n     - 设置 `ip_state` 为 4，表示 IP 层已完成当前操作。\n     - 跳转回 **状态 00**，等待下一次查询。\n\n  -- **其他逻辑**：\n     - **`activate_last` 更新**：在状态机之外，代码更新 `activate_last` 变量以记录上一个 `ACTIVATE` 状态，用于边缘检测。\n     - **`IP_FIFO` 调用**：调用 `IP_FIFO` 功能块处理 IP 层的状态和 ID，确保 IP 层正常工作。\n\n  -- **错误处理**：\n     - 如果在 **状态 30** 或 **状态 40** 中发生错误，代码会设置 `ERROR` 并跳转到 **状态 99**，进行错误处理和状态重置。\n\n  -- **循环控制**：\n     - 状态机通过 `state` 变量的跳转实现循环控制，确保每个状态按顺序执行，直到查询完成或发生错误。\n\n  -- **输出结果**：\n     - 如果查询成功，`IP4` 输出解析到的 IP 地址，`DONE` 输出 `TRUE`。\n     - 如果查询失败，`ERROR` 输出错误代码，`DONE` 保持 `FALSE`。", "name": "DNS_CLIENT"}