{"variables": [], "instructions": [], "planning": "- 概述\n此功能块 `LOG_MSG` 用于处理日志消息。它通过调用 `PRINT_SF` 实例将日志消息打印到输出，并根据条件将消息存储到日志缓冲区中。同时，它还处理日志缓冲区的更新和重置逻辑。\n\n- 变量定义\n代码中定义了两类变量：\n1. `FB_PRINT_SF`：`PRINT_SF` 功能块的实例，用于打印日志消息。\n2. `idX`：整型变量，用于存储当前日志消息的索引。\n\n- 主逻辑部分\n-- REGION 日志消息过滤\n首先，代码检查日志消息的优先级是否高于当前日志级别。通过将 `LOG_CL.NEW_MSG_OPTION` 左移 16 位并转换为字节，与 `LOG_CL.LEVEL` 进行比较。如果消息优先级低于或等于日志级别，则直接返回，不处理该消息。\n\n-- REGION 日志消息打印\n如果消息满足优先级条件，则调用 `FB_PRINT_SF` 实例，将日志消息打印到输出。`PRINTF_DATA` 参数传递 `LOG_CL.PRINTF`，`STR` 参数传递 `LOG_CL.NEW_MSG`。\n\n-- REGION 日志缓冲区重置\n如果 `LOG_CL.RESET` 为真，则重置日志缓冲区的状态。具体操作包括：\n1. 将 `LOG_CL.RESET` 设置为 `FALSE`，表示重置已完成。\n2. 将 `LOG_CL.RING_MODE` 设置为 `FALSE`，表示退出环形缓冲区模式。\n3. 将 `LOG_CL.IDX` 重置为 `0`，表示从缓冲区开头开始存储新消息。\n4. 将 `LOG_CL.UPDATE_COUNT` 增加 `1`，表示缓冲区更新次数加一。\n\n-- REGION 日志消息存储\n如果日志缓冲区的大小 `LOG_CL.SIZE` 大于 `0`，并且新消息 `LOG_CL.NEW_MSG` 的长度大于 `0`，则执行以下逻辑：\n1. 检查当前索引 `LOG_CL.IDX` 是否大于或等于缓冲区大小。如果是，表示缓冲区已满，进入环形缓冲区模式：\n   - 将 `LOG_CL.RING_MODE` 设置为 `TRUE`。\n   - 将 `LOG_CL.IDX` 重置为 `0`，从头开始覆盖旧消息。\n2. 更新日志缓冲区的状态：\n   - 将 `LOG_CL.UPDATE_COUNT` 增加 `1`，表示缓冲区更新次数加一。\n   - 将 `LOG_CL.IDX` 增加 `1`，指向下一个存储位置。\n   - 将 `idX` 设置为当前索引值。\n   - 将新消息 `LOG_CL.NEW_MSG` 存储到 `LOG_CL.MSG` 数组的当前索引位置。\n   - 将消息选项 `LOG_CL.NEW_MSG_OPTION` 存储到 `LOG_CL.MSG_OPTION` 数组的当前索引位置。\n   - 将 `LOG_CL.NEW_MSG` 清空，表示消息已处理完毕。", "name": "LOG_MSG"}