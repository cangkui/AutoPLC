{"variables": [], "instructions": [], "planning": "- 概述\n这段代码实现了一个循环缓冲区（Circular Buffer）的功能块，名为“UNI_CIRCULAR_BUFFER”。该功能块用于存储和管理不同类型的数据（如字符串、实数和双字），并支持数据的插入、读取和缓冲区管理。循环缓冲区是一种高效的数据结构，特别适用于需要频繁插入和删除数据的场景。\n\n- 变量定义\n代码中定义了以下几类变量：\n - 输入输出变量：DATA，包含缓冲区的数据和管理信息。\n - 临时变量：tmp_dw（双字临时变量）、pTmp（指向字节的指针）、n、n1、n2（用于循环和计算的整数）、x（字节临时变量）、buf_totalsize（缓冲区总大小）。\n - 常量：HeaderSize（头部大小，固定为4字节）。\n - 内部变量：cnt（计数）、mode_last（上一次的模式）。\n\n- - 主逻辑部分\n-- REGION 数据插入（模式1）\n   当DATA.D_MODE为1时，表示需要将数据插入到循环缓冲区中。以下是详细步骤：\n   1. **确定数据类型和大小**：首先，根据DATA.D_HEAD的值确定要插入的数据类型（字符串、实数或双字），并计算数据的大小（cnt）。具体逻辑如下：\n      - 如果DATA.D_HEAD的值为1，表示数据类型为字符串，cnt为字符串的长度。\n      - 如果DATA.D_HEAD的值为2，表示数据类型为实数，cnt为4（实数的字节大小）。\n      - 如果DATA.D_HEAD的值为3，表示数据类型为双字，cnt为4（双字的字节大小）。\n      - 如果DATA.D_HEAD的值不在上述范围内，cnt为0。\n   2. **检查缓冲区空间**：计算缓冲区的总大小（buf_totalsize），并检查是否有足够的空间来存储数据和头部信息（HeaderSize为4字节）。如果剩余空间不足，则增加数据丢失计数（DATA.BUF_DATA_LOST）并返回。\n   3. **更新数据大小和计数**：如果空间足够，则更新数据的大小（DATA.D_SIZE）和缓冲区中的数据计数（DATA.BUF_DATA_CNT）。\n   4. **写入头部信息**：将头部信息（包含数据类型和大小）写入缓冲区。具体步骤如下：\n      - 将DATA.D_HEAD和cnt组合成一个双字（tmp_dw）。\n      - 使用循环将tmp_dw的每个字节依次写入缓冲区，并更新写指针（DATA._Last）。如果写指针超过缓冲区总大小，则将其重置为0。\n   5. **写入数据**：将数据从pTmp指向的内存位置复制到缓冲区中，并更新写指针（DATA._Last）。如果写指针超过缓冲区总大小，则将其重置为0。\n   6. **更新缓冲区状态**：更新缓冲区的大小（DATA.BUF_SIZE）、数据计数（DATA.BUF_COUNT）和已用百分比（DATA.BUF_USED）。最后，重置DATA.D_MODE为0，表示插入操作完成。\n\n-- REGION 数据读取（模式10-12）\n   当DATA.D_MODE为10、11或12时，表示需要从循环缓冲区中读取数据。以下是详细步骤：\n   1. **检查缓冲区是否有数据**：如果缓冲区中没有数据（DATA.BUF_COUNT为0），则返回。\n   2. **读取头部信息**：从缓冲区中读取头部信息，确定数据类型和大小。具体步骤如下：\n      - 使用循环从缓冲区中读取4个字节，组合成一个双字（tmp_dw）。如果读指针（DATA._GetEnd）超过缓冲区总大小，则将其重置为0。\n      - 从tmp_dw中提取数据大小（cnt）和数据类型（DATA.D_HEAD）。\n   3. **确定数据输出位置**：根据DATA.D_HEAD的值，确定数据输出的位置（pTmp）。具体逻辑如下：\n      - 如果DATA.D_HEAD的值为1，表示数据类型为字符串，pTmp指向DATA.D_STRING。\n      - 如果DATA.D_HEAD的值为2，表示数据类型为实数，pTmp指向DATA.D_REAL。\n      - 如果DATA.D_HEAD的值为3，表示数据类型为双字，pTmp指向DATA.D_DWORD。\n   4. **读取数据**：将数据从缓冲区复制到pTmp指向的内存位置，并更新读指针（DATA._GetEnd）。如果读指针超过缓冲区总大小，则将其重置为0。\n   5. **处理字符串数据**：如果读取的是字符串，则在末尾添加一个空字符（0），表示字符串的结束。\n   6. **更新缓冲区状态**：根据读取模式（10、11或12）更新缓冲区的状态。具体逻辑如下：\n      - 如果模式为10且下一次模式为11，或者模式为12且下一次模式为0，则更新缓冲区的读指针（DATA._First）、大小（DATA.BUF_SIZE）、数据计数（DATA.BUF_COUNT）和已用百分比（DATA.BUF_USED）。最后，重置DATA.D_MODE为0，表示读取操作完成。\n\n-- REGION 缓冲区重置（模式99）\n   当DATA.D_MODE为99时，表示需要重置循环缓冲区。以下是详细步骤：\n   1. **重置指针和计数器**：将缓冲区的所有指针（DATA._First、DATA._Last、DATA._GetStart、DATA._GetEnd）和计数器（DATA.BUF_COUNT、DATA.BUF_SIZE、DATA.BUF_USED）重置为初始值。\n   2. **清空数据**：清空所有数据，包括字符串（DATA.D_STRING）、实数（DATA.D_REAL）、双字（DATA.D_DWORD）和头部信息（DATA.D_HEAD）。\n   3. **重置模式**：重置DATA.D_MODE为0，表示缓冲区已重置。\n\n-- REGION 更新最大使用率\n   在功能块的末尾，检查当前缓冲区的使用率（DATA.BUF_USED）是否超过最大使用率（DATA.BUF_USED_MAX）。如果是，则更新最大使用率。\n\n- 总结\n该功能块通过状态机的方式实现了循环缓冲区的数据插入、读取和重置功能。它支持多种数据类型，并能够动态管理缓冲区的大小和状态。循环缓冲区的设计使得数据的插入和读取操作非常高效，特别适用于需要频繁处理数据的场景。", "name": "UNI_CIRCULAR_BUFFER"}