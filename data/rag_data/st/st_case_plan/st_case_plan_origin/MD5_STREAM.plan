{"variables": [], "instructions": [], "planning": "- 概述\n这段代码实现了一个名为“MD5_STREAM”的功能块，用于计算输入数据的MD5哈希值。MD5是一种广泛使用的哈希算法，用于生成128位的哈希值。该功能块通过分块处理输入数据，并逐步更新哈希值，最终生成MD5哈希值。\n\n- 变量定义\n代码中定义了以下几类变量：\n - 输入输出变量：MODE（模式）、BUF（缓冲区）、MD5（哈希值）、SIZE（数据大小）、POS（当前位置）。\n - 内部变量：hash（哈希值的四个部分）、a, b, c, d（临时变量）、end（结束位置）、block（块计数）、x（数据块）、n, n1, z（循环计数器）、pad_1（填充标志）。\n\n- - 主逻辑部分\n-- REGION MODE 1：初始化\n   在模式1中，首先初始化MD5哈希值的四个部分（hash[0]到hash[3]），这些初始值分别是：\n   - hash[0] := DWORD#16#67452301;\n   - hash[1] := DWORD#16#EFCDAB89;\n   - hash[2] := DWORD#16#98BADCFE;\n   - hash[3] := DWORD#16#10325476;\n\n   接下来，计算需要处理的块数。块数的计算公式为：\n   ```plaintext\n   block := SHR(SIZE,6) + BOOL_TO_UDINT((UDINT_TO_BYTE(SIZE) AND 16#3F) > 55);\n   ```\n   这里，`SHR(SIZE,6)`将数据大小右移6位，相当于除以64，得到完整的块数。`BOOL_TO_UDINT((UDINT_TO_BYTE(SIZE) AND 16#3F) > 55)`用于判断最后一个块是否需要额外的填充块。如果数据大小的低6位（即`SIZE AND 16#3F`）大于55，则需要增加一个块来处理填充。\n\n   然后，初始化填充标志`pad_1`为FALSE，表示尚未进行填充。设置`POS`为0，表示从数据的起始位置开始处理。`End`变量被设置为数据的总大小`SIZE`，而`SIZE`被设置为当前块的大小（最大为64字节）。最后，将模式设置为2，进入数据处理阶段。\n\n-- REGION MODE 2：数据处理\n   在模式2中，首先将缓冲区`BUF`中未使用的部分填充为0。具体来说，从`SIZE`到63的位置被设置为0：\n   ```plaintext\n   FOR n := UDINT_TO_INT(SIZE) TO 63 DO\n       BUF[n] := 0;\n   END_FOR;\n   ```\n\n   如果数据大小小于64字节且尚未填充，则在缓冲区中添加填充字节（0x80）：\n   ```plaintext\n   IF SIZE < 64 AND NOT pad_1 THEN\n       BUF[SIZE] := 2#1000_0000;\n       pad_1 := TRUE;\n   END_IF;\n   ```\n\n   更新`POS`和`SIZE`变量以反映当前处理的位置：\n   ```plaintext\n   POS := POS + SIZE;\n   SIZE := MIN(64,End - POS);\n   ```\n\n   接下来，将缓冲区中的数据转换为32位字，并存储在数组`x`中。具体来说，每4个字节被转换为一个32位字：\n   ```plaintext\n   n := 0;\t\n   FOR n1 := 0 TO 15 DO\n       x[n1] := OSCAT_BASIC.DWORD_OF_BYTE(BUF[n+3],BUF[n+2],BUF[n+1],BUF[n]); \n       n := n + 4;\n   END_FOR;\n   ```\n\n   如果块计数`block`为0，则设置`x[14]`为数据大小的低32位，并将模式设置为3，进入哈希值计算阶段：\n   ```plaintext\n   IF block = 0 THEN \n       x[14] := SHL(UDINT_TO_DWORD(End),3); \n       MODE := 3;\n   ELSE\n       block := block - 1;\n   END_IF;\n   ```\n\n   接下来，初始化临时变量`a`, `b`, `c`, `d`为哈希值的四个部分：\n   ```plaintext\n   a := hash[0];\n   b := hash[1];\n   c := hash[2];\n   d := hash[3];\n   ```\n\n   然后，使用`MD5_AUX`函数进行四轮哈希计算。每轮计算使用不同的常数和位移量，逐步更新临时变量。具体来说，每轮计算包括16次操作，每次操作调用`MD5_AUX`函数，更新`a`, `b`, `c`, `d`的值。四轮计算分别对应MD5算法的四个阶段：\n   - 第一轮：使用常数16#D76AA478等。\n   - 第二轮：使用常数16#F61E2562等。\n   - 第三轮：使用常数16#FFFA3942等。\n   - 第四轮：使用常数16#F4292244等。\n\n   最后，将临时变量的值累加到哈希值的四个部分中：\n   ```plaintext\n   hash[0] := hash[0] + a;\n   hash[1] := hash[1] + b;\n   hash[2] := hash[2] + c;\n   hash[3] := hash[3] + d;\n   ```\n\n-- REGION MODE 3：哈希值输出\n   在模式3中，将哈希值的四个部分转换为字节数组，并存储在`MD5`数组中。具体来说，通过循环和位移操作，将每个32位哈希值转换为4个字节，并按顺序存储在`MD5`数组中：\n   ```plaintext\n   z := 0;\n   FOR n := 0 TO 3 DO \n       FOR n1 := 0 TO 3 DO\n           MD5[z] := DWORD_TO_BYTE(hash[n]);\n           hash[n] := ROR(hash[n],8);\n           z := z + 1;\n       END_FOR;\n   END_FOR;\n   ```\n\n   这个过程将哈希值的四个32位部分（`hash[0]`到`hash[3]`）转换为16个字节，存储在`MD5`数组中，最终生成128位的MD5哈希值。\n\n- 总结\n该功能块通过分块处理输入数据，并使用MD5算法逐步计算哈希值。最终，生成的128位哈希值存储在`MD5`数组中，供外部使用。", "name": "MD5_STREAM"}