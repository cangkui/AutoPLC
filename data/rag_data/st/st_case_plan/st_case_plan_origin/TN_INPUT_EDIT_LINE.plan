{"variables": [], "instructions": [], "planning": "- 概述\n  该功能块 `TN_INPUT_EDIT_LINE` 用于处理文本输入行的编辑操作，包括字符插入、删除、光标移动等。它还支持输入掩码、隐藏输入（如密码输入）以及文本显示的更新。该功能块通过操作输入控制数据（`Xus_TN_INPUT_CONTROL_DATA`）来实现这些功能，并将结果写入屏幕（`Xus_TN_SCREEN`）。\n\n- 变量定义\n  代码中定义了以下几类变量：\n  - 输入变量：`in_count`、`in_Count_End`、`in_CursorOffset` 等用于计数和光标位置控制。\n  - 控制数据变量：`Xus_TN_INPUT_CONTROL_DATA` 包含输入控制的相关信息，如光标位置、输入数据、输入掩码、属性等。\n  - 屏幕变量：`Xus_TN_SCREEN` 用于存储屏幕数据。\n  - 功能块实例：`FB_TN_SC_WRITE` 用于将文本写入屏幕。\n  - 临时变量：`st_CHAR`、`st_String` 等用于存储临时字符和字符串。\n\n- - 主逻辑部分\n  -- REGION 初始化\n     首先将 `in_CursorOffset` 初始化为 0。这个变量用于记录光标移动的偏移量。然后检查 `Xus_TN_INPUT_CONTROL_DATA.bo_Focus` 是否为真，表示当前输入行是否处于焦点状态。如果处于焦点状态，则继续处理输入操作。\n\n  -- REGION 字符输入处理\n     如果输入行处于焦点状态且有新的 ASCII 字符输入（`Xus_TN_INPUT_CONTROL_DATA.by_Input_ASCII_Code > 0`），则进一步检查是否允许输入该字符：\n     - 如果 `bo_Input_Only_Num` 为真且 `bo_Input_ASCII_IsNum` 为真，表示只允许输入数字，且当前输入的是数字。\n     - 如果 `bo_Input_Only_Num` 为假，表示允许输入任意字符。\n     如果允许输入，则将字符转换为字符串（`st_CHAR`），并使用 `REPLACE` 函数将其插入到输入数据的当前光标位置（`Xus_TN_INPUT_CONTROL_DATA.in_Cursor_Pos`）。然后设置 `in_CursorOffset` 为 1，表示光标向右移动一个位置。同时，标记需要更新输入显示（`Xus_TN_INPUT_CONTROL_DATA.bo_Update_Input = TRUE`）。\n\n  -- REGION 扩展键处理\n     根据 `Xus_TN_INPUT_CONTROL_DATA.by_Input_Exten_Code` 的值处理扩展键输入：\n     - 67（右箭头）：光标向右移动一个位置，设置 `in_CursorOffset` 为 1。\n     - 68（左箭头）：光标向左移动一个位置，设置 `in_CursorOffset` 为 -1。\n     - 08（退格键）：删除光标前的一个字符。使用 `REPLACE` 函数将光标位置的字符替换为空格，并将光标向左移动一个位置（`in_CursorOffset = -1`）。同时，标记需要更新输入显示。\n     - 13（回车键）：如果输入掩码（`st_Input_Mask`）存在（长度大于 0），则将当前输入数据保存到 `st_Input_String`，并去除首尾空格（使用 `TRIME` 函数）。然后标记输入完成（`bo_Input_Entered = TRUE`），并将输入数据重置为输入掩码。同时，将光标移动到输入掩码的第一个非空格字符处。如果第一个字符不是空格，则设置 `in_CursorOffset` 为 1，表示光标向右移动一个位置。\n\n  -- REGION 光标位置调整\n     根据 `in_CursorOffset` 的值调整光标位置：\n     - 如果 `in_CursorOffset > 0`，表示光标需要向右移动。从当前光标位置（`in_Cursor_Pos + 1`）开始，向右查找下一个空格字符。如果找到空格字符，则将光标移动到该位置，并标记需要更新输入显示。如果未找到，则光标位置不变。\n     - 如果 `in_CursorOffset < 0`，表示光标需要向左移动。从当前光标位置（`in_Cursor_Pos - 1`）开始，向左查找上一个空格字符。如果找到空格字符，则将光标移动到该位置，并标记需要更新输入显示。如果未找到，则光标位置不变。\n     如果光标位置超出输入数据的长度或小于 1，则将其调整到合法范围内：\n     - 如果光标位置大于输入数据的长度，则将其设置为输入数据的长度。\n     - 如果光标位置小于 1，则将其设置为 1。\n\n  -- REGION 更新输入显示\n     如果需要更新输入显示（`Xus_TN_INPUT_CONTROL_DATA.bo_Update_Input = TRUE`）或需要更新所有显示（`Xus_TN_INPUT_CONTROL_DATA.bo_Update_All = TRUE`），则执行以下操作：\n     - 如果 `bo_Update_All` 为真，则更新标题显示。标题的位置根据 `in_Title_X_Offset` 和 `in_Title_Y_Offset` 的值确定：\n       - 如果 `in_Title_X_Offset` 和 `in_Title_Y_Offset` 都为 0，则标题显示在输入行的左侧。\n       - 否则，标题显示在输入行的偏移位置。\n       使用 `FB_TN_SC_WRITE` 将标题字符串写入屏幕。\n     - 如果输入是隐藏的（`bo_Input_Hidden = TRUE`），则将输入数据中的非掩码字符替换为 `*`，以隐藏实际输入内容。具体操作如下：\n       - 如果输入数据的长度等于输入掩码的长度，则遍历输入数据：\n         - 如果掩码字符为空格，则检查输入数据中对应位置的字符是否为空格。如果是，则保留空格；否则，替换为 `*`。\n         - 如果掩码字符不为空格，则保留输入数据中的字符。\n     - 如果输入不是隐藏的，则直接使用输入数据显示。\n     - 根据输入行是否处于焦点状态，选择相应的属性（`by_Attr_mF` 或 `by_Attr_oF`）来显示输入数据。\n     - 使用 `FB_TN_SC_WRITE` 将输入数据写入屏幕，并更新光标的位置（`in_Cursor_Y` 和 `in_Cursor_X`）。\n     - 最后，重置 `bo_Update_All` 和 `bo_Update_Input` 为假，表示更新完成。", "name": "TN_INPUT_EDIT_LINE"}