{"variables": [], "instructions": [], "planning": "- 概述\n这段代码实现了一个名为 `TN_RECEIVE` 的功能块，用于处理从网络缓冲区接收到的数据，并将其解析为特定的输入代码或 ASCII 字符。解析后的结果存储在 `Xus_TN_SCREEN` 结构中，用于后续处理或显示。\n\n- 变量定义\n代码中定义了以下几类变量：\n - 输入输出变量：`R_BUF`（网络缓冲区）和 `Xus_TN_SCREEN`（用于存储解析后的输入信息）。\n - 内部变量：`REQ_Size`（用于存储接收到的数据大小）和 `REQ1`、`REQ2`、`REQ3`（用于存储接收到的前三个字节的数据）。\n\n- 主逻辑部分\n -- REGION 初始化\n    首先，将 `Xus_TN_SCREEN` 中的 `by_Input_ASCII_Code` 和 `by_Input_Exten_Code` 初始化为 `BYTE#00`，表示没有输入。\n\n -- REGION 数据处理\n    检查 `R_BUF.SIZE` 是否大于 0，表示网络缓冲区中有数据需要处理。如果有数据，则执行以下逻辑：\n     1. 将 `R_BUF.SIZE` 的值赋给 `REQ_Size`，表示接收到的数据大小。\n     2. 将 `R_BUF.BUFFER` 中的前三个字节分别赋给 `REQ1`、`REQ2` 和 `REQ3`，表示接收到的数据的前三个字节。\n\n -- REGION 解析逻辑\n    根据接收到的数据，执行以下解析逻辑：\n     1. 如果 `REQ1` 是 `BYTE#27`（ESC 键），并且 `REQ_Size` 大于等于 3，则进一步检查 `REQ2` 和 `REQ3`：\n        - 如果 `REQ2` 是 `BYTE#91`，并且 `REQ3` 是 `BYTE#65` 到 `BYTE#68` 或 `BYTE#72` 或 `BYTE#75`，则将 `REQ3` 的值赋给 `Xus_TN_SCREEN.by_Input_Exten_Code`，表示扩展输入代码。\n        - 如果 `REQ2` 是 `BYTE#79`，并且 `REQ3` 是 `BYTE#80` 到 `BYTE#83`，则将 `REQ3` 的值赋给 `Xus_TN_SCREEN.by_Input_Exten_Code`，表示扩展输入代码。\n     2. 如果 `REQ1` 是 `BYTE#32` 到 `BYTE#126` 之间的 ASCII 字符，则将 `REQ1` 的值赋给 `Xus_TN_SCREEN.by_Input_ASCII_Code`，表示 ASCII 输入字符。同时，使用 `OSCAT_BASIC.ISC_NUM` 函数检查 `REQ1` 是否为数字，并将结果赋给 `Xus_TN_SCREEN.bo_Input_ASCII_IsNum`。\n     3. 如果 `REQ1` 是 `BYTE#8`（退格键）、`BYTE#9`（Tab 键）、`BYTE#13`（回车键）或 `BYTE#27`（ESC 键），则将 `REQ1` 的值赋给 `Xus_TN_SCREEN.by_Input_Exten_Code`，表示扩展输入代码。\n\n -- REGION 缓冲区清理\n    在处理完数据后，将 `R_BUF.SIZE` 设置为 `UINT#00`，表示清空网络缓冲区，以便接收新的数据。", "name": "TN_RECEIVE"}