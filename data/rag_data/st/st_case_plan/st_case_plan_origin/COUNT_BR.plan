{"variables": [], "instructions": [], "planning": "- 概述\n  这段代码实现了一个简单的计数器功能块 `COUNT_BR`。它支持通过设置、递增、递减、重置等操作来控制一个字节类型的计数器值。计数器的值被限制在 0 到最大值（`MX`）之间。\n\n- 变量定义\n  代码中定义了以下几类变量：\n  - 输入变量：`SET`（设置计数器值）、`IN`（输入值）、`UP`（递增）、`DN`（递减）、`STEP`（步长，默认值为 1）、`MX`（最大值，默认值为 255）、`RST`（重置计数器）。\n  - 输出变量：`CNT`（当前计数器值）。\n  - 内部变量：`last_up`（记录上一次 `UP` 的状态）、`last_dn`（记录上一次 `DN` 的状态）。\n\n- 主逻辑部分\n  -- REGION 计数器逻辑\n     计数器的逻辑通过一系列条件判断来实现：\n     1. 如果 `RST` 为真，则计数器 `CNT` 被重置为 0。\n     2. 如果 `SET` 为真，则计数器 `CNT` 被设置为 `IN` 的值，同时使用 `LIMIT` 函数确保 `CNT` 的值在 0 到 `MX` 之间。\n     3. 如果 `UP` 为真且上一次 `UP` 为假（即 `UP` 的上升沿触发），则计数器 `CNT` 增加 `STEP` 的值，同时使用 `INC` 函数确保 `CNT` 的值不超过 `MX`。\n     4. 如果 `DN` 为真且上一次 `DN` 为假（即 `DN` 的上升沿触发），则计数器 `CNT` 减少 `STEP` 的值，同时使用 `INC` 函数确保 `CNT` 的值不小于 0。\n     5. 最后，记录当前 `UP` 和 `DN` 的状态到 `last_up` 和 `last_dn`，以便在下一次循环中检测上升沿。\n\n- 总结\n  该功能块通过简单的逻辑实现了计数器的基本功能，包括设置、递增、递减和重置操作。它还通过边缘检测（`last_up` 和 `last_dn`）确保每次递增或递减操作仅在输入信号的上升沿触发一次，避免了重复计数的问题。计数器的值始终被限制在 0 到 `MX` 之间，确保了数据的有效性。", "name": "COUNT_BR"}