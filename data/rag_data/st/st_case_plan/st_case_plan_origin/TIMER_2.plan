{"variables": [], "instructions": [], "planning": "- 概述\n  这段代码定义了一个名为 `TIMER_2` 的功能块，用于根据日期、时间和模式来控制一个定时器的输出。它支持多种模式，包括按星期、按天、工作日、周末、节假日等条件来启用定时器，并根据设定的持续时间和起始时间来控制输出 `Q` 的状态。\n\n- 变量定义\n  代码中定义了以下几类变量：\n  - **输入变量**：`DT_in`（输入的日期时间）、`start`（起始时间）、`duration`（持续时间）、`mode`（模式）、`HOLIDAY`（是否为节假日）。\n  - **输出变量**：`Q`（定时器输出状态）。\n  - **内部变量**：`last_check`（上次检查时间）、`dat`（当前日期）、`daytime`（当前时间）、`activation`（激活时间）、`tx`（当前时间戳）、`enabled`（是否启用定时器）、`init`（初始化标志）、`wday`（星期几）。\n  - **保持变量**：`run_date`（上次运行的日期，用于避免在同一天重复运行）。\n\n- 主逻辑部分\n  -- **初始化部分**：\n     首先，获取当前时间戳 `tx`。如果功能块未初始化（`init` 为 `FALSE`），则设置 `init` 为 `TRUE`，并初始化 `last_check` 为当前时间减去 100 毫秒。\n\n  -- **时间检查部分**：\n     如果当前时间与上次检查时间 `last_check` 的差值小于 100 毫秒，则直接返回，避免频繁执行逻辑。\n\n  -- **日期和时间提取部分**：\n     从输入的日期时间 `DT_in` 中提取当前日期 `dat` 和当前时间 `daytime`，并计算当前日期是星期几 `wday`。\n\n  -- **模式判断部分**：\n     根据 `mode` 的值，判断是否启用定时器 `enabled`：\n     - `1..7`：判断当前星期是否与 `mode` 匹配。\n     - `11`：总是启用。\n     - `12..16`：判断当前日期是否满足按天循环的条件。\n     - `20`：判断是否为工作日（星期一到星期五）。\n     - `21`：判断是否为周末（星期六和星期日）。\n     - `22`：判断是否为工作日且不是节假日。\n     - `23`：判断是否为周末或是节假日。\n     - `24`：判断是否为节假日。\n     - `25`：判断是否为每月的第一天。\n     - `26`：判断是否为每月的最后一天。\n     - `27`：判断是否为 12 月 31 日。\n     - `28`：判断是否为每年的第一天。\n     如果 `mode` 不匹配以上任何条件，则禁用定时器。\n\n  -- **定时器激活部分**：\n     如果定时器被启用（`enabled` 为 `TRUE`）、输出 `Q` 为 `FALSE`、当前时间 `daytime` 大于等于起始时间 `start`，并且当前日期 `dat` 不等于上次运行的日期 `run_date`，则激活定时器，设置 `Q` 为 `TRUE`，并记录激活时间 `activation` 和运行日期 `run_date`。\n\n  -- **定时器停止部分**：\n     如果定时器已激活（`Q` 为 `TRUE`），并且当前时间与激活时间的差值大于等于持续时间 `duration`，则停止定时器，设置 `Q` 为 `FALSE`。\n\n  -- **更新检查时间**：\n     最后，更新 `last_check` 为当前时间 `tx`，以便下次检查。\n\n- 总结\n  该功能块根据日期、时间和模式来控制定时器的输出，支持多种复杂的条件判断。通过维护 `run_date` 变量，可以避免在同一天重复激活定时器。定时器的输出状态 `Q` 根据起始时间和持续时间动态调整。", "name": "TIMER_2"}