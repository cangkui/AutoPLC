{"variables": [], "instructions": [], "planning": "- 概述\n这个功能块`NET_VAR_DWORD8`用于处理8个DWORD类型的输入和输出数据，并通过网络缓冲区进行数据传输。它包含初始化逻辑、数据打包和解包逻辑，并处理数据传输过程中的错误。\n\n- 变量定义\n代码中定义了以下几类变量：\n - 输入输出变量：`X`，用于与网络缓冲区交互。\n - 输入变量：`IN1`到`IN8`，表示8个DWORD类型的输入数据。\n - 输出变量：`OUT1`到`OUT8`，表示8个DWORD类型的输出数据，以及`ID`，用于标识当前功能块的实例。\n - 内部变量：`init`（初始化标志）、`i`和`i2`（循环计数器）、`index`和`index2`（缓冲区索引）、`ra`（临时存储数组，用于存储8个DWORD数据）。\n\n- 主逻辑部分\n-- REGION 初始化\n   此区域负责功能块的初始化。如果`init`为假（即功能块第一次运行），则将其设置为真，并递增`X.ID_MAX`以生成当前功能块的唯一`ID`。\n   ```plaintext\n   IF NOT init THEN\n       init := TRUE;\n       X.ID_MAX := X.ID_MAX + USINT#1;\n       ID := USINT_TO_BYTE(X.ID_MAX);\n   END_IF;\n   ```\n\n-- REGION 数据处理\n   此区域根据`X.STATE`的值决定是打包数据（发送）还是解包数据（接收），并处理可能的错误。\n   - 如果`X.STATE`大于0且`X.ERROR_ID`为0，则继续处理。\n   - 如果`index + 34`超出缓冲区大小，则设置错误`X.ERROR_ID`为当前`ID`。\n   - 如果`X.STATE`为1（发送状态）：\n     - 将输入数据`IN1`到`IN8`存储到临时数组`ra`中。\n     - 将`ID`和分隔符`BYTE#13`写入缓冲区。\n     - 将`ra`中的每个DWORD数据拆分为4个字节，并按顺序写入缓冲区。\n     - 更新`index`以指向缓冲区的下一个位置。\n   - 如果`X.STATE`为2（接收状态）：\n     - 检查缓冲区中的`ID`和分隔符`BYTE#13`是否正确。\n     - 如果正确，则将缓冲区中的4个字节重新组合为DWORD数据，并存储到`ra`中。\n     - 将`ra`中的数据赋值给输出变量`OUT1`到`OUT8`。\n     - 如果检查失败，则设置错误`X.ERROR_ID`为当前`ID`。\n   - 更新`X.index`以指向缓冲区的下一个位置。\n   ```plaintext\n   IF X.STATE > BYTE#0 AND X.ERROR_ID = BYTE#0 THEN\n       index := X.index; \n       IF INT_TO_UINT(index + 34) > X.BUF_SIZE THEN  \n           X.ERROR_ID := ID;\n       ELSE\n           IF X.STATE = BYTE#1 THEN \n               ra[1] := IN1;\n               ra[2] := IN2;\n               ra[3] := IN3;\n               ra[4] := IN4;\n               ra[5] := IN5;\n               ra[6] := IN6;\n               ra[7] := IN7;\n               ra[8] := IN8;\n               X.S_BUF.BUFFER[index] := ID; \n               index := index + 1;\n               X.S_BUF.BUFFER[index] := BYTE#13; \n               index := index + 1;\n               FOR i2 := 1 TO 8 DO;\n                   FOR i := 1 TO 4 DO;\n                       X.S_BUF.BUFFER[index] := DWORD_TO_BYTE(ra[i2]);\n                       ra[i2] := ROR(ra[i2],8);\n                       index := index + 1;\n                   END_FOR;\n               END_FOR;\n\n           ELSIF X.STATE = BYTE#2 THEN \n               index2 := index + 1; \n               IF X.R_BUF.BUFFER[index] <> ID OR X.R_BUF.BUFFER[index2] <> BYTE#13 THEN \n                   X.ERROR_ID := ID;\n               ELSE\n                   index := index + 2;\n                   FOR i2 := 1 TO 8 DO;\n                       ra[i2] := DWORD#0;\n                       FOR i := 1 TO 4 DO;\n                           ra[i2] := ra[i2] OR BYTE_TO_DWORD(X.R_BUF.BUFFER[index]);\n                           ra[i2] := ROR(ra[i2],8);\n                           index := index + 1;\n                       END_FOR;\n                   END_FOR;\n                   OUT1 := ra[1];\n                   OUT2 := ra[2];\n                   OUT3 := ra[3];\n                   OUT4 := ra[4];\n                   OUT5 := ra[5];\n                   OUT6 := ra[6];\n                   OUT7 := ra[7];\n                   OUT8 := ra[8];\n               END_IF;\n           END_IF;\n           X.index := index;\n       END_IF;\n   END_IF;\n   ```", "name": "NET_VAR_DWORD8"}