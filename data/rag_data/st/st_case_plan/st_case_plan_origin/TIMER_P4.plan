{"variables": [], "instructions": [], "planning": "- 概述\n  这个功能块名为“TIMER_P4”，用于处理基于时间的事件触发逻辑。它支持多种时间事件类型，如每日、每周、每月、每年等，并且可以通过输入参数和事件数组来控制输出信号的状态。\n\n- 变量定义\n  代码中定义了以下几类变量：\n  - 输入变量：DTIME（当前时间）、TREF_0和TREF_1（参考时间）、HOLY（假日标志）、L0-L3（逻辑输入）、OFS（偏移量）、ENQ（使能）、MAN（手动模式）、MI（手动输入）、RST（复位）。\n  - 输入输出变量：PROG（事件数组，包含时间事件的详细信息）。\n  - 输出变量：Q0-Q3（输出信号）、STATUS（状态码）。\n  - 常量：array_max（数组最大索引）、channel_max（通道最大索引）。\n  - 内部变量：day_start（当天开始时间）、start（事件开始时间）、event（当前事件）、pos（循环索引）、last_execute（上次执行时间）、current_day（当前天数）、mask（掩码）、ma和mo（逻辑与/或掩码）、qn和qs（输出状态）、channel（当前通道）、tx（临时时间变量）。\n\n- - 主逻辑部分\n  -- REGION 复位处理\n      如果复位信号RST为真，则执行以下操作：\n      1. 将上次执行时间`last_execute`重置为`DT#1970-1-1-00:00`，即初始时间。\n      2. 遍历事件数组`PROG`，对于每个事件，如果其通道号`CHANNEL`在偏移量`OFS`到`OFS + 4`的范围内，则将其`LAST`字段重置为`last_execute`。\n      3. 遍历所有通道（0到`channel_max`），将每个通道的状态标志`qs`重置为`FALSE`。\n\n  -- REGION 时间事件处理\n      如果当前时间`DTIME`与上次执行时间`last_execute`不同，则执行以下操作：\n      1. 更新`last_execute`为当前时间`DTIME`。\n      2. 计算当天的开始时间`day_start`，即`DATE_TO_DT(DT_TO_DATE(DTIME))`。\n      3. 初始化所有通道的状态标志`qn`为`FALSE`。\n      4. 遍历事件数组`PROG`，对于每个事件`event`，执行以下逻辑：\n         - 计算当前通道`channel`为`event.CHANNEL - OFS`。\n         - 如果事件类型`event.TYP`大于0且通道号`channel`在0到`channel_max`之间，则：\n           - 将`event.LAND`和`event.LOR`分别存储到`ma[channel]`和`mo[channel]`中。\n           - 根据事件类型`event.TYP`，执行不同的时间事件逻辑：\n             - **类型1（每日事件）**：计算事件开始时间`start`为`day_start + TOD_TO_TIME(event.start)`，并检查当前时间`DTIME`是否在`start`到`start + event.DURATION`之间，如果是，则设置`qn[channel]`为`TRUE`。\n             - **类型2（每周事件）**：检查当前日期是否为事件定义的工作日`event.DAY`，如果是，则计算`start`并检查时间范围，设置`qn[channel]`。\n             - **类型3（每月事件）**：检查当前日期是否为事件定义的月份日期`event.DAY`，如果是，则计算`start`并检查时间范围，设置`qn[channel]`。\n             - **类型10（特定工作日事件）**：检查当前日期是否为事件定义的工作日`event.DAY`，如果是，则计算`start`并检查时间范围，设置`qn[channel]`。\n             - **类型20（每月特定日期事件）**：检查当前日期是否为事件定义的日期`event.DAY`，如果是，则计算`start`并检查时间范围，设置`qn[channel]`。\n             - **类型21（每月最后一天事件）**：检查当前日期是否为当月的最后一天，如果是，则计算`start`并检查时间范围，设置`qn[channel]`。\n             - **类型30（每年特定日期事件）**：检查当前日期是否为事件定义的日期`event.DAY`，如果是，则计算`start`并检查时间范围，设置`qn[channel]`。\n             - **类型31（每年最后一天事件）**：检查当前日期是否为当年的最后一天，如果是，则计算`start`并检查时间范围，设置`qn[channel]`。\n             - **类型40（闰日事件）**：检查当前日期是否为闰日，如果是，则计算`start`并检查时间范围，设置`qn[channel]`。\n             - **类型41（假日事件）**：如果假日标志`HOLY`为`TRUE`，则计算`start`并检查时间范围，设置`qn[channel]`。\n             - **类型42（假日或周末事件）**：如果假日标志`HOLY`为`TRUE`或当前日期为周末（周六或周日），则计算`start`并检查时间范围，设置`qn[channel]`。\n             - **类型43（工作日事件）**：如果当前日期为工作日（周一到周五），则计算`start`并检查时间范围，设置`qn[channel]`。\n             - **类型50（基于参考时间的事件）**：根据`event.DAY`选择参考时间`TREF_0`或`TREF_1`，计算`start`为`day_start + TOD_TO_TIME(tx) + TOD_TO_TIME(event.start)`，并检查时间范围，设置`qn[channel]`。\n             - **类型51（基于参考时间的反向事件）**：与类型50类似，但`start`为`day_start + TOD_TO_TIME(tx) - TOD_TO_TIME(event.start)`。\n             - **类型52-55（基于参考时间的特殊事件）**：这些类型的事件不仅设置`qn[channel]`，还会更新状态标志`qs`和事件数组中的`LAST`字段。\n\n  -- REGION 输出逻辑\n      1. 根据输入逻辑`L0-L3`生成掩码`mask`，其中`mask.0`到`mask.3`分别对应`L0-L3`的值。\n      2. 计算输出信号`Q0-Q3`，逻辑如下：\n         - `Q0`：如果使能`ENQ`为`TRUE`，并且满足以下条件之一：\n           - `qn[0]`或`qs[0]`为`TRUE`，并且`ma[0]`与`mask`的与运算结果为`ma[0]`。\n           - `mo[0]`与`mask`的或运算结果大于0。\n           - 手动模式`MAN`为`TRUE`且`MI.0`为`TRUE`。\n         - `Q1`、`Q2`、`Q3`的逻辑与`Q0`类似，分别对应通道1、2、3。\n      3. 根据使能`ENQ`和手动模式`MAN`，设置状态码`STATUS`：\n         - 如果`ENQ`为`FALSE`，则`STATUS`为100。\n         - 如果`MAN`为`TRUE`，则`STATUS`为101。\n         - 否则，`STATUS`为102。", "name": "TIMER_P4"}