{"variables": [], "instructions": [], "planning": "- 概述\n  该功能块 `SNTP_CLIENT` 实现了一个简单的 SNTP（简单网络时间协议）客户端，用于从指定的 SNTP 服务器获取时间信息。它通过 IP 协议与服务器通信，并将返回的时间信息转换为 PLC 可用的格式。\n\n- 变量定义\n  代码中定义了以下几类变量：\n  - 输入输出变量：`IP_C`（IP 控制结构）、`S_BUF`（发送缓冲区）、`R_BUF`（接收缓冲区）。\n  - 输入变量：`IP4`（SNTP 服务器的 IP 地址）、`ACTIVATE`（激活信号）。\n  - 输出变量：`ERROR`（错误代码）、`DONE_P`（完成标志）、`UDT`（获取的时间信息）、`XMS`（毫秒部分）。\n  - 内部变量：`IP_FIFO`（IP FIFO 结构）、`ip_state`（IP 状态）、`ip_id`（IP ID）、`i`（循环计数器）、`last`（上次时间戳）、`state`（状态机状态）、`tx`（当前时间戳）、`activate_last`（上次激活信号状态）、`ip4_stored`（存储的 IP 地址）。\n\n- - 主逻辑部分\n  该功能块的核心逻辑是一个状态机，用于管理 SNTP 请求的流程。状态机的每个状态都有特定的任务和逻辑，以下是每个状态的详细说明：\n\n  -- REGION 状态机\n     - 状态 00（初始化状态）：\n       - 将 `DONE_P`（完成标志）设置为 `FALSE`，表示当前没有完成操作。\n       - 检测 `ACTIVATE` 信号的上升沿（即 `ACTIVATE` 为 `TRUE` 且 `activate_last` 为 `FALSE`）。\n       - 如果检测到上升沿，则：\n         - 存储输入的 `IP4`（SNTP 服务器的 IP 地址）到 `ip4_stored`。\n         - 将状态机的状态设置为 10，准备发送 SNTP 请求。\n         - 将 `ERROR`（错误代码）初始化为 0，表示没有错误。\n         - 将 `ip_state`（IP 状态）设置为 1，表示开始 IP 层的初始化。\n\n     - 状态 10（准备发送 SNTP 请求）：\n       - 检查 `ip_state` 是否为 3。如果是，表示 IP 层已经准备好，可以发送 SNTP 请求。\n       - 填充发送缓冲区 `S_BUF`：\n         - 第一个字节设置为 `BYTE#16#1B`，表示 SNTP 请求的格式。\n         - 其余 47 个字节设置为 `BYTE#16#00`，填充缓冲区。\n       - 记录当前时间戳 `tx` 到 `last`，用于后续计算时间偏移。\n       - 将状态机的状态设置为 30，准备等待 SNTP 响应。\n       - 配置 IP 控制结构 `IP_C`：\n         - `C_PORT` 设置为 123（SNTP 协议的默认端口）。\n         - `C_IP` 设置为之前存储的 `ip4_stored`。\n         - `C_MODE` 设置为 1，表示使用 UDP 协议。\n         - `C_ENABLE` 设置为 `TRUE`，启用 IP 通信。\n         - `TIME_RESET` 设置为 `TRUE`，重置 IP 层的计时器。\n         - `R_OBSERVE` 设置为 `TRUE`，启用接收缓冲区观察。\n       - 设置发送缓冲区大小 `S_BUF.SIZE` 为 48 字节，接收缓冲区大小 `R_BUF.SIZE` 为 0。\n\n     - 状态 30（等待 SNTP 响应）：\n       - 检查 `IP_C.ERROR` 是否为 0。如果不为 0，表示通信过程中发生错误：\n         - 将 `ERROR` 设置为 `IP_C.ERROR`。\n         - 重置发送缓冲区和接收缓冲区的大小为 0。\n         - 将状态机的状态设置为 0，回到初始化状态。\n       - 如果 `S_BUF.SIZE` 为 0 且 `R_BUF.SIZE` 大于等于 48 字节，表示成功接收到 SNTP 响应：\n         - 解析 SNTP 响应中的时间信息：\n           - 从接收缓冲区 `R_BUF` 的第 40 到 43 字节提取时间戳，转换为 `DWORD` 格式，并减去 `DWORD#2208988800`（SNTP 时间戳的基准时间），然后转换为 `DT` 格式，存储到 `UDT`。\n           - 从接收缓冲区 `R_BUF` 的第 44 到 45 字节提取毫秒部分，转换为 `INT` 格式，并加上时间偏移（`tx - last` 的一半），存储到 `XMS`。\n           - 将 `XMS` 的秒部分加到 `UDT`，并将 `XMS` 更新为毫秒部分。\n         - 将状态机的状态设置为 0，回到初始化状态。\n         - 将 `DONE_P` 设置为 `TRUE`，表示成功完成操作。\n\n       - 如果状态机回到状态 0，则关闭 IP 观察模式 `R_OBSERVE`，并将 `ip_state` 设置为 4，表示完成一次请求。\n\n  -- REGION IP FIFO 处理\n     - 在状态机执行后，调用 `IP_FIFO` 功能块处理 IP 层的 FIFO 队列，更新 `ip_state` 和 `ip_id`。\n\n  -- REGION 激活信号处理\n     - 在状态机执行后，更新 `activate_last` 以跟踪 `ACTIVATE` 信号的状态变化，用于检测下一次的上升沿。\n\n- 输出结果\n  功能块的输出包括：\n  - `ERROR`：如果在通信过程中发生错误，返回错误代码。\n  - `DONE_P`：当成功获取时间信息时，设置为 `TRUE`。\n  - `UDT`：从 SNTP 服务器获取的时间信息，转换为 PLC 的 `DT` 格式。\n  - `XMS`：时间信息的毫秒部分。", "name": "SNTP_CLIENT"}