{"variables": [], "instructions": [], "planning": "- 概述\n  该功能块 `TN_SEND_ROWS` 用于将屏幕内容发送到网络缓冲区。它处理屏幕的行和列数据，并根据需要更新缓冲区。该功能块还支持清除屏幕和设置光标位置的操作。\n\n- 变量定义\n  代码中定义了以下几类变量：\n  - 输入/输出变量：IP_C（IP连接状态）、S_BUF（网络缓冲区）、Xus_TN_SCREEN（屏幕数据）。\n  - 输入变量：S_BUF_SIZE（缓冲区大小）。\n  - 内部变量：行计数器、列计数器、最后一行索引、循环中断标志、行计数器、偏移量、写入索引、写入索引备份、当前颜色、最后颜色、写入停止位置。\n\n- - 主逻辑部分\n  -- 初始检查\n    首先，功能块检查两个条件：\n    1. IP_C.C_STATE（IP连接状态）是否小于 127。\n    2. S_BUF.SIZE（网络缓冲区的大小）是否大于 0。\n    如果满足任一条件，功能块直接返回，不执行后续逻辑。这是为了确保只有在 IP 连接正常且缓冲区为空的情况下才继续处理。\n\n  -- 清除屏幕逻辑\n    如果 IP 连接状态为 254 或屏幕清除标志（Xus_TN_SCREEN.bo_Clear_Screen）为真，则执行清除屏幕的操作。具体步骤如下：\n    1. 将屏幕的所有 24 行标记为需要更新（Xus_TN_SCREEN.bya_Line_Update[in_Line_Count] := TRUE）。\n    2. 向缓冲区写入清除屏幕的 ANSI 转义序列。这些序列包括：\n       - ESC[0;3;4m：设置屏幕属性（如颜色）。\n       - ESC[2J：清除整个屏幕。\n       - ESC[?7l：禁用自动换行。\n    3. 更新写入索引（in_Write_Index），以便后续操作从正确的位置开始。\n\n  -- 行数据写入逻辑\n    功能块遍历屏幕的每一行（共 24 行），如果某行需要更新（Xus_TN_SCREEN.bya_Line_Update[in_Row_Count] = TRUE），则执行以下操作：\n    1. 向缓冲区写入设置光标位置的 ANSI 转义序列（ESC[<row>;1H），将光标移动到当前行的起始位置。\n    2. 遍历该行的每一列（共 80 列），执行以下操作：\n       - 如果当前列的颜色（by_Cur_Color）与上一列的颜色（by_last_Color）不同，则向缓冲区写入颜色设置的 ANSI 转义序列（ESC[<color>m）。颜色设置包括前景色和背景色。\n       - 将当前字符（Xus_TN_SCREEN.bya_CHAR[in_Offset]）写入缓冲区。\n       - 如果写入索引（in_Write_Index）超过写入停止位置（in_Write_Stop），则设置中断标志（bo_Break_Loop := TRUE）并退出循环。这是为了防止缓冲区溢出。\n    3. 如果循环中断，则记录最后写入的行索引（in_Last_Row_Index），并将当前行的更新标志设置为 FALSE（Xus_TN_SCREEN.bya_Line_Update[in_Row_Count] := FALSE）。\n\n  -- 光标位置设置逻辑\n    如果循环未中断（bo_Break_Loop = FALSE），则重置行计数器（in_Row_Count := 0）。如果写入索引与备份索引不同（in_Write_Index <> in_Write_Index_Backup），则向缓冲区写入设置光标位置的 ANSI 转义序列（ESC[<row>;<col>H），将光标移动到屏幕的指定位置。\n\n  -- 更新缓冲区大小\n    最后，功能块将写入索引加 1 并转换为无符号整数，更新缓冲区的大小（S_BUF.SIZE := INT_TO_UINT(in_Write_Index + 1)）。这是为了确保缓冲区的大小与实际写入的数据一致。", "name": "TN_SEND_ROWS"}