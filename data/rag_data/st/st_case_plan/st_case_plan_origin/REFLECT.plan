{"variables": [], "instructions": [], "planning": "- 概述\n  这个函数名为`REFLECT`，用于对一个`DWORD`类型的输入数据进行位反转操作。位反转是指将数据的二进制表示进行镜像翻转，例如将`1101`反转为`1011`。\n\n- 变量定义\n  代码中定义以下几类变量：\n  - 输入变量：`D`（需要反转的`DWORD`类型数据）和`L`（反转的位数）。\n  - 内部变量：`i`（用于循环计数的`INT`类型变量）。\n\n- 主逻辑部分\n  -- REGION 初始化\n     - 将输出变量`REFLECT`初始化为`0`，用于存储反转后的结果。\n  -- REGION 位反转逻辑\n     - 使用`FOR`循环从`1`到`L`，逐位反转数据：\n       - 将`REFLECT`左移一位（`SHL`），为新的位腾出空间。\n       - 使用`BOOL_TO_DWORD`将`D`的最低位（`D.0`）转换为`DWORD`类型，并与`REFLECT`进行按位或操作（`OR`），将当前位添加到结果中。\n       - 将`D`右移一位（`SHR`），处理下一个位。\n     - 循环结束后，将剩余的未处理位（`D`）左移`L`位并与`REFLECT`进行按位或操作，确保所有位都被正确反转。\n  -- REGION 返回结果\n     - 返回反转后的结果`REFLECT`。\n\n- 示例说明\n  假设输入`D = 13`（二进制为`1101`）且`L = 4`，函数的执行过程如下：\n  1. 初始化`REFLECT = 0`。\n  2. 循环4次：\n     - 第一次循环：`REFLECT = 1`，`D = 6`（`110`）。\n     - 第二次循环：`REFLECT = 10`，`D = 3`（`11`）。\n     - 第三次循环：`REFLECT = 101`，`D = 1`（`1`）。\n     - 第四次循环：`REFLECT = 1011`，`D = 0`。\n  3. 最终结果为`REFLECT = 11`（二进制为`1011`），即`13`的反转结果。\n\n- 总结\n  该函数通过逐位操作实现了`DWORD`类型数据的位反转，适用于需要对二进制数据进行镜像翻转的场景。", "name": "REFLECT"}