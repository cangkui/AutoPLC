{"variables": [], "instructions": [], "planning": "- 概述\n  这段代码实现了一个功能块 `TN_SC_BOX`，用于在屏幕上绘制一个带有边框的矩形区域。功能块支持不同类型的边框样式，并且可以填充矩形区域。它还处理了边框字符的绘制和填充区域的更新。\n\n- 变量定义\n  代码中定义了以下几类变量：\n  - 功能块实例：`FB_TN_SC_FILL`，用于填充矩形区域。\n  - 边框字符变量：`by_BorderChar_L_T`, `by_BorderChar_T`, `by_BorderChar_B`, `by_BorderChar_R_T`, `by_BorderChar_L`, `by_BorderChar_R`, `by_BorderChar_L_B`, `by_BorderChar_R_B`，用于存储边框的各个字符。\n  - 位置和偏移变量：`in_Y`, `in_X`, `in_Border_Offset`, `in_Offset_1`, `in_Offset_2`，用于计算和存储绘制位置。\n  - 输入参数：`Iin_Y1`, `Iin_X1`, `Iin_Y2`, `Iin_X2`, `Iby_FILL`, `Iby_ATTR`, `Iin_BORDER`，用于指定矩形区域的位置、填充字符、属性和边框类型。\n  - 屏幕结构体：`Xus_TN_SCREEN`，用于存储屏幕的字符和颜色数据。\n\n- - 主逻辑部分\n  -- REGION 边框类型选择\n    功能块首先根据输入参数 `Iin_BORDER` 的值选择边框类型。边框类型决定了边框字符的样式和边框的偏移量。具体逻辑如下：\n    - 类型 0：无边框。所有边框字符设置为空格（`BYTE#32`），边框偏移量 `in_Border_Offset` 设置为 0。\n    - 类型 1：单线边框。使用单线边框字符（如 `BYTE#218` 表示左上角，`BYTE#196` 表示上边框等），边框偏移量 `in_Border_Offset` 设置为 1。\n    - 类型 2：双线边框。使用双线边框字符（如 `BYTE#201` 表示左上角，`BYTE#205` 表示上边框等），边框偏移量 `in_Border_Offset` 设置为 1。\n    - 其他值：默认无边框。所有边框字符设置为空格，边框偏移量 `in_Border_Offset` 设置为 1。\n\n  -- REGION 填充矩形区域\n    如果输入参数 `Iby_FILL` 大于 0，表示需要填充矩形区域。功能块调用 `FB_TN_SC_FILL` 功能块来执行填充操作。填充区域的位置根据边框偏移量进行调整，确保填充不会覆盖边框。具体逻辑如下：\n    - 填充区域的起始位置为 `Iin_Y1 + in_Border_Offset` 和 `Iin_X1 + in_Border_Offset`。\n    - 填充区域的结束位置为 `Iin_Y2 - in_Border_Offset` 和 `Iin_X2 - in_Border_Offset`。\n    - 使用 `Iby_FILL` 作为填充字符，`Iby_ATTR` 作为填充属性，并将屏幕结构体 `Xus_TN_SCREEN` 传递给 `FB_TN_SC_FILL` 功能块。\n\n  -- REGION 绘制边框\n    如果 `Iin_BORDER` 不为 0，功能块将绘制边框。边框的绘制分为以下几个步骤：\n    - 计算左右边框的起始位置 `in_Offset_1` 和 `in_Offset_2`，分别对应矩形区域的左上角和右上角。\n    - 使用循环逐行绘制左右边框字符：\n      - 对于每一行，将左边框字符 `by_BorderChar_L` 和右边框字符 `by_BorderChar_R` 写入屏幕的字符数组 `bya_CHAR`，并将属性 `Iby_Attr` 写入颜色数组 `bya_COLOR`。\n      - 更新 `in_Offset_1` 和 `in_Offset_2` 以移动到下一行。\n    - 计算上下边框的起始位置 `in_Offset_1` 和 `in_Offset_2`，分别对应矩形区域的左上角和左下角。\n    - 使用循环逐列绘制上下边框字符：\n      - 对于每一列，将上边框字符 `by_BorderChar_T` 和下边框字符 `by_BorderChar_B` 写入屏幕的字符数组 `bya_CHAR`，并将属性 `Iby_Attr` 写入颜色数组 `bya_COLOR`。\n      - 更新 `in_Offset_1` 和 `in_Offset_2` 以移动到下一列。\n    - 绘制四个角的边框字符：\n      - 左上角字符 `by_BorderChar_L_T` 写入屏幕的字符数组 `bya_CHAR`，并将属性 `Iby_Attr` 写入颜色数组 `bya_COLOR`。\n      - 右上角字符 `by_BorderChar_R_T` 写入屏幕的字符数组 `bya_CHAR`，并将属性 `Iby_Attr` 写入颜色数组 `bya_COLOR`。\n      - 左下角字符 `by_BorderChar_R_B` 写入屏幕的字符数组 `bya_CHAR`，并将属性 `Iby_Attr` 写入颜色数组 `bya_COLOR`。\n      - 右下角字符 `by_BorderChar_L_B` 写入屏幕的字符数组 `bya_CHAR`，并将属性 `Iby_Attr` 写入颜色数组 `bya_COLOR`。\n\n  -- REGION 更新屏幕\n    在绘制边框和填充区域后，功能块将相关行标记为需要更新。具体逻辑如下：\n    - 使用循环逐行设置 `Xus_TN_SCREEN.bya_Line_Update[in_Y]` 为 `TRUE`，表示这些行需要更新。\n    - 更新屏幕的字符和颜色数据，以确保绘制的内容显示在屏幕上。\n\n- 输出结果\n  功能块执行后，屏幕上将显示一个带有指定边框和填充的矩形区域。边框的样式和填充字符由输入参数决定，屏幕数据被更新以反映新的绘制内容。", "name": "TN_SC_BOX"}