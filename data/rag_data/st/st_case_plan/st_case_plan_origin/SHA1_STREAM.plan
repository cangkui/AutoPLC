{"variables": [], "instructions": [], "planning": "- 概述\n  此代码实现了一个名为 `SHA1_STREAM` 的功能块，用于计算 SHA-1 哈希值。SHA-1 是一种广泛使用的加密哈希函数，生成 160 位（20 字节）的哈希值。该功能块通过分块处理输入数据，逐步计算哈希值。\n\n- 变量定义\n  代码中定义了以下几类变量：\n  - 输入输出变量：`MODE`（模式）、`BUF`（输入缓冲区）、`SHA1`（输出哈希值）、`SIZE`（输入数据大小）、`POS`（当前处理位置）。\n  - 内部变量：`hash`（哈希值中间状态）、`end`（数据结束位置）、`block`（块计数）、`pad_1`（填充标志）、`w`（消息调度数组）、`n`、`n1`（循环计数器）、`a`、`b`、`c`、`d`、`e`（哈希计算中间变量）、`f`、`k`、`x`、`z`（临时变量）。\n\n- - 主逻辑部分\n  -- REGION MODE 1：初始化\n     在 `MODE = 1` 时，功能块初始化 SHA-1 哈希计算的中间状态。具体步骤包括：\n     1. 初始化 `hash` 数组为 SHA-1 的初始常量值：\n        - `hash[0] := DWORD#16#67452301`\n        - `hash[1] := DWORD#16#EFCDAB89`\n        - `hash[2] := DWORD#16#98BADCFE`\n        - `hash[3] := DWORD#16#10325476`\n        - `hash[4] := DWORD#16#C3D2E1F0`\n     2. 初始化消息调度数组 `w` 的后 64 个元素为 0：\n        - 使用 `FOR` 循环将 `w[16]` 到 `w[79]` 初始化为 0。\n     3. 计算需要处理的块数 `block`：\n        - `block := SHR(SIZE,6) + BOOL_TO_UDINT((UDINT_TO_BYTE(SIZE) AND 16#3F) > 55)`\n        - 这里 `SHR(SIZE,6)` 计算完整块数，`BOOL_TO_UDINT(...)` 处理剩余字节是否超过 55 的情况。\n     4. 初始化填充标志 `pad_1` 为 `FALSE`，表示尚未进行填充。\n     5. 设置 `POS` 为 0，表示从数据的起始位置开始处理。\n     6. 将 `SIZE` 设置为当前块的大小（最多 64 字节）：\n        - `SIZE := MIN(64,End)`\n     7. 将 `MODE` 设置为 2，进入下一阶段。\n\n  -- REGION MODE 2：处理数据块\n     在 `MODE = 2` 时，功能块处理当前数据块并更新哈希值。具体步骤包括：\n     1. 如果数据块大小小于 64 字节且尚未填充，则在数据末尾添加填充位（`2#1000_0000`）：\n        - `IF SIZE < 64 AND NOT pad_1 THEN BUF[SIZE] := 2#1000_0000; pad_1 := TRUE; END_IF`\n     2. 更新 `POS` 和 `SIZE`，准备处理下一块数据：\n        - `POS := POS + SIZE`\n        - `SIZE := MIN(64,End - POS)`\n     3. 将当前数据块转换为 16 个 32 位字，存储在 `w` 数组的前 16 个位置：\n        - 使用 `FOR` 循环和 `OSCAT_BASIC.DWORD_OF_BYTE` 函数将 `BUF` 中的数据转换为 `w` 数组。\n     4. 如果这是最后一个块，则在 `w[15]` 中存储数据的总长度（以位为单位），并将 `MODE` 设置为 3：\n        - `IF block = 0 THEN w[15] := SHL(UDINT_TO_DWORD(End),3); MODE := 3; ELSE block := block - 1; END_IF`\n     5. 计算消息调度数组 `w` 的后 64 个元素：\n        - 使用 `FOR` 循环和 `ROL`（循环左移）函数计算 `w[16]` 到 `w[79]` 的值。\n     6. 初始化哈希计算的中间变量 `a`、`b`、`c`、`d`、`e`：\n        - `a := hash[0]`\n        - `b := hash[1]`\n        - `c := hash[2]`\n        - `d := hash[3]`\n        - `e := hash[4]`\n     7. 执行 80 轮 SHA-1 计算，更新中间变量：\n        - 使用 `FOR` 循环和条件语句根据轮数选择不同的逻辑函数 `f` 和常量 `k`。\n        - 计算 `x := ROL(a,5) + f + e + k + w[n]`\n        - 更新 `e := d; d := c; c := ROL(b,30); b := a; a := x`\n     8. 将计算结果累加到 `hash` 数组中：\n        - `hash[0] := hash[0] + a`\n        - `hash[1] := hash[1] + b`\n        - `hash[2] := hash[2] + c`\n        - `hash[3] := hash[3] + d`\n        - `hash[4] := hash[4] + e`\n\n  -- REGION MODE 3：生成最终哈希值\n     在 `MODE = 3` 时，功能块将 `hash` 数组转换为最终的 20 字节哈希值，并存储在 `SHA1` 数组中。具体步骤包括：\n     1. 遍历 `hash` 数组的每个元素，将其转换为 4 个字节，并存储到 `SHA1` 数组中：\n        - 使用嵌套 `FOR` 循环和 `ROL` 函数将 `hash` 数组的值逐字节写入 `SHA1` 数组。\n     2. 使用循环和位操作将 `hash` 数组的值逐字节写入 `SHA1` 数组：\n        - `FOR n := 0 TO 4 DO`\n        - `FOR n1 := 0 TO 3 DO`\n        - `hash[n] := ROL(hash[n],8); SHA1[z] := DWORD_TO_BYTE(hash[n]); z := z + 1;`\n\n- 输出结果\n  最终，`SHA1` 数组包含输入数据的 SHA-1 哈希值，`POS` 表示处理完成的位置，`MODE` 保持不变，表示功能块已完成计算。", "name": "SHA1_STREAM"}