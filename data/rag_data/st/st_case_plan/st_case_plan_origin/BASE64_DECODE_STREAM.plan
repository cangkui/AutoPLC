{"variables": [], "instructions": [], "planning": "- 概述\n这段代码实现了一个名为 `BASE64_DECODE_STREAM` 的功能块，用于将 Base64 编码的数据流解码为原始字节数据。Base64 是一种常见的编码方式，通常用于将二进制数据转换为文本格式。该功能块通过逐字节处理输入缓冲区中的数据，并将其解码为输出缓冲区中的原始字节。\n\n- 变量定义\n代码中定义了以下几类变量：\n  - `VAR_IN_OUT`：输入输出缓冲区，`BUF1` 是 Base64 编码的输入缓冲区，`BUF2` 是解码后的输出缓冲区。\n  - `VAR_INPUT`：`SIZE1` 是输入缓冲区 `BUF1` 的有效数据长度。\n  - `VAR_OUTPUT`：`SIZE2` 是输出缓冲区 `BUF2` 的有效数据长度。\n  - `VAR`：内部变量，包括用于解码的临时变量 `a`, `b`, `o`, `off`, `i1`, `i2`, `c`。\n\n- 主逻辑部分\n  -- REGION 初始化\n    首先检查输入缓冲区的大小 `SIZE1`，如果小于等于 0，则直接设置输出缓冲区大小 `SIZE2` 为 0 并返回。否则，初始化内部变量：\n    - `c` 为 `SIZE1 - 1`，表示输入缓冲区的最后一个有效索引。\n    - `i2` 为 0，表示输出缓冲区的当前写入位置。\n    - `a` 和 `b` 为 0，分别用于存储解码过程中的位偏移和临时数据。\n\n  -- REGION 解码循环\n    使用 `FOR` 循环遍历输入缓冲区 `BUF1` 中的每个字节：\n    - 读取当前字节 `o`，并根据其值确定 Base64 字符的偏移量 `off`：\n      - 如果 `o` 是 `=`（Base64 填充字符），则退出循环。\n      - 如果 `o` 是小写字母，则设置 `off` 为 71。\n      - 如果 `o` 是大写字母，则设置 `off` 为 65。\n      - 如果 `o` 是数字，则设置 `off` 为 -4。\n      - 如果 `o` 是 `+`，则设置 `off` 为 -19。\n      - 如果 `o` 是 `/`，则设置 `off` 为 -16。\n    - 将 `o` 减去 `off` 得到 Base64 字符对应的 6 位值，并将其左移后与 `b` 进行或运算。\n    - 增加位偏移 `a` 的值。\n    - 如果 `a` 大于等于 8，表示已经收集到足够的位来生成一个字节，则：\n      - 从 `b` 中提取高 8 位并写入输出缓冲区 `BUF2`。\n      - 更新 `b` 和 `a`，继续处理剩余的位。\n\n  -- REGION 输出结果\n    循环结束后，将输出缓冲区的有效长度 `SIZE2` 设置为当前写入位置 `i2`，表示解码后的数据长度。", "name": "BASE64_DECODE_STREAM"}