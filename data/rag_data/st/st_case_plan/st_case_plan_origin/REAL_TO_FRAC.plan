{"variables": [], "instructions": [], "planning": "- 概述\n这段代码是一个使用SCL编写的功能块，名为“REAL_TO_FRAC”，用于将一个实数（REAL）转换为分数（FRACTION）。它通过逐步逼近的方法，找到一个最接近给定实数的分数，且分母不超过指定的最大值。\n\n- 变量定义\n代码中定义了以下几类变量：\n - 输入变量：`X`（要转换的实数值）和`N`（分母的最大值）。\n - 内部变量：\n   - `temp`：用于临时存储计算结果的变量。\n   - `sign`：用于存储输入值的符号（正或负）。\n   - `X_gerundet`：将`X`四舍五入到最接近的整数值。\n   - `X_ohne_Nachkomma`：去掉`X`的小数部分后的值。\n   - `Numerator`和`Denominator`：当前逼近的分子和分母。\n   - `Numerator_old`和`Denominator_old`：上一次逼近的分子和分母。\n\n- 主逻辑部分\n-- REGION 初始化\n   首先，检查输入值`X`是否为负数。如果是，则将`sign`设置为`TRUE`，并将`X`转换为正数，以便后续计算。\n\n-- REGION 逼近算法\n   使用一个`REPEAT`循环来逐步逼近最接近`X`的分数。在每次循环中：\n   1. 将`X`四舍五入到最接近的整数，并存储在`X_gerundet`中。\n   2. 更新分子和分母的值，使用公式：\n      - `numerator = numerator * X_gerundet + numerator_old`\n      - `denominator = denominator * X_gerundet + denominator_old`\n   3. 检查`X`是否已经是一个整数（即`X = X_ohne_Nachkomma`）。如果是，则检查当前分母是否小于等于`N`。如果是，则将当前的分子和分母存储为最终结果，并退出循环。\n   4. 如果`X`仍然有小数部分，则更新`X`为`1.0 / (X - X_ohne_Nachkomma)`，并继续循环。\n   5. 循环继续，直到分母的值超过`N`。\n\n-- REGION 结果处理\n   循环结束后，根据`sign`的值决定最终的分子符号。如果`sign`为`TRUE`，则将分子设置为负数；否则，保持为正数。最后，将最终的分子和分母赋值给功能块的输出变量`REAL_TO_FRAC.NUMERATOR`和`REAL_TO_FRAC.DENOMINATOR`。\n\n- 输出结果\n功能块返回一个分数，其分子和分母分别存储在`REAL_TO_FRAC.NUMERATOR`和`REAL_TO_FRAC.DENOMINATOR`中。分子可能为负数，取决于输入值`X`的符号，而分母始终为正数，且不超过指定的最大值`N`。", "name": "REAL_TO_FRAC"}