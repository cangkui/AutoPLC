Natural Language Requirements:  
{"variables": [], "instructions": [], "planning": "- Overview\nThis functional block `NET_VAR_DWORD8` is designed to handle 8 DWORD-type input and output data, facilitating data transmission through a network buffer. It includes initialization logic, data packing and unpacking logic, and error handling during data transfer.\n\n- Variable Definitions\nThe code defines the following categories of variables:\n - Input/Output Variables: `X`, used for interaction with the network buffer.\n - Input Variables: `IN1` to `IN8`, representing 8 DWORD-type input data.\n - Output Variables: `OUT1` to `OUT8`, representing 8 DWORD-type output data, and `ID`, used to identify the current instance of the functional block.\n - Internal Variables: `init` (initialization flag), `i` and `i2` (loop counters), `index` and `index2` (buffer indices), `ra` (temporary storage array for holding 8 DWORD data).\n\n- Main Logic Section\n-- REGION Initialization\n   This region handles the initialization of the functional block. If `init` is FALSE (indicating the first run), it sets `init` to TRUE and increments `X.ID_MAX` to generate a unique `ID` for the current functional block.\n   ```plaintext\n   IF NOT init THEN\n       init := TRUE;\n       X.ID_MAX := X.ID_MAX + USINT#1;\n       ID := USINT_TO_BYTE(X.ID_MAX);\n   END_IF;\n   ```\n\n-- REGION Data Processing\n   This region determines whether to pack (send) or unpack (receive) data based on the value of `X.STATE` and handles potential errors.\n   - If `X.STATE` is greater than 0 and `X.ERROR_ID` is 0, processing continues.\n   - If `index + 34` exceeds the buffer size, an error `X.ERROR_ID` is set to the current `ID`.\n   - If `X.STATE` is 1 (send state):\n     - Stores input data `IN1` to `IN8` in the temporary array `ra`.\n     - Writes `ID` and the separator `BYTE#13` to the buffer.\n     - Splits each DWORD in `ra` into 4 bytes and writes them sequentially to the buffer.\n     - Updates `index` to point to the next buffer position.\n   - If `X.STATE` is 2 (receive state):\n     - Checks if the `ID` and separator `BYTE#13` in the buffer are correct.\n     - If correct, reassembles 4 bytes from the buffer into DWORD data and stores them in `ra`.\n     - Assigns data from `ra` to output variables `OUT1` to `OUT8`.\n     - If the check fails, sets `X.ERROR_ID` to the current `ID`.\n   - Updates `X.index` to point to the next buffer position.\n   ```plaintext\n   IF X.STATE > BYTE#0 AND X.ERROR_ID = BYTE#0 THEN\n       index := X.index; \n       IF INT_TO_UINT(index + 34) > X.BUF_SIZE THEN  \n           X.ERROR_ID := ID;\n       ELSE\n           IF X.STATE = BYTE#1 THEN \n               ra[1] := IN1;\n               ra[2] := IN2;\n               ra[3] := IN3;\n               ra[4] := IN4;\n               ra[5] := IN5;\n               ra[6] := IN6;\n               ra[7] := IN7;\n               ra[8] := IN8;\n               X.S_BUF.BUFFER[index] := ID; \n               index := index + 1;\n               X.S_BUF.BUFFER[index] := BYTE#13; \n               index := index + 1;\n               FOR i2 := 1 TO 8 DO;\n                   FOR i := 1 TO 4 DO;\n                       X.S_BUF.BUFFER[index] := DWORD_TO_BYTE(ra[i2]);\n                       ra[i2] := ROR(ra[i2],8);\n                       index := index + 1;\n                   END_FOR;\n               END_FOR;\n\n           ELSIF X.STATE = BYTE#2 THEN \n               index2 := index + 1; \n               IF X.R_BUF.BUFFER[index] <> ID OR X.R_BUF.BUFFER[index2] <> BYTE#13 THEN \n                   X.ERROR_ID := ID;\n               ELSE\n                   index := index + 2;\n                   FOR i2 := 1 TO 8 DO;\n                       ra[i2] := DWORD#0;\n                       FOR i := 1 TO 4 DO;\n                           ra[i2] := ra[i2] OR BYTE_TO_DWORD(X.R_BUF.BUFFER[index]);\n                           ra[i2] := ROR(ra[i2],8);\n                           index := index + 1;\n                       END_FOR;\n                   END_FOR;\n                   OUT1 := ra[1];\n                   OUT2 := ra[2];\n                   OUT3 := ra[3];\n                   OUT4 := ra[4];\n                   OUT5 := ra[5];\n                   OUT6 := ra[6];\n                   OUT7 := ra[7];\n                   OUT8 := ra[8];\n               END_IF;\n           END_IF;\n           X.index := index;\n       END_IF;\n   END_IF;\n   ```", "name": "NET_VAR_DWORD8"}