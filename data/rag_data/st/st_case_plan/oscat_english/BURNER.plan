Natural Language Requirements:  

{"variables": [], "instructions": [], "planning": "- Overview\nThis code is a function block written in SCL, named 'BURNER', designed to control the operation of a burner. It includes multiple states to manage the burner's preheating, ignition, operation, and shutdown processes. The code also handles logic for overtemperature, reset, timer reset, and calculates the burner's energy consumption.\n\n- Variable Definitions\nThe code defines the following types of variables:\n - Input variables: Include start signal, stage 2 signal, overtemperature signal, oil temperature signal, flame signal, reset signal, timer reset signal, multiple time parameters (preheat time, pre-ventilation time, pre-ignition time, post-ignition time, stage 2 delay, safety time, lockout time), multiple ignition flag, and power parameters (KW1, KW2).\n - Output variables: Include motor control, coil 1 control, coil 2 control, preheat control, ignition control, energy consumption (KWh), status, and fault flag.\n - Input/output variables: Include runtime 1, runtime 2, and cycle count.\n - Internal variables: Include state, last time, current time, last state change time, timer 1, timer 2, last oil temperature state, and cycle count 2.\n\n- Main Logic Section\n-- REGION Initialization and Reset Handling\n   This region handles reset, overtemperature, and state 0 conditions. First, it checks the reset signal (rst), overtemperature signal (over_temp), or if the current state is 0. If any condition is met, it further checks if the lockout time has passed (tx - last_change >= lockout_time) and the reset signal is true. If satisfied, it sets the state to 110, clears the fault flag, and sets the state to 1. Otherwise, it resets the motor (motor), coil 1 (coil1), coil 2 (coil2), ignition (ignite), and preheat (pre_heat) controls. If the overtemperature signal is true, it sets the state to 9 and marks a fault (fail := TRUE). Finally, it records the current time (last_change := tx) and the last time (last := tx), and sets the state to 1.\n\n-- REGION Timer Reset Handling\n   This region handles the timer reset signal (rst_timer). If the timer reset signal is true, it resets runtime 1 (runtime1), runtime 2 (runtime2), cycle count (cycles), and cycle count 2 (cycles2) to 0.\n\n-- REGION State Machine\n   This region implements the burner's state machine, executing different logic based on the current state (state):\n   - State 1 (state := 1):\n     - If the start signal (in) and flame signal (flame) are true, it jumps to state 7 (state := 7), turns off preheat (pre_heat := FALSE), and sets the status to 2 (status := 2).\n     - If only the start signal is true, it turns on preheat (pre_heat := TRUE), jumps to state 2 (state := 2), and records the current time (last_change := tx).\n   - State 2 (state := 2):\n     - If the preheat time has passed (tx - last_change >= pre_heat_time) and the oil temperature is true (oil_temp), it turns on the motor (motor := TRUE), jumps to state 3 (state := 3), and records the current time (last_change := tx).\n     - If the preheat time has passed but the oil temperature is false (NOT oil_temp), it jumps to state 7 (state := 7), turns off preheat (pre_heat := FALSE), and sets the status to 1 (status := 1).\n     - If the flame signal is true, it jumps to state 7 (state := 7), turns off preheat (pre_heat := FALSE), and sets the status to 2 (status := 2).\n   - State 3 (state := 3):\n     - If the pre-ventilation time minus the pre-ignition time has passed (tx - last_change >= pre_vent_time - pre_ignite_time), it turns on ignition (ignite := TRUE), jumps to state 4 (state := 4), and records the current time (last_change := tx).\n     - If the flame signal is true, it jumps to state 7 (state := 7), turns off preheat (pre_heat := FALSE) and the motor (motor := FALSE), and sets the status to 3 (status := 3).\n   - State 4 (state := 4):\n     - If the pre-ignition time has passed (tx - last_change >= pre_ignite_time), it turns on coil 1 (coil1 := TRUE), jumps to state 5 (state := 5), and records the current time (last_change := tx).\n   - State 5 (state := 5):\n     - If the safety time has passed (tx - last_change >= safety_time) or the flame signal is true, it checks the flame signal:\n       - If the flame signal is false, it jumps to state 7 (state := 7), turns off the motor (motor := FALSE), coil 1 (coil1 := FALSE), preheat (pre_heat := FALSE), and ignition (ignite := FALSE), and sets the status to 4 (status := 4).\n       - If the flame signal is true, it jumps to state 6 (state := 6) and records the current time (last_change := tx).\n   - State 6 (state := 6):\n     - If the flame signal is false and the multiple ignition flag is false (NOT multiple_ignition), it jumps to state 7 (state := 7), turns off the motor (motor := FALSE), coil 1 (coil1 := FALSE), coil 2 (coil2 := FALSE), preheat (pre_heat := FALSE), and ignition (ignite := FALSE), and sets the status to 5 (status := 5).\n     - If the flame signal is false and the multiple ignition flag is true, it turns on ignition again (ignite := TRUE), jumps to state 5 (state := 5), and turns off coil 2 (coil2 := FALSE).\n     - If the flame signal is true, it checks the post-ignition time (post_ignite_time) and stage 2 delay (stage2_delay):\n       - If the post-ignition time has passed, it turns off ignition (ignite := FALSE).\n       - If the stage 2 delay has passed and the stage 2 signal is true (stage2), it turns on coil 2 (coil2 := TRUE); otherwise, it turns off coil 2 (coil2 := FALSE).\n\n-- REGION Non-Start State Handling\n   This region handles cases where the start signal is false (NOT in). If the start signal is false, it resets the state to 1 (state := 1), turns off the motor (motor := FALSE), coil 1 (coil1 := FALSE), coil 2 (coil2 := FALSE), ignition (ignite := FALSE), and preheat (pre_heat := FALSE), and records the current time (last_change := tx).\n\n-- REGION Timer Update and Energy Consumption Calculation\n   This region updates timers and calculates energy consumption. Based on the flame signal (flame), start signal (in), motor (motor), coil 1 (coil1), and coil 2 (coil2) states, it updates runtime 1 (runtime1), runtime 2 (runtime2), cycle count (cycles), and cycle count 2 (cycles2). Then, it calculates energy consumption (KWh := UDINT_TO_REAL(runtime1) * KW1 / 3600.0 + UDINT_TO_REAL(runtime2) * KW2 / 3600.0) using runtime and power parameters (KW1, KW2).\n\n-- REGION Status and Fault Flag Update\n   This region updates the status and fault flag. If the status is greater than 0 and less than 100 (status > 0 AND status < 100), it marks a fault (fail := TRUE). Otherwise, based on the start signal (in), flame signal (flame), motor (motor), coil 1 (coil1), and coil 2 (coil2) states, it updates the status:\n   - If the start signal is false, it sets the status to 110 (status := 110).\n   - If the flame signal, start signal, motor, coil 1, and coil 2 are all true, it sets the status to 113 (status := 113).\n   - If the flame signal, start signal, motor, and coil 1 are true, it sets the status to 112 (status := 112).\n   - Otherwise, it sets the status to 111 (status := 111).\n\nEND_FUNCTION_BLOCK", "name": "BURNER"}