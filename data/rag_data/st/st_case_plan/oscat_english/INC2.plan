Natural Language Requirements: {"variables": [], "instructions": [], "planning": "- Overview\n  This is a simple function `INC2` designed to calculate an incremented value within a given range. The function takes as input the current value `X`, the increment `D`, the lower bound `L`, and the upper bound `U`. The core logic uses modulo arithmetic to ensure the result always stays within the specified range.\n\n- Variable Definitions\n  The code defines the following types of variables:\n  - Input variables: `X` (current value), `D` (increment), `L` (lower bound), `U` (upper bound).\n  - Internal variable: `tmp` (used to store the length of the range).\n\n- Main Logic\n  -- REGION Calculate Range Length\n     First, compute the length of the range `tmp` using the formula `tmp := U - L + 1`. This value represents the number of integers from `L` to `U` (inclusive).\n  -- REGION Compute Incremented Result\n     Then, use modulo arithmetic to calculate the incremented result. The formula is `INC2 := (X + D - L + tmp) MOD tmp + L`. This formula ensures the result stays within the `L` to `U` range, even if `X + D` exceeds the bounds, by wrapping around via modulo arithmetic. The steps are as follows:\n    1. `X + D`: Compute the current value plus the increment.\n    2. `X + D - L`: Subtract the lower bound to prepare for modulo operation.\n    3. `(X + D - L + tmp) MOD tmp`: Use modulo to confine the result between `0` and `tmp - 1`.\n    4. Finally, add `L` to remap the result back to the `L` to `U` range.\n  -- REGION Return Result\n     The function then returns the computed result `INC2`.\n\n- Summary\n   The core idea of this function is to use modulo arithmetic for cyclic incrementation, ensuring results always stay within the specified range. It is useful for scenarios requiring cyclic traversal of a range, such as loop counting or cyclic indexing.", "name": "INC2"}