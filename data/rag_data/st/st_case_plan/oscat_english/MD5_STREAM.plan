Natural Language Requirements: {"variables": [], "instructions": [], "planning": "- Overview\nThis code implements a function block named 'MD5_STREAM' for calculating the MD5 hash value of input data. MD5 is a widely used hashing algorithm that generates a 128-bit hash value. The function block processes input data in chunks and incrementally updates the hash value until the final MD5 hash is produced.\n\n- Variable Definitions\nThe code defines the following types of variables:\n - Input/Output Variables: MODE (mode), BUF (buffer), MD5 (hash value), SIZE (data size), POS (current position).\n - Internal Variables: hash (four parts of the hash value), a, b, c, d (temporary variables), end (end position), block (block count), x (data block), n, n1, z (loop counters), pad_1 (padding flag).\n\n- Main Logic\n-- REGION MODE 1: Initialization\n   In Mode 1, the four parts of the MD5 hash value (hash[0] to hash[3]) are initialized with the following constants:\n   - hash[0] := DWORD#16#67452301;\n   - hash[1] := DWORD#16#EFCDAB89;\n   - hash[2] := DWORD#16#98BADCFE;\n   - hash[3] := DWORD#16#10325476;\n\n   Next, the number of blocks to process is calculated using the formula:\n   ```plaintext\n   block := SHR(SIZE,6) + BOOL_TO_UDINT((UDINT_TO_BYTE(SIZE) AND 16#3F) > 55);\n   ```\n   Here, `SHR(SIZE,6)` shifts the data size right by 6 bits (equivalent to dividing by 64) to get the number of complete blocks. `BOOL_TO_UDINT((UDINT_TO_BYTE(SIZE) AND 16#3F) > 55)` determines whether an additional padding block is needed. If the lower 6 bits of the data size (`SIZE AND 16#3F`) exceed 55, an extra block is added for padding.\n\n   The padding flag `pad_1` is initialized to FALSE, indicating no padding has been applied yet. `POS` is set to 0, marking the start of data processing. The `End` variable is set to the total data size `SIZE`, while `SIZE` is adjusted to the current block size (up to 64 bytes). Finally, the mode is set to 2 to proceed to the data processing phase.\n\n-- REGION MODE 2: Data Processing\n   In Mode 2, unused portions of the buffer `BUF` are filled with zeros. Specifically, positions from `SIZE` to 63 are set to 0:\n   ```plaintext\n   FOR n := UDINT_TO_INT(SIZE) TO 63 DO\n       BUF[n] := 0;\n   END_FOR;\n   ```\n\n   If the data size is less than 64 bytes and padding hasn't been applied, a padding byte (0x80) is added to the buffer:\n   ```plaintext\n   IF SIZE < 64 AND NOT pad_1 THEN\n       BUF[SIZE] := 2#1000_0000;\n       pad_1 := TRUE;\n   END_IF;\n   ```\n\n   The `POS` and `SIZE` variables are updated to reflect the current processing position:\n   ```plaintext\n   POS := POS + SIZE;\n   SIZE := MIN(64,End - POS);\n   ```\n\n   The buffer data is then converted into 32-bit words and stored in array `x`. Each group of 4 bytes is converted into one 32-bit word:\n   ```plaintext\n   n := 0;\t\n   FOR n1 := 0 TO 15 DO\n       x[n1] := OSCAT_BASIC.DWORD_OF_BYTE(BUF[n+3],BUF[n+2],BUF[n+1],BUF[n]); \n       n := n + 4;\n   END_FOR;\n   ```\n\n   If the block count `block` reaches 0, `x[14]` is set to the lower 32 bits of the data size, and the mode is switched to 3 for hash value computation:\n   ```plaintext\n   IF block = 0 THEN \n       x[14] := SHL(UDINT_TO_DWORD(End),3); \n       MODE := 3;\n   ELSE\n       block := block - 1;\n   END_IF;\n   ```\n\n   Temporary variables `a`, `b`, `c`, `d` are initialized with the four parts of the hash value:\n   ```plaintext\n   a := hash[0];\n   b := hash[1];\n   c := hash[2];\n   d := hash[3];\n   ```\n\n   The `MD5_AUX` function is then used to perform four rounds of hash computation. Each round uses different constants and shift amounts to update the temporary variables incrementally. The four rounds correspond to the four stages of the MD5 algorithm:\n   - Round 1: Uses constants like 16#D76AA478.\n   - Round 2: Uses constants like 16#F61E2562.\n   - Round 3: Uses constants like 16#FFFA3942.\n   - Round 4: Uses constants like 16#F4292244.\n\n   Finally, the temporary variables are added to the four parts of the hash value:\n   ```plaintext\n   hash[0] := hash[0] + a;\n   hash[1] := hash[1] + b;\n   hash[2] := hash[2] + c;\n   hash[3] := hash[3] + d;\n   ```\n\n-- REGION MODE 3: Hash Output\n   In Mode 3, the four parts of the hash value are converted into a byte array and stored in the `MD5` array. Each 32-bit hash value is split into 4 bytes and stored sequentially in the `MD5` array:\n   ```plaintext\n   z := 0;\n   FOR n := 0 TO 3 DO \n       FOR n1 := 0 TO 3 DO\n           MD5[z] := DWORD_TO_BYTE(hash[n]);\n           hash[n] := ROR(hash[n],8);\n           z := z + 1;\n       END_FOR;\n   END_FOR;\n   ```\n\n   This process converts the four 32-bit parts of the hash value (`hash[0]` to `hash[3]`) into 16 bytes, stored in the `MD5` array, resulting in the final 128-bit MD5 hash value.\n\n- Summary\nThe function block processes input data in chunks and computes the hash value incrementally using the MD5 algorithm. The resulting 128-bit hash value is stored in the `MD5` array for external use.", "name": "MD5_STREAM"}