Natural Language Requirements:  
{"variables": [], "instructions": [], "planning": "- Overview\n  This code defines a function block named `TIMER_2`, which controls the output of a timer based on date, time, and mode. It supports multiple modes, including conditions like day of the week, specific days, weekdays, weekends, holidays, etc., to enable the timer. The output state `Q` is controlled according to the set duration and start time.\n\n- Variable Definitions\n  The code defines the following types of variables:\n  - **Input Variables**: `DT_in` (input date-time), `start` (start time), `duration` (duration), `mode` (mode), `HOLIDAY` (whether it's a holiday).\n  - **Output Variable**: `Q` (timer output state).\n  - **Internal Variables**: `last_check` (last check time), `dat` (current date), `daytime` (current time), `activation` (activation time), `tx` (current timestamp), `enabled` (whether the timer is enabled), `init` (initialization flag), `wday` (day of the week).\n  - **Persistent Variable**: `run_date` (last run date, to avoid repeated runs on the same day).\n\n- Main Logic\n  -- **Initialization Part**:\n     First, the current timestamp `tx` is obtained. If the function block is not initialized (`init` is `FALSE`), `init` is set to `TRUE`, and `last_check` is initialized to the current time minus 100 milliseconds.\n\n  -- **Time Check Part**:\n     If the difference between the current time and `last_check` is less than 100 milliseconds, the logic is skipped to avoid frequent execution.\n\n  -- **Date and Time Extraction Part**:\n     The current date `dat` and time `daytime` are extracted from the input date-time `DT_in`, and the day of the week `wday` is calculated.\n\n  -- **Mode Evaluation Part**:\n     Based on the value of `mode`, the timer `enabled` is determined:\n     - `1..7`: Checks if the current day of the week matches `mode`.\n     - `11`: Always enabled.\n     - `12..16`: Checks if the current date meets the recurring day condition.\n     - `20`: Checks if it's a weekday (Monday to Friday).\n     - `21`: Checks if it's a weekend (Saturday and Sunday).\n     - `22`: Checks if it's a weekday and not a holiday.\n     - `23`: Checks if it's a weekend or a holiday.\n     - `24`: Checks if it's a holiday.\n     - `25`: Checks if it's the first day of the month.\n     - `26`: Checks if it's the last day of the month.\n     - `27`: Checks if it's December 31.\n     - `28`: Checks if it's the first day of the year.\n     If `mode` doesn't match any of these conditions, the timer is disabled.\n\n  -- **Timer Activation Part**:\n     If the timer is enabled (`enabled` is `TRUE`), the output `Q` is `FALSE`, the current time `daytime` is greater than or equal to the start time `start`, and the current date `dat` does not match the last run date `run_date`, the timer is activated. `Q` is set to `TRUE`, and the activation time `activation` and run date `run_date` are recorded.\n\n  -- **Timer Deactivation Part**:\n     If the timer is active (`Q` is `TRUE`) and the difference between the current time and activation time is greater than or equal to the duration `duration`, the timer is stopped by setting `Q` to `FALSE`.\n\n  -- **Update Check Time**:\n     Finally, `last_check` is updated to the current time `tx` for the next check.\n\n- Summary\n  This function block controls the timer output based on date, time, and mode, supporting complex conditional checks. By maintaining the `run_date` variable, it avoids repeated activations on the same day. The output state `Q` is dynamically adjusted according to the start time and duration.", "name": "TIMER_2"}