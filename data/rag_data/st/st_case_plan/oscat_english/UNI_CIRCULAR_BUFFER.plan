Natural Language Requirements:  
{"variables": [], "instructions": [], "planning": "- Overview\nThis code implements a Circular Buffer functionality block named \"UNI_CIRCULAR_BUFFER\". The block is designed to store and manage different types of data (such as strings, real numbers, and double words) while supporting data insertion, retrieval, and buffer management. A circular buffer is an efficient data structure, particularly suited for scenarios requiring frequent data insertion and deletion.\n\n- Variable Definitions\nThe code defines the following types of variables:\n - Input/Output Variables: DATA, containing buffer data and management information.\n - Temporary Variables: tmp_dw (double word temporary variable), pTmp (pointer to byte), n, n1, n2 (integers for loops and calculations), x (byte temporary variable), buf_totalsize (total buffer size).\n - Constants: HeaderSize (header size, fixed at 4 bytes).\n - Internal Variables: cnt (counter), mode_last (last mode).\n\n- Main Logic\n-- REGION Data Insertion (Mode 1)\n   When DATA.D_MODE is 1, it indicates the need to insert data into the circular buffer. The detailed steps are as follows:\n   1. **Determine Data Type and Size**: First, the data type (string, real number, or double word) is determined based on the value of DATA.D_HEAD, and the data size (cnt) is calculated. The logic is as follows:\n      - If DATA.D_HEAD is 1, the data type is a string, and cnt is the string length.\n      - If DATA.D_HEAD is 2, the data type is a real number, and cnt is 4 (byte size of a real number).\n      - If DATA.D_HEAD is 3, the data type is a double word, and cnt is 4 (byte size of a double word).\n      - If DATA.D_HEAD is none of the above, cnt is 0.\n   2. **Check Buffer Space**: The total buffer size (buf_totalsize) is calculated, and it checks whether there is enough space to store the data and header information (HeaderSize is 4 bytes). If insufficient space remains, the data loss counter (DATA.BUF_DATA_LOST) is incremented, and the function returns.\n   3. **Update Data Size and Count**: If space is sufficient, the data size (DATA.D_SIZE) and buffer data count (DATA.BUF_DATA_CNT) are updated.\n   4. **Write Header Information**: The header information (containing data type and size) is written to the buffer. The steps are:\n      - Combine DATA.D_HEAD and cnt into a double word (tmp_dw).\n      - Use a loop to write each byte of tmp_dw sequentially into the buffer, updating the write pointer (DATA._Last). If the write pointer exceeds the total buffer size, it is reset to 0.\n   5. **Write Data**: Copy data from the memory location pointed to by pTmp into the buffer, updating the write pointer (DATA._Last). If the pointer exceeds the buffer size, it is reset to 0.\n   6. **Update Buffer Status**: The buffer size (DATA.BUF_SIZE), data count (DATA.BUF_COUNT), and usage percentage (DATA.BUF_USED) are updated. Finally, DATA.D_MODE is reset to 0, indicating the insertion is complete.\n\n-- REGION Data Retrieval (Modes 10-12)\n   When DATA.D_MODE is 10, 11, or 12, it indicates the need to retrieve data from the circular buffer. The detailed steps are:\n   1. **Check for Data**: If the buffer is empty (DATA.BUF_COUNT is 0), the function returns.\n   2. **Read Header Information**: The header information is read to determine the data type and size. The steps are:\n      - Use a loop to read 4 bytes from the buffer, combining them into a double word (tmp_dw). If the read pointer (DATA._GetEnd) exceeds the buffer size, it is reset to 0.\n      - Extract the data size (cnt) and type (DATA.D_HEAD) from tmp_dw.\n   3. **Determine Output Location**: Based on DATA.D_HEAD, the output location (pTmp) is determined:\n      - If DATA.D_HEAD is 1, pTmp points to DATA.D_STRING (string).\n      - If DATA.D_HEAD is 2, pTmp points to DATA.D_REAL (real number).\n      - If DATA.D_HEAD is 3, pTmp points to DATA.D_DWORD (double word).\n   4. **Read Data**: Copy data from the buffer to the memory location pointed to by pTmp, updating the read pointer (DATA._GetEnd). If the pointer exceeds the buffer size, it is reset to 0.\n   5. **Handle String Data**: If the data is a string, a null character (0) is added at the end to terminate it.\n   6. **Update Buffer Status**: Depending on the retrieval mode (10, 11, or 12), the buffer status is updated:\n      - If the mode is 10 and the next mode is 11, or if the mode is 12 and the next mode is 0, the read pointer (DATA._First), buffer size (DATA.BUF_SIZE), data count (DATA.BUF_COUNT), and usage percentage (DATA.BUF_USED) are updated. Finally, DATA.D_MODE is reset to 0, indicating retrieval is complete.\n\n-- REGION Buffer Reset (Mode 99)\n   When DATA.D_MODE is 99, it indicates the need to reset the circular buffer. The steps are:\n   1. **Reset Pointers and Counters**: All buffer pointers (DATA._First, DATA._Last, DATA._GetStart, DATA._GetEnd) and counters (DATA.BUF_COUNT, DATA.BUF_SIZE, DATA.BUF_USED) are reset to their initial values.\n   2. **Clear Data**: All data is cleared, including strings (DATA.D_STRING), real numbers (DATA.D_REAL), double words (DATA.D_DWORD), and header information (DATA.D_HEAD).\n   3. **Reset Mode**: DATA.D_MODE is reset to 0, indicating the buffer has been reset.\n\n-- REGION Update Maximum Usage Rate\n   At the end of the function block, the current buffer usage rate (DATA.BUF_USED) is checked against the maximum usage rate (DATA.BUF_USED_MAX). If it exceeds the maximum, the latter is updated.\n\n- Summary\nThis function block implements data insertion, retrieval, and reset functionalities for a circular buffer using a state machine approach. It supports multiple data types and dynamically manages buffer size and status. The circular buffer design ensures highly efficient data insertion and retrieval, making it ideal for scenarios requiring frequent data processing.", "name": "UNI_CIRCULAR_BUFFER"}