Natural Language Requirements:  

```json
{
  "variables": [],  
  "instructions": [],  
  "planning": "- Overview\nThis code is a function block written in SCL, named 'TN_INPUT_CONTROL', designed to manage and control the focus, updates, and display logic of input elements. It handles functionalities such as input element selection, scrolling, updates, and tooltip display.\n\n- Variable Definitions\nThe code defines the following types of variables:\n - Input/Output Variables: `Xus_TN_SCREEN` (screen-related data) and `Xus_TN_INPUT_CONTROL` (input control-related data), both of derived types.\n - Local Variables: Includes multiple instances of derived types (e.g., `FB_TN_INPUT_SELECT_POPUP`, `FB_TN_INPUT_SELECT_TEXT`) and some basic-type variables (e.g., `in_index`, `in_Scroll_Offset`, `in_Focus_new`, `in_Focus_alt`, `bo_Tool_Tip_Update`).\n\n- Main Logic Section\n -- REGION Initial Checks\n    The function block first checks two conditions:\n    1. Whether `Xus_TN_INPUT_CONTROL.bo_Enable` is false (i.e., if input control is disabled).\n    2. Whether `Xus_TN_SCREEN.bo_Menue_Bar_Dialog` is true (i.e., if it's in menu bar dialog mode).\n    If either condition is true, the function block returns immediately without executing further logic. This ensures no unnecessary processing occurs when input control is disabled or in a specific dialog mode.\n\n -- REGION Focus Reset\n    If `Xus_TN_INPUT_CONTROL.bo_Reset_Fokus` is true, the focus reset logic is executed:\n    1. Set `bo_Reset_Fokus` to false, indicating the focus reset is complete.\n    2. Use a `FOR` loop to iterate through all input elements (quantity determined by `Xus_TN_INPUT_CONTROL.in_Count`), setting each element's `bo_Focus` to false to remove focus from all inputs.\n    3. If the number of input elements is â‰¥1, set the first element's `bo_Focus` to true and update `in_Focus_at` to 1, indicating focus is now on the first input element.\n    4. Set `bo_Update_all` to true, signaling that all input element states need updating.\n\n -- REGION Scroll Offset Calculation\n    If the screen is not in modal dialog mode (i.e., `Xus_TN_SCREEN.bo_Modal_Dialog` is false), calculate the scroll offset (`in_Scroll_Offset`) based on `Xus_TN_SCREEN.by_Input_Exten_Code`:\n    - If `by_Input_Exten_Code` is `BYTE#09`, set the offset to 1.\n    - If `by_Input_Exten_Code` is `BYTE#65`, set the offset to -1.\n    - If `by_Input_Exten_Code` is `BYTE#66`, set the offset to 1.\n    These offsets are used to move focus when specific keys are pressed.\n\n -- REGION Focus Update\n    If the scroll offset (`in_Scroll_Offset`) is non-zero, execute focus update logic:\n    1. Use the `LIMIT` function to ensure the current focus position (`in_Focus_at`) stays within valid bounds (1 to `in_Count`).\n    2. Calculate the new focus position (`in_Focus_new`) by adding the scroll offset to the current position.\n    3. If the new position exceeds the input element count, reset it to 1 or `in_Count` to enable cyclic scrolling.\n    4. Record the old focus position (`in_Focus_alt`).\n    5. Set `bo_Focus` to false for the old position's input element and mark `bo_Update_Input` as true to update it.\n    6. Set `bo_Focus` to true for the new position's input element and mark `bo_Update_Input` as true to update it.\n    7. Update `in_Focus_at` to the new position.\n    8. Set `bo_Tool_Tip_Update` to true to refresh the tooltip.\n    9. Reset `in_Scroll_Offset` to zero, indicating the focus update is complete.\n\n -- REGION Full Update\n    If `Xus_TN_INPUT_CONTROL.bo_Update_all` is true, execute the full update logic:\n    1. Use a `FOR` loop to iterate through all input elements, setting each element's `bo_Update_All` to true for a comprehensive update.\n    2. Set `bo_Update_all` to false to indicate completion.\n    3. Set `bo_Tool_Tip_Update` to true to refresh the tooltip.\n\n -- REGION Input Element Processing\n    Use a `FOR` loop to process each input element based on its type (`in_Type`):\n    1. If `in_Type` > 0, proceed with further processing.\n    2. If the element has focus (`bo_Focus` is true), update its input codes (`by_Input_ASCII_Code` and `by_Input_Exten_Code`) and the numeric ASCII flag (`bo_Input_ASCII_IsNum`).\n    3. If `bo_Tool_Tip_Update` is true, call the `FB_TN_SC_WRITE_C` function block to display the tooltip. The tooltip's position, attributes, and content are determined by variables in `Xus_TN_INPUT_CONTROL`.\n    4. Based on `in_Type`, call the corresponding function block:\n       - For `in_Type` = 1, use `FB_TN_INPUT_EDIT_LINE` to handle line editing.\n       - For `in_Type` = 2, use `FB_TN_INPUT_SELECT_TEXT` to handle text selection.\n       - For `in_Type` = 3, use `FB_TN_INPUT_SELECT_POPUP` to handle popup selection.\n    5. If the element has focus, update the screen's cursor position (`in_Cursor_X` and `in_Cursor_Y`) to match the element's cursor position.\n\n -- REGION Cursor Position Update\n    If an input element has focus, update the screen's cursor position (`in_Cursor_X` and `in_Cursor_Y`) to match the element's cursor position. This ensures the cursor appears correctly during user interaction.",  
  "name": "TN_INPUT_CONTROL"  
}
```