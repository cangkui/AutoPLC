Natural Language Requirements:  
{"variables": [], "instructions": [], "planning": "- Overview\nThis functional block `FILE_SERVER` handles file operations, including opening, closing, reading, writing, deleting, seeking, and retrieving file size. It uses a state machine (`step`) to control different file operation flows and updates the file server's status based on operation results.\n\n- Variable Definitions\nThe code defines the following types of variables:\n - Input/output variables: `FSD` (File Server Data) and `PT` (Network Buffer).\n - Internal variables: Includes buffer size for file operations, file handle, read/write length, file position, filename, error code, error flag, file change flag, state step, etc.\n - Temporary variables: No explicit definition, but controlled via `step` and `command`.\n\n- Main Logic\n-- REGION State Machine Control\nThe state machine uses the `step` variable to control different file operation flows. Each `step` corresponds to a specific operation, such as file opening, closing, reading, or writing. The core logic is implemented via a `CASE` statement, executing actions based on the current `step` value and updating `step` to transition to the next state.\n   - `step = 0`: Initial state. Checks `FSD.MODE` to determine the operation flow. `FSD.MODE` ranges from 1 to 5, corresponding to different modes:\n     - If `FSD.MODE = 4` (file close): If the file handle `handle` > 0, sets `File_change` to `TRUE` and jumps to `step = 32000` for file closing; otherwise, jumps to `step = 90` for file deletion.\n     - If `FSD.MODE = 5`: Jumps directly to `step = 32000` for file closing.\n     - If `handle = 0` (file not open): Jumps to `step = 100` for file opening.\n     - If `used_filename` matches `FSD.FILENAME` and `FSD.MODE` matches `last_mode`, jumps to `step = 200` for file seeking; otherwise, sets `File_change` to `TRUE` and jumps to `step = 32000` for file closing.\n\n   - `step = 90` and `step = 95`: Handles file deletion. Sets `command = 7` (delete operation) and jumps to `step = 95`. If `command = 0` (deletion complete), jumps to `step = 30000` for error handling.\n\n   - `step = 100` and `step = 110`: Handles file opening. Sets `command = 8` (get file size) and jumps to `step = 110`. If `command = 0` (size retrieval complete), sets the file open mode based on `FSD.MODE`:\n     - `FSD.MODE = 1`: Sets mode to `'r'` (read-only) and updates `FSD.FILE_SIZE`.\n     - `FSD.MODE = 2`: Sets mode to `'a'` (append) and updates `FSD.FILE_SIZE`.\n     - `FSD.MODE = 3`: Sets mode to `'w'` (write) and sets `FSD.FILE_SIZE` to 0.\n     Then sets `command = 1` (file open) and jumps to `step = 150`.\n\n   - `step = 150`: After file opening, checks for errors. If an error occurs, jumps to `step = 30000`; otherwise, updates `handle`, `used_filename`, `file_position`, sets `FSD.FILE_OPEN` to `TRUE`, and jumps to `step = 200` for file seeking.\n\n   - `step = 200` and `step = 210`: Handles file seeking. Determines if repositioning is needed based on `FSD.OFFSET`:\n     - If `FSD.OFFSET = 4294967294`: Seeks to end of file (`seek_position = FSD.FILE_SIZE`), sets `command = 5` (seek), and jumps to `step = 210`.\n     - If `FSD.OFFSET > FSD.FILE_SIZE`: Sets `error_code = 255` and jumps to `step = 30000`.\n     - If `FSD.OFFSET` ≠ `file_position`: Sets `seek_position = FSD.OFFSET`, `command = 5`, and jumps to `step = 210`.\n     - If `FSD.OFFSET` = `file_position`: Jumps directly to `step = 300` for read/write.\n     In `step = 210`, if `command = 0` (seek complete), updates `file_position` to `seek_position` and jumps to `step = 300`.\n\n   - `step = 300`: Based on `FSD.MODE`, jumps to:\n     - `step = 400` for reading (`FSD.MODE = 1`).\n     - `step = 500` for writing (`FSD.MODE = 2` or `3`).\n\n   - `step = 400` and `step = 410`: Handles file reading. Checks if read length exceeds buffer size (`buf_size`), adjusts `read_max_length` accordingly, and ensures it doesn’t exceed file size. If `read_max_length > 0`, sets `command = 3` (read) and jumps to `step = 410`. If `command = 0` (read complete), updates `PT.SIZE` and `file_position`, then jumps to `step = 30000`.\n\n   - `step = 500` and `step = 510`: Handles file writing. Checks if write length exceeds `buf_size`, adjusts `write_length`, and if `write_length > 0`, sets `command = 4` (write) and jumps to `step = 510`. If `command = 0` (write complete), updates `file_position` and `FSD.FILE_SIZE`, then jumps to `step = 30000`.\n\n   - `step = 30000`: After operation completion, resets `FSD.MODE` and `FSD.ERROR`, returning to initial state `step = 0`.\n\n   - `step = 32000` and `step = 32100`: Handles file closing. If `handle > 0`, sets `command = 2` (close) and jumps to `step = 32100`. If `command = 0` (close complete), resets file state (`FSD.FILE_OPEN`, `file_position`, etc.). If `File_change = TRUE`, jumps back to `step = 0`; otherwise, jumps to `step = 30000`.\n\n-- REGION File Operation Execution\nExecutes specific file operations based on `command`, including open/close/read/write/seek/delete/get size. Each operation calls system functions (e.g., `SysFileOpen`, `SysFileClose`) and updates error flags/codes.\n   - `command = 1`: Opens file via `SysFileOpen`, updates `open_handle` and `error`.\n   - `command = 2`: Closes file via `SysFileClose`, updates `error`.\n   - `command = 3`: Reads file via `SysFileRead`, updates `length_read` and `error`.\n   - `command = 4`: Writes file via `SysFileWrite`, updates `length_written` and `error`.\n   - `command = 5`: Seeks file via `SysFileSetPos`, updates `error`.\n   - `command = 6`: Gets file position via `SysFileGetPos`, updates `tell_position` and `error`.\n   - `command = 7`: Deletes file via `SysFileDelete`, updates `error`.\n   - `command = 8`: Gets file size via `SysFileGetSize`, updates `file_size` and `error_code`.\n\n-- REGION Error Handling\nAfter each operation, checks for errors. If an error occurs, sets error flags/codes and jumps to `step = 30000`. In `step = 30000`, resets `FSD.MODE` and `FSD.ERROR`, returning to `step = 0`.", "name": "FILE_SERVER"}