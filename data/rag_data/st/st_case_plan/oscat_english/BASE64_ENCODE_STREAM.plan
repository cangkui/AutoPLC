Natural Language Requirements:  
{"variables": [], "instructions": [], "planning": "- Overview\nThis code implements a functional block `BASE64_ENCODE_STREAM`, which performs Base64 encoding on the input byte array `BUF1` and stores the result in `BUF2`. Base64 encoding is a method of converting binary data into an ASCII string format, commonly used for transmitting binary data over text-based protocols.\n\n- Variable Definitions\nThe code defines the following types of variables:\n - Input/Output Variables: `BUF1` is the input byte array, and `BUF2` is the output Base64-encoded result.\n - Input Variable: `SIZE1` represents the length of the input byte array.\n - Output Variable: `SIZE2` represents the length of the Base64-encoded output.\n - Internal Variables: `a` tracks the remaining unprocessed bits, `b` stores the current bit combination being processed, `i`, `i2`, and `i3` are loop and index variables, `c` is the last index of the input byte array, and `BASE64` is the character set used for Base64 encoding.\n\n- Main Logic\n -- REGION Input Validation\n    First, it checks if the input length `SIZE1` is less than or equal to 0. If true, it sets the output length `SIZE2` to 0 and returns immediately, indicating no data needs encoding.\n -- REGION Initialization\n    Initializes variable `c` as the last index of the input array, `i2` to 0 (for tracking the output array index), `a` to 0 (for tracking remaining unprocessed bits), and `b` to 0 (for storing the current bit combination).\n -- REGION Base64 Encoding Main Loop\n    Uses a `FOR` loop to iterate through each byte in the input array `BUF1`. In each iteration, it left-shifts the current byte by 8 bits and performs a bitwise OR with `b`, while incrementing `a`. Then, a `WHILE` loop processes the data in `b` until fewer than 6 bits remain. Each 6-bit segment is converted to a Base64 character and stored in `BUF2`, updating `i2` and `b` accordingly.\n -- REGION Handling Remaining Bits\n    If there are remaining unprocessed bits (`a > 0`) after the loop, they are left-shifted and converted to a Base64 character, stored in `BUF2`. A `FOR` loop then appends Base64 padding characters `=` until the output array length is a multiple of 4. Finally, the output length `SIZE2` is set to the padded length.\n -- REGION Output Result\n    If no remaining bits are left, the output length `SIZE2` is directly set to the current value of `i2`.\n\n- Summary\nThis functional block processes input data byte-by-byte, converts it into Base64 format, handles remaining bits and padding characters, and ultimately produces a Base64-compliant output. The logic is clear and well-suited for scenarios requiring Base64 encoding.", "name": "BASE64_ENCODE_STREAM"}