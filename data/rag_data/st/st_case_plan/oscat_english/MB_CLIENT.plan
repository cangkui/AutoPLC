Natural Language Requirements:  
{"variables": [], "instructions": [], "planning": "- Overview\n  This functional block, named 'MB_CLIENT', handles the client-side logic for the Modbus communication protocol. It supports multiple Modbus function codes (FCs), including operations such as reading and writing registers and coils. The block manages the communication flow through a state machine and handles errors and timeout scenarios.\n\n- Variable Definitions\n  The code defines the following types of variables:\n  - Input/Output Variables: IP_C (IP configuration), S_BUF (send buffer), R_BUF (receive buffer), DATA (data array).\n  - Input Variables: Data size, enable signal, UDP mode, function code, unit ID, read address, read points, read data address, read data bit position, write address, write points, write data address, write data bit position, delay time.\n  - Output Variables: Error code, busy status.\n  - Internal Variables: IP state, IP ID, IP FIFO, mask, temporary variables (e.g., w_tmp, idx1, idx2), state, transaction ID, response, comparison value, timer (TON_1).\n\n- Main Logic Section\n  -- REGION State Machine Logic\n    The state machine manages the functional block's operation flow using a `CASE` statement. Below is the detailed logic for each state:\n    - **State 00**:\n      This is the initial state of the functional block. First, the timer TON_1 is initialized, and the enable signal (ENABLE) or delay time (DELAY) is checked. If the timer expires (TON_1.Q is true) or the delay time is 0, the timer is stopped (TON_1(IN:=FALSE)), the state is set to 20, and the IP state (IP_STATE) is set to 1. This state primarily waits for the enable signal or delay time to initiate the communication process.\n\n    - **State 20**:\n      This is one of the core processing states of the functional block. If the IP state is 3, indicating IP communication is ready, the block processes different Modbus requests based on the function code (FC). Below is the logic for each FC:\n      - **FC 1-2 (Read Coils or Discrete Inputs)**:\n        Verify that the read points (R_POINTS) are ≤ 2000. If valid, construct the send buffer (S_BUF) with the read address (R_ADDR) and read points. Calculate the response data length (Response) and set the comparison value (comp). If the read points exceed the limit, set the error code (ERROR) to 2.\n      - **FC 3-4 (Read Holding Registers or Input Registers)**:\n        Verify that the read points are ≤ 125. If valid, construct the send buffer with the read address and read points. Calculate the response data length and set the comparison value. If the read points exceed the limit, set the error code to 2.\n      - **FC 5 (Write Single Coil)**:\n        Verify that the write data address (W_DATA_ADR) is within the data size (DATA_SIZE) range. If valid, construct the send buffer with the write address (W_ADDR) and write data (DATA[W_DATA_ADR]). Set the response data length and comparison value. If the write data address is out of range, set the error code to 2.\n      - **FC 6 (Write Single Register)**:\n        Verify that the write data address is within the data size range. If valid, construct the send buffer with the write address and write data. Set the response data length and comparison value. If the write data address is out of range, set the error code to 2.\n      - **FC 15 (Write Multiple Coils)**:\n        Verify that the write data address and write points (W_POINTS) are within the data size range and that write points are ≤ 1968. If valid, construct the send buffer with the write address, write points, and write data. Write the data bit by bit into the buffer via a loop. Set the response data length and comparison value. If the write data address or points exceed the limit, set the error code to 2.\n      - **FC 16 (Write Multiple Registers)**:\n        Verify that the write data address and write points are within the data size range and that write points are ≤ 123. If valid, construct the send buffer with the write address, write points, and write data. Write the data word by word into the buffer via a loop. Set the response data length and comparison value. If the write data address or points exceed the limit, set the error code to 2.\n      - **FC 22 (Read/Write Multiple Registers)**:\n        Verify that the write data address and write points are within the data size range, write points are ≤ 121, and read points (R_POINTS) are ≤ 125. If valid, construct the send buffer with the write address, write points, read address, and read points. Write the data word by word into the buffer via a loop. Set the response data length and comparison value. If the write data address, write points, or read points exceed the limit, set the error code to 2.\n      - **FC 23 (Read/Write Multiple Registers and Coils)**:\n        Verify that the write data address and write points are within the data size range, write points are ≤ 121, and read points are ≤ 125. If valid, construct the send buffer with the write address, write points, read address, and read points. Write the data word by word into the buffer via a loop. Set the response data length and comparison value. If the write data address, write points, or read points exceed the limit, set the error code to 2.\n      - **Invalid Function Code**:\n        If the function code is not in the above range, set the error code to 1.\n\n      If all validations pass and no errors occur, increment the transaction ID (Transaction_ID) and transition to state 30. Otherwise, set the IP state to 4 and return to state 00.\n\n    - **State 30**:\n      This state handles response processing. First, check the error status of IP_C (IP_C.ERROR). If an error exists, set the error code (ERROR) to IP_C.ERROR, set the IP state to 4, and return to state 00. If the send buffer is empty and the receive buffer (R_BUF) is not empty, process the response data:\n      - Check if the response data format and content match. If the response data length (R_BUF.SIZE) is ≥ 9 and the response function code (R_BUF.BUFFER[7]) is > 128, it indicates an error in the response. Set the error code to the response error code (R_BUF.BUFFER[8]), set the IP state to 4, and return to state 00.\n      - If the response data length matches the expected length (Response + 9) and the response content aligns with the send buffer, process the received data based on the function code:\n        - **FC 1-2 (Read Coils or Discrete Inputs)**:\n          Write the received data bit by bit into the specified positions of the DATA array.\n        - **FC 3-4 (Read Holding Registers or Input Registers)**:\n          Write the received data word by word into the specified positions of the DATA array.\n        - **Other Function Codes**:\n          If the function code is invalid, set the error code to 1.\n      - If the response data is invalid, set the error code to 3.\n\n      After processing, set the IP state to 4 and return to state 00.\n\n  -- REGION IP FIFO Management\n    The IP_FIFO functional block manages the FIFO queue for IP communication. The FIFO state is updated based on the IP state (IP_STATE) and IP ID (IP_ID). This logic ensures the FIFO queue correctly handles sent and received data.\n\n  -- REGION Busy Status Management\n    The busy status (BUSY) output is set based on whether the IP state is 3. If the IP state is 3, indicating the block is processing a communication request, BUSY is true; otherwise, BUSY is false.\n\n- Summary\n  This functional block implements Modbus client communication logic through a state machine, supporting multiple function codes and operations. State 00 initializes the communication flow, state 20 constructs requests, and state 30 processes responses. The block manages communication flow, errors, and timeouts using timers and the state machine. IP FIFO management and busy status management ensure communication reliability and real-time performance.", "name": "MB_CLIENT"}