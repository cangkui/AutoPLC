Natural Language Requirements:  
{"variables": [], "instructions": [], "planning": "- Overview\n  This code implements a functional block `TN_SC_BOX` designed to draw a rectangular area with a border on the screen. The block supports different border styles and can fill the rectangular region. It also handles the drawing of border characters and updates the filled area.\n\n- Variable Definitions\n  The code defines the following types of variables:\n  - Functional block instance: `FB_TN_SC_FILL`, used to fill the rectangular area.\n  - Border character variables: `by_BorderChar_L_T`, `by_BorderChar_T`, `by_BorderChar_B`, `by_BorderChar_R_T`, `by_BorderChar_L`, `by_BorderChar_R`, `by_BorderChar_L_B`, `by_BorderChar_R_B`, storing various border characters.\n  - Position and offset variables: `in_Y`, `in_X`, `in_Border_Offset`, `in_Offset_1`, `in_Offset_2`, used for calculating and storing drawing positions.\n  - Input parameters: `Iin_Y1`, `Iin_X1`, `Iin_Y2`, `Iin_X2`, `Iby_FILL`, `Iby_ATTR`, `Iin_BORDER`, specifying the rectangular area's position, fill character, attributes, and border type.\n  - Screen structure: `Xus_TN_SCREEN`, storing character and color data for the screen.\n\n- Main Logic\n  -- REGION Border Type Selection\n    The block first selects the border type based on the input parameter `Iin_BORDER`. The border type determines the style of border characters and the border offset. The logic is as follows:\n    - Type 0: No border. All border characters are set to space (`BYTE#32`), and the border offset `in_Border_Offset` is set to 0.\n    - Type 1: Single-line border. Uses single-line border characters (e.g., `BYTE#218` for the top-left corner, `BYTE#196` for the top border, etc.), and the border offset `in_Border_Offset` is set to 1.\n    - Type 2: Double-line border. Uses double-line border characters (e.g., `BYTE#201` for the top-left corner, `BYTE#205` for the top border, etc.), and the border offset `in_Border_Offset` is set to 1.\n    - Other values: Defaults to no border. All border characters are set to space, and the border offset `in_Border_Offset` is set to 1.\n\n  -- REGION Fill Rectangular Area\n    If the input parameter `Iby_FILL` is greater than 0, the rectangular area needs to be filled. The block calls the `FB_TN_SC_FILL` functional block to perform the fill operation. The fill area's position is adjusted based on the border offset to ensure the fill does not overlap the border. The logic is as follows:\n    - The fill area's start position is `Iin_Y1 + in_Border_Offset` and `Iin_X1 + in_Border_Offset`.\n    - The fill area's end position is `Iin_Y2 - in_Border_Offset` and `Iin_X2 - in_Border_Offset`.\n    - Uses `Iby_FILL` as the fill character, `Iby_ATTR` as the fill attribute, and passes the screen structure `Xus_TN_SCREEN` to the `FB_TN_SC_FILL` block.\n\n  -- REGION Draw Border\n    If `Iin_BORDER` is not 0, the block draws the border. The border drawing process consists of the following steps:\n    - Calculate the start positions `in_Offset_1` and `in_Offset_2` for the left and right borders, corresponding to the top-left and top-right corners of the rectangle.\n    - Use loops to draw left and right border characters line by line:\n      - For each line, write the left border character `by_BorderChar_L` and right border character `by_BorderChar_R` to the screen's character array `bya_CHAR`, and write the attribute `Iby_Attr` to the color array `bya_COLOR`.\n      - Update `in_Offset_1` and `in_Offset_2` to move to the next line.\n    - Calculate the start positions `in_Offset_1` and `in_Offset_2` for the top and bottom borders, corresponding to the top-left and bottom-left corners of the rectangle.\n    - Use loops to draw top and bottom border characters column by column:\n      - For each column, write the top border character `by_BorderChar_T` and bottom border character `by_BorderChar_B` to the screen's character array `bya_CHAR`, and write the attribute `Iby_Attr` to the color array `bya_COLOR`.\n      - Update `in_Offset_1` and `in_Offset_2` to move to the next column.\n    - Draw the four corner border characters:\n      - Write the top-left character `by_BorderChar_L_T` to the screen's character array `bya_CHAR` and the attribute `Iby_Attr` to the color array `bya_COLOR`.\n      - Write the top-right character `by_BorderChar_R_T` to the screen's character array `bya_CHAR` and the attribute `Iby_Attr` to the color array `bya_COLOR`.\n      - Write the bottom-left character `by_BorderChar_R_B` to the screen's character array `bya_CHAR` and the attribute `Iby_Attr` to the color array `bya_COLOR`.\n      - Write the bottom-right character `by_BorderChar_L_B` to the screen's character array `bya_CHAR` and the attribute `Iby_Attr` to the color array `bya_COLOR`.\n\n  -- REGION Update Screen\n    After drawing the border and filling the area, the block marks the relevant lines for updating. The logic is as follows:\n    - Use loops to set `Xus_TN_SCREEN.bya_Line_Update[in_Y]` to `TRUE` for each line, indicating these lines need updating.\n    - Update the screen's character and color data to ensure the drawn content is displayed.\n\n- Output Result\n  After execution, the screen will display a rectangular area with the specified border and fill. The border style and fill character are determined by the input parameters, and the screen data is updated to reflect the new content.", "name": "TN_SC_BOX"}