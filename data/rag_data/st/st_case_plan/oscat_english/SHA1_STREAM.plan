Natural Language Requirements: {"variables": [], "instructions": [], "planning": "- Overview\n  This code implements a function block called `SHA1_STREAM` for calculating SHA-1 hash values. SHA-1 is a widely used cryptographic hash function that generates a 160-bit (20-byte) hash value. The function block processes input data in chunks to incrementally compute the hash value.\n\n- Variable Definitions\n  The code defines the following types of variables:\n  - Input/Output Variables: `MODE` (mode), `BUF` (input buffer), `SHA1` (output hash value), `SIZE` (input data size), `POS` (current processing position).\n  - Internal Variables: `hash` (intermediate hash state), `end` (data end position), `block` (block count), `pad_1` (padding flag), `w` (message schedule array), `n`, `n1` (loop counters), `a`, `b`, `c`, `d`, `e` (intermediate hash calculation variables), `f`, `k`, `x`, `z` (temporary variables).\n\n- Main Logic\n  -- REGION MODE 1: Initialization\n     When `MODE = 1`, the function block initializes the intermediate state for SHA-1 hash calculation. Specific steps include:\n     1. Initialize the `hash` array with SHA-1's initial constant values:\n        - `hash[0] := DWORD#16#67452301`\n        - `hash[1] := DWORD#16#EFCDAB89`\n        - `hash[2] := DWORD#16#98BADCFE`\n        - `hash[3] := DWORD#16#10325476`\n        - `hash[4] := DWORD#16#C3D2E1F0`\n     2. Initialize the last 64 elements of the message schedule array `w` to 0:\n        - Use a `FOR` loop to set `w[16]` to `w[79]` to 0.\n     3. Calculate the number of blocks to process, `block`:\n        - `block := SHR(SIZE,6) + BOOL_TO_UDINT((UDINT_TO_BYTE(SIZE) AND 16#3F) > 55)`\n        - Here, `SHR(SIZE,6)` calculates the number of full blocks, and `BOOL_TO_UDINT(...)` handles cases where remaining bytes exceed 55.\n     4. Initialize the padding flag `pad_1` to `FALSE`, indicating no padding has been applied yet.\n     5. Set `POS` to 0, indicating processing starts from the beginning of the data.\n     6. Set `SIZE` to the current block size (up to 64 bytes):\n        - `SIZE := MIN(64,End)`\n     7. Set `MODE` to 2 to proceed to the next phase.\n\n  -- REGION MODE 2: Process Data Blocks\n     When `MODE = 2`, the function block processes the current data block and updates the hash value. Specific steps include:\n     1. If the block size is less than 64 bytes and padding hasn't been applied, add a padding bit (`2#1000_0000`) at the end of the data:\n        - `IF SIZE < 64 AND NOT pad_1 THEN BUF[SIZE] := 2#1000_0000; pad_1 := TRUE; END_IF`\n     2. Update `POS` and `SIZE` to prepare for the next data block:\n        - `POS := POS + SIZE`\n        - `SIZE := MIN(64,End - POS)`\n     3. Convert the current data block into 16 32-bit words stored in the first 16 positions of the `w` array:\n        - Use a `FOR` loop and the `OSCAT_BASIC.DWORD_OF_BYTE` function to convert `BUF` data into the `w` array.\n     4. If this is the last block, store the total data length (in bits) in `w[15]` and set `MODE` to 3:\n        - `IF block = 0 THEN w[15] := SHL(UDINT_TO_DWORD(End),3); MODE := 3; ELSE block := block - 1; END_IF`\n     5. Calculate the last 64 elements of the message schedule array `w`:\n        - Use a `FOR` loop and the `ROL` (rotate left) function to compute values for `w[16]` to `w[79]`.\n     6. Initialize intermediate hash variables `a`, `b`, `c`, `d`, `e`:\n        - `a := hash[0]`\n        - `b := hash[1]`\n        - `c := hash[2]`\n        - `d := hash[3]`\n        - `e := hash[4]`\n     7. Perform 80 rounds of SHA-1 calculations to update intermediate variables:\n        - Use a `FOR` loop and conditional statements to select different logic functions `f` and constants `k` based on the round number.\n        - Calculate `x := ROL(a,5) + f + e + k + w[n]`\n        - Update `e := d; d := c; c := ROL(b,30); b := a; a := x`\n     8. Accumulate results into the `hash` array:\n        - `hash[0] := hash[0] + a`\n        - `hash[1] := hash[1] + b`\n        - `hash[2] := hash[2] + c`\n        - `hash[3] := hash[3] + d`\n        - `hash[4] := hash[4] + e`\n\n  -- REGION MODE 3: Generate Final Hash Value\n     When `MODE = 3`, the function block converts the `hash` array into the final 20-byte hash value stored in the `SHA1` array. Specific steps include:\n     1. Traverse each element of the `hash` array, converting it into 4 bytes and storing them in the `SHA1` array:\n        - Use nested `FOR` loops and the `ROL` function to write `hash` array values byte by byte into the `SHA1` array.\n     2. Use loops and bit operations to write `hash` array values byte by byte into the `SHA1` array:\n        - `FOR n := 0 TO 4 DO`\n        - `FOR n1 := 0 TO 3 DO`\n        - `hash[n] := ROL(hash[n],8); SHA1[z] := DWORD_TO_BYTE(hash[n]); z := z + 1;`\n\n- Output\n  Finally, the `SHA1` array contains the SHA-1 hash value of the input data, `POS` indicates the completed processing position, and `MODE` remains unchanged, indicating the function block has finished its calculations.", "name": "SHA1_STREAM"}