Natural Language Requirements: {"variables": [], "instructions": [], "planning": "- Overview\nThe function block is named `BUFFER_COMP` and is used to compare the contents of two buffers, returning the position where the second buffer first appears within the first buffer. If no match is found, it returns -1.\n\n- Variable Definitions\nThe code defines the following types of variables:\n - Input variables: `PT1` and `PT2` are pointers to the two buffers, `SIZE1` and `SIZE2` are the sizes of the two buffers, and `START` is the starting position for the search.\n - Internal variables: `i` and `j` are loop counters, `end` is the end position for the search, and `firstbyte` is the first byte of the second buffer.\n\n- Main Logic Section\n-- REGION Main Logic\n   First, check if the size of the second buffer is less than or equal to the size of the first buffer. If true, calculate the end position `end` for the search as `SIZE1 - SIZE2`. Then, retrieve the first byte `firstbyte` of the second buffer.\n   Next, traverse the first buffer starting from the `START` position up to the `end` position. In each iteration, check if the current byte matches `firstbyte`. If it matches, proceed to compare the remaining bytes of the two buffers.\n   In the inner `WHILE` loop, compare the bytes of the two buffers one by one. If a mismatched byte is found, exit the inner loop. If the inner loop completes successfully (i.e., `j` equals `SIZE2`), return the current position `i` as the match position and terminate the function.\n   If the entire buffer is traversed without finding a match, return -1.", "name": "BUFFER_COMP"}