Natural Language Requirements:  
{"variables": [], "instructions": [], "planning": "- Overview\n  The function block `TN_SEND_ROWS` is used to send screen content to a network buffer. It processes row and column data from the screen and updates the buffer as needed. This function block also supports operations such as clearing the screen and setting the cursor position.\n\n- Variable Definitions\n  The code defines the following types of variables:\n  - Input/Output Variables: IP_C (IP connection status), S_BUF (network buffer), Xus_TN_SCREEN (screen data).\n  - Input Variables: S_BUF_SIZE (buffer size).\n  - Internal Variables: Row counter, column counter, last row index, loop break flag, row counter, offset, write index, write index backup, current color, last color, write stop position.\n\n- - Main Logic Section\n  -- Initial Checks\n    First, the function block checks two conditions:\n    1. Whether IP_C.C_STATE (IP connection status) is less than 127.\n    2. Whether S_BUF.SIZE (network buffer size) is greater than 0.\n    If either condition is met, the function block returns immediately without executing further logic. This ensures processing only continues when the IP connection is stable and the buffer is empty.\n\n  -- Clear Screen Logic\n    If the IP connection status is 254 or the screen clear flag (Xus_TN_SCREEN.bo_Clear_Screen) is true, the clear screen operation is executed. The steps are as follows:\n    1. Mark all 24 screen rows as needing an update (Xus_TN_SCREEN.bya_Line_Update[in_Line_Count] := TRUE).\n    2. Write ANSI escape sequences to the buffer to clear the screen. These sequences include:\n       - ESC[0;3;4m: Sets screen attributes (e.g., color).\n       - ESC[2J: Clears the entire screen.\n       - ESC[?7l: Disables auto-wrap.\n    3. Update the write index (in_Write_Index) so subsequent operations start from the correct position.\n\n  -- Row Data Writing Logic\n    The function block iterates through each row of the screen (24 rows in total). If a row needs an update (Xus_TN_SCREEN.bya_Line_Update[in_Row_Count] = TRUE), it performs the following:\n    1. Writes an ANSI escape sequence (ESC[<row>;1H) to the buffer to set the cursor position at the start of the current row.\n    2. Iterates through each column of the row (80 columns in total) and performs:\n       - If the current column's color (by_Cur_Color) differs from the previous column's color (by_last_Color), writes an ANSI color-setting escape sequence (ESC[<color>m) to the buffer. Color settings include foreground and background colors.\n       - Writes the current character (Xus_TN_SCREEN.bya_CHAR[in_Offset]) to the buffer.\n       - If the write index (in_Write_Index) exceeds the write stop position (in_Write_Stop), sets the break flag (bo_Break_Loop := TRUE) and exits the loop to prevent buffer overflow.\n    3. If the loop breaks, records the last written row index (in_Last_Row_Index) and sets the current row's update flag to FALSE (Xus_TN_SCREEN.bya_Line_Update[in_Row_Count] := FALSE).\n\n  -- Cursor Position Setting Logic\n    If the loop does not break (bo_Break_Loop = FALSE), resets the row counter (in_Row_Count := 0). If the write index differs from the backup index (in_Write_Index <> in_Write_Index_Backup), writes an ANSI escape sequence (ESC[<row>;<col>H) to the buffer to set the cursor position at the specified screen location.\n\n  -- Update Buffer Size\n    Finally, the function block increments the write index by 1, converts it to an unsigned integer, and updates the buffer size (S_BUF.SIZE := INT_TO_UINT(in_Write_Index + 1)) to ensure the buffer size matches the actual written data.", "name": "TN_SEND_ROWS"}