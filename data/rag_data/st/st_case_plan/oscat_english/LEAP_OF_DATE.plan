Natural Language Requirements:  
{"variables": [], "instructions": [], "planning": "- Overview\n  This code implements a function named `LEAP_OF_DATE`, which determines whether a given date is a leap year. The function takes a `DATE` type input parameter `idate` and returns a boolean value indicating whether the date is a leap year.\n\n- Variable Definitions\n  The code defines one type of variable:\n  - Input variable: `idate`, representing the date to be evaluated.\n\n- Main Logic\n  -- REGION Main Logic\n     The core logic of the function is implemented via the following expression:\n     ```plaintext\n     LEAP_OF_DATE := SHL(((DATE_TO_DWORD(idate) + 43200) / 31557600), 30) = 16#80000000;\n     ```\n     This logic can be broken down into the following steps:\n     1. **DATE_TO_DWORD(idate)**: Converts the input `DATE` type to `DWORD` type, representing the number of seconds from a reference time (e.g., January 1, 1970) to the given date.\n     2. **+ 43200**: Adds 43,200 seconds (i.e., 12 hours) to the converted seconds to account for timezone or date offset adjustments.\n     3. **/ 31557600**: Divides the result by 31,557,600 seconds (i.e., the number of seconds in a year), yielding a floating-point number representing the year.\n     4. **SHL(..., 30)**: Left-shifts the result by 30 bits, equivalent to multiplying it by 2^30 (i.e., 1,073,741,824).\n     5. **= 16#80000000**: Checks whether the left-shifted result equals 16#80000000 (binary: 10000000 00000000 00000000 00000000). If equal, it returns `TRUE`, indicating the date is a leap year; otherwise, it returns `FALSE`.\n\n     This implementation leverages the mathematical properties of date-to-seconds conversion, using bit-shifting and comparison to determine leap years. Although the logic is complex, it efficiently performs the leap year check.\n\n- Output Result\n  The function returns a boolean value:\n  - `TRUE`: Indicates the input date is a leap year.\n  - `FALSE`: Indicates the input date is not a leap year.", "name": "LEAP_OF_DATE"}