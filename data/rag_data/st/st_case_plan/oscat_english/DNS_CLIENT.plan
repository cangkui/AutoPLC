Natural Language Requirements:  
{"variables": [], "instructions": [], "planning": "- Overview\n  This code defines a functional block named `DNS_CLIENT`, which resolves domain names and retrieves corresponding IP addresses using the DNS protocol. It controls the DNS query process through a state machine, including steps such as sending DNS requests, receiving responses, and parsing responses. The block supports input for domain names and DNS server IP addresses, and outputs the resolved IP address, a completion flag, and error messages.\n\n- Variable Definitions\n  The code defines the following types of variables:\n  - Input/Output Variables: `IP_C` (IP control structure), `S_BUF` (send buffer), `R_BUF` (receive buffer).\n  - Input Variables: `ACTIVATE` (activation flag), `DOMAIN` (domain name), `IP4_DNS` (DNS server IP address).\n  - Output Variables: `IP4` (resolved IP address), `DONE` (completion flag), `ERROR` (error code).\n  - Internal Variables: `IP_FIFO` (IP FIFO structure), `ip_state` (IP state), `ip_id` (IP ID), `i` (loop counter), `state` (state machine state), `domain_copy` (domain name copy), `activate_last` (previous activation state), `url_length` (domain name length), `char` (character), `char_count` (character counter), `tid` (transaction ID), `anc` (answer counter), `x` (temporary byte), `rr_stop` (resource record stop flag), `ttl_last` (last TTL value), `ttl_tmp` (temporary TTL value).\n\n- Main Logic\n  The main logic controls the DNS query process via a state machine (`state` variable). Below is the detailed processing logic for each state:\n\n  -- **State 00**:\n     - Checks if the `ACTIVATE` input is true and the previous state was false (`activate_last` is false).\n     - If the condition is met, it initializes `DONE` and `ERROR` to default values (`FALSE` and `0`) and transitions to **State 05** to start the DNS query process.\n     - This is the entry point of the state machine.\n\n  -- **State 05**:\n     - Attempts to decode the input `DOMAIN` directly into an IP address (using the `IP4_DECODE` function).\n     - If successful (`IP4 > 0`), it sets `DONE` to `TRUE` and returns to **State 00**, as no further query is needed.\n     - If decoding fails, it initializes `ip_state` to 1, `ttl_last` to 0, copies `DOMAIN` to `domain_copy`, and transitions to **State 10**.\n\n  -- **State 10**:\n     - Checks if `ip_state` is 3, indicating the IP layer is ready to send the DNS query.\n     - Calculates the domain name length (`url_length`) and initializes the send buffer `S_BUF` with the DNS query packet:\n       - Sets the transaction ID (`tid`) and increments it.\n       - Sets query flags (`BYTE#16#01` for a standard query).\n       - Converts the domain name into DNS packet format (fills the buffer with segment lengths and characters).\n       - Sets the query type (`BYTE#01` for A record) and query class (`BYTE#01` for Internet class).\n     - Configures the IP control structure `IP_C`:\n       - Sets the target port to 53 (DNS service port).\n       - Sets the target IP to `IP4_DNS` (DNS server IP).\n       - Enables IP layer sending (`C_ENABLE := TRUE`).\n     - Sets the send buffer size, clears the receive buffer, and transitions to **State 30**.\n\n  -- **State 30**:\n     - Checks `IP_C.ERROR` for errors. If an error exists, it sets `ERROR` to the error code and transitions to **State 99** (error handling).\n     - If no errors, checks for a valid DNS response:\n       - Verifies if the transaction ID in `R_BUF` matches the sent `tid`.\n       - Ensures the receive buffer size is sufficient (at least 34 bytes plus domain name length).\n     - If the response is valid, parses the error code in the DNS header (`R_BUF.BUFFER[3]` lower 4 bits):\n       - If the error code is 0 (no error), retrieves the answer count (`anc`) and transitions to **State 40**.\n       - If an error exists, transitions to **State 99**.\n\n  -- **State 40**:\n     - Processes resource records (RRs) in the DNS response:\n       - Iterates through `R_BUF`, skipping the domain name section (by checking for `BYTE#63` or `BYTE#0`).\n       - If the record type is A (`BYTE#1`) and class is Internet (`BYTE#1`), parses the TTL (`ttl_tmp`) and IP address (`IP4`).\n       - If the current TTL is greater than `ttl_last`, updates `ttl_last` and `IP4`.\n     - If all answers are processed and `IP4` is valid (`IP4 > 0`), sets `DONE` to `TRUE`.\n     - If `IP4` is invalid, sets `ERROR` to 255 (no valid IP found).\n     - Transitions to **State 99**.\n\n  -- **State 99**:\n     - Resets the receive buffer size (`R_BUF.SIZE := 0`) to indicate processing is complete.\n     - Sets `ip_state` to 4, indicating the IP layer has finished.\n     - Returns to **State 00** to await the next query.\n\n  -- **Additional Logic**:\n     - **`activate_last` Update**: Outside the state machine, updates `activate_last` to track the previous `ACTIVATE` state for edge detection.\n     - **`IP_FIFO` Call**: Calls the `IP_FIFO` block to manage IP layer state and ID, ensuring proper operation.\n\n  -- **Error Handling**:\n     - If errors occur in **State 30** or **State 40**, sets `ERROR` and transitions to **State 99** for cleanup.\n\n  -- **Loop Control**:\n     - The state machine loops via `state` transitions, ensuring sequential execution until completion or error.\n\n  -- **Output**:\n     - On success, `IP4` outputs the resolved IP, and `DONE` is `TRUE`.\n     - On failure, `ERROR` contains the error code, and `DONE` remains `FALSE`.", "name": "DNS_CLIENT"}