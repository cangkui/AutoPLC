Natural Language Requirements:  
{"variables": [], "instructions": [], "planning": "- Overview\nThis functional block is named 'IP2GEO' and is used to retrieve geographic location information based on an IP address. It fetches data via an HTTP request from an external API and parses the returned XML-formatted geographic information. The block includes state machine logic to manage the entire request and parsing process.\n\n- Variable Definitions\nThe code defines the following types of variables:\n - Input/Output Variables: IP_C (IP control structure), S_BUF (send buffer), R_BUF (receive buffer), GEO (geographic data).\n - Input Variables: IP (IP address), ACTIVATE (activation signal).\n - Output Variables: BUSY (busy status), DONE (completion status), ERROR_C (error code), ERROR_T (error type).\n - Internal Variables: CTRL (XML control structure), XML_READER (XML reader), URL_DATA (URL data), DNS_CLIENT (DNS client), HTTP_GET (HTTP GET request), last_state (last activation state), value_int (integer value), value_real (real value), v_real (temporary real value), state (current state).\n\n- Main Logic Section\n-- REGION State Machine Logic\nThe core logic of the functional block is a state machine that manages the conversion process from an IP address to geographic information. The states of the state machine are as follows:\n\n   - State 00: Initialization State\n     - If the ACTIVATE signal transitions from false to true (rising edge), it moves to State 20, indicating the start of processing.\n     - Simultaneously, output variables are initialized: BUSY is set to TRUE (indicating the block is processing), DONE is set to FALSE (processing incomplete), and ERROR_C and ERROR_T are set to 0 (no errors).\n\n   - State 20: URL Construction\n     - URL_DATA is initialized as a fixed string pointing to the IP query API (`http://ipinfodb.com/ip_query.php?timezone=true&IP=`).\n     - If the input IP address is greater than 0, the IP address is converted to a string and appended to the query part of URL_DATA.\n     - The state transitions to State 40, indicating the start of DNS resolution.\n\n   - State 40: DNS Resolution\n     - The DNS_CLIENT is called to resolve the domain name, using IP_C, S_BUF, R_BUF, and URL_DATA.DOMAIN as parameters.\n     - If DNS resolution succeeds (DNS_CLIENT.DONE is TRUE), it moves to State 60, indicating the start of the HTTP request.\n     - If DNS resolution fails (DNS_CLIENT.ERROR > 0), the error code ERROR_C is set to DNS_CLIENT.ERROR, the error type ERROR_T is set to 01, and it transitions to State 100, indicating the end of processing.\n\n   - State 60: HTTP Request\n     - HTTP_GET is called to send the HTTP request, using IP_C, S_BUF, R_BUF, DNS_CLIENT.IP4, and URL_DATA as parameters.\n     - If the HTTP request succeeds (HTTP_GET.DONE is TRUE), it moves to State 80, indicating the start of XML parsing.\n     - Simultaneously, the CTRL structure is initialized: START_POS and STOP_POS are set to the start and end positions of the HTTP response, COMMAND is set to a specific XML parsing command, and WATCHDOG is set to 1 millisecond.\n     - If the HTTP request fails (HTTP_GET.ERROR > 0), the error code ERROR_C is set to HTTP_GET.ERROR, the error type ERROR_T is set to 02, and it transitions to State 100, indicating the end of processing.\n\n   - State 80: XML Parsing\n     - XML_READER is called to parse the XML data from the HTTP response, using CTRL and R_BUF.BUFFER as parameters.\n     - Based on the value of CTRL.TYP, the current XML node type is determined:\n       - If CTRL.TYP < 98, the node is a data node, and the parsed data is stored in the corresponding field of the GEO structure based on CTRL.COUNT. For example:\n         - COUNT = 07: Parses the IP address (GEO.IP4).\n         - COUNT = 10: Parses the state (GEO.STATE).\n         - COUNT = 13: Parses the country code (GEO.COUNTRY_CODE).\n         - Other fields include country name, region code, region name, city, latitude, longitude, timezone name, GMT offset, daylight saving time, etc.\n       - If CTRL.TYP = 99, XML parsing is complete, DONE is set to TRUE, and it transitions to State 100, indicating the end of processing.\n\n   - State 100: Final State\n     - If the HTTP request is incomplete (HTTP_GET.DONE is FALSE), the state is reset to 0, returning the functional block to the initial state to await the next activation.\n     - Simultaneously, BUSY is set to FALSE (indicating the block is no longer processing), and DONE is set based on ERROR_T: if ERROR_T = 0 (no errors), DONE is TRUE; otherwise, it is FALSE.\n\n-- REGION DNS_CLIENT Call\n   - In State 40, DNS_CLIENT is called to resolve the domain name.\n   - DNS_CLIENT uses IP_C, S_BUF, R_BUF, and URL_DATA.DOMAIN as inputs to resolve the URL's domain.\n   - After resolution, DNS_CLIENT updates its output status (DONE and ERROR), and the functional block decides the next step based on these statuses.\n\n-- REGION HTTP_GET Call\n   - In State 60, HTTP_GET is called to send the HTTP request.\n   - HTTP_GET uses IP_C, S_BUF, R_BUF, DNS_CLIENT.IP4, and URL_DATA as inputs to send a GET request to the specified URL.\n   - After the request completes, HTTP_GET updates its output status (DONE and ERROR), and the functional block decides the next step based on these statuses.\n\n-- REGION State Updates\n   - In each step of the state machine, the state machine state is updated based on the current state and operation results.\n   - Simultaneously, corresponding output variables (e.g., BUSY, DONE, ERROR_C, ERROR_T) are set to reflect the current status of the functional block.\n\n-- REGION Final State Handling\n   - In State 100, if the HTTP request is incomplete, the state is reset to 0, returning the functional block to the initial state to await the next activation.\n   - Simultaneously, BUSY is set to FALSE (indicating the block is no longer processing), and DONE is set based on ERROR_T: if ERROR_T = 0 (no errors), DONE is TRUE; otherwise, it is FALSE.\n\n- Summary\nThis functional block uses a state machine to manage the conversion process from an IP address to geographic information, including URL construction, DNS resolution, HTTP requests, and XML parsing. Through the state machine design, the block effectively handles various error scenarios and resets its state upon completion for the next operation. Each state has clear responsibilities and transition conditions, ensuring the process is transparent and controllable.", "name": "IP2GEO"}