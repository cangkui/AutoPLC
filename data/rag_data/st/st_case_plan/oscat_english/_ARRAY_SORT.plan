Natural Language Requirements:  
{"variables": [], "instructions": [], "planning": "- Overview\nThis code implements a function named `_ARRAY_SORT`, designed to sort an array of real numbers. It uses a **non-recursive version of the QuickSort algorithm**, explicitly maintaining a stack to simulate the recursive process. The core idea of QuickSort is to select a 'pivot' value, partition the array into two parts—one with elements smaller than the pivot and the other with elements larger than the pivot—and then recursively sort these two parts. This function manages the subarray ranges to be sorted using a stack, thereby avoiding recursive calls.\n\n- Variable Definitions\nThe code defines the following types of variables:\n - **Input Variables**: `PT` is a pointer to the real number array, and `SIZE` is the size of the array.\n - **Internal Variables**: These include the stack counter `stack_count`, the stack `stack`, the start and end indices of subarrays `links` and `rechts`, the pivot value `pivot`, two loop variables `i` and `j`, two flag variables `ende_innen` and `ende_aussen` for loop control, and a temporary variable `tmp` for swapping array elements.\n\n- Main Logic\n-- REGION Initialization\n    - Initialize `links` to 1, representing the starting index of the array.\n    - Initialize `rechts` to `SHR(size, 2)` (i.e., the array size right-shifted by 2, equivalent to dividing by 4), representing the ending index of the array.\n    - Initialize `stack_count` to 1, indicating the current depth of the stack.\n    - Initialize `ende_aussen` to `FALSE`, indicating the outer loop has not ended.\n\n-- REGION Outer Loop (WHILE NOT ende_aussen)\n    The outer loop handles the subarray ranges to be sorted. The core logic is as follows:\n    - If `links < rechts`, the current subarray range is valid, and the following steps are executed:\n        1. Select the pivot value `pivot`, typically the middle element of the subarray (`PT^[SHR(rechts+links,1)]`).\n        2. Initialize `i` and `j` to point to the start and end positions of the subarray, respectively.\n        3. Enter the inner loop (REPEAT...UNTIL ende_innen) to find elements that need swapping by moving `i` and `j`.\n        4. If `i >= j`, the subarray partitioning is complete, and the inner loop exits.\n        5. Otherwise, swap the values of `PT^[i]` and `PT^[j]`.\n        6. Push the current subarray's end index `rechts` onto the stack.\n        7. If the stack is not full (`stack_count < 32`), increment the stack depth; otherwise, exit the outer loop and return `FALSE` to indicate sorting failure.\n        8. Update `rechts` to `MAX(links, i-1)` to continue processing the left half.\n    - If `links >= rechts`, the current subarray range is invalid, and the following steps are executed:\n        1. If the stack depth is 1, exit the outer loop.\n        2. Otherwise, pop the previous subarray's end index from the stack, update `links` and `rechts`, and continue processing the right half.\n\n-- REGION Termination Logic\n    - If the outer loop ends normally, return `TRUE` to indicate successful sorting.\n\n- Summary\nThis function implements the QuickSort algorithm non-recursively by using a stack to manage subarray ranges. It efficiently sorts real number arrays, but due to the stack size limit (32), it may return `FALSE` if the array is too large or the recursion depth is too high, causing a stack overflow. Therefore, this function is suitable for sorting medium-sized arrays.", "name": "_ARRAY_SORT"}