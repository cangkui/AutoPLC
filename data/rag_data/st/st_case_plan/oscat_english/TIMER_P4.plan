Natural Language Requirements:  
{"variables": [], "instructions": [], "planning": "- Overview\n  This functional block, named 'TIMER_P4', is designed to handle time-based event triggering logic. It supports various time event types such as daily, weekly, monthly, yearly, etc., and controls the state of output signals through input parameters and an event array.\n\n- Variable Definitions\n  The code defines the following types of variables:\n  - Input Variables: DTIME (current time), TREF_0 and TREF_1 (reference times), HOLY (holiday flag), L0-L3 (logical inputs), OFS (offset), ENQ (enable), MAN (manual mode), MI (manual input), RST (reset).\n  - Input/Output Variables: PROG (event array containing detailed information about time events).\n  - Output Variables: Q0-Q3 (output signals), STATUS (status code).\n  - Constants: array_max (maximum array index), channel_max (maximum channel index).\n  - Internal Variables: day_start (start time of the current day), start (event start time), event (current event), pos (loop index), last_execute (last execution time), current_day (current day count), mask (mask), ma and mo (logical AND/OR masks), qn and qs (output states), channel (current channel), tx (temporary time variable).\n\n- Main Logic\n  -- REGION Reset Handling\n      If the reset signal RST is TRUE, the following actions are performed:\n      1. Reset the last execution time `last_execute` to `DT#1970-1-1-00:00` (initial time).\n      2. Iterate through the event array `PROG`. For each event, if its channel number `CHANNEL` is within the range of `OFS` to `OFS + 4`, reset its `LAST` field to `last_execute`.\n      3. Iterate through all channels (0 to `channel_max`) and reset each channel's status flag `qs` to `FALSE`.\n\n  -- REGION Time Event Handling\n      If the current time `DTIME` differs from the last execution time `last_execute`, the following actions are performed:\n      1. Update `last_execute` to the current time `DTIME`.\n      2. Calculate the start time of the current day `day_start` as `DATE_TO_DT(DT_TO_DATE(DTIME))`.\n      3. Initialize all channel status flags `qn` to `FALSE`.\n      4. Iterate through the event array `PROG`. For each event `event`, execute the following logic:\n         - Calculate the current channel `channel` as `event.CHANNEL - OFS`.\n         - If the event type `event.TYP` is greater than 0 and the channel number `channel` is between 0 and `channel_max`, then:\n           - Store `event.LAND` and `event.LOR` into `ma[channel]` and `mo[channel]`, respectively.\n           - Depending on the event type `event.TYP`, execute different time event logic:\n             - **Type 1 (Daily Event)**: Calculate the event start time `start` as `day_start + TOD_TO_TIME(event.start)` and check if the current time `DTIME` is between `start` and `start + event.DURATION`. If true, set `qn[channel]` to `TRUE`.\n             - **Type 2 (Weekly Event)**: Check if the current date matches the defined weekday `event.DAY`. If true, calculate `start` and check the time range, then set `qn[channel]`.\n             - **Type 3 (Monthly Event)**: Check if the current date matches the defined day of the month `event.DAY`. If true, calculate `start` and check the time range, then set `qn[channel]`.\n             - **Type 10 (Specific Weekday Event)**: Similar to Type 2, checks for a specific weekday.\n             - **Type 20 (Specific Day of Month Event)**: Similar to Type 3, checks for a specific day of the month.\n             - **Type 21 (Last Day of Month Event)**: Checks if the current date is the last day of the month.\n             - **Type 30 (Specific Day of Year Event)**: Checks if the current date matches the defined day of the year.\n             - **Type 31 (Last Day of Year Event)**: Checks if the current date is the last day of the year.\n             - **Type 40 (Leap Day Event)**: Checks if the current date is a leap day.\n             - **Type 41 (Holiday Event)**: If the holiday flag `HOLY` is `TRUE`, calculates `start` and checks the time range, then sets `qn[channel]`.\n             - **Type 42 (Holiday or Weekend Event)**: If `HOLY` is `TRUE` or the current date is a weekend (Saturday or Sunday), calculates `start` and checks the time range, then sets `qn[channel]`.\n             - **Type 43 (Weekday Event)**: If the current date is a weekday (Monday to Friday), calculates `start` and checks the time range, then sets `qn[channel]`.\n             - **Type 50 (Reference Time-Based Event)**: Selects reference time `TREF_0` or `TREF_1` based on `event.DAY`, calculates `start` as `day_start + TOD_TO_TIME(tx) + TOD_TO_TIME(event.start)`, and checks the time range, then sets `qn[channel]`.\n             - **Type 51 (Inverse Reference Time-Based Event)**: Similar to Type 50, but `start` is calculated as `day_start + TOD_TO_TIME(tx) - TOD_TO_TIME(event.start)`.\n             - **Types 52-55 (Special Reference Time-Based Events)**: These events not only set `qn[channel]` but also update the status flag `qs` and the `LAST` field in the event array.\n\n  -- REGION Output Logic\n      1. Generate a mask `mask` based on input logic `L0-L3`, where `mask.0` to `mask.3` correspond to `L0-L3` values.\n      2. Calculate output signals `Q0-Q3` as follows:\n         - `Q0`: If enable `ENQ` is `TRUE` and one of the following conditions is met:\n           - `qn[0]` or `qs[0]` is `TRUE`, and the AND operation between `ma[0]` and `mask` equals `ma[0]`.\n           - The OR operation between `mo[0]` and `mask` is greater than 0.\n           - Manual mode `MAN` is `TRUE` and `MI.0` is `TRUE`.\n         - `Q1`, `Q2`, `Q3` follow similar logic for channels 1, 2, and 3, respectively.\n      3. Set the status code `STATUS` based on enable `ENQ` and manual mode `MAN`:\n         - If `ENQ` is `FALSE`, `STATUS` is 100.\n         - If `MAN` is `TRUE`, `STATUS` is 101.\n         - Otherwise, `STATUS` is 102.", "name": "TIMER_P4"}