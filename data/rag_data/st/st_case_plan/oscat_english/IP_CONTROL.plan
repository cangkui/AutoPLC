Natural Language Requirements:  
{"variables": [], "instructions": [], "planning": "- Overview\n  This code implements a functional block named 'IP_CONTROL' for managing network connection establishment, data transmission, and error handling. It supports both TCP and UDP protocols and provides control logic for connecting, sending, and receiving data. The code manages connection states via a state machine and uses timers to monitor timeout conditions.\n\n- Variable Definitions\n  The code defines the following types of variables:\n   - Input/Output Variables: Used for interaction with external systems, including IP addresses, port numbers, timeout durations, network buffers, etc.\n   - Internal Variables: Used to store connection states, timestamps, error codes, sent/received byte counts, etc.\n   - Constants: Define various states of the state machine, such as initialization, connection, waiting, closing, etc.\n\n- Main Logic Section\n  -- REGION Initialization and Parameter Setup\n      First, the current timestamp (`tx`) is retrieved, and input parameters are checked for validity. If the port number (`IP_C.C_PORT`) is unset, a default value (`PORT`) is used. If the IP address (`IP_C.C_IP`) is unset and the mode (`IP_C.C_MODE`) is less than 4, the default value (`IP`) is applied. Next, it checks for new connection parameters (e.g., changes in IP address, port number, or mode) and sets the connection enable flag (`c_enable`). If the block is in a stopped state (`state = STOP`) with no errors (`IP_C.ERROR = 0`), it initializes connection parameters (IP address, port number, mode, etc.) and transitions to the corresponding initialization state (`UDP_INIT`, `TC_INIT`, or `TS_INIT`) based on the protocol (UDP or TCP).\n\n  -- REGION State Machine Management\n      The state machine is the core logic of the block, managing the connection lifecycle. Key state transitions include:\n      - **UDP_INIT**: Initializes a UDP connection. Creates a UDP socket (`SysSockCreate`). If creation fails, sets an error state (`c_status := 1`) and transitions to the closing state (`C_CLOSE`). If successful, configures socket options (broadcast and non-blocking modes) and initializes the socket address structure (`sockaddr`). For modes 2 or 3 (binding mode), it attempts to bind the socket. On success, it transitions to the waiting state (`C_WAIT`); otherwise, it sets an error state and closes the connection.\n      - **TC_INIT**: Initializes a TCP connection. Creates a TCP socket. If creation fails, sets an error state and closes the connection. If successful, configures socket options (TCP_NODELAY and non-blocking mode) and initializes the socket address structure before transitioning to the connection state (`TC_CONNECT`).\n      - **TC_CONNECT**: Attempts to establish a TCP connection. If the connection enable flag (`c_enable`) is false or an error occurs (`c_status = 255`), it transitions to the closing state. Otherwise, it attempts to connect the socket. On success, it transitions to the waiting state; if non-blocking mode (`c_select`) is enabled, it uses the `select` function to wait for connection completion.\n      - **TS_INIT**: Initializes a TCP server. Creates a TCP socket. If creation fails, sets an error state and closes the connection. If successful, configures socket options (address reuse and non-blocking mode) and initializes the socket address structure. It then attempts to bind and listen on the socket. If binding or listening fails, it sets an error state and closes the connection; otherwise, it transitions to the open state (`TS_OPEN`).\n      - **TS_OPEN**: Waits for client connections. Uses `SysSockAccept` to accept incoming connections. If a valid connection is received, it transitions to the waiting state; if the connection enable flag is false, it closes the connection.\n      - **C_WAIT**: After connection establishment, waits for data transmission or reception. If the connection is lost or disabled, it transitions to the closing state.\n      - **C_CLOSE**: Closes the connection, releases resources, and returns to the stopped state. It first closes the socket and resets the state to `STOP`.\n\n  -- REGION Connection State Updates\n      Updates the block's output state based on connection status changes. If the connection is successfully established (`c_ready`), it sets the connection state to 254 and resets the timestamp (`IP_C.TIME_RESET := TRUE`). If the connection is lost (`NOT c_ready`), it sets the connection state to 1 and clears related data (e.g., send buffer size and send request flag).\n\n  -- REGION Data Reception\n      After connection establishment, checks if the receive buffer is full. If not, it receives data from the socket. For UDP mode, it uses `SysSockRecvFrom`; for TCP mode, it uses `SysSockRecv`. Received data is stored in the receive buffer, and the receive timestamp and status are updated. If the received byte count is 0 (TCP mode), it indicates a disconnection, triggering an error state and closing the connection.\n\n  -- REGION Data Transmission\n      If the send buffer contains data (`S_BUF.SIZE > 0`) and the connection is active, it initiates the send process. First, it initializes send parameters (e.g., total bytes, current position, and size) and sets the send request flag (`s_req`). It then uses `SysSockSendTo` (UDP) or `SysSockSend` (TCP) to transmit data. After sending, it updates the send status and buffer pointer. If sending fails, it sets an error state and closes the connection.\n\n  -- REGION Timeout Handling\n      Monitors connection, send, and receive timeouts. If a connection timeout occurs (`tx - c_time > error_time`), it sets the connection error state (`c_status := 255`). If a send timeout occurs (`tx - s_time > error_time`), it sets the send error state (`s_status := 255`). If a receive timeout occurs (`tx - r_time > error_time`), it sets the receive error state (`r_status := 255`).\n\n  -- REGION Error Handling\n      Updates the block's error output (`IP_C.ERROR`) based on connection, send, and receive error states. If a critical error occurs, it closes the connection and returns to the stopped state. Error states are propagated to external systems via the block's output variables.\n\n- Summary\n  This functional block manages network connection lifecycles via a state machine, supporting TCP and UDP protocols with data transmission capabilities. It ensures system stability through timeout monitoring and error state handling mechanisms.", "name": "IP_CONTROL"}