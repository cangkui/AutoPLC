Natural Language Requirements:  
{"variables": [], "instructions": [], "planning": "- Overview\nThis function block `GET_WAN_IP` is designed to retrieve the WAN (Wide Area Network) IPv4 address via an HTTP request from a dynamic DNS service (e.g., `checkip.dyndns.com`). It performs DNS resolution and an HTTP GET request to obtain the IP address while handling potential errors.\n\n- Variable Definitions\nThe code defines the following types of variables:\n - Input/Output Variables: `IP_C` (IP control structure), `S_BUF` (send buffer), `R_BUF` (receive buffer).\n - Input Variable: `ACTIVATE` (activation signal).\n - Output Variables: `WAN_IP4` (retrieved WAN IPv4 address), `DONE` (operation completion flag), `NEW_IP4` (new IP address flag), `ERROR_C` (error code), `ERROR_T` (error type).\n - Internal Variables: `URL_DATA` (URL data structure), `DNS_CLIENT` (DNS client instance), `HTTP_GET` (HTTP GET instance), `activate_last` (previous activation signal state), `wan_ip4_last` (previous WAN IPv4 address), `state` (state machine status), `st_ip` (string storing the IP address), `i1`, `p1`, `p2`, `p3` (temporary index variables).\n\n- Main Logic\n-- REGION State Machine Logic\nThe state machine controls the execution flow of the function block using the `state` variable. The detailed logic for each state is as follows:\n   - **State 00**:\n      - This is the initial state, waiting for a rising edge of the `ACTIVATE` signal (transition from `FALSE` to `TRUE`).\n      - If a rising edge is detected, it transitions to State 20 and initializes:\n        - `DONE` to `FALSE` (operation not complete).\n        - `ERROR_C` to `0` (no error).\n        - `ERROR_T` to `0` (no error type).\n      - If no rising edge is detected, it remains in State 00, continuing to wait.\n\n   - **State 20**:\n      - Prepares for DNS resolution.\n      - Uses the `STRING_TO_URL` function to convert `checkip.dyndns.com` into the `URL_DATA` structure, which includes the domain, default protocol, and path.\n      - After conversion, transitions to State 40.\n\n   - **State 40**:\n      - Calls the `DNS_CLIENT` instance for DNS resolution.\n      - Checks the `DNS_CLIENT.DONE` flag:\n        - If `TRUE`, DNS resolution succeeds, and it transitions to State 60.\n        - If `DNS_CLIENT.ERROR` is greater than `0`, DNS resolution fails, logs the error code and type, and jumps to State 100.\n      - If DNS resolution is incomplete and no errors occur, it remains in State 40, continuing to wait.\n\n   - **State 60**:\n      - Calls the `HTTP_GET` instance to send an HTTP GET request.\n      - Checks the `HTTP_GET.DONE` flag:\n        - If `TRUE`, the HTTP request succeeds, and it transitions to State 80.\n        - If `HTTP_GET.ERROR` is greater than `0`, the HTTP request fails, logs the error code and type, and jumps to State 100.\n      - If the HTTP request is incomplete and no errors occur, it remains in State 60, continuing to wait.\n\n   - **State 80**:\n      - Parses the HTTP response body to extract the IP address.\n      - Initializes `st_ip` as an empty string and `p1` as `0`.\n      - Uses a `FOR` loop to scan the HTTP response body (from `HTTP_GET.BODY_START` to `HTTP_GET.BODY_STOP`) for a colon (`:`):\n        - If found, records its position in `p1` and exits the loop.\n      - Sets `p3` to `p1 + 15`, indicating a maximum of 15 characters after the colon.\n      - If `p1` is greater than `0` and `p3` is less than `HTTP_GET.BODY_STOP`, extracts the IP address from `p1` to `p3`:\n        - If the current character is not `<`, converts it to a string and appends it to `st_ip`.\n        - If `<` is encountered, exits the loop.\n      - Uses the `IP4_DECODE` function to convert `st_ip` into a DWORD-format IP address stored in `WAN_IP4`.\n      - Checks if `WAN_IP4` is valid (not `0`):\n        - If valid, sets `DONE` to `TRUE` (operation complete).\n        - If `WAN_IP4` differs from the previous `wan_ip4_last`, sets `NEW_IP4` to `TRUE` (new IP detected).\n        - Updates `wan_ip4_last` to the current `WAN_IP4`.\n        - If invalid, logs the error code and type.\n      - Finally, transitions to State 100.\n\n   - **State 100**:\n      - This is the final state. It checks the `HTTP_GET.DONE` flag:\n        - If `FALSE`, the HTTP request is incomplete; resets the state machine to State 0 and sets the `DONE` flag (if no errors).\n        - If `TRUE`, the HTTP request is complete; remains in State 100.\n      - The `UNLOCK_BUF` signal is activated here to release the buffer.\n\n-- REGION DNS_CLIENT Call\n   - In State 40, the `DNS_CLIENT` instance is called for DNS resolution with the following parameters:\n     - `IP_C`: IP control structure.\n     - `S_BUF`: Send buffer.\n     - `R_BUF`: Receive buffer.\n     - `DOMAIN`: Domain name from `URL_DATA`.\n     - `IP4_DNS`: DNS server IP (defaults to `0` for the system's DNS).\n     - `ACTIVATE`: Activated when the state is 40.\n\n-- REGION HTTP_GET Call\n   - In State 60, the `HTTP_GET` instance is called for the HTTP GET request with the following parameters:\n     - `IP_C`: IP control structure.\n     - `S_BUF`: Send buffer.\n     - `R_BUF`: Receive buffer.\n     - `IP4`: IP address from `DNS_CLIENT`.\n     - `GET`: Activated when the state is 60.\n     - `MODE`: HTTP request mode (`2` for GET).\n     - `UNLOCK_BUF`: Activated in State 100 to release the buffer.\n     - `URL_DATA`: URL data structure.\n\n-- REGION Activation Signal Tracking\n   - At the end of the function block, `activate_last` is updated to the current `ACTIVATE` signal value to detect rising edges in the next cycle.\n\n- Summary\nThis function block uses a state machine to manage DNS resolution and HTTP requests, extracting the WAN IPv4 address from a dynamic DNS service while handling errors. It is suitable for automated systems requiring external network IP address retrieval.", "name": "GET_WAN_IP"}