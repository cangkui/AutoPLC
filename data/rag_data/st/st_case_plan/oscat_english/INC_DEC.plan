Natural Language Requirements:  
{"variables": [], "instructions": [], "planning": "- Overview\nThis function block `INC_DEC` implements a simple increment/decrement counter. It detects changes in two input signals, `CHa` and `CHb`, to determine the counter's direction (increment or decrement) and updates the counter value `cnt` accordingly. Additionally, the counter can be reset using the `RST` signal.\n\n- Variable Definitions\nThe code defines the following types of variables:\n - Input variables: `CHa` and `CHb` are two input signals used to detect changes; `RST` is the reset signal, which resets the counter to 0.\n - Output variables: `dir` indicates the counter's direction (TRUE for increment, FALSE for decrement); `cnt` is the current counter value.\n - Internal variables: `edgea` and `edgeb` are used to detect edge changes in `CHa` and `CHb`; `clka` and `clkb` represent edge change signals for `CHa` and `CHb`; `clk` is the logical OR of `clka` and `clkb`, indicating a change in either input signal; `axb` is the XOR result of `CHa` and `CHb`, used to determine the counter's direction.\n\n- Main Logic Section\n-- REGION Detecting Input Signal Changes\n   This region uses XOR operations to detect edge changes in `CHa` and `CHb`, storing the results in `clka` and `clkb`. `edgea` and `edgeb` store the previous cycle's values of `CHa` and `CHb` for comparison with the current values. `clk` is the logical OR of `clka` and `clkb`, indicating a change in either input signal.\n   - `axb := cha XOR chb;`: Computes the XOR result of `CHa` and `CHb` to determine the counter's direction.\n   - `clka := cha XOR edgea;`: Detects edge changes in `CHa`.\n   - `edgea := cha;`: Stores the current value of `CHa` for comparison in the next cycle.\n   - `clkb := chb XOR edgeb;`: Detects edge changes in `CHb`.\n   - `edgeb := chb;`: Stores the current value of `CHb` for comparison in the next cycle.\n   - `clk := clka OR clkb;`: Detects a change in either input signal.\n\n-- REGION Determining Counter Direction\n   This region determines the counter's direction based on the values of `axb`, `clka`, or `clkb`.\n   - `IF axb AND clka THEN dir := TRUE; END_IF;`: If `axb` is TRUE and `clka` is TRUE, sets the direction to increment.\n   - `IF axb AND clkb THEN dir := FALSE; END_IF;`: If `axb` is TRUE and `clkb` is TRUE, sets the direction to decrement.\n\n-- REGION Updating Counter Value\n   This region updates the counter value `cnt` based on the counter's direction and the `clk` signal.\n   - `IF clk AND dir THEN cnt := cnt + 1; END_IF;`: If `clk` is TRUE and the direction is increment, increments the counter value by 1.\n   - `IF clk AND NOT dir THEN cnt := cnt -1; END_IF;`: If `clk` is TRUE and the direction is decrement, decrements the counter value by 1.\n\n-- REGION Resetting the Counter\n   This region resets the counter to 0 using the `RST` signal.\n   - `IF rst THEN cnt := 0; END_IF;`: If `RST` is TRUE, resets the counter value to 0.", "name": "INC_DEC"}