Natural Language Requirements:  
{"variables": [], "instructions": [], "planning": "- Overview\n  This code defines a function named `BYTE_OF_DWORD`, which extracts a specified byte from a 32-bit unsigned integer (DWORD). The function takes a 32-bit integer and a byte position as input and returns the corresponding byte value at that position.\n\n- Variable Definitions\n  The code defines two types of variables:\n  - Input variables: `in` is a 32-bit unsigned integer (DWORD) representing the value to be processed; `N` is a byte (BYTE) indicating the byte position to extract (0 to 3).\n  - Output variable: `BYTE_OF_DWORD` is a byte (BYTE) representing the extracted byte value from `in`.\n\n- Main Logic\n  -- REGION Byte Extraction Logic\n    This region implements the functionality to extract a specified byte from a DWORD. The steps are as follows:\n    1. First, shift `N` left by 3 bits (equivalent to multiplying by 8) to determine the number of right shifts needed. This is because each byte occupies 8 bits, so to extract the `N`-th byte, `in` must be right-shifted by `N * 8` bits.\n    2. Use the `SHR` function to right-shift `in` by the calculated number of bits, moving the target byte to the lowest 8 bits.\n    3. Use the `DWORD_TO_BYTE` function to convert the right-shifted result into a byte type, extracting the lowest 8 bits.\n    4. Assign the extracted byte value to the output variable `BYTE_OF_DWORD`.\n\n  Examples:\n  - If `in` is `0x12345678` and `N` is `1`, right-shifting by 8 bits yields `0x00123456`, and the extracted byte value is `0x56`.\n  - If `N` is `0`, no shifting occurs, and the extracted byte value is `0x78`.\n\n- Output\n  The function outputs `BYTE_OF_DWORD`, which is the byte value extracted from the specified position in the input DWORD.", "name": "BYTE_OF_DWORD"}