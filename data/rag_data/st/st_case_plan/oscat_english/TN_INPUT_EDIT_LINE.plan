Natural Language Requirements:  
{"variables": [], "instructions": [], "planning": "- Overview\n  The function block `TN_INPUT_EDIT_LINE` is designed to handle text input line editing operations, including character insertion, deletion, cursor movement, and more. It also supports input masking, hidden input (e.g., password entry), and text display updates. This function block operates by manipulating input control data (`Xus_TN_INPUT_CONTROL_DATA`) and writes the results to the screen (`Xus_TN_SCREEN`).\n\n- Variable Definitions\n  The code defines the following types of variables:\n  - Input variables: `in_count`, `in_Count_End`, `in_CursorOffset`, etc., used for counting and cursor position control.\n  - Control data variables: `Xus_TN_INPUT_CONTROL_DATA` contains relevant input control information, such as cursor position, input data, input mask, attributes, etc.\n  - Screen variables: `Xus_TN_SCREEN` stores screen data.\n  - Function block instances: `FB_TN_SC_WRITE` is used to write text to the screen.\n  - Temporary variables: `st_CHAR`, `st_String`, etc., store temporary characters and strings.\n\n- Main Logic\n  -- REGION Initialization\n     First, `in_CursorOffset` is initialized to 0. This variable records the cursor movement offset. Then, it checks whether `Xus_TN_INPUT_CONTROL_DATA.bo_Focus` is TRUE, indicating whether the input line currently has focus. If it does, input operations are processed.\n\n  -- REGION Character Input Handling\n     If the input line has focus and a new ASCII character is input (`Xus_TN_INPUT_CONTROL_DATA.by_Input_ASCII_Code > 0`), it further checks whether the character is allowed:\n     - If `bo_Input_Only_Num` is TRUE and `bo_Input_ASCII_IsNum` is TRUE, only numeric input is allowed, and the current input is a number.\n     - If `bo_Input_Only_Num` is FALSE, any character input is allowed.\n     If allowed, the character is converted to a string (`st_CHAR`) and inserted into the input data at the current cursor position (`Xus_TN_INPUT_CONTROL_DATA.in_Cursor_Pos`) using the `REPLACE` function. `in_CursorOffset` is set to 1, indicating the cursor moves right by one position. The input display update flag is also set (`Xus_TN_INPUT_CONTROL_DATA.bo_Update_Input = TRUE`).\n\n  -- REGION Extended Key Handling\n     Based on the value of `Xus_TN_INPUT_CONTROL_DATA.by_Input_Exten_Code`, extended key inputs are processed:\n     - 67 (Right Arrow): Moves the cursor right by one position, setting `in_CursorOffset` to 1.\n     - 68 (Left Arrow): Moves the cursor left by one position, setting `in_CursorOffset` to -1.\n     - 08 (Backspace): Deletes the character before the cursor. The `REPLACE` function replaces the character at the cursor position with a space, and the cursor moves left by one position (`in_CursorOffset = -1`). The input display update flag is also set.\n     - 13 (Enter Key): If an input mask (`st_Input_Mask`) exists (length > 0), the current input data is saved to `st_Input_String`, with leading/trailing spaces trimmed (using the `TRIME` function). The input completion flag is set (`bo_Input_Entered = TRUE`), and the input data is reset to the input mask. The cursor is then moved to the first non-space character of the input mask. If the first character is not a space, `in_CursorOffset` is set to 1, indicating the cursor moves right by one position.\n\n  -- REGION Cursor Position Adjustment\n     The cursor position is adjusted based on `in_CursorOffset`:\n     - If `in_CursorOffset > 0`, the cursor moves right. Starting from the current cursor position (`in_Cursor_Pos + 1`), it searches right for the next space character. If found, the cursor moves there, and the input display update flag is set. If not found, the cursor position remains unchanged.\n     - If `in_CursorOffset < 0`, the cursor moves left. Starting from the current cursor position (`in_Cursor_Pos - 1`), it searches left for the previous space character. If found, the cursor moves there, and the input display update flag is set. If not found, the cursor position remains unchanged.\n     If the cursor position exceeds the input data length or is less than 1, it is adjusted to a valid range:\n     - If the cursor position is greater than the input data length, it is set to the input data length.\n     - If the cursor position is less than 1, it is set to 1.\n\n  -- REGION Input Display Update\n     If the input display needs updating (`Xus_TN_INPUT_CONTROL_DATA.bo_Update_Input = TRUE`) or all displays need updating (`Xus_TN_INPUT_CONTROL_DATA.bo_Update_All = TRUE`), the following actions are performed:\n     - If `bo_Update_All` is TRUE, the title display is updated. The title position is determined by `in_Title_X_Offset` and `in_Title_Y_Offset`:\n       - If both offsets are 0, the title is displayed to the left of the input line.\n       - Otherwise, the title is displayed at the specified offset.\n       The `FB_TN_SC_WRITE` function block writes the title string to the screen.\n     - If the input is hidden (`bo_Input_Hidden = TRUE`), non-mask characters in the input data are replaced with `*` to hide the actual input. The process is as follows:\n       - If the input data length matches the input mask length, the input data is traversed:\n         - If the mask character is a space, the corresponding input data character is checked. If it is a space, it is retained; otherwise, it is replaced with `*`.\n         - If the mask character is not a space, the input data character is retained.\n     - If the input is not hidden, the input data is displayed directly.\n     - Depending on whether the input line has focus, the corresponding attribute (`by_Attr_mF` or `by_Attr_oF`) is used to display the input data.\n     - The `FB_TN_SC_WRITE` function block writes the input data to the screen, and the cursor position (`in_Cursor_Y` and `in_Cursor_X`) is updated.\n     - Finally, `bo_Update_All` and `bo_Update_Input` are reset to FALSE, indicating the update is complete.", "name": "TN_INPUT_EDIT_LINE"}