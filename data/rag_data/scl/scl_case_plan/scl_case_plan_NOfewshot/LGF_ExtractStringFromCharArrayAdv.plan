

以下是基于需求与代码分析的算法流程描述：

```
1. 初始化阶段
   - 校验输入数组有效性：
     * 若非数组或元素类型非Char/Byte → 置ERR_NO_ARRAY并返回
   - 设置初始值：
     * position = -1, length = 0, 清空extractedString
     * 计算textBefore/textAfter的预存长度

2. 主处理循环（REPEAT结构）
   a. 数组分段转字符串：
     * 从当前tempPosInArray起始
     * 取min(数组剩余长度, 254)字符转临时字符串
   
   b. 前导文本搜索：
     * 在临时字符串中查找textBefore
     * 未找到 → 移动搜索起点（考虑textBefore长度防截断）
     * 找到 → 根据includeBeforeAfter调整起始点：
       √ 包含前后文本 → 起点设为textBefore起始位置
       √ 不包含 → 起点设为textAfter结束位置

   c. 后导文本处理：
     * 从新起点再次转换字符串
     * 搜索textAfter：
       √ 找到 → 计算最终长度和位置
       √ 未找到 → 提取剩余字符串，置部分找到警告
   
3. 终止条件：
   - 找到前后文本 → 设置成功状态，返回提取结果
   - 搜索位置超出数组长度 → 置未找到警告退出
   - 仅找到前导文本 → 置部分找到警告

4. 状态码映射：
   - 16#0000: 完全成功
   - 16#8200: 输入非法数组
   - 16#9001: 找到前导未找到后导
   - 16#9002: 完全未找到
```

关键调整点说明：
1. 采用分段处理策略（254字符/次）优化大数组处理
2. 搜索位置移动时保留(textBefore长度-1)字符防止跨段匹配丢失
3. 包含前后文本的标记处理贯穿始终，影响：
   - 起始位置计算
   - 最终提取长度计算
   - 结果字符串的截取范围

该流程保持与原始代码结构一致，但抽象出核心处理逻辑，适用于指导不同编程语言的实现。