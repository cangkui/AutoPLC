

### 算法流程思维链总结

---

#### **核心逻辑调整思路**
1. **操作优先级**：复位操作具有最高优先级（立即重置指针），push/pop在同一扫描周期内按顺序处理
2. **最小值处理策略**：采用即时查找模式，每次pop时遍历当前所有元素寻找最小值位置，避免维护辅助栈
3. **数组操作特性**：删除中间元素时需要前移后续元素，保持数组连续性

---

#### **详细执行流程**

**1. 初始化配置**
```sccl
设置栈容量常量 = 4
初始化栈指针 = 0
错误状态默认值 = FALSE
状态码默认值 = 16#0000
```

**2. 操作处理顺序**
```
复位 → Push → Pop → 状态更新
```

**3. 复位操作**
```sccl
IF reset上升沿 THEN
   栈指针归零（物理保留数组数据）
   保持原数组元素（实际使用时被后续操作覆盖）
```

**4. Push操作**
```sccl
IF push触发 AND 栈指针 < 4 THEN
   stack[当前指针] = 输入值
   指针自增
ELSE IF 栈已满
   设置错误状态 = TRUE
   状态码 = 16#8A04
   立即返回（跳过后续操作）
```

**5. Pop操作**
```sccl
IF pop触发 THEN
   |-- 空栈检查 --
   IF 栈指针 = 0
      设置错误状态 = TRUE
      状态码 = 16#8A05
      立即返回
   
   |-- 最小值定位 --
   初始化min_index=0
   FOR i=1 TO 栈指针-1:
       IF stack[i] < stack[min_index]
          更新min_index
   
   |-- 元素移除策略 --
   保存返回值 = stack[min_index]
   IF min_index不在栈顶:
      前移后续元素（从min_index到栈顶-1）
   置空原栈顶位置为0
   指针自减
```

**6. 边界条件处理**
```sccl
每次操作后：
   IF 未触发任何错误
      重置error = FALSE
      状态码 = 16#0000
   ELSE
      保持错误状态直到下次有效操作
```

---

#### **关键设计决策**
1. **空间效率优先**：牺牲O(n)时间复杂度换取不增加额外存储空间（相比维护最小栈的O(1)时间复杂度方案）
2. **数据残留处理**：pop时将被删除位置后的元素前移，但原栈顶位置置零（可视需求改为保留数据）
3. **非原子操作影响**：在元素前移过程中若发生中断，可能导致数据不一致（需考虑实际应用场景的可靠性要求）

---

#### **潜在优化方向**
1. **最小值缓存**：在push时记录历史最小值位置，减少pop时的遍历开销
2. **循环栈实现**：允许栈顶回绕以提升空间利用率
3. **批量操作支持**：增加多元素push/pop接口
4. **动态扩容**：添加自动扩展栈容量机制

此流程描述已根据实际代码实现调整，重点关注了数组操作特性和状态管理逻辑，可作为后续代码维护或功能扩展的基础框架。