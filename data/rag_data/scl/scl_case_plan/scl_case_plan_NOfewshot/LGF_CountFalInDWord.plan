

### 算法流程描述（基于代码逻辑调整）

#### **核心思想**  
通过逐位检测相邻bit的1→0跳变，并跨周期处理DWORD首尾bit的连续性跳变。

---

#### **步骤分解**

1. **初始化阶段**  
   - 清零临时计数器 `tempCount`
   - 将输入值 `value` 复制到临时变量 `tempDWord`

2. **跨周期边界检测**  
   - 检查上一次保存的DWORD最低位(`statDWordPrevCycle.%X0`)与当前DWORD最高位(`tempDWord.%X31`)是否构成1→0跳变
   - 如果成立，计数器加1

3. **循环检测内部跳变**  
   - **循环31次**（覆盖DWORD所有相邻bit对）：
     - 检查当前bit(`%X0`)与右侧相邻bit(`%X1`)是否构成1→0跳变
     - 如果成立，计数器加1
     - 将DWORD右移1位（通过`SHR`指令）

4. **保存当前状态**  
   - 将当前输入值 `value` 存入 `statDWordPrevCycle` 用于下一周期检测

5. **输出结果**  
   - 将最终计数值写入 `numberOfEdges`

---

#### **关键设计要点**  
- **跨周期处理**：通过比较当前周期最高位与上一周期最低位，实现环形边界检测
- **高效移位**：使用SHR指令代替逐位操作，优化执行效率
- **内存优化**：仅保留必要状态变量`statDWordPrevCycle`，避免冗余存储
- **位序约定**：假设DWORD位序为%X0（最低位）到%X31（最高位）

---

#### **预期行为示例**  
当输入值 `value` 的二进制序列为：  
`1110 1101 0011 0101 1110 1101 0011 0101`  
算法将检测所有形如`1`后紧跟`0`的相邻bit对，并累计到输出值中。