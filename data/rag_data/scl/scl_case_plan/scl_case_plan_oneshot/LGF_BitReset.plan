### 算法流程描述：DWORD位复位操作（LGF_BitReset）

#### 1. **功能概述**
- **目标**：在DWORD类型变量中复位（清零）指定位置的位。
- **输入**：
  - `value`：待操作的DWORD值
  - `bitNo`：需要复位的位序号（0~31）
- **输出**：返回复位指定位后的DWORD值。

#### 2. **核心逻辑**
1. **输入验证**（隐式）：
   - 通过`bitNo MOD 32`自动处理超范围位号（如`bitNo=35`会被映射为`3`）。
2. **位复位操作**：
   - **步骤1**：生成掩码  
     通过`SHL`左移指令将`0x0001`（二进制`1`）移动到`bitNo`指定的位置。  
     例如：`bitNo=3` → `0x0001 << 3 = 0x0008`（二进制`1000`）。
   - **步骤2**：取反掩码  
     用`BINARY_ONES（0xFFFFFFFF） XOR 掩码`得到复位掩码。  
     例如：`0xFFFFFFFF XOR 0x0008 = 0xFFFFFFF7`（第3位为0，其余为1）。
   - **步骤3**：应用掩码  
     将原值与复位掩码按位与（`AND`），清零目标位。  
     公式：`result = value AND (0xFFFFFFFF XOR (1 << bitNo))`。

#### 3. **代码优化点**
- **常量预定义**：使用`BINARY_ONES`和`TRUE_BOOL_BIT`提升可读性。
- **自动位号循环**：`bitNo MOD 32`确保任何输入均有效。
- **无错误处理**：假设输入合法，直接设置`ENO=TRUE`。

#### 4. **扩展性说明**
- **兼容性**：通过类型转换可支持`WORD`/`BYTE`（需调用`DWORD_TO_BYTE`等）。
- **性能**：单条位运算指令实现，无循环或分支。

#### 5. **调整建议**
- 若需严格验证`bitNo`范围，可增加以下逻辑（但当前设计已通过取模覆盖）：
  ```scala
  IF #bitNo >= 32 THEN 
      ENO := FALSE; // 可选错误标记
      RETURN #value; // 返回原值
  END_IF;
  ```

#### 6. **示例流程**
- **输入**：`value=0xFFFF（全1）`, `bitNo=4`
- **执行**：
  1. `1 << 4` → `0x10`
  2. `0xFFFFFFFF XOR 0x10` → `0xFFFFFFEF`
  3. `0xFFFF AND 0xFFFFFFEF` → `0xFFEF`
- **输出**：`0xFFEF`（第4位清零）