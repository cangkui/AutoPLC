### 算法流程描述（用于检测系统字节序）

#### 1. 功能目标
- 检测当前系统的字节序（大端序或小端序）
- 返回布尔值：TRUE表示大端序，FALSE表示小端序

#### 2. 核心原理
- **字节序检测方法**：通过检查多字节数据在内存中的存储方式来判断
- **实现策略**：
  - 创建一个特定的位模式（0x0001）
  - 将该位模式左移15位（对于16位字），使其最高位为1
  - 检查最低字节的值：
    - 如果最低字节非零 → 小端序（因为高位字节存储在低地址）
    - 如果最低字节为零 → 大端序（因为高位字节存储在高地址）

#### 3. 变量定义
- **临时变量**：
  - `tempSixteenBits`：用于存储位模式的16位字
- **常量**：
  - `BIT_PATTERN_ONE`：初始位模式（0x0001）
  - `MOVE_BIT_POS`：位移量（15位）

#### 4. 算法流程
1. **准备位模式**：
   - 将`BIT_PATTERN_ONE`左移15位，结果存入`tempSixteenBits`
   - （此时若为大端序，最低字节应为0；小端序则不为0）

2. **检测字节序**：
   - 检查`tempSixteenBits`的最低字节（`.%B0`）
   - 判断条件：`最低字节 ≠ 0x00` → 小端序（返回FALSE）
   - 否则 → 大端序（返回TRUE）

3. **设置执行状态**：
   - `ENO := TRUE` 表示函数执行成功

#### 5. 代码调整建议
- **可读性增强**：
  ```iecst
  // 更清晰的返回逻辑（与原始代码等效但更易读）
  #LGF_IsBigEndian := #tempSixteenBits.%B0 = B#16#00;
  ```
- **注释补充**：
  ```iecst
  // 在大端系统中，左移后的0x8000存储为[0x80, 0x00]，故%B0=0
  // 在小端系统中，存储为[0x00, 0x80]，故%B0≠0
  ```

#### 6. 注意事项
- 该方法基于16位字检测，适用于PLC的WORD类型
- 在S7-1200/1500系统中，实际总是返回FALSE（因为均为小端架构），但保留了检测逻辑的通用性
- 常量`MOVE_BIT_POS`的值15对应16位字的最高位（0-based索引）

> 注：原始代码通过`<> B#16#00`实现反向逻辑，直接返回大端序检测结果，这种实现虽然简洁但需要理解底层原理才能快速读懂。