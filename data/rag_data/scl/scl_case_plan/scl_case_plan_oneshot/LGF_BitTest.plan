### 算法流程描述

#### 1. **功能概述**
该函数 `LGF_BitTest` 用于检查一个 DWord 类型变量中指定位置的比特位是 `TRUE`（1）还是 `FALSE`（0）。  
输入参数：
- `value`：待检查的 DWord 变量。
- `bitNo`：需要检查的比特位序号（0~31）。  

输出：
- 返回值为 `Bool` 类型，表示指定比特位的状态。

#### 2. **核心逻辑**
1. **比特位范围检查**：
   - DWord 类型有 32 个比特位（0~31），因此 `bitNo` 的有效范围是 0~31。
   - 使用 `bitNo MOD 32` 确保 `bitNo` 在有效范围内（即使输入超出范围也能正确计算）。

2. **比特位检查方法**：
   - 使用 `SHL`（左移）操作将 `1`（`TRUE_BOOL_BIT`）移动到 `bitNo` 指定的位置。
   - 使用 `AND` 逻辑运算检查 `value` 在该比特位是否为 `1`：
     - 如果 `value AND (1 << bitNo) != 0`，则该比特位为 `1`，返回 `TRUE`。
     - 否则返回 `FALSE`。

3. **错误处理**：
   - 无显式错误处理，但通过 `MOD` 运算确保 `bitNo` 始终有效。
   - `ENO` 始终设为 `TRUE`，表示函数执行成功。

#### 3. **代码流程**
1. **输入参数**：
   - `value`：待检查的 DWord 变量。
   - `bitNo`：比特位序号（0~31）。

2. **常量定义**：
   - `BINARY_ZERO`：DWord 类型的 `0`，用于比较。
   - `TRUE_BOOL_BIT`：DWord 类型的 `1`，用于左移操作。
   - `MAX_NO_OF_BITS`：DWord 的比特位数（32）。

3. **核心计算**：
   - 计算 `SHL(IN := 1, N := bitNo MOD 32)`，将 `1` 左移到 `bitNo` 位置。
   - 计算 `value AND (1 << bitNo)`，检查该比特位是否为 `1`。
   - 比较结果是否不等于 `0`，返回 `TRUE` 或 `FALSE`。

4. **输出**：
   - 返回 `TRUE` 或 `FALSE`，表示指定比特位的状态。

#### 4. **调整建议**
- **输入验证**：如果 `bitNo` 可能超出 0~31 范围，建议增加警告或日志（但当前逻辑已通过 `MOD` 处理）。
- **性能优化**：当前逻辑已足够高效，无需额外优化。
- **扩展性**：该函数也可用于 `Word`（16 位）或 `Byte`（8 位）类型，只需转换输入参数类型。

### 最终逻辑表达式
```scala
#LGF_BitTest := (#value AND SHL(IN := 1, N := (#bitNo MOD 32))) != 0;
```