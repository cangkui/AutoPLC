{
    "R_TRIG": {
        "instruction_name": "R_TRIG",
        "parameters": {
            "Input": [
                {
                    "name": "CLK",
                    "type": "BOOL",
                    "description": "Edge signal to detect the transition of this signal."
                }
            ],
            "Output": [
                {
                    "name": "Q",
                    "type": "BOOL",
                    "description": "Result of edge detection."
                }
            ]
        },
        "example_code": "VAR\nR_TRIG_DB:R_TRIG;\nEND_VAR \nBEGIN\nR_TRIG_DB(CLK := TagIn, Q => TagOut);\nThe R_TRIG type variable R_TRIG_DB needs to be defined in the VAR...END_VAR area. The previous state of the variable in input CLK is stored in the \"R_TRIG_DB\" variable. If the signal state of \"TagIn\" is detected to change from \"0\" to \"1\", then the signal state in \"TagOut\" will be \"1\" for one cycle.",
        "additional_info": "None.",
        "brief_description": "The function detects the rising edge of the input signal; when the input CLK changes from \"0\" to \"1\", a rising edge signal is generated in the output Q. It can be applied in scenarios where detecting the rising edge changes of a signal is needed."
    },
    "F_TRIG": {
        "instruction_name": "F_TRIG",
        "parameters": {
            "Input": [
                {
                    "name": "CLK",
                    "type": "BOOL",
                    "description": "Arrival signal to query the edge of this signal."
                }
            ],
            "Output": [
                {
                    "name": "Q",
                    "type": "BOOL",
                    "description": "Result of edge detection."
                }
            ]
        },
        "example_code": "VAR\nF_TRIG_DB:F_TRIG;\nEND_VAR \nBEGIN\nF_TRIG_DB(CLK := TagIn, Q => TagOut);\nF_TRIG type variable F_TRIG_DB must be defined in the VAR...END_VAR area. The previous state of the variable in input CLK is stored in the variable 'F_TRIG_DB'. If a signal state change from '1' to '0' is detected for 'TagIn', then the signal state of 'TagOut' will be '1' for one cycle.",
        "additional_info": "After the CPU starts, if the value of input 'CLK' is FALSE, then 'F_TRIG' will set the output 'Q' to TRUE and hold it for one cycle.",
        "brief_description": "The function detects the state change of input CLK from '1' to '0' and generates a falling edge signal in output Q, which can be applied in scenarios where detecting the falling edge of a signal is necessary for appropriate processing."
    },
    "TP": {
        "instruction_name": "TP",
        "parameters": {
            "Input": [
                {
                    "name": "IN",
                    "type": "BOOL",
                    "description": "Start input."
                },
                {
                    "name": "PT",
                    "type": "TIME",
                    "description": "Duration of the pulse."
                }
            ],
            "Output": [
                {
                    "name": "Q",
                    "type": "BOOL",
                    "description": "The output remains set for the duration of PT."
                },
                {
                    "name": "ET",
                    "type": "TIME",
                    "description": "The current value of the timer."
                }
            ]
        },
        "example_code": "VAR\nTP_DB:TP_TIME;\nEND_VAR \nBEGIN\n TP_DB(IN := Start, PT := PresetTime, Q => Status, ET => ElapsedTime); The variable TP_DB of type TP_TIME needs to be defined in the VAR...END_VAR area. When the 'Start' signal rises, the PT preset time starts timing, and 'Status' is set to '1'. The current time value is stored in 'ElapsedTime'.",
        "additional_info": "Each time the 'Generate Pulse' instruction is called, an IEC timer is allocated to store instance data.",
        "brief_description": "The function generates a pulse with a duration of PT based on the rising edge of the input signal IN, setting output Q to 1 until PT time elapses and automatically resets. It also monitors the current timer value ET. This can be applied in scenarios where control of specific time pulse signals is needed."
    },
    "TON": {
        "instruction_name": "TON",
        "parameters": {
            "Input": [
                {
                    "name": "IN",
                    "type": "BOOL",
                    "description": "Start input."
                },
                {
                    "name": "PT",
                    "type": "TIME",
                    "description": "Duration of the on-delay."
                }
            ],
            "Output": [
                {
                    "name": "Q",
                    "type": "BOOL",
                    "description": "The output that remains set when the timer PT time has expired."
                },
                {
                    "name": "ET",
                    "type": "TIME",
                    "description": "The current value of the timer."
                }
            ]
        },
        "example_code": "VAR\nTON_DB:TON_TIME;\nEND_VAR \nBEGIN\n TON_DB(IN := Start, PT := PresetTime, Q => Status, ET => ElapsedTime); \nYou need to define a variable TON_DB of type TON_TIME in the VAR...END_VAR area. When the 'Start' signal rises, the PT preset time starts counting. After the time period expires, 'Status' is set to '1'. As long as 'Start' is '1', 'Status' remains set. The current time value is stored in 'ElapsedTime'.",
        "additional_info": "Each time the 'on-delay' instruction is called, it must be assigned to an IEC timer that stores instance data.",
        "brief_description": "The function of 'on-delay' can be applied in scenarios where a timer is started on the rising edge of an input signal, and an output parameter is set after the specified delay time."
    },
    "TOF": {
        "instruction_name": "TOF",
        "parameters": {
            "Input": [
                {
                    "name": "IN",
                    "type": "BOOL",
                    "description": "Start input."
                },
                {
                    "name": "PT",
                    "type": "TIME",
                    "description": "Duration of the off-delay."
                }
            ],
            "Output": [
                {
                    "name": "Q",
                    "type": "BOOL",
                    "description": "Output that resets after the time PT."
                },
                {
                    "name": "ET",
                    "type": "TIME",
                    "description": "Current value of the timer."
                }
            ]
        },
        "example_code": "VAR\nTOF_DB:TOF_TIME;\nEND_VAR \nBEGIN\n TOF_DB(IN := Start, PT := PresetTime, Q => Status, ET => ElapsedTime); // TOF_TIME type variable TOF_DB must be defined in VAR...END_VAR area. The 'Status' is set when the 'Start' signal rises. When 'Start' becomes '0', the preset time PT starts counting. After the time ends, 'Status' resets. The current timer value is stored in 'ElapsedTime.'",
        "additional_info": "Each call to the 'off-delay' instruction must be assigned to an IEC timer that stores instance data.",
        "brief_description": "The function starts the output on the rising edge of the input signal and begins timing when the input signal changes to '0'. After the preset time is reached, it resets the output while also allowing access to the current timer value. This can be used in scenarios where a response to an input signal is needed, followed by an automatic reset of the output after a certain time."
    },
    "TONR": {
        "instruction_name": "TONR",
        "parameters": {
            "Input": [
                {
                    "name": "IN",
                    "type": "BOOL",
                    "description": "Start input."
                },
                {
                    "name": "R",
                    "type": "BOOL",
                    "description": "Reset parameters ET and Q."
                },
                {
                    "name": "PT",
                    "type": "TIME",
                    "description": "Maximum duration for time recording."
                }
            ],
            "Output": [
                {
                    "name": "Q",
                    "type": "BOOL",
                    "description": "Operand that remains set when the time within the timer PT has expired."
                },
                {
                    "name": "ET",
                    "type": "TIME",
                    "description": "Accumulated time."
                }
            ]
        },
        "example_code": "VAR\nTONR_DB:TONR_TIME;\nEND_VAR \nBEGIN\nTONR_DB(IN := Start, R := Reset, PT := PresetTime, Q => Status, ET => Time);  You need to define the variable TONR_DB of type TONR_TIME in the VAR...END_VAR area. When the 'Start' signal rises, the PT preset time begins to count. The accumulated time value will be stored in 'Time'. When the specified time value of PT is reached, 'Status' is set to '1'.",
        "additional_info": "Each time the 'time accumulator' instruction is called, an IEC timer must be allocated to store instance data.",
        "brief_description": "This function uses a time accumulator to accumulate time values over a specified period; as long as the state of the start input signal is '1', time accumulation will occur. It can be used in scenarios where recording of accumulated time values is needed."
    },
    "RESET_TIMER": {
        "instruction_name": "RESET_TIMER",
        "parameters": {
            "Output": [
                {
                    "name": "<IEC Timer>",
                    "type": "IEC_TIMER, TP_TIME, TON_TIME, TOF_TIME, TONR_TIME",
                    "description": "The IEC timer to be reset."
                }
            ]
        },
        "example_code": "IF #started = false THEN TON_DB.TON(IN := Start, PT := PresetTime, Q => Status, ET => ElapsedTime); #started := true; END_IF; IF TON_DB.ET < T#25s THEN RESET_TIMER(TIMER := TON_DB); #started := false; END_IF; When the variable #started is '0', the 'on-delay' instruction is executed. If the elapsed time of the IEC timer 'TON_DB' is less than 25s, the 'reset timer' instruction is executed, resetting the timer stored in the background data block 'TON_DB'.",
        "additional_info": "Reinitializing the actual value of the IEC timer while it is running may compromise the function of the IEC timer, potentially leading to inconsistencies between the program and the actual process.",
        "brief_description": "The function resets the specified IEC timer to '0', applicable in scenarios where the IEC timer needs to be reinitialized, for example, when the current time of the timer is less than a specific threshold, necessitating a reset to restart timing."
    },
    "PRESET_TIMER": {
        "instruction_name": "PRESET_TIMER",
        "parameters": {
            "Input": [
                {
                    "name": "<Duration>",
                    "type": "TIME",
                    "description": "The duration for which the IEC timer will run."
                }
            ],
            "Output": [
                {
                    "name": "<IEC Timer>",
                    "type": "IEC_TIMER, TP_TIME, TON_TIME, TOF_TIME, TONR_TIME",
                    "description": "The IEC timer that is set with the specified duration."
                }
            ]
        },
        "example_code": "IF #started = false THEN TON_DB.TON(IN := Start, PT := PresetTime, Q => Status, ET => ElapsedTime); #started := true; #preset := true END_IF; IF TON_DB.ET < T#10s AND #preset = true THEN PRESET_TIMER(PT := T#25s, TIMER := TON_DB); #preset := false; END_IF; When the variable #started is '0', execute 'power on ...'",
        "additional_info": "If the specified IEC timer is counting when the instruction is executed, the instruction will override the current value of the specified IEC timer.",
        "brief_description": "This function sets a time for the IEC timer. If the result of the input logical operation is '1', this instruction is executed every cycle. It can be applied in scenarios where there is a need to reset or preset the timer duration."
    },
    "S_PULSE": {
        "instruction_name": "S_PULSE",
        "parameters": {
            "Input": [
                {
                    "name": "T_NO",
                    "type": "TIMER, INT",
                    "description": "The timer that has been started. The number of timers depends on the CPU."
                },
                {
                    "name": "S",
                    "type": "BOOL",
                    "description": "Start input."
                },
                {
                    "name": "TV",
                    "type": "S5TIME, WORD",
                    "description": "Preset time value."
                },
                {
                    "name": "R",
                    "type": "BOOL",
                    "description": "Reset input."
                }
            ],
            "Output": [
                {
                    "name": "Q",
                    "type": "BOOL",
                    "description": "Status of the timer."
                },
                {
                    "name": "BI",
                    "type": "WORD",
                    "description": "Current binary-coded time value."
                }
            ]
        },
        "example_code": "Result := S_PULSE(T_NO := Timer_1, S := 1, TV := Number, R := Reset, Q => Status, BI => Value); When the operand '1' has a rising edge, 'Timer_1' starts. It uses the 'Number' time value for decrementing until the state of '1' returns to '1'.",
        "additional_info": "None.",
        "brief_description": "The function starts a specified timer and begins timing for a preset duration when it detects a logical change of the parameter S from '0' to '1'. It can be applied in scenarios that require edge detection of signals and timing control."
    },
    "S_PEXT": {
        "instruction_name": "S_PEXT",
        "parameters": {
            "Input": [
                {
                    "name": "T_NO",
                    "type": "TIMER, INT",
                    "description": "The initiated timer. The number of timers depends on the CPU."
                },
                {
                    "name": "S",
                    "type": "BOOL",
                    "description": "Start signal."
                },
                {
                    "name": "TV",
                    "type": "S5TIME, WORD",
                    "description": "Preset time value."
                },
                {
                    "name": "R",
                    "type": "BOOL",
                    "description": "Reset input."
                }
            ],
            "Output": [
                {
                    "name": "Q",
                    "type": "BOOL",
                    "description": "Timer status."
                },
                {
                    "name": "BI",
                    "type": "WORD",
                    "description": "Current binary-coded time value."
                }
            ]
        },
        "example_code": "Result := S_PEXT(T_NO := Timer_1, S := 1, TV := Number, R := Reset, Q => Status, BI => Value); When the signal status of 'Timer_1' changes from '0' to '1', '1' starts. When the timer is running, 'Status' returns signal status '1'. When the preset time is reached, 'Status' resets to '0'.",
        "additional_info": "None.",
        "brief_description": "The function detects the rising edge of parameter S's signal and starts the timer, which stops after running for the preset time TV. It can be applied in scenarios that require detection of the rising edge of a signal and delaying for a period of time."
    },
    "S_ODT": {
        "instruction_name": "S_ODT",
        "parameters": {
            "Input": [
                {
                    "name": "T_NO",
                    "type": "TIMER, INT",
                    "description": "The timer that has been started. The number of timers depends on the CPU."
                },
                {
                    "name": "S",
                    "type": "BOOL",
                    "description": "Start input."
                },
                {
                    "name": "TV",
                    "type": "S5TIME, WORD",
                    "description": "Preset time value."
                },
                {
                    "name": "R",
                    "type": "BOOL",
                    "description": "Reset input."
                }
            ],
            "Output": [
                {
                    "name": "Q",
                    "type": "BOOL",
                    "description": "Status of the timer."
                },
                {
                    "name": "BI",
                    "type": "WORD",
                    "description": "Current binary encoded time value."
                }
            ]
        },
        "example_code": "Result := S_ODT(T_NO := Timer_1, S := 1, TV := Number, R := Reset, Q => Status, BI => Value); When the signal state of 'Timer_1' changes from '0' to '1', it starts. As long as the signal state of '1' remains '1', the timer will count for the duration 'Number'.",
        "additional_info": "None.",
        "brief_description": "The function starts the preset timer upon detecting a rising edge in the signal of parameter S, acting as a delay timer. It can be applied in scenarios requiring delayed control, such as delay control in automation devices."
    },
    "S_ODTS": {
        "instruction_name": "S_ODTS",
        "parameters": {
            "Input": [
                {
                    "name": "T_NO",
                    "type": "TIMER、INT",
                    "description": "The timer that has been started. The number of timers depends on the CPU."
                },
                {
                    "name": "S",
                    "type": "BOOL",
                    "description": "Start input."
                },
                {
                    "name": "TV",
                    "type": "S5TIME、WORD",
                    "description": "Preset time value."
                },
                {
                    "name": "R",
                    "type": "BOOL",
                    "description": "Reset input."
                }
            ],
            "Output": [
                {
                    "name": "Q",
                    "type": "BOOL",
                    "description": "The state of the timer."
                },
                {
                    "name": "BI",
                    "type": "WORD",
                    "description": "The current binary coded time value."
                }
            ]
        },
        "example_code": "Result := S_ODTS(T_NO := Timer_1, S := 1, TV := Number, R := Reset, Q => Status, BI => Value); When the signal state of 'Timer_1' changes from '0' to '1', the timer starts. The run time of the timer is 'Number'. If the timer reaches the preset time, 'Status' will return the signal state '1', regardless of the state of '1'.",
        "additional_info": "None.",
        "brief_description": "The function starts the timer upon detecting a rising edge of the parameter S signal and assigns parameters for a holding contact delay timer. It can be applied in scenarios where it is necessary to detect the rising edge of a signal and start a timer."
    },
    "S_OFFDT": {
        "instruction_name": "S_OFFDT",
        "parameters": {
            "Input": [
                {
                    "name": "T_NO",
                    "type": "TIMER, INT",
                    "description": "The timer that has been started. The number of timers depends on the CPU."
                },
                {
                    "name": "S",
                    "type": "BOOL",
                    "description": "Start input."
                },
                {
                    "name": "TV",
                    "type": "S5TIME, WORD",
                    "description": "Preset time value."
                },
                {
                    "name": "R",
                    "type": "BOOL",
                    "description": "Reset input."
                }
            ],
            "Output": [
                {
                    "name": "Q",
                    "type": "BOOL",
                    "description": "The status of the timer."
                },
                {
                    "name": "BI",
                    "type": "WORD",
                    "description": "The current binary encoded time value."
                }
            ]
        },
        "example_code": "Result := S_OFFDT(T_NO := Timer_1, S := 1, TV := Number, R := Reset, Q => Status, BI => Value); If the state of signal '1' changes from '1' to '0', the 'Timer_1' timer will be started. The running time of the timer is 'Number'. As long as the timer is timing or '1' returns the signal state '1', the signal state of 'Status' will be '1'.",
        "additional_info": "None.",
        "brief_description": "The function detects the falling edge of the signal parameter S to start the preset timer, which can be applied in scenarios requiring delay control triggered by the falling edge of the signal."
    },
    "CTU": {
        "instruction_name": "CTU",
        "parameters": {
            "Input": [
                {
                    "name": "CU",
                    "type": "BOOL",
                    "description": "Count input."
                },
                {
                    "name": "R",
                    "type": "BOOL",
                    "description": "Reset input."
                },
                {
                    "name": "PV",
                    "type": "INTEGER",
                    "description": "Target value for the output Q."
                }
            ],
            "Output": [
                {
                    "name": "Q",
                    "type": "BOOL",
                    "description": "Status of the counter."
                },
                {
                    "name": "CV",
                    "type": "INTEGER, CHAR, WCHAR, DATE",
                    "description": "Current value of the counter."
                }
            ]
        },
        "example_code": "IEC_COUNTER_DB.CTU(CU := Start, R := Reset, PV := PresetValue, Q => Status, CV => CounterValue);",
        "additional_info": "The counter value increments until it reaches the upper limit of the data type.",
        "brief_description": "This function increments the value of the CV parameter using the 'Count Up' instruction when the signal state of CU transitions from '0' to '1'. It can be applied in scenarios that require counting or tracking the number of occurrences of events, such as counting products on a production line or tracking the number of times a machine operates."
    },
    "CTD": {
        "instruction_name": "CTD",
        "parameters": {
            "Input": [
                {
                    "name": "CD",
                    "type": "BOOL",
                    "description": "Count input."
                },
                {
                    "name": "LD",
                    "type": "BOOL",
                    "description": "Load input."
                },
                {
                    "name": "PV",
                    "type": "Integer",
                    "description": "Preset value to set output CV when LD = 1."
                }
            ],
            "Output": [
                {
                    "name": "Q",
                    "type": "BOOL",
                    "description": "Counter status."
                },
                {
                    "name": "CV",
                    "type": "Integer, CHAR, WCHAR, DATE",
                    "description": "Current counter value."
                }
            ]
        },
        "example_code": "IEC_SCOUNTER_DB.CTD(CD := Start, LD := Load, PV := PresetValue, Q => Status, CV => CounterValue);",
        "additional_info": "The counter value decreases until it reaches the lower limit of the data type.",
        "brief_description": "This function is a decrement count instruction used to reduce the value of the CV parameter. When the signal state of parameter CD changes from '0' to '1' (rising edge), this instruction is executed to decrease the current counter value CV by '1'. This instruction can be applied in scenarios where counting events is required or when the count value needs to be decremented upon reaching specific conditions."
    },
    "CTUD": {
        "instruction_name": "CTUD",
        "parameters": {
            "Input": [
                {
                    "name": "CU",
                    "type": "BOOL",
                    "description": "Count up input."
                },
                {
                    "name": "CD",
                    "type": "BOOL",
                    "description": "Count down input."
                },
                {
                    "name": "R",
                    "type": "BOOL",
                    "description": "Reset input."
                },
                {
                    "name": "LD",
                    "type": "BOOL",
                    "description": "Load input."
                },
                {
                    "name": "PV",
                    "type": "INTEGER",
                    "description": "Preset output value for QU / When LD = 1, preset output value for CV."
                }
            ],
            "Output": [
                {
                    "name": "QU",
                    "type": "BOOL",
                    "description": "State of the count up counter."
                },
                {
                    "name": "QD",
                    "type": "BOOL",
                    "description": "State of the count down counter."
                },
                {
                    "name": "CV",
                    "type": "INTEGER, CHAR, WCHAR, DATE",
                    "description": "Current counter value."
                }
            ]
        },
        "example_code": "IEC_COUNTER_DB.CTUD(CU := Start1, CD := Start2, LD := Load, R := Reset, PV := PresetValue, QU => CU_Status, QD => CD_Status, CV => CounterValue);",
        "additional_info": "If CU and CD both have rising edges within one program cycle, the counter value remains unchanged.",
        "brief_description": "Function that uses the \"Count Up/Down\" instruction to increment and decrement the counter value of the CV parameter. Depending on the state of the signals CU and CD, the value of the parameter CV will increase or decrease accordingly. It can be applied in scenarios that require counting up or down, such as a counter on a production line, countdown timers for traffic lights, etc."
    },
    "S_CU": {
        "instruction_name": "S_CU",
        "parameters": {
            "Input": [
                {
                    "name": "C_NO",
                    "type": "COUNTER, INT",
                    "description": "Counter operation."
                },
                {
                    "name": "CU",
                    "type": "BOOL",
                    "description": "Count input."
                },
                {
                    "name": "S",
                    "type": "BOOL",
                    "description": "Input for presetting the counter."
                },
                {
                    "name": "PV",
                    "type": "WORD",
                    "description": "Preset BCD format counter value."
                },
                {
                    "name": "R",
                    "type": "BOOL",
                    "description": "Reset input."
                }
            ],
            "Output": [
                {
                    "name": "Q",
                    "type": "BOOL",
                    "description": "Counter status."
                },
                {
                    "name": "CV",
                    "type": "WORD",
                    "description": "Current counter value."
                }
            ]
        },
        "example_code": "Result := S_CU(C_NO := Counter_1, CU := Start, S := 1, PV := PresetValue, R := Reset, Q => Status, CV => Value);",
        "additional_info": "The counter stops increasing after reaching the upper limit of 999.",
        "brief_description": "This function increments the specified counter when the CU parameter's signal state changes from '0' to '1' (rising edge). It can also stop counting after reaching 999, making it suitable for scenarios that require event counting or incrementing counter values at specific moments."
    },
    "S_CD": {
        "instruction_name": "S_CD",
        "parameters": {
            "Input": [
                {
                    "name": "C_NO",
                    "type": "COUNTER, INT",
                    "description": "Counter operation."
                },
                {
                    "name": "CD",
                    "type": "BOOL",
                    "description": "Decrement count input."
                },
                {
                    "name": "S",
                    "type": "BOOL",
                    "description": "Input terminal for presetting the counter."
                },
                {
                    "name": "PV",
                    "type": "WORD",
                    "description": "Preset value of the counter in BCD format."
                },
                {
                    "name": "R",
                    "type": "BOOL",
                    "description": "Reset input."
                }
            ],
            "Output": [
                {
                    "name": "Q",
                    "type": "BOOL",
                    "description": "Counter status."
                },
                {
                    "name": "CV",
                    "type": "WORD",
                    "description": "Current counter value."
                }
            ]
        },
        "example_code": "Result := S_CD(C_NO := Counter_1, CD := Start, S := 1, PV := PresetValue, R := Reset, Q => Status, CV => Value);",
        "additional_info": "The counter stops decrementing when the counter value reaches the lower limit of 0.",
        "brief_description": "This function serves as a decrement count instruction, applicable in scenarios where it is necessary to decrement the counter value based on the rising edge of a certain signal."
    },
    "S_CUD": {
        "instruction_name": "S_CUD",
        "parameters": {
            "Input": [
                {
                    "name": "C_NO",
                    "type": "COUNTER, INT",
                    "description": "Counter operation."
                },
                {
                    "name": "CU",
                    "type": "BOOL",
                    "description": "Increment count input."
                },
                {
                    "name": "CD",
                    "type": "BOOL",
                    "description": "Decrement count input."
                },
                {
                    "name": "S",
                    "type": "BOOL",
                    "description": "Input for presetting the counter."
                },
                {
                    "name": "PV",
                    "type": "WORD",
                    "description": "Preset BCD format counter value."
                },
                {
                    "name": "R",
                    "type": "BOOL",
                    "description": "Reset input."
                }
            ],
            "Output": [
                {
                    "name": "Q",
                    "type": "BOOL",
                    "description": "Counter status."
                },
                {
                    "name": "CV",
                    "type": "WORD",
                    "description": "Current counter value."
                }
            ]
        },
        "example_code": "Result := S_CD(C_NO := Counter_1, CU := CU, CD := CD, S := 1, PV := PresetValue, R := Reset, Q => Status, CV => Value);",
        "additional_info": "The counter value stops changing when it reaches the upper limit of 999 or the lower limit of 0.",
        "brief_description": "This function assigns parameters and increments/decrements the count. It can be applied to perform count operations on a specified counter based on the states of input signals CU and CD. When the counter value reaches the upper limit of 999 or the lower limit of 0, the counter value will no longer change."
    },
    "TypeOf": {
        "instruction_name": "TypeOf",
        "parameters": {
            "Input": [
                {
                    "name": "<operand>",
                    "type": "binary number, integer, floating point, time, date and time, string, Variant, ResolvedSymbol",
                    "description": "The operand used for querying."
                }
            ]
        },
        "example_code": "\n//other scl code here \nVAR_INPUT\ninputValue : Variant;\nEND_VAR\nBEGIN\n// here shows how to use `TypeOf` with Variant\n CASE TypeOf(#inputValue) OF \nByte: // `Byte` is a predefined data type in SCL\n//do something ; \nWord: // `Word` is a predefined data type in SCL \n//do something ; \nDWord: // `DWord` is a predefined data type in SCL \n//do something ;\nEND_CASE;\n//other scl code here \n",
        "additional_info": "Can only be used in IF or CASE instructions, not allowed to assign to operands.",
        "brief_description": "The function checks the data type of the variable pointed to by a Variant or ResolvedSymbol variable and compares it, which can be used in IF or CASE instructions to determine whether the variable type matches the expected type."
    },
    "TypeOfElements": {
        "instruction_name": "TypeOfElements",
        "parameters": {
            "Input": [
                {
                    "name": "<Operand>",
                    "type": "Variant",
                    "description": "Operand used for querying."
                }
            ]
        },
        "example_code": "\n// Other SCL code here \nVAR_INPUT\nVariantToArray : Variant;\nEND_VAR\nBEGIN\nIF IS_ARRAY(#VariantToArray) AND TypeOfElements(#VariantToArray) = DInt THEN // `DInt` is a pre-defined SCL data type \n// Do something; \nEND_IF;",
        "additional_info": "Can only be used in IF or CASE statements, not allowed to assign to the operand.",
        "brief_description": "This function checks the data type of the elements in the ARRAY of a Variant variable and compares them. It can be used in IF or CASE statements to query the data type of the variable pointed to by the Variant variable and perform conditional judgments and operations based on the query result."
    },
    "IS_ARRAY": {
        "instruction_name": "IS_ARRAY",
        "parameters": {
            "Input": [
                {
                    "name": "<operand>",
                    "type": "Variant",
                    "description": "The operand for the ARRAY query."
                }
            ]
        },
        "example_code": "//other scl code here \nVAR_INPUT\nVariantToArray : Variant;\nEND_VAR\nIF IS_ARRAY(#VariantToArray) THEN \n#result := CountOfElements(#VariantToArray); \nEND_IF;",
        "additional_info": "Can only be used within an IF statement.",
        "brief_description": "This function checks whether the Variant points to a variable of the ARRAY data type. It can be used in scenarios where it is necessary to determine if a certain Variant variable is of array type and to handle it accordingly within an IF statement."
    },
    "TypeOfDB": {
        "instruction_name": "TypeOfDB",
        "parameters": {
            "Input": [
                {
                    "name": "<operand>",
                    "type": "DB_ANY",
                    "description": "The operand used for querying."
                }
            ]
        },
        "example_code": "IF TypeOfDB(#InputDBAny) = TO THEN ... END_IF;",
        "additional_info": "Can only be used within IF or CASE statements.",
        "brief_description": "The function is used to query the data type of a certain data block. It can be applied in SCL programming where there is a need to check the data block type addressed by a DB_ANY data type variable within IF or CASE statements."
    },
    "ABS": {
        "instruction_name": "ABS",
        "parameters": {
            "Input": [
                {
                    "name": "<expression>",
                    "type": "SINT, INT, DINT, LINT, floating point",
                    "description": "Input value."
                }
            ],
            "Return": [
                {
                    "name": "Ret_Val",
                    "type": "SINT, INT, DINT, LINT, floating point",
                    "description": "Result."
                }
            ]
        },
        "example_code": "Result1 := ABS(Value);",
        "additional_info": "The result has the same data type as the input value.",
        "brief_description": "The function calculates the absolute value of the input value and saves the result to the specified operand. It can be applied in scenarios that require the absolute value of a variable."
    },
    "MIN": {
        "instruction_name": "MIN",
        "parameters": {
            "Input": [
                {
                    "name": "IN1",
                    "type": "integer, float, TIME, TOD, DATE, DTL",
                    "description": "The first input value."
                },
                {
                    "name": "IN2",
                    "type": "integer, float, TIME, TOD, DATE, DTL",
                    "description": "The second input value."
                },
                {
                    "name": "INn",
                    "type": "integer, float, TIME, TOD, DATE, DTL",
                    "description": "Other input values to compare."
                }
            ],
            "Return": [
                {
                    "name": "Ret_Val",
                    "type": "integer, float, TIME, TOD, DATE, DTL",
                    "description": "The result."
                }
            ]
        },
        "example_code": "#Result := MIN(IN1 := #Value1, IN2 := #Value2, IN3 := #Value3);",
        "additional_info": "The result is the minimum value among all inputs.",
        "brief_description": "The function compares multiple input values and returns the minimum value, which can be applied in scenarios that require comparing multiple values to obtain the minimum."
    },
    "MAX": {
        "instruction_name": "MAX",
        "parameters": {
            "Input": [
                {
                    "name": "IN1",
                    "type": "Integer, Float, TIME, TOD, DATE, DTL",
                    "description": "The first input value."
                },
                {
                    "name": "IN2",
                    "type": "Integer, Float, TIME, TOD, DATE, DTL",
                    "description": "The second input value."
                },
                {
                    "name": "INn",
                    "type": "Integer, Float, TIME, TOD, DATE, DTL",
                    "description": "Other inserted inputs (values to be compared)."
                }
            ],
            "Return": [
                {
                    "name": "Ret_Val",
                    "type": "Integer, Float, TIME, TOD, DATE, DTL",
                    "description": "The result."
                }
            ]
        },
        "example_code": "#Result := MAX(IN1 := #Value1, IN2 := #Value2, IN3 := #Value3);",
        "additional_info": "The result is the maximum value among all inputs.",
        "brief_description": "The function compares multiple input values and returns the maximum value, applicable in scenarios where the maximum value needs to be derived from several numbers."
    },
    "LIMIT": {
        "instruction_name": "LIMIT",
        "parameters": {
            "Input": [
                {
                    "name": "MN",
                    "type": "Integer, Float, TIME, TOD, DATE, DTL",
                    "description": "Lower limit."
                },
                {
                    "name": "IN",
                    "type": "Integer, Float, TIME, TOD, DATE, DTL",
                    "description": "Input value."
                },
                {
                    "name": "MX",
                    "type": "Integer, Float, TIME, TOD, DATE, DTL",
                    "description": "Upper limit."
                }
            ],
            "Return": [
                {
                    "name": "Ret_Val",
                    "type": "Integer, Float, TIME, TOD, DATE, DTL",
                    "description": "Result"
                }
            ]
        },
        "example_code": "#Result := LIMIT(MN := #Minimum, IN := #Value, MX := #Maximum);",
        "additional_info": "If MN is greater than MX, the result will be the value of the IN parameter, and ENO will be '0'.",
        "brief_description": "The function restricts the value of the IN parameter to be between the values of MN and MX, which can be applied in scenarios requiring range limits on a value."
    },
    "SQR": {
        "instruction_name": "SQR",
        "parameters": {
            "Input": [
                {
                    "name": "<expression>",
                    "type": "Real",
                    "description": "Input value."
                }
            ],
            "Return": [
                {
                    "name": "Ret_Val",
                    "type": "Real",
                    "description": "Result"
                }
            ]
        },
        "example_code": "Result1 := SQR(#Value);",
        "additional_info": "The result is the square of the input value.",
        "brief_description": "This function calculates the square of the input value and stores the result in the specified operand, which can be applied in scenarios that require numerical square calculations."
    },
    "SQRT": {
        "instruction_name": "SQRT",
        "parameters": {
            "Input": [
                {
                    "name": "<expression>",
                    "type": "float",
                    "description": "Input value."
                }
            ],
            "Return": [
                {
                    "name": "Ret_Val",
                    "type": "float",
                    "description": "Result"
                }
            ]
        },
        "example_code": "Result1 := SQRT(#Value);",
        "additional_info": "If the input value is less than zero, return invalid float.",
        "brief_description": "This function calculates the square root of the input value and saves the result to the specified operand. It can be applied in scenarios where square root calculations are needed."
    },
    "LN": {
        "instruction_name": "LN",
        "parameters": {
            "Input": [
                {
                    "name": "<expression>",
                    "type": "float",
                    "description": "Input value."
                }
            ],
            "Return": [
                {
                    "name": "Ret_Val",
                    "type": "float",
                    "description": "Result"
                }
            ]
        },
        "example_code": "#Result1 := LN(#Value);",
        "additional_info": "If the input value is less than zero, an invalid floating point number is returned.",
        "brief_description": "This function calculates the natural logarithm of the input value with base e, applicable in scenarios requiring the natural logarithm of a floating point number."
    },
    "EXP": {
        "instruction_name": "EXP",
        "parameters": {
            "Input": [
                {
                    "name": "<expression>",
                    "type": "float",
                    "description": "Input value."
                }
            ],
            "Return": [
                {
                    "name": "Ret_Val",
                    "type": "float",
                    "description": "Result"
                }
            ]
        },
        "example_code": "#Result1 := EXP(#Value);",
        "additional_info": "None.",
        "brief_description": "The function calculates the exponential value using base e and stores the result in the specified operand. It can be applied in scenarios where exponential values need to be computed."
    },
    "SIN": {
        "instruction_name": "SIN",
        "parameters": {
            "Input": [
                {
                    "name": "<expression>",
                    "type": "float",
                    "description": "Input value (angle value in radians)."
                }
            ],
            "Return": [
                {
                    "name": "Ret_Val",
                    "type": "float",
                    "description": "Result."
                }
            ]
        },
        "example_code": "#Result := SIN(#Value);",
        "additional_info": "None.",
        "brief_description": "This function calculates the sine of the input value, applicable in scenarios that require the sine of an angle value in radians."
    },
    "COS": {
        "instruction_name": "COS",
        "parameters": {
            "Input": [
                {
                    "name": "<expression>",
                    "type": "float",
                    "description": "Input value (angle value in radians)."
                }
            ],
            "Return": [
                {
                    "name": "Ret_Val",
                    "type": "float",
                    "description": "Result"
                }
            ]
        },
        "example_code": "Result := COS(Value);",
        "additional_info": "None.",
        "brief_description": "Function to calculate the cosine value of the input, applicable in scenarios needing the cosine of angle values in radians."
    },
    "TAN": {
        "instruction_name": "TAN",
        "parameters": {
            "Input": [
                {
                    "name": "<expression>",
                    "type": "float",
                    "description": "Input value (angle value in radians)."
                }
            ],
            "Return": [
                {
                    "name": "Ret_Val",
                    "type": "float",
                    "description": "Result"
                }
            ]
        },
        "example_code": "#Result := TAN(Value);",
        "additional_info": "None.",
        "brief_description": "The function calculates the tangent of the input value (input value is in radians) and can be applied in situations requiring the calculation of the tangent of an angle."
    },
    "ASIN": {
        "instruction_name": "ASIN",
        "parameters": {
            "Input": [
                {
                    "name": "<expression>",
                    "type": "float",
                    "description": "Sine value."
                }
            ],
            "Return": [
                {
                    "name": "Ret_Val",
                    "type": "float",
                    "description": "Result"
                }
            ]
        },
        "example_code": "#Result := ASIN(Value);",
        "additional_info": "The result range is between -π/2 and +π/2.",
        "brief_description": "This function calculates the angle value corresponding to a sine value, applicable in situations where an angle value is required, especially when the sine value is known and is within the range of -1 to +1."
    },
    "ACOS": {
        "instruction_name": "ACOS",
        "parameters": {
            "Input": [
                {
                    "name": "<expression>",
                    "type": "float",
                    "description": "Cosine value."
                }
            ],
            "Return": [
                {
                    "name": "Ret_Val",
                    "type": "float",
                    "description": "Result"
                }
            ]
        },
        "example_code": "#Result := ACOS(Value);",
        "additional_info": "The result range is between 0 and +π.",
        "brief_description": "The function calculates the angle value corresponding to a cosine value, which can be applied to determine the angle corresponding to a cosine value that is a floating point number between -1 and +1."
    },
    "ATAN": {
        "instruction_name": "ATAN",
        "parameters": {
            "Input": [
                {
                    "name": "<expression>",
                    "type": "float",
                    "description": "Tangent value."
                }
            ],
            "Return": [
                {
                    "name": "Ret_Val",
                    "type": "float",
                    "description": "Result"
                }
            ]
        },
        "example_code": "#Result := ATAN(Value);",
        "additional_info": "Result range is between -π/2 and +π/2.",
        "brief_description": "The function calculates the angle corresponding to the tangent value, applicable in scenarios where the inverse tangent value is needed."
    },
    "FRAC": {
        "instruction_name": "FRAC",
        "parameters": {
            "Input": [
                {
                    "name": "<expression>",
                    "type": "float",
                    "description": "Input value."
                }
            ],
            "Return": [
                {
                    "name": "Ret_Val",
                    "type": "float",
                    "description": "Result"
                }
            ]
        },
        "example_code": "#Result1 := FRAC(Value);",
        "additional_info": "None.",
        "brief_description": "The function returns the decimal part of a number and can be applied in scenarios where the decimal part of a float number is needed."
    },
    "Deserialize": {
        "instruction_name": "Deserialize",
        "parameters": {
            "Input": [
                {
                    "name": "SRC_ARRAY",
                    "type": "ARRAY[*] of BYTE or ARRAY of CHAR",
                    "description": "An ARRAY of BYTE or ARRAY of CHAR used to hold the data stream that will be deserialized."
                }
            ],
            "InOut": [
                {
                    "name": "DEST_VARIABLE",
                    "type": "All data types",
                    "description": "The target variable where the deserialized data will be written."
                },
                {
                    "name": "POS",
                    "type": "DINT",
                    "description": "The operand in the POS parameter will store the index of the first byte based on the number of bytes occupied by the converted customer data."
                }
            ]
        },
        "example_code": "No example code, but it is typically used when needing to convert a serialized data structure back to its original form.",
        "additional_info": "Ensure there is sufficient storage space before conversion, and the data type of SRC_ARRAY must be an ARRAY of BYTE or ARRAY of CHAR.",
        "brief_description": "The function allows using the 'Deserialize' instruction to reverse-convert PLC data types (UDT), STRUCT, or ARRAY into their sequential representation and populate all content. It can be applied when needing to convert serialized data structures back to their original form."
    },
    "Serialize": {
        "instruction_name": "Serialize",
        "parameters": {},
        "example_code": "No specific example code.",
        "additional_info": "The padding data in the source data area is not defined in the target array. The standard storage area has a capacity of 64 KB, and structures larger than 64 KB cannot be serialized.",
        "brief_description": "This function converts multiple PLC data types (such as UDT, STRUCT, or ARRAY of <data type>) into a sequential representation for temporary storage and transmission of structured data items to other CPUs. It can be applied in scenarios where complex data structures need to be transmitted between different CPUs, provided the data size does not exceed 64 KB."
    },
    "MOVE_BLK": {
        "instruction_name": "MOVE_BLK",
        "parameters": {
            "Input": [
                {
                    "name": "IN",
                    "type": "Variant",
                    "description": "SInt, Int, DInt, USInt, UInt, UDInt, Real, LReal Byte, Word, DWord, Time, Date, TOD, WChar"
                },
                {
                    "name": "COUNT",
                    "type": "UInt",
                    "description": "Number of elements copied. If no ARRAY is specified in the SRC or DEST parameters, set the value of the COUNT parameter to '1'."
                },
                {
                    "name": "OUT",
                    "type": "SInt, Int, DInt, USInt, UInt, UDInt, Real, LReal Byte, Word, DWord, Time, Date, TOD, WChar",
                    "description": "Destination start address"
                }
            ]
        },
        "example_code": "MOVE_BLK(IN := #a_array[2], COUNT := #countOfNumber, OUT => #b_array[1]);",
        "additional_info": "This instruction can only be executed when the data types of the source and destination ranges are the same.",
        "brief_description": "The function moves data from one storage area (source range) to another storage area (destination range), applicable in scenarios where elements from an array or data block need to be copied to another array or data block."
    },
    "MOVE_BLK_Variant": {
        "instruction_name": "MOVE_BLK_Variant",
        "parameters": {
            "Input": [
                {
                    "name": "SRC",
                    "type": "Variant",
                    "description": "The source block to be copied."
                },
                {
                    "name": "COUNT",
                    "type": "UDINT",
                    "description": "The number of elements copied. If no ARRAY is specified in parameter SRC or DEST, the value of parameter COUNT is set to '1'."
                },
                {
                    "name": "SRC_INDEX",
                    "type": "DINT",
                    "description": "Defines the first element to be copied: • The SRC_INDEX parameter is zero-based. If an ARRAY is specified in SRC, the integer in the SRC_INDEX parameter will specify the first element in the source region to be copied, regardless of the declared ARRAY limits. • If no ARRAY is specified in SRC or only a specific element of the ARRAY is specified, the value of the SRC_INDEX parameter is set to '0'."
                },
                {
                    "name": "DEST_INDEX",
                    "type": "DINT",
                    "description": "Defines the starting point of the destination storage. • The DEST_INDEX parameter is zero-based. If an ARRAY is specified in DEST, the integer in the DEST_INDEX parameter will specify the first element in the destination range to be copied, regardless of the declared ARRAY limits. • If no ARRAY is specified in DEST, the value of the DEST_INDEX parameter is set to '0'."
                }
            ],
            "Output": [
                {
                    "name": "DEST",
                    "type": "Variant",
                    "description": "The target area where the content from the source block will be copied."
                }
            ],
            "Return": [
                {
                    "name": "Ret_Val",
                    "type": "INT",
                    "description": "Error information"
                }
            ]
        },
        "example_code": "Result := MOVE_BLK_Variant(SRC := #SrcField, COUNT := Count, SRC_INDEX := Src_Index, DEST_INDEX := Dest_Index, DEST => #DestField);",
        "additional_info": "Regardless of how the ARRAY is later declared, parameters SRC_INDEX and DEST_INDEX always count from the lower limit '0'.",
        "brief_description": "The function moves data of Variant type from one Variant type to another, applicable for scenarios requiring copying of Variant arrays or reading elements of Variant arrays."
    },
    "UMOVE_BLK": {
        "instruction_name": "UMOVE_BLK",
        "parameters": {},
        "example_code": "UMOVE_BLK(IN := #a_array[2], COUNT := Count, OUT => #b_array[1]);",
        "additional_info": "This move operation cannot be interrupted by other tasks of the operating system. The CPU has specific limitations, allowing this instruction to move a maximum of 16 KB of data.",
        "brief_description": "The function is to move data from one storage area to another, and the move operation cannot be interrupted. It can be applied in scenarios that require the secure and reliable transfer of large amounts of data (up to 16 KB)."
    },
    "FILL_BLK": {
        "instruction_name": "FILL_BLK",
        "parameters": {},
        "example_code": "FILL_BLK(IN := #FillValue, COUNT := Count, OUT => #TargetArea[1]);",
        "additional_info": "This instruction can only be executed when the data types of the source range and the target range are the same. If the copied data exceeds the elements in the OUT output, unexpected results will be returned.",
        "brief_description": "The function fills a storage area with the input value starting from a specified address. It can be applied in scenarios where a specific value needs to be filled into a designated storage area, such as initializing a block of memory."
    },
    "UFILL_BLK": {
        "instruction_name": "UFILL_BLK",
        "parameters": {},
        "example_code": "UFILL_BLK(IN := #FillValue, COUNT := Count, OUT => #TargetArea[1]);",
        "additional_info": "This move operation will not be interrupted by other tasks of the operating system. This instruction can be used to move up to 16 KB of data.",
        "brief_description": "The function is to fill a storage area with input values in a non-interruptible manner, applicable in scenarios that require continuous and uninterrupted filling of large amounts of data."
    },
    "SCATTER": {
        "instruction_name": "SCATTER",
        "parameters": {},
        "example_code": "SCATTER(IN := #SourceWord, OUT => #DestinationArray);",
        "additional_info": "Multidimensional ARRAY of BOOL does not support this instruction. The number of elements contained in an ARRAY, STRUCT, or PLC data type must exactly match the number specified by the bit sequence.",
        "brief_description": "The function is to parse variables of data types BYTE, WORD, DWORD, or LWORD into individual bits and store them in an ARRAY of BOOL, an anonymous STRUCT, or PLC data types that contain only Boolean elements. It can be applied in scenarios where a bit sequence needs to be decomposed into individual bits, such as performing bit-level operations on byte data."
    },
    "SCATTER_BLK": {
        "instruction_name": "SCATTER_BLK",
        "parameters": {},
        "example_code": "SCATTER_BLK(IN := #SourceArrayWord[2], COUNT_IN := #CounterInput, OUT => #DestinationArrayBool[0]);",
        "additional_info": "If the lower bound of the target ARRAY is not '0', the index must always start with BYTE, WORD, DWORD, or LWORD limits.",
        "brief_description": "The function decomposes the elements of a bit-sequence ARRAY into individual bits and can be applied in scenarios where BYTE, WORD, DWORD, or LWORD type arrays need to be broken down into single bits."
    },
    "GATHER": {
        "instruction_name": "GATHER",
        "parameters": {},
        "example_code": "GATHER(IN := #SourceArray, OUT => #DestinationWord);",
        "additional_info": "Multidimensional ARRAY of BOOL does not support this instruction. The number of elements contained in ARRAY, STRUCT, or PLC data types must exactly match the number specified by the bit sequence.",
        "brief_description": "The function combines individual bits into a bit sequence and can be applied to combine bits from ARRAY of BOOL, anonymous STRUCT, or PLC data types that contain only boolean elements into a single bit sequence."
    },
    "GATHER_BLK": {
        "instruction_name": "GATHER_BLK",
        "parameters": {},
        "example_code": "GATHER_BLK(IN := #SourceArrayBool[0], COUNT_OUT := #CounterOutput, OUT => #DestinationArrayWord[2]);",
        "additional_info": "If the lower limit of the source ARRAY is not '0', the index must always start restricted to BYTE, WORD, DWORD, or LWORD.",
        "brief_description": "The function combines the individual bits from an array or structure that only contains Boolean elements into one or more elements in a bit sequence array. It can be applied in scenarios where BOOL arrays or bit information from PLC data types are aggregated into an ARRAY of <bit sequences>."
    },
    "AssignmentAttempt": {
        "instruction_name": "AssignmentAttempt",
        "parameters": {},
        "example_code": "The block interface is designed as follows.",
        "additional_info": "In SCL, NULL can also be assigned during an assignment attempt, specifically setting references to NULL.",
        "brief_description": "The function is for assigning values to reference variables and can be applied in scenarios where values need to be assigned to variables in SCL."
    },
    "SWAP": {
        "instruction_name": "SWAP",
        "parameters": {},
        "example_code": "Result := SWAP(Value);",
        "additional_info": "No specific additional information.",
        "brief_description": "This function can change the order of bytes in the input value and store the result in the specified operand. It can be applied in situations where a change of data byte order is needed."
    },
    "ReadFromArrayDB": {
        "instruction_name": "ReadFromArrayDB",
        "parameters": {},
        "example_code": "TagResult := ReadFromArrayDB(DB := ArrayDB, INDEX := 2, VALUE => TargetField);",
        "additional_info": "The ARRAY data block contains only an ARRAY of <data type>. The elements of the ARRAY can be PLC data types or any other basic data types.",
        "brief_description": "The function reads an element from the ARRAY DB block referenced by the index, and can be applied in scenarios where specific position elements need to be read from an ARRAY data block in Siemens SCL programming."
    },
    "WriteToArrayDB": {
        "instruction_name": "WriteToArrayDB",
        "parameters": {},
        "example_code": "TagResult := WriteToArrayDB(DB := ArrayDB, INDEX := 2, VALUE := SourceField);",
        "additional_info": "The ARRAY data block is a data block that only contains an ARRAY of <data type>. The elements of the ARRAY can be PLC data types or any other basic data types.",
        "brief_description": "The function writes the element referenced by the index into the ARRAY DB block type data block, applicable for situations where data needs to be written to the ARRAY data block."
    },
    "ReadFromArrayDBL": {
        "instruction_name": "ReadFromArrayDBL",
        "parameters": {},
        "example_code": "ReadFromArrayDBL_DB(REQ := TagReg, DB := ArrayDB, INDEX := 2, VALUE := TargetField, BUSY => TagBusy, DONE => TagDone, ERROR => TagError);",
        "additional_info": "If the ARRAY data block is specified with the block attribute 'store only in load memory', then the array data block will only be stored in load memory.",
        "brief_description": "The function reads the element at the specified index from the ARRAY data block in load memory, applicable to scenarios where data needs to be read from a specific ARRAY DB block."
    },
    "WriteToArrayDBL": {
        "instruction_name": "WriteToArrayDBL",
        "parameters": {},
        "example_code": "WriteToArrayDBL_DB(REQ := TagReg, DB := ArrayDB, INDEX := 2, VALUE := SourceField, BUSY => TagBusy, DONE => TagDone, ERROR => TagError);",
        "additional_info": "If the ARRAY data block is specified with the block attribute 'Only stored in load memory', then the array data block will be stored only in the load memory.",
        "brief_description": "This function writes the indexed referenced element to a data block of type ARRAY DB that is stored in load memory. It can be applied in scenarios where data needs to be written to an ARRAY data block that is only stored in load memory."
    },
    "PEEK": {
        "instruction_name": "PEEK",
        "parameters": {},
        "example_code": "Result1 := PEEK(AREA := Area, DBNUMBER := DBNumber, BYTEOFFSET := Byte);",
        "additional_info": "To read memory addresses in the input, output, or bit storage areas, the value of the DBNUMBER parameter must be set to '0', otherwise the instruction will be invalid.",
        "brief_description": "The function reads a memory address from the storage area without specifying a data type, applicable in scenarios where reading memory addresses in the input, output, or bit storage areas is required."
    },
    "PEEK_BOOL": {
        "instruction_name": "PEEK_BOOL",
        "parameters": {},
        "example_code": "Result := PEEK_BOOL(AREA := Area, DBNUMBER := DBNumber, BYTEOFFSET := Byte, BITOFFSET := Bit);",
        "additional_info": "To read a storage bit from the input, output, or bit memory areas, the value of the DBNUMBER parameter must be set to '0', otherwise the instruction will be invalid.",
        "brief_description": "The function reads a storage bit from the standard memory area and can be applied to situations that require reading storage bits from input, output, or bit memory areas without specifying data types."
    },
    "POKE": {
        "instruction_name": "POKE",
        "parameters": {},
        "example_code": "POKE(AREA := Area, DBNUMBER := DBNumber, BYTEOFFSET := Byte, VALUE := Value);",
        "additional_info": "If you want to write to an input, output, or bit storage area, the value of the DBNUMBER parameter must be set to '0', otherwise the instruction will be invalid.",
        "brief_description": "The function is used to write a storage address into a standard storage area without specifying a data type. It can be applied to directly write data to a specific storage area in a program, particularly when data type is not a concern, such as writing configuration parameters or directly manipulating hardware addresses."
    },
    "POKE_BOOL": {
        "instruction_name": "POKE_BOOL",
        "parameters": {},
        "example_code": "POKE_BOOL(AREA := Area, DBNUMBER := DBNumber, BYTEOFFSET := Byte, BITOFFSET := Bit, VALUE := Value);",
        "additional_info": "To write a storage bit to an input, output, or bit storage area, the value of the DBNUMBER parameter must be set to '0'; otherwise, the instruction will be invalid.",
        "brief_description": "The function writes a storage bit to a standard storage area and can be used to manipulate storage bits without needing to specify a data type."
    },
    "POKE_BLK": {
        "instruction_name": "POKE_BLK",
        "parameters": {},
        "example_code": "POKE_BLK(AREA_SRC := Source_Area, DBNUMBER_SRC := Source_DBNumber, BYTEOFFSET_SRC := Source_Byte, AREA_DEST := Destination_Area, DBNUMBER_DEST := Destination_DBNumber, BYTEOFFSET_DEST := Destination_Byte, COUNT := Count);",
        "additional_info": "If you want to write the storage address into input, output, or bit storage areas, you must set the value of the DBNUMBER parameter to '0'; otherwise, the instruction will be invalid.",
        "brief_description": "The function uses the 'write storage area' instruction to write a storage area into different standard storage areas without specifying a data type, applicable in scenarios that require copying or moving data between different data blocks."
    },
    "READ_LITTLE": {
        "instruction_name": "READ_LITTLE",
        "parameters": {},
        "example_code": "#TagResult := READ_LITTLE(SRC_ARRAY := #SourceField, DEST_VARIABLE => #DINTVariable, POS := #TagPos);",
        "additional_info": "The variant of the SRC_ARRAY parameter must be an ARRAY of BYTE. The variant of the DEST_VARIABLE must be a basic data type.",
        "brief_description": "The function reads data in little-endian format and writes it to a single variable. It can be used in scenarios to read byte sequences from storage and convert them into basic data types."
    },
    "WRITE_LITTLE": {
        "instruction_name": "WRITE_LITTLE",
        "parameters": {},
        "example_code": "#TagResult := WRITE_LITTLE(SRC_VARIABLE := #DINTVariable, DEST_ARRAY := #TargetField, POS := #TagPos);",
        "additional_info": "SRC_VARIABLE must be a variant pointing to a basic data type. DEST_ARRAY must be a variant of ARRAY of BYTE.",
        "brief_description": "The function writes the data of a single variable into storage using little-endian byte order and can be applied to store the value of basic data type variables in a byte array in little-endian format."
    },
    "READ_BIG": {
        "instruction_name": "READ_BIG",
        "parameters": {},
        "example_code": "#TagResult := READ_BIG(SRC_ARRAY := #SourceField, DEST_VARIABLE => #DINTVariable, POS := #TagPos);",
        "additional_info": "The SRC_ARRAY parameter must be an ARRAY of BYTE. The DEST_VARIABLE parameter must be a basic data type.",
        "brief_description": "This function reads data from storage in big-endian byte order and writes it into a single variable. It can be used in scenarios where byte sequence data needs to be read in big-endian format and converted to a specific data type."
    },
    "WRITE_BIG": {
        "instruction_name": "WRITE_BIG",
        "parameters": {},
        "example_code": "#TagResult := WRITE_BIG(SRC_VARIABLE := #DINTVariable, DEST_ARRAY := #TargetField, POS := #TagPos);",
        "additional_info": "The Variant of SRC_VARIABLE must point to a basic data type. The Variant of DEST_ARRAY must be an ARRAY of BYTE.",
        "brief_description": "The function writes data in big-endian format and can write the data of a single variable to a storage area. It is suitable for situations where data needs to be written from one variable to another array in big-endian byte order. For example, when the Variant of SRC_VARIABLE points to a basic data type, and the Variant of DEST_ARRAY is a BYTE array."
    },
    "VariantGet": {
        "instruction_name": "VariantGet",
        "parameters": {
            "Input": [
                {
                    "name": "SRC",
                    "type": "Variant",
                    "description": "The variable to be read."
                },
                {
                    "name": "DST",
                    "type": "bit string, integer, floating point, timer, datetime, string, ARRAY element, PLC data type",
                    "description": "Destination at which to write data."
                }
            ]
        },
        "example_code": "\nVAR_IN_OUT\nVariantVal : Variant;\nEND_VAR\n\nVAR_TEMP\ntempVal : Int;\nEND_VAR\nBEGIN\n//other scl code here \nIF TypeOf(#VariantVal) = Int THEN \nVariantGet(SRC := #VariantVal, DST := #tempVal);\nEND_IF;",
        "additional_info": "The data type of the DST parameter variable must match the data type pointed to by the Variant.",
        "brief_description": "The function reads the value of a Variant variable and writes it to another variable. It can be applied in scenarios where it is necessary to retrieve the value of a Variant type data and store it in a variable of known data type."
    },
    "VariantPut": {
        "instruction_name": "VariantPut",
        "parameters": {
            "Input": [
                {
                    "name": "SRC",
                    "type": "Bit string, integer, floating point, timer, date time, string, ARRAY element, PLC data type",
                    "description": "The variable to be written"
                },
                {
                    "name": "DST",
                    "type": "Variant",
                    "description": "Destination at which to write data"
                }
            ]
        },
        "example_code": "\nVAR_IN_OUT\nVariantVal : Variant;\nEND_VAR\n\nVAR_TEMP\ntempVal : Int;\nEND_VAR\nBEGIN\n//other scl code here \nIF TypeOf(#tempVal) = TypeOf(#VariantVal) THEN \nVariantPut(SRC := #tempVal, DST := #VariantVal);\nEND_IF;",
        "additional_info": "The data type of the SRC parameter variable must match the data type pointed to by the Variant.",
        "brief_description": "The function writes the value of the SRC parameter variable into the storage area of the DST parameter pointed to by the Variant. It can be used in scenarios where a variable of a known data type needs to be assigned to a Variant variable."
    },
    "CountOfElements": {
        "instruction_name": "CountOfElements",
        "parameters": {
            "Input": [
                {
                    "name": "<Operand>",
                    "type": "Variant",
                    "description": "Variant array"
                }
            ],
            "Return": [
                {
                    "name": "Ret_Val",
                    "type": "Integer",
                    "description": "Length of the Variant array"
                }
            ]
        },
        "example_code": "VAR_INPUT\nVariantToArray : Variant;\nEND_VAR\n\nVAR_TEMP\nResult : UDInt;\nEND_VAR\nBEGIN\n//other SCL code here \n#Result := CountOfElements(#VariantToArray);",
        "additional_info": "A Variant pointer may not point to an instance and thus may not point to multiple instances or an ARRAY of multiple instances. If the Variant variable is not an ARRAY, the result will also return '0'.",
        "brief_description": "The function queries the number of elements in the ARRAY pointed to by the Variant pointer, applicable in scenarios that require determining array length or validating the type of the Variant variable."
    },
    "MoveResolvedSymbolsToBuffer": {
        "instruction_name": "MoveResolvedSymbolsToBuffer",
        "parameters": {},
        "example_code": "MoveResolvedSymbolsToBuffer(firstIndex := 2, lastIndex := 7, src := MySrcDB.Input_ResolvedSymbols, dstOffsets := #Input_Offset, mode := 2#0, dst := MyTargetDB.InOut_Buffer, status := #InOut_Status);",
        "additional_info": "The value of the mode parameter is used to define the storage format in the dst parameter. The status parameter is an INT array used to store the copy status.",
        "brief_description": "The function reads values from resolved symbols and writes them into a buffer. It can be applied in scenarios where multiple resolved symbol values need to be stored in a designated storage area."
    },
    "MoveToResolvedSymbol": {
        "instruction_name": "MoveToResolvedSymbol",
        "parameters": {},
        "example_code": "MoveToResolvedSymbol(SRC := MySrcDB.Input_Variant, DST => MyTargetDB.Output_ResolvedSymbol);",
        "additional_info": "The variables must have been resolved using the ResolveSymbols instruction beforehand. The data types of the source variable and the target variable must be the same.",
        "brief_description": "This function reads the variable value and writes it into the target variable referenced by the resolved symbol. It can be applied in scenarios within SCL programming where the value of a resolved variable needs to be passed to another variable."
    },
    "MoveFromResolvedSymbol": {
        "instruction_name": "MoveFromResolvedSymbol",
        "parameters": {},
        "example_code": "MoveFromResolvedSymbol(SRC := MySrcDB.Input_ResolvedSymbol, DST => MyTargetDB.Output_Variant);",
        "additional_info": "The variable must have been resolved using the ResolveSymbols instruction beforehand. The data types of the source and target variables must be the same.",
        "brief_description": "This function reads the value of a variable referenced by a resolved symbol and writes it to the target variable. It can be used in SCL programming when assigning the value of a resolved symbol reference to a target variable."
    },
    "ResolveSymbols": {
        "instruction_name": "ResolveSymbols",
        "parameters": {},
        "example_code": "ResolveSymbols_DB(execute := #Input_Execute, firstIndex := 0, lastIndex := 9, done => #Output_Done, busy => #Output_Busy, error => _bool_out_, status => _int_out_, nameList := MySrcDB.InOut_Symbols, referenceList := MyTargetDB.InOut_ResolvedSymbols);",
        "additional_info": "Symbol variable names are transmitted in WSTRING format and must not exceed 254 UTF-16 characters in length. Elements within an array are supported, but a fixed index must be specified to access the elements.",
        "brief_description": "The function resolves multiple symbol variable names and receives references to the variables after execution, applicable to scenarios where dynamic resolution of variable references is required."
    },
    "MoveResolvedSymbolsFromBuffer": {
        "instruction_name": "MoveResolvedSymbolsFromBuffer",
        "parameters": {
            "Input": [
                {
                    "name": "firstIndex",
                    "type": "DINT",
                    "description": "The index of the first resolved symbol to be written in the target buffer."
                },
                {
                    "name": "lastIndex",
                    "type": "DINT",
                    "description": "The index of the last resolved symbol to be written in the target buffer."
                },
                {
                    "name": "mode",
                    "type": "DWORD",
                    "description": "Memory format, either BigEndian or LittleEndian."
                },
                {
                    "name": "src",
                    "type": "Array of BYTE",
                    "description": "The source buffer from which values are read."
                },
                {
                    "name": "srcOffsets",
                    "type": "Array of DINT",
                    "description": "The offsets of values in the source buffer."
                }
            ],
            "InOut": [
                {
                    "name": "dst",
                    "type": "Array of ResolvedSymbol",
                    "description": "The target buffer containing references to resolved symbols."
                },
                {
                    "name": "status",
                    "type": "Array of INT",
                    "description": "Contains the copy status of each value to be written."
                }
            ]
        },
        "example_code": "No specific example code, but it illustrates how to use the firstIndex and lastIndex parameters to limit the variables of resolved symbols that need to have values written, the mode parameter defines the memory format, the srcOffsets parameter specifies the offsets, the dst parameter contains references to resolved symbols, and the status parameter holds the copy status.",
        "additional_info": "Ensure that the array limits of srcOffsets and dst match to include the offset for dst[i]. This instruction does not verify whether the specified offsets overlap, which may result in random value reads.",
        "brief_description": "The function reads values from the storage area and writes them into multiple resolved symbol values. It can be used in handling storage received from communication instructions (such as TRCV) and writes the received data into specified symbols."
    },
    "LOWER_BOUND": {
        "instruction_name": "LOWER_BOUND",
        "parameters": {
            "Input": [
                {
                    "name": "ARR",
                    "type": "ARRAY[*]",
                    "description": "Array to read the variable lower bound."
                },
                {
                    "name": "DIM",
                    "type": "UDINT",
                    "description": "The dimension of the array to read the variable lower bound."
                }
            ],
            "Return": [
                {
                    "name": "Ret_Val",
                    "type": "DINT",
                    "description": "Return value indicating the lower bound of the array variable."
                }
            ]
        },
        "example_code": "VAR_INPUT\nArrayA:ARRAY[*,*] of DInt;\nEND_VAR;\nBEGIN\n#Result := LOWER_BOUND(ARR := #ArrayA, DIM := 2); This instruction will read the variable lower bound value of #ArrayA from the second dimension. If the instruction is executed successfully, the result will be written to the operand 'Result'.",
        "additional_info": "Refer to example code usage",
        "brief_description": "Function to read the lower bound of an ARRAY variable, applicable in scenarios where the lower bound value of a specific dimension of the array is needed."
    },
    "UPPER_BOUND": {
        "instruction_name": "UPPER_BOUND",
        "parameters": {
            "Input": [
                {
                    "name": "ARR",
                    "type": "ARRAY[*]",
                    "description": "The array with a variable upper bound to be read."
                },
                {
                    "name": "DIM",
                    "type": "UDINT",
                    "description": "The dimension of the array for which the variable upper bound is to be read."
                }
            ],
            "Return": [
                {
                    "name": "Ret_Val",
                    "type": "DINT",
                    "description": "Return value indicating the upper bound of the ARRAY variable."
                }
            ]
        },
        "example_code": "VAR_INPUT\nArrayA:ARRAY[*,*] of DInt; \nEND_VAR;  \nBEGIN \n#Result := UPPER_BOUND(ARR := #ArrayA, DIM := 2); This instruction will read the variable upper bound value of #ArrayA from the second dimension. If the instruction is executed successfully, the result will be written to the operand 'Result'.",
        "additional_info": "Reference example code usage",
        "brief_description": "The function reads the upper bound of an ARRAY variable and can be applied in scenarios where the upper bound value of a specific dimension of an array is needed."
    },
    "BLKMOV": {
        "instruction_name": "BLKMOV",
        "parameters": {
            "Input": [
                {
                    "name": "SRCBLK",
                    "type": "Variant",
                    "description": "Specifies the memory area to be moved (source area)."
                }
            ],
            "Output": [
                {
                    "name": "DSTBLK",
                    "type": "Variant",
                    "description": "Specifies the memory area to which the block will be moved (destination area)."
                }
            ]
        },
        "example_code": "SCL sample code is provided to demonstrate how to use the BLKMOV instruction to copy data and handle potential errors.",
        "additional_info": "The variables of this instruction are only applicable to memory areas where the 'Optimize Block Access' property is not activated. The source and destination areas must not overlap, and there are specific moving rules.",
        "brief_description": "Functionality is to move data from one memory area to another; it can be applied in scenarios where data blocks need to be copied in ascending address order."
    },
    "UBLKMOV": {
        "instruction_name": "UBLKMOV",
        "parameters": {
            "Input": [
                {
                    "name": "SRCBLK",
                    "type": "Variant",
                    "description": "Specifies the storage area to be moved (source area)."
                }
            ],
            "Output": [
                {
                    "name": "DSTBLK",
                    "type": "Variant",
                    "description": "Specifies the storage area to move the block to (destination area)."
                }
            ]
        },
        "example_code": "Provided SCL example code demonstrating how to use the UBLKMOV instruction to copy data and handle potential errors.",
        "additional_info": "Similar to BLKMOV, but this move operation will not be interrupted by other tasks of the operating system, leading to an increased CPU interrupt response time.",
        "brief_description": "The function is to perform an uninterruptible data movement in memory, applicable in scenarios that require highly reliable data transmission, ensuring that the data block is not interrupted during the moving process."
    },
    "FILL": {
        "instruction_name": "FILL",
        "parameters": {
            "Input": [
                {
                    "name": "BVAL",
                    "type": "Variant",
                    "description": "The specified storage area (source area) from which the content will be used to fill the target area specified in the BLK parameter."
                }
            ],
            "Output": [
                {
                    "name": "BLK",
                    "type": "Variant",
                    "description": "The specified storage area to be filled with data from the source area."
                }
            ]
        },
        "example_code": "SCL example code is provided to demonstrate how to use the FILL instruction to fill data.",
        "additional_info": "The source and target areas must not overlap, and there are specific movement rules.",
        "brief_description": "The function fills the target area with data from the source area until the target area is full, applicable in scenarios requiring the copying of content from one storage area to another."
    },
    "CONVERT": {
        "instruction_name": "CONVERT",
        "parameters": {
            "Input": [
                {
                    "name": "Source Type",
                    "type": "Binary, Integer, Floating Point, etc.",
                    "description": "The value to be converted."
                }
            ],
            "Output": [
                {
                    "name": "Target Type",
                    "type": "Binary, Integer, Floating Point, etc.",
                    "description": "The result of the conversion."
                }
            ]
        },
        "example_code": "",
        "additional_info": "In the instruction functional box, you can specify the source data type and target data type for conversion.",
        "brief_description": "The function converts the source value to the specified target data type and can be applied in scenarios where data type conversion is needed."
    },
    "ROUND": {
        "instruction_name": "ROUND",
        "parameters": {
            "Input": [
                {
                    "name": "expression",
                    "type": "float",
                    "description": "The input value to be rounded."
                }
            ]
        },
        "example_code": "ROUND(#inputValToRound);",
        "additional_info": "If the input value is exactly between an even and an odd number, the even number is chosen.",
        "brief_description": "The function rounds the input value to the nearest integer. If the input value is exactly between an even and an odd number, the even number is chosen. It can be applied in scenarios where floating-point numbers need to be rounded."
    },
    "CEIL": {
        "instruction_name": "CEIL",
        "parameters": {
            "Input": [
                {
                    "name": "expression",
                    "type": "float",
                    "description": "Input value."
                }
            ]
        },
        "example_code": "CEIL(#inputValue);",
        "additional_info": "The function value can be greater than or equal to the input value.",
        "brief_description": "The function rounds a floating point number up to the nearest integer, which can be applied in scenarios where it is necessary to adjust a floating point value to the closest integer that is greater than or equal to that value."
    },
    "FLOOR": {
        "instruction_name": "FLOOR",
        "parameters": {
            "Input": [
                {
                    "name": "expression",
                    "type": "float",
                    "description": "Input value."
                }
            ]
        },
        "example_code": "FLOOR(#inputValue);",
        "additional_info": "The function value can be equal to or less than the input value.",
        "brief_description": "The function rounds down a floating-point number to the nearest smaller integer, applicable in scenarios where it is necessary to convert floating-point values to the nearest smaller integer."
    },
    "TRUNC": {
        "instruction_name": "TRUNC",
        "parameters": {
            "Input": [
                {
                    "name": "Expression",
                    "type": "Float",
                    "description": "Input value."
                }
            ]
        },
        "example_code": "TRUNC(#inputValue);",
        "additional_info": "This instruction only selects the integer part of the input value, excluding decimal places.",
        "brief_description": "The function is used for truncating to an integer, directly extracting the integer part from the input value, applicable in scenarios where the integer part of a float is needed while ignoring the decimal part."
    },
    "SCALE_X": {
        "instruction_name": "SCALE_X",
        "parameters": {
            "Input": [
                {
                    "name": "EN",
                    "type": "BOOL",
                    "description": "Enable input."
                },
                {
                    "name": "MIN",
                    "type": "Integer or Float",
                    "description": "Lower limit of the value range."
                },
                {
                    "name": "VALUE",
                    "type": "Float",
                    "description": "Value to be scaled."
                },
                {
                    "name": "MAX",
                    "type": "Integer or Float",
                    "description": "Upper limit of the value range."
                }
            ],
            "Output": [
                {
                    "name": "ENO",
                    "type": "BOOL",
                    "description": "Enable output."
                }
            ]
        },
        "example_code": "SCALE_X(MIN := #minLim, VALUE := #inputValue, MAX := #maxLim);",
        "additional_info": "The calculation is done using the formula OUT = [VALUE * (MAX - MIN)] + MIN. If the enable input EN signal state is '0' or the value of MIN is greater than or equal to MAX, the enable output ENO will return the signal state '0'.",
        "brief_description": "This function maps a float to a specified value range for scaling, and can be applied in scenarios that require proportional transformation and range limitation of floating point values."
    },
    "NORM_X": {
        "instruction_name": "NORM_X",
        "parameters": {
            "Input": [
                {
                    "name": "EN",
                    "type": "BOOL",
                    "description": "Enable input."
                },
                {
                    "name": "MIN",
                    "type": "integer or float",
                    "description": "Lower limit of the value range."
                },
                {
                    "name": "VALUE",
                    "type": "integer or float",
                    "description": "The value to be normalized."
                },
                {
                    "name": "MAX",
                    "type": "integer or float",
                    "description": "Upper limit of the value range."
                }
            ],
            "Output": [
                {
                    "name": "ENO",
                    "type": "BOOL",
                    "description": "Enable output."
                }
            ]
        },
        "example_code": "NORM_X(MIN := #minLim, VALUE := #inputValue, MAX := #maxLim);",
        "additional_info": "The calculation is performed using the formula OUT = (VALUE - MIN) / (MAX - MIN). If the enable input signal EN is '0' or the value of MIN is greater than or equal to MAX, the enable output ENO returns a signal state of '0'.",
        "brief_description": "The function maps the input value to a linear scale for normalization, applicable in scenarios where a value needs to be normalized according to a specified range."
    },
    "REF": {
        "instruction_name": "REF",
        "parameters": {
            "Input": [
                {
                    "name": "Expression",
                    "type": "Bit sequence, integer, floating point, etc.",
                    "description": "The variable that the reference will point to."
                }
            ]
        },
        "example_code": "Provided SCL example code that demonstrates how to declare references in the block interface and assign the corresponding variables in the program code.",
        "additional_info": "Before using REF(), a reference must be declared in the block interface, and the specified variable's data type must exactly match the data type of the declared reference.",
        "brief_description": "The function allows the use of the REF() keyword to specify the variable that the reference points to, applicable in situations where references need to be declared in the block interface and variables assigned in program code."
    },
    "Variant_TO_DB_ANY": {
        "instruction_name": "Variant_TO_DB_ANY",
        "parameters": {
            "Input": [
                {
                    "name": "IN",
                    "type": "Variant",
                    "description": "Variable to be read."
                }
            ],
            "Output": [
                {
                    "name": "ERR",
                    "type": "INT",
                    "description": "Error information."
                }
            ]
        },
        "example_code": "Variant_TO_DB_ANY(in := #inputSource, err => #error);",
        "additional_info": "Executes this instruction if the condition is met; otherwise outputs '0' as the data block number.",
        "brief_description": "The function converts Variant to DB_ANY for querying the data block number of the variable to be read. It can be applied in scenarios that require reading data block information and handling errors."
    },
    "DB_ANY_TO_Variant": {
        "instruction_name": "DB_ANY_TO_Variant",
        "parameters": {
            "Input": [
                {
                    "name": "IN",
                    "type": "DB_ANY",
                    "description": "The data block whose number is to be read."
                }
            ],
            "Output": [
                {
                    "name": "ERR",
                    "type": "INT",
                    "description": "Error information."
                }
            ]
        },
        "example_code": "DB_ANY_TO_Variant(in := #nbrOfDB, err => #error);",
        "additional_info": "If the conditions are met, this instruction is executed. If not met or the data block does not exist, the value NULL is output in the RET_VAL parameter.",
        "brief_description": "The function generates a Variant variable from the data block, applicable in scenarios where data blocks need to be read and converted to Variant types."
    },
    "SCALE": {
        "instruction_name": "SCALE",
        "parameters": {
            "Input": [
                {
                    "name": "IN",
                    "type": "INT",
                    "description": "The input value to be scaled."
                },
                {
                    "name": "HI_LIM",
                    "type": "REAL",
                    "description": "Upper limit."
                },
                {
                    "name": "LO_LIM",
                    "type": "REAL",
                    "description": "Lower limit."
                },
                {
                    "name": "BIPOLAR",
                    "type": "BOOL",
                    "description": "Indicates whether to interpret the IN parameter as bipolar or unipolar."
                }
            ],
            "Output": [
                {
                    "name": "OUT",
                    "type": "REAL",
                    "description": "The result of the instruction."
                }
            ]
        },
        "example_code": "SCALE(IN := #inputValue, HI_LIM := #maxLim, LO_LIM := #minLim, BIPOLAR := #bipolarIndicator, OUT => #resultValue);",
        "additional_info": "The values of constants K1 and K2 depend on the signal state of the BIPOLAR parameter. If the value of IN exceeds K2 or is less than K1, an error is outputted.",
        "brief_description": "The function converts an integer to a scaled floating-point number within physical units, applicable in scenarios requiring the conversion and scaling of integers to physical units."
    },
    "UNSCALE": {
        "instruction_name": "UNSCALE",
        "parameters": {
            "Input": [
                {
                    "name": "IN",
                    "type": "REAL",
                    "description": "The input value to be unscaled and converted to an integer."
                },
                {
                    "name": "HI_LIM",
                    "type": "REAL",
                    "description": "Upper limit."
                },
                {
                    "name": "LO_LIM",
                    "type": "REAL",
                    "description": "Lower limit."
                },
                {
                    "name": "BIPOLAR",
                    "type": "BOOL",
                    "description": "Indicates whether the value of parameter IN should be interpreted as bipolar or unipolar."
                }
            ],
            "Output": [
                {
                    "name": "OUT",
                    "type": "INT",
                    "description": "The result of the instruction."
                }
            ]
        },
        "example_code": "UNSCALE(IN := #inputValue, HI_LIM := #maxLim, LO_LIM := #minLim, BIPOLAR := #bipolarIndicator, OUT => #resultValue);",
        "additional_info": "The values of constants K1 and K2 depend on the signal state of parameter BIPOLAR. If the value of IN exceeds HI_LIM or is less than LO_LIM, an error is output and the result is set to the nearest limit value.",
        "brief_description": "The function of unscaling converts floating-point numbers to integers and can be applied to scenarios where analog signals or floating-point values need to be mapped to an integer range."
    },
    "IF": {
        "instruction_name": "IF",
        "parameters": {},
        "example_code": "Provided SCL example code showing how to use the IF instruction for conditional judgment and executing corresponding instructions.",
        "additional_info": "The IF instruction can take various forms, including the IF THEN ELSE END_IF structure, and can nest any number of ELSIF and THEN combinations.",
        "brief_description": "The function is to control the branching of program flow based on conditions, applicable in scenarios that require conditional judgment and selection of different execution paths."
    },
    "CASE": {
        "instruction_name": "CASE",
        "parameters": {},
        "example_code": "Provided SCL example code demonstrating how to use the CASE instruction for multi-branch selection.",
        "additional_info": "The CASE instruction can be nested by replacing a block of instructions with CASE, and ELSE is an optional syntax part.",
        "brief_description": "The function is to create multiple branches and execute one of the sequences of instructions based on the value of an expression. It can be applied in scenarios that require multiple conditional checks and different operations."
    },
    "FOR": {
        "instruction_name": "FOR",
        "parameters": {},
        "example_code": "Provides SCL example code demonstrating how to use the FOR instruction for looping operations.",
        "additional_info": "FOR loops can be nested, and care should be taken to avoid infinite loops while writing. Pay attention to the data type and value range of the loop variable.",
        "brief_description": "The function is to repeatedly execute the program loop in a counting loop, applicable in scenarios requiring repeated operations, such as processing array elements, batch data processing, etc."
    },
    "WHILE": {
        "instruction_name": "WHILE",
        "parameters": {},
        "example_code": "Provided SCL example code demonstrating how to use the WHILE instruction for looping operations.",
        "additional_info": "WHILE loops can be nested and controlled through the CONTINUE and EXIT instructions.",
        "brief_description": "The function is to repeatedly execute a program loop while a condition is met, applicable in scenarios that require a set of operations to be repeated until a specific condition is satisfied."
    },
    "REPEAT": {
        "instruction_name": "REPEAT",
        "parameters": {},
        "example_code": "Provided SCL example code demonstrating how to use the REPEAT instruction for looping operations.",
        "additional_info": "Even if the termination condition is met, the REPEAT instruction executes only once and can control the execution of loops through the CONTINUE and EXIT instructions.",
        "brief_description": "The function is used to repeatedly execute a program loop until a certain condition is met, applicable in scenarios where actions need to be repeated until specific conditions are fulfilled."
    },
    "CONTINUE": {
        "instruction_name": "CONTINUE",
        "parameters": {},
        "example_code": "Provides SCL example code demonstrating how to use the CONTINUE instruction to skip the remaining part of the current loop when specific conditions are met.",
        "additional_info": "The CONTINUE instruction affects the program loop in which it is located.",
        "brief_description": "The function is used to end the current program execution of a FOR, WHILE, or REPEAT loop and re-evaluate the conditions for continuing the loop, applicable for skipping the remaining part of the current loop when specific conditions are met."
    },
    "EXIT": {
        "instruction_name": "EXIT",
        "parameters": {},
        "example_code": "Provided SCL example code demonstrates how to use the EXIT instruction to exit a loop when specific conditions are met.",
        "additional_info": "The EXIT instruction will affect the program loop in which it is located.",
        "brief_description": "The function is used to cancel the execution of FOR, WHILE, or REPEAT loops at any time, regardless of whether conditions are met, and can be applied in scenarios where there is a need to prematurely terminate a loop before completion."
    },
    "GOTO": {
        "instruction_name": "GOTO",
        "parameters": {},
        "example_code": "Provided SCL example code demonstrating how to use the GOTO instruction for program jumping.",
        "additional_info": "Jump labels and the GOTO instruction must be in the same block, and the jump label name can only be specified once.",
        "brief_description": "The function allows the program to continue execution from a specified point marked by a jump label, applicable in scenarios requiring unconditional jumps within the program."
    },
    "RETURN": {
        "instruction_name": "RETURN",
        "parameters": {},
        "example_code": "Provided SCL example code demonstrating how to use the RETURN instruction to exit the current block when specific conditions are met.",
        "additional_info": "If the RETURN instruction appears at the end of the block, it can be skipped.",
        "brief_description": "The function is to terminate the program execution within the current processing block and continue execution in the calling block, applicable in situations where it is necessary to exit the current block upon meeting specific conditions."
    },
    "ENDIS_PW": {
        "instruction_name": "ENDIS_PW",
        "parameters": {
            "Input": [
                {
                    "name": "REQ",
                    "type": "BOOL",
                    "description": "Determines the current password status for each access level in the CPU. -- F_PWD, Input, BOOL, locks or unlocks the password for the access level 'full access including fail-safe (unprotected)'."
                },
                {
                    "name": "FULL_PWD",
                    "type": "BOOL",
                    "description": "Locks or unlocks the password for the access level 'full access (unprotected)'."
                },
                {
                    "name": "R_PWD",
                    "type": "BOOL",
                    "description": "Locks or unlocks the password for the access level 'read-only access'."
                },
                {
                    "name": "HMI_PWD",
                    "type": "BOOL",
                    "description": "Locks or unlocks the password for the access level 'HMI access'."
                }
            ],
            "Output": [
                {
                    "name": "F_PWD_ON",
                    "type": "BOOL",
                    "description": "Current password status for the access level 'full access including fail-safe (unprotected)'."
                },
                {
                    "name": "FULL_PWD_ON",
                    "type": "BOOL",
                    "description": "Current password status for the access level 'full access (unprotected)'."
                },
                {
                    "name": "R_PWD_ON",
                    "type": "BOOL",
                    "description": "Current password status for the access level 'read-only access'."
                },
                {
                    "name": "HMI_PWD_ON",
                    "type": "BOOL",
                    "description": "Current password status for the access level 'HMI access'."
                },
                {
                    "name": "RET_VAL",
                    "type": "WORD",
                    "description": "Error information."
                }
            ]
        },
        "example_code": "Provides SCL example code demonstrating how to use the ENDIS_PW instruction to lock and unlock passwords.",
        "additional_info": "By locking the passwords, existing legitimate connections can be terminated, and after locking, access to the fail-safe CPU can be granted to a select few users.",
        "brief_description": "This function is used to lock and unlock passwords for various access levels in the CPU and can be applied in scenarios that require control over different access level permissions, such as terminating existing legitimate connections or granting specific users access to the fail-safe CPU."
    },
    "SHUT_DOWN": {
        "instruction_name": "SHUT_DOWN",
        "parameters": {
            "Input": [
                {
                    "name": "MODE",
                    "type": "UINT",
                    "description": "Specifies the mode for shutdown or restart."
                },
                {
                    "name": "COMMENT",
                    "type": "STRING",
                    "description": "Specifies the reason for the restart."
                }
            ],
            "Return": [
                {
                    "name": "Ret_Val",
                    "type": "WORD",
                    "description": "Return value indicating the result of the operation."
                }
            ]
        },
        "example_code": "Provides SCL example code demonstrating how to use the SHUT_DOWN instruction to shut down or restart the system.",
        "additional_info": "Different shutdown or restart operations are performed based on the value of the MODE parameter.",
        "brief_description": "The function is to shut down the target system, including the CPU and Windows, and can be applied in scenarios requiring safe shutdown or restart of the system."
    },
    "RE_TRIGR": {
        "instruction_name": "RE_TRIGR",
        "parameters": {
            "Input": [
                {
                    "name": "MODE",
                    "type": "UINT",
                    "description": "Specifies the mode for shutting down or restarting."
                },
                {
                    "name": "COMMENT",
                    "type": "STRING",
                    "description": "Specifies the reason for the restart."
                }
            ],
            "Return": [
                {
                    "name": "Ret_Val",
                    "type": "WORD",
                    "description": "Return value indicating the result of the operation."
                }
            ]
        },
        "example_code": "RE_TRIGR();",
        "additional_info": "This instruction does not take any parameters and does not provide error information; it is used to re-trigger the CPU cycle time monitoring.",
        "brief_description": "Function is to reset the cycle monitoring time, applicable in scenarios requiring re-triggering of the CPU's cycle time monitoring."
    },
    "STP": {
        "instruction_name": "STP",
        "parameters": {
            "Input": [
                {
                    "name": "MODE",
                    "type": "UINT",
                    "description": "Specifies the mode for shutting down or restarting."
                },
                {
                    "name": "COMMENT",
                    "type": "STRING",
                    "description": "Specifies the reason for the restart."
                }
            ],
            "Return": [
                {
                    "name": "Ret_Val",
                    "type": "WORD",
                    "description": "Return value indicating the result of the operation."
                }
            ]
        },
        "example_code": "Provided SCL example code demonstrating how to use the SHUT_DOWN instruction to shut down or restart the system.",
        "additional_info": "This instruction will terminate program execution; whether to switch from RUN mode to STOP mode depends on the CPU configuration.",
        "brief_description": "The function is to exit the program and set the CPU to STOP mode, applicable in scenarios that require a safe stop of the program or device."
    },
    "GET_ERROR": {
        "instruction_name": "GET_ERROR",
        "parameters": {},
        "example_code": "Provided SCL example code demonstrating how to use the GET_ERROR instruction to retrieve and handle error information.",
        "additional_info": "Error information can only be stored in operands of the ErrorStruct system data type, and this data type can be inserted multiple times, but the name cannot be changed.",
        "brief_description": "The function retrieves local error information and can be applied in scenarios that require diagnosis and handling of error information."
    },
    "GET_ERR_ID": {
        "instruction_name": "GET_ERR_ID",
        "parameters": {},
        "example_code": "Provides SCL example code that demonstrates how to use the GET_ERR_ID instruction to obtain and handle error IDs.",
        "additional_info": "The error ID can only be stored in operands of the WORD data type.",
        "brief_description": "The function is to obtain the local error ID, which can be applied in scenarios that require diagnosis and handling, such as obtaining error codes for appropriate error handling when errors occur in the program."
    },
    "INIT_RD": {
        "instruction_name": "INIT_RD",
        "parameters": {
            "Input": [
                {
                    "name": "Operand",
                    "type": "BOOL",
                    "description": "If the signal status of input 'REQ' is '1', reset all retained data."
                }
            ],
            "Output": [
                {
                    "name": "RET_VAL",
                    "type": "INT",
                    "description": "Error information."
                }
            ]
        },
        "example_code": "Provides SCL example code demonstrating how to use the INIT_RD instruction to reset all retained data.",
        "additional_info": "The execution time of this instruction exceeds the duration of the program cycle, so it can only be executed in the startup OB.",
        "brief_description": "The function is to initialize all retained data, which can be applied to reset all retained data in the startup OB."
    },
    "WAIT": {
        "instruction_name": "WAIT",
        "parameters": {
            "Input": [
                {
                    "name": "WT",
                    "type": "INT",
                    "description": "The delay time is measured in microseconds."
                }
            ]
        },
        "example_code": "Provides SCL example code that demonstrates how to use the INIT_RD instruction to reset all retained data.",
        "additional_info": "The configurable delay can range from -32768 to 32767 microseconds, and the shortest delay time depends on the CPU and the execution time of the instruction.",
        "brief_description": "The function is used to configure the delay time, pausing program execution. It can be applied to scenarios where a temporary stop of program execution is needed to provide a waiting period for a specific process."
    },
    "RUNTIME": {
        "instruction_name": "RUNTIME",
        "parameters": {
            "InOut": [
                {
                    "name": "Operand",
                    "type": "LREAL",
                    "description": "The result of the instruction is only applicable for internal applications."
                }
            ]
        },
        "example_code": "RUNTIME(#memory);",
        "additional_info": "This instruction uses an internal high-frequency counter to measure time. If the counter overflows, the return value of this instruction will be <= 0.0.",
        "brief_description": "The function measures the program's execution time and can be applied in scenarios where precise measurement of program block execution time is needed."
    },
    "DECO": {
        "instruction_name": "DECO",
        "parameters": {
            "Input": [
                {
                    "name": "IN",
                    "type": "UINT",
                    "description": "The position of the bit to be set in the output value."
                }
            ]
        },
        "example_code": "Provides SCL example code demonstrating how to use the DECO instruction for decoding operations.",
        "additional_info": "If the value of parameter IN is greater than 31, execute the instruction modulo 32.",
        "brief_description": "The function is for decoding, allowing the specified bit position in the input value to be set, which can be applied in scenarios that require bit manipulation of data, especially when specific bits need to be set based on the input value."
    },
    "ENCO": {
        "instruction_name": "ENCO",
        "parameters": {
            "Input": [
                {
                    "name": "IN",
                    "type": "bit string",
                    "description": "Input value."
                }
            ]
        },
        "example_code": "Provided SCL example code that demonstrates how to use the ENCO instruction for encoding operations.",
        "additional_info": "If the value of the parameter IN is 0, the output OUT will be '0'.",
        "brief_description": "The function is for encoding, reading the bit number of the least significant bit set in the input value, applicable in scenarios where it is necessary to encode the input bit string to obtain the position of the first bit set to 1 in the bit string."
    },
    "SEL": {
        "instruction_name": "SEL",
        "parameters": {
            "Input": [
                {
                    "name": "G",
                    "type": "BOOL",
                    "description": "Switch."
                },
                {
                    "name": "IN0",
                    "type": "Binary, Integer, etc.",
                    "description": "First input value."
                },
                {
                    "name": "IN1",
                    "type": "Binary, Integer, etc.",
                    "description": "Second input value."
                }
            ]
        },
        "example_code": "Provides an SCL example code demonstrating how to use the SEL instruction to select an input value based on the switch parameter.",
        "additional_info": "This instruction can only be executed when all parameter variables are of the same data type level.",
        "brief_description": "Function is to select one of the two input values based on the switch parameter. It can be applied in scenarios where different input values need to be chosen based on conditions."
    },
    "MUX": {
        "instruction_name": "MUX",
        "parameters": {
            "Input": [
                {
                    "name": "K",
                    "type": "integer",
                    "description": "Specifies the parameter for the content to be transmitted."
                },
                {
                    "name": "IN0",
                    "type": "binary, integer, etc.",
                    "description": "The first input value."
                },
                {
                    "name": "IN1",
                    "type": "binary, integer, etc.",
                    "description": "The second input value."
                },
                {
                    "name": "INn",
                    "type": "binary, integer, etc.",
                    "description": "Optional input values."
                },
                {
                    "name": "INELSE",
                    "type": "binary, integer, etc.",
                    "description": "The value to be copied when K<n."
                }
            ]
        },
        "example_code": "Provides SCL example code demonstrating how to use the MUX instruction for multiplexing operations.",
        "additional_info": "All variables assigned with parameters must be of the same data type.",
        "brief_description": "The function is multiplexing, capable of copying the selected input parameter values and issuing them. It is typically applied in scenarios requiring the selection of different input values based on various conditions. For example, when reading data from multiple sensors and selecting corresponding data based on sensor IDs, the MUX instruction can be utilized."
    },
    "DEMUX": {
        "instruction_name": "DEMUX",
        "parameters": {
            "Input": [
                {
                    "name": "K",
                    "type": "integer",
                    "description": "Specifies the output to which the input value (IN) should be copied."
                },
                {
                    "name": "IN",
                    "type": "binary, integer, etc.",
                    "description": "Input value."
                }
            ],
            "Output": [
                {
                    "name": "OUT0",
                    "type": "binary, integer, etc.",
                    "description": "First output."
                },
                {
                    "name": "OUT1",
                    "type": "binary, integer, etc.",
                    "description": "Second output."
                },
                {
                    "name": "OUTn",
                    "type": "binary, integer, etc.",
                    "description": "Optional output."
                },
                {
                    "name": "OUTELSE",
                    "type": "binary, integer, etc.",
                    "description": "Output where input IN's value should be copied when K > n."
                }
            ]
        },
        "example_code": "Provides SCL example code demonstrating how to use the DEMUX instruction for multiplexing operations.",
        "additional_info": "Ensure that the input parameter 'IN' and all output parameters have the same data type.",
        "brief_description": "The function is multiplexing, transferring the value of the input parameter to the selected output parameter. It can be applied in scenarios that require distributing one input value to multiple outputs based on a specified index."
    },
    "SHR": {
        "instruction_name": "SHR",
        "parameters": {
            "Input": [
                {
                    "name": "IN",
                    "type": "Bit string or integer",
                    "description": "The value to be shifted."
                },
                {
                    "name": "N",
                    "type": "USINT, UINT, etc.",
                    "description": "The number of bits to shift the value (IN)."
                }
            ],
            "Return": [
                {
                    "name": "Ret_Val",
                    "type": "Bit string, integer",
                    "description": "The result"
                }
            ]
        },
        "example_code": "#Result := SHR(IN := #in_byte, N := #n);  This is used to right shift the operand #in_byte by #n bits. The result of this instruction is returned as the function value in the 'Result' operand.",
        "additional_info": "When shifting unsigned values, the vacated bits on the left are filled with zeros; when shifting signed values, the sign bit's status is used to fill the vacated bits.",
        "brief_description": "The function is to shift the content of the parameter bit by bit to the right, applicable in scenarios where right bit manipulation is required."
    },
    "SHL": {
        "instruction_name": "SHL",
        "parameters": {
            "Input": [
                {
                    "name": "IN",
                    "type": "Bit string or integer",
                    "description": "The value to be shifted."
                },
                {
                    "name": "N",
                    "type": "USINT, UINT, etc.",
                    "description": "The number of bits to shift the value (IN)."
                }
            ],
            "Return": [
                {
                    "name": "Ret_Val",
                    "type": "Bit string, integer",
                    "description": "The result"
                }
            ]
        },
        "example_code": "#Result := SHL(IN := #in_byte, N := #n); Used to shift the operand #in_byte to the left by #n bits. The result of this instruction is returned as the function value in the 'Result' operand.",
        "additional_info": "The bits that are vacated in the result due to the shift will be filled with 0s.",
        "brief_description": "The function is to shift the contents of the parameters to the left bit by bit, applicable in scenarios where left shift operations on bit strings or integers are needed."
    },
    "ROL": {
        "instruction_name": "ROL",
        "parameters": {
            "Input": [
                {
                    "name": "IN",
                    "type": "bit string/integer",
                    "description": "The value to be rotated."
                },
                {
                    "name": "N",
                    "type": "USINT/UINT/UDINT/ULINT",
                    "description": "The number of positions to rotate the value (IN)."
                }
            ],
            "Return": [
                {
                    "name": "Ret_Val",
                    "type": "bit string/integer",
                    "description": "The result."
                }
            ]
        },
        "example_code": "#Result := ROL(IN := #valueToRotate, N := #numberBitPos);",
        "additional_info": "If the value of parameter N is '0', the input IN value is returned as the result. If the value of parameter N is greater than the available bits, the operand value in IN will be rotated by the specified number of positions.",
        "brief_description": "This function rotates the content of parameter IN to the left by one bit and returns the result. It can be applied in scenarios where data bits need to be rotated to the left."
    },
    "DRUM": {
        "instruction_name": "DRUM",
        "parameters": {
            "Input": [
                {
                    "name": "RESET",
                    "type": "BOOL",
                    "description": "Signal state '1' indicates reset state."
                },
                {
                    "name": "JOG",
                    "type": "BOOL",
                    "description": "When the signal state changes from '0' to '1', this instruction will proceed to the next step."
                },
                {
                    "name": "DRUM_EN",
                    "type": "BOOL",
                    "description": "Signal state '1' allows the sequencer to execute ahead based on event and time conditions."
                },
                {
                    "name": "LST_STEP",
                    "type": "BYTE",
                    "description": "Maximum number of steps."
                },
                {
                    "name": "EVENT(i)",
                    "type": "BOOL",
                    "description": "Event bit."
                }
            ],
            "Output": [
                {
                    "name": "OUT(j)",
                    "type": "BOOL",
                    "description": "Output bit."
                },
                {
                    "name": "Q",
                    "type": "BOOL",
                    "description": "Signal state '1' indicates that the time for the last step has expired."
                },
                {
                    "name": "OUT_WORD",
                    "type": "WORD",
                    "description": "Target word address where the sequencer writes output values."
                },
                {
                    "name": "ERR_CODE",
                    "type": "WORD",
                    "description": "Error information."
                }
            ]
        },
        "example_code": "Provides SCL example code demonstrating how to use the SHL instruction for left shift operations.",
        "additional_info": "The time consumed for each step is determined by the product of a preset time base (DTBP) and the preset step value (S_PRESET). The current step and preset step of the sequencer can be controlled through static parameters (e.g., DSP, DSC).",
        "brief_description": "Function is to execute a sequencer program, applicable for step operations based on event and time conditions. Control stepping of the program by assigning output bits and output words, as well as based on enable masks and preset time."
    },
    "DCAT": {
        "instruction_name": "DCAT",
        "parameters": {
            "Input": [
                {
                    "name": "CMD",
                    "type": "BOOL",
                    "description": "Command input."
                },
                {
                    "name": "O_FB",
                    "type": "BOOL",
                    "description": "Feedback input when opened."
                },
                {
                    "name": "C_FB",
                    "type": "BOOL",
                    "description": "Feedback input when closed."
                }
            ],
            "Output": [
                {
                    "name": "Q",
                    "type": "BOOL",
                    "description": "Displays the status of parameter CMD."
                },
                {
                    "name": "OA",
                    "type": "BOOL",
                    "description": "Alarm output when opened."
                },
                {
                    "name": "CA",
                    "type": "BOOL",
                    "description": "Alarm output when closed."
                }
            ],
            "Static": [
                {
                    "name": "ET",
                    "type": "DINT",
                    "description": "Current elapsed time."
                },
                {
                    "name": "PT",
                    "type": "DINT",
                    "description": "Preset timer value."
                },
                {
                    "name": "PREV_TIME",
                    "type": "DWORD",
                    "description": "Previous system time."
                },
                {
                    "name": "CMD_HIS",
                    "type": "BOOL",
                    "description": "CMD history bit."
                }
            ]
        },
        "example_code": "Provided SCL example code showing how to use the SHL instruction for left shift operation.",
        "additional_info": "If the signal status of the command input changes before the preset time is reached, timing is reset. This instruction does not provide error messages.",
        "brief_description": "The function uses the 'Discrete Control Timer Alarm' instruction to start timing from the moment the command to open or close is issued based on parameter CMD, activating the corresponding alarm after the specified time. It can be applied in scenarios requiring timed monitoring and alarms for equipment."
    },
    "MCAT": {
        "instruction_name": "MCAT",
        "parameters": {
            "Input": [
                {
                    "name": "O_CMD",
                    "type": "BOOL",
                    "description": "\"Open\" command input."
                },
                {
                    "name": "C_CMD",
                    "type": "BOOL",
                    "description": "\"Close\" command input."
                },
                {
                    "name": "S_CMD",
                    "type": "BOOL",
                    "description": "\"Stop\" command input."
                },
                {
                    "name": "O_FB",
                    "type": "BOOL",
                    "description": "Feedback input when opened."
                },
                {
                    "name": "C_FB",
                    "type": "BOOL",
                    "description": "Feedback input when closed."
                }
            ],
            "Output": [
                {
                    "name": "OO",
                    "type": "BOOL",
                    "description": "\"Open\" output."
                },
                {
                    "name": "CO",
                    "type": "BOOL",
                    "description": "\"Close\" output."
                },
                {
                    "name": "OA",
                    "type": "BOOL",
                    "description": "Alarm output when opened."
                },
                {
                    "name": "CA",
                    "type": "BOOL",
                    "description": "Alarm output when closed."
                },
                {
                    "name": "Q",
                    "type": "BOOL",
                    "description": "Signal status \"0\" indicates an error state."
                }
            ],
            "Static": [
                {
                    "name": "ET",
                    "type": "DINT",
                    "description": "Current elapsed time."
                },
                {
                    "name": "PT",
                    "type": "DINT",
                    "description": "Preset timer value."
                },
                {
                    "name": "PREV_TIME",
                    "type": "DWORD",
                    "description": "Last system time."
                },
                {
                    "name": "O_HIS",
                    "type": "BOOL",
                    "description": "\"Open\" historical bit."
                },
                {
                    "name": "C_HIS",
                    "type": "BOOL",
                    "description": "\"Close\" historical bit."
                }
            ]
        },
        "example_code": "SCL example code is provided, demonstrating how to use the SHL instruction for left shift operations.",
        "additional_info": "The instruction's response to various input conditions is detailed, listing changes in output parameters under different situations.",
        "brief_description": "The function is used to start timing when receiving an open command input (either open or close). If it exceeds the preset time before feedback is received, the corresponding alarm is triggered. This can be applied in scenarios requiring control of devices to complete opening or closing actions within a specified time."
    },
    "IMC": {
        "instruction_name": "IMC",
        "parameters": {
            "Input": [
                {
                    "name": "IN_BIT0 to IN_BIT15",
                    "type": "BOOL",
                    "description": "Compares the input bits with the mask bits."
                },
                {
                    "name": "CMP_STEP",
                    "type": "BYTE",
                    "description": "Step number for comparison using the mask."
                }
            ],
            "Output": [
                {
                    "name": "OUT",
                    "type": "BOOL",
                    "description": "Signal state '1' indicates a match has been found."
                },
                {
                    "name": "ERR_CODE",
                    "type": "WORD",
                    "description": "Error information."
                }
            ],
            "Static": [
                {
                    "name": "CMP_VAL",
                    "type": "ARRAY OF WORD",
                    "description": "Comparison mask."
                }
            ]
        },
        "example_code": "Provides SCL example code demonstrating how to use the SHL instruction for left shift operations.",
        "additional_info": "If a match is found during the comparison, the signal state of parameter OUT is set to '1'. Otherwise, the parameter OUT is set to '0'. If the value of parameter CMP_STEP is greater than 15, the instruction is not executed, and an error message is output in parameter ERR_CODE.",
        "brief_description": "The function compares input bits with mask bits, comparing the signal states of up to 16 configured input bits with the corresponding mask bits and outputs the match result. It can be applied in scenarios where logical control needs to be executed based on the comparison results of input bits and mask bits."
    },
    "SMC": {
        "instruction_name": "SMC",
        "parameters": {
            "Input": [
                {
                    "name": "IN_BIT0 to IN_BIT15",
                    "type": "BOOL",
                    "description": "Compares the input bits with the mask bits."
                }
            ],
            "Output": [
                {
                    "name": "OUT",
                    "type": "BOOL",
                    "description": "Signal status '1' indicates a match was found."
                },
                {
                    "name": "OUT_STEP",
                    "type": "BYTE",
                    "description": "Contains the step number with the matching mask."
                },
                {
                    "name": "ERR_CODE",
                    "type": "WORD",
                    "description": "Error information."
                }
            ],
            "Static": [
                {
                    "name": "LAST",
                    "type": "BYTE",
                    "description": "Specifies the step number of the last step scanned to obtain a matching mask."
                },
                {
                    "name": "CMP_VAL",
                    "type": "ARRAY OF WORD",
                    "description": "Comparison mask."
                }
            ]
        },
        "example_code": "Provides SCL example code that demonstrates how to use the SHL instruction for left shift operations.",
        "additional_info": "If a match is found, the signal status of parameter OUT is set to '1', and the step number with the matching mask is written to parameter OUT_STEP. If multiple steps have matching masks, parameter OUT_STEP only indicates the first step found. If no match is found, the signal status of parameter OUT is set to '0'.",
        "brief_description": "The function compares a scanned matrix and can be used to match the signal status of input bits with a comparison mask, commonly used to find the matching step number based on the state of input bits for program flow control."
    },
    "LEAD_LAG": {
        "instruction_name": "LEAD_LAG",
        "parameters": {
            "Input": [
                {
                    "name": "IN",
                    "type": "REAL",
                    "description": "The input value at the current sampling time to be processed."
                },
                {
                    "name": "SAMPLE_T",
                    "type": "INT",
                    "description": "Sampling time."
                }
            ],
            "Output": [
                {
                    "name": "OUT",
                    "type": "REAL",
                    "description": "The result of the instruction."
                },
                {
                    "name": "ERR_CODE",
                    "type": "WORD",
                    "description": "Error information."
                }
            ],
            "Static": [
                {
                    "name": "LD_TIME",
                    "type": "REAL",
                    "description": "The unit of the lead time is the same as the sampling time."
                },
                {
                    "name": "LG_TIME",
                    "type": "REAL",
                    "description": "The unit of the lag time is the same as the sampling time."
                },
                {
                    "name": "GAIN",
                    "type": "REAL",
                    "description": "Gain (gain in %/%)."
                },
                {
                    "name": "PREV_IN",
                    "type": "REAL",
                    "description": "The previous input."
                },
                {
                    "name": "PREV_OUT",
                    "type": "REAL",
                    "description": "The previous output."
                }
            ]
        },
        "example_code": "Provides SCL example code demonstrating how to use the SHL instruction for left shift operations.",
        "additional_info": "The gain value for the GAIN parameter must be greater than zero. If the value of GAIN is less than or equal to zero, no calculation will be performed, and an error message will be output in ERR_CODE.",
        "brief_description": "The function processes analog signals using the 'lead and lag algorithm' and can be applied in compensators for dynamic feedforward control."
    },
    "SEG": {
        "instruction_name": "SEG",
        "parameters": {
            "Input": [
                {
                    "name": "IN",
                    "type": "WORD",
                    "description": "Source word represented by four hexadecimal digits."
                }
            ],
            "Output": [
                {
                    "name": "OUT",
                    "type": "DWORD",
                    "description": "Bit pattern for a 7-segment display."
                }
            ]
        },
        "example_code": "SCL example code is provided, demonstrating how to use the SHL instruction for left shift operations.",
        "additional_info": "The result of the instruction is output as a double word in the OUT parameter.",
        "brief_description": "The function converts the specified source word of four hexadecimal digits into an equivalent bit pattern for a 7-segment display, which can be used to generate bit patterns for 7-segment displays."
    },
    "BCDCPL": {
        "instruction_name": "BCDCPL",
        "parameters": {
            "Input": [
                {
                    "name": "Operand",
                    "type": "Bit String",
                    "description": "7-bit BCD number."
                }
            ]
        },
        "example_code": "Provided SCL example code demonstrating how to use the SHL instruction for left shift operations.",
        "additional_info": "Calculate using the mathematical formula 10000000 (BCD encoded) - 7-bit BCD value.",
        "brief_description": "This function calculates the decimal complement of the 7-bit BCD number specified in the operand, applicable in scenarios requiring the complement of BCD encoding."
    },
    "BITSUM": {
        "instruction_name": "BITSUM",
        "parameters": {
            "Input": [
                {
                    "name": "Operand",
                    "type": "DWORD",
                    "description": "The operand for which to count the number of bits set to 1."
                }
            ]
        },
        "example_code": "BITSUM(#inputValue);",
        "additional_info": "No other useful information provided in the documentation.",
        "brief_description": "This function counts the number of bits set to '1' in the operand, applicable for situations where the count of 1's in a DWORD type operand needs to be determined."
    },
    "T_COMP": {
        "instruction_name": "T_COMP",
        "parameters": {
            "Input": [
                {
                    "name": "IN1",
                    "type": "DATE",
                    "description": "TIME, LTIME, TOD, LTOD, DT, LDT, DTL, S5Time, the first value to be compared."
                },
                {
                    "name": "IN2",
                    "type": "DATE",
                    "description": "TIME, LTIME, TOD, LTOD, DT, LDT, DTL, S5Time, the second value to be compared."
                }
            ],
            "Output": [
                {
                    "name": "OUT",
                    "type": "BOOL",
                    "description": "Return value."
                }
            ]
        },
        "example_code": "Provided SCL example code demonstrating how to use the SHL instruction for left shift operations.",
        "additional_info": "To make a comparison, the length and format of the data types must be the same. The result of the comparison will be output in the OUT parameter as a return value.",
        "brief_description": "This function compares the contents of two variables of data type 'timer' or 'date and time', applicable in scenarios requiring comparison of two time or date data to obtain comparison results."
    },
    "T_CONV": {
        "instruction_name": "T_CONV",
        "parameters": {
            "Input": [
                {
                    "name": "IN",
                    "type": "Integer, TIME, Date and Time*",
                    "description": "The value to be converted."
                }
            ],
            "Return": [
                {
                    "name": "OUT",
                    "type": "Integer, TIME, Date and Time*",
                    "description": "The conversion result."
                }
            ]
        },
        "example_code": "DT_TO_LTOD(inputTime);",
        "additional_info": "If the input and output parameters have the same data type, this instruction will copy the corresponding value.",
        "brief_description": "This function converts the data type of the IN input parameter to the data type on the OUT output, applicable in scenarios where it is necessary to convert data values between different data types."
    },
    "T_ADD": {
        "instruction_name": "T_ADD",
        "parameters": {
            "Input": [
                {
                    "name": "IN1",
                    "type": "TIME",
                    "description": "LTIME, the first number to be added."
                },
                {
                    "name": "IN2",
                    "type": "TIME",
                    "description": "LTIME, the second number to be added."
                }
            ],
            "Return": [
                {
                    "name": "OUT",
                    "type": "DINT",
                    "description": "DWORD, TIME, TOD, the result of the addition."
                }
            ]
        },
        "example_code": "T_ADD(IN1 := #timeValTOD, IN2 := #timeValTIME);",
        "additional_info": "During the calculation, the output parameter OUT may exceed its maximum value or fall below its minimum value. This error can be detected by evaluating the enable output ENO.",
        "brief_description": "The function adds two input time values and can be applied in scenarios where time information accumulation is required."
    },
    "T_SUB": {
        "instruction_name": "T_SUB",
        "parameters": {
            "Input": [
                {
                    "name": "IN1",
                    "type": "TIME",
                    "description": "LTIME, the minuend."
                },
                {
                    "name": "IN2",
                    "type": "TIME",
                    "description": "LTIME, the subtrahend."
                }
            ],
            "Return": [
                {
                    "name": "OUT",
                    "type": "DINT",
                    "description": "DWORD, TIME, TOD, the result of the subtraction."
                }
            ]
        },
        "example_code": "T_SUB(IN1 := #value1TOD, IN2 := #value2Time);",
        "additional_info": "During the calculation, the output parameter OUT may exceed its maximum value or fall below its minimum value. This error can be detected by evaluating the enable output ENO.",
        "brief_description": "The function performs a subtraction operation on the time values of two input parameters and can be applied in situations requiring time difference calculations."
    },
    "T_DIFF": {
        "instruction_name": "T_DIFF",
        "parameters": {
            "Input": [
                {
                    "name": "IN1",
                    "type": "DTL",
                    "description": "DATE, TOD, minuend."
                },
                {
                    "name": "IN2",
                    "type": "DTL",
                    "description": "DATE, TOD, subtrahend."
                }
            ],
            "Return": [
                {
                    "name": "OUT",
                    "type": "TIME",
                    "description": "INT, LTIME, INT, the difference between the input parameters."
                }
            ]
        },
        "example_code": "T_DIFF(IN1 := #todvalue1, IN2 := #todvalue2);",
        "additional_info": "If the time value in the IN2 input parameter is greater than the time value in the IN1 input parameter, a negative result will be output in the OUT output parameter.",
        "brief_description": "This function calculates the difference between two time values and can be applied in scenarios where calculating the interval between two points in time is necessary."
    },
    "T_COMBINE": {
        "instruction_name": "T_COMBINE",
        "parameters": {
            "Input": [
                {
                    "name": "IN1",
                    "type": "DATE",
                    "description": "Input variable for the date."
                },
                {
                    "name": "IN2",
                    "type": "TOD",
                    "description": "Input variable for the time."
                }
            ],
            "Return": [
                {
                    "name": "OUT",
                    "type": "DTL",
                    "description": "Return value that combines date and time, as DT or LDT."
                }
            ]
        },
        "example_code": "CONCAT_DATE_TOD(IN1 := #valueDATE, IN2 := #valueTOD);",
        "additional_info": "When using T_COMBINE in SCL programs, drag the instruction 'T_COMBINE' from the 'Instructions' task card into the SCL programming window, where the internal instructions CONCAT_DATE_TOD or CONCAT_DATE_LTOD will be displayed in the window.",
        "brief_description": "The function merges date values and time values to generate a combined date-time value, which can be applied in scenarios requiring the merging of date and time into a single timestamp."
    },
    "WR_SYS_T": {
        "instruction_name": "WR_SYS_T",
        "parameters": {
            "Input": [
                {
                    "name": "IN",
                    "type": "DTL",
                    "description": "Date and time in DT, LDT format."
                }
            ],
            "Return": [
                {
                    "name": "RET_VAL",
                    "type": "INT",
                    "description": "The status of the instruction."
                }
            ]
        },
        "example_code": "WR_SYS_T(#inputTIME);",
        "additional_info": "The module time of the CPU clock will be used as a template for all time processing processes initiated by the CPU.",
        "brief_description": "Function to set the date and time (module time) of the CPU clock, applicable in scenarios where the CPU clock time needs to be changed or set."
    },
    "RD_SYS_T": {
        "instruction_name": "RD_SYS_T",
        "parameters": {
            "Output": [
                {
                    "name": "OUT",
                    "type": "DTL",
                    "description": "Date and time of DT, LDT, and CPU."
                }
            ],
            "Return": [
                {
                    "name": "RET_VAL",
                    "type": "INT",
                    "description": "Status of the instruction."
                }
            ]
        },
        "example_code": "RD_SYS_T(#outputTIME);",
        "additional_info": "The obtained value does not include information about the local time zone or daylight saving time.",
        "brief_description": "The function reads the current date and time of the CPU clock (module time) and can be applied in scenarios that require obtaining system time."
    },
    "RD_LOC_T": {
        "instruction_name": "RD_LOC_T",
        "parameters": {
            "Output": [
                {
                    "name": "OUT",
                    "type": "DTL",
                    "description": "LDT, DTL, local time."
                }
            ],
            "Return": [
                {
                    "name": "RET_VAL",
                    "type": "INT",
                    "description": "Status of the instruction."
                }
            ]
        },
        "example_code": "RD_LOC_T(#outputLocTIME);",
        "additional_info": "When outputting the local time, information related to time zones, start times (already set in the CPU clock configuration) for daylight saving time and standard time will be used.",
        "brief_description": "The function reads the current local time from the CPU clock and can be applied to scenarios where local time needs to be retrieved while considering daylight saving time and standard time transitions."
    },
    "WR_LOC_T": {
        "instruction_name": "WR_LOC_T",
        "parameters": {
            "Input": [
                {
                    "name": "LOCTIME",
                    "type": "DTL",
                    "description": "LDT, local time."
                },
                {
                    "name": "DST",
                    "type": "BOOL",
                    "description": "Daylight Saving Time."
                }
            ],
            "Return": [
                {
                    "name": "RET_VAL",
                    "type": "INT",
                    "description": "Error message."
                }
            ]
        },
        "example_code": "WR_LOC_T(LOCTIME := #inputLocTIME, DST := #dstValue);",
        "additional_info": "The granularity of time information for local time and system time depends on the specific product and is at least 1 millisecond.",
        "brief_description": "This function is used to set the date and time of the CPU clock and can be applied in scenarios requiring synchronization or setting system time."
    },
    "SET_TIMEZONE": {
        "instruction_name": "SET_TIMEZONE",
        "parameters": {
            "Input": [
                {
                    "name": "REQ",
                    "type": "BOOL",
                    "description": "Execute function."
                },
                {
                    "name": "TimeZone",
                    "type": "TimeTransformationRule",
                    "description": "Local time zone parameters and daylight saving time/standard time conversion parameters."
                }
            ],
            "Output": [
                {
                    "name": "DONE",
                    "type": "BOOL",
                    "description": "Status parameter."
                },
                {
                    "name": "BUSY",
                    "type": "BOOL",
                    "description": "Status parameter."
                },
                {
                    "name": "ERROR",
                    "type": "BOOL",
                    "description": "Status parameter."
                },
                {
                    "name": "STATUS",
                    "type": "WORD",
                    "description": "Detailed error and status information."
                }
            ]
        },
        "example_code": "#SET_TIMEZONE_Instance(REQ := #execute,TimeZone := #timezone,DONE=>#statDone,BUSY=>#modeBUSY,ERROR=>#modeERROR,STATUS=>#statusTime);",
        "additional_info": "This instruction needs to be called each time the time zone is changed. For example, it is recommended to call 'SET_TIMEZONE' when starting the OB.",
        "brief_description": "The function is to set the local time zone and daylight saving time/standard time conversion parameters, which can be applied to set the system time zone or perform time zone conversion in startup organization blocks."
    },
    "SNC_RTCB": {
        "instruction_name": "SNC_RTCB",
        "parameters": {
            "Output": [
                {
                    "name": "RET_VAL",
                    "type": "INT",
                    "description": "If an error occurs during execution, the return value will contain the error code."
                }
            ]
        },
        "example_code": "SCL example code is provided, demonstrating how to use the SHL instruction for left shift operations.",
        "additional_info": "Synchronization can only succeed if 'SNC_RTCB' is called on a CPU that is designated as the master clock for at least one bus segment.",
        "brief_description": "The function synchronizes the clock slaves, transferring the date and time of the master clock from a specific bus segment to all clock slaves in that bus segment. It can be applied in scenarios where it is necessary to synchronize the date and time of the master clock with the slaves."
    },
    "TIME_TCK": {
        "instruction_name": "TIME_TCK",
        "parameters": {
            "Return": [
                {
                    "name": "RET_VAL",
                    "type": "TIME",
                    "description": "The system time read."
                }
            ]
        },
        "example_code": "Provides SCL example code demonstrating how to use the SHL instruction for left shift operations.",
        "additional_info": "The system time is a time counter that starts counting from 0 up to a maximum value of 2147483647 ms. When overflow occurs, the system time will restart counting from '0'.",
        "brief_description": "The function is to read the CPU's system time, which can be applied in scenarios that require obtaining the current system time or calculating program run time."
    },
    "RTM": {
        "instruction_name": "RTM",
        "parameters": {
            "Input": [
                {
                    "name": "NR",
                    "type": "RTM",
                    "description": "The number of the runtime hour counter."
                },
                {
                    "name": "MODE",
                    "type": "BYTE",
                    "description": "Job ID."
                },
                {
                    "name": "PV",
                    "type": "DINT",
                    "description": "The new value for the runtime hour counter."
                }
            ],
            "Output": [
                {
                    "name": "CQ",
                    "type": "BOOL",
                    "description": "The status of the runtime hour counter."
                },
                {
                    "name": "CV",
                    "type": "DINT",
                    "description": "The current value of the runtime hour counter."
                }
            ],
            "Return": [
                {
                    "name": "RET_VAL",
                    "type": "INT",
                    "description": "If an error occurs during instruction execution, the return value will contain the error code."
                }
            ]
        },
        "example_code": "Provides SCL example code demonstrating how to use the SHL instruction for left shift operations.",
        "additional_info": "The runtime hour counter can also be stopped or restarted during the execution of the user program, but this may result in incorrect saved values.",
        "brief_description": "Functionality for setting, starting, stopping, and reading operations of the 32-bit runtime hour counter of the CPU. It can be applied in scenarios where monitoring device runtime is required."
    },
    "S_MOVE": {
        "instruction_name": "S_MOVE",
        "parameters": {
            "Input": [
                {
                    "name": "IN",
                    "type": "STRING",
                    "description": "WSTRING, the source string."
                }
            ],
            "Output": [
                {
                    "name": "OUT",
                    "type": "STRING",
                    "description": "WSTRING, the target string."
                }
            ]
        },
        "example_code": "SCL example code is provided, showing how to use the SHL instruction for left shift operations.",
        "additional_info": "To copy variables of data type ARRAY, you can use the instructions 'MOVE_BLK' and 'UMOVE_BLK'.",
        "brief_description": "The function writes the string content from parameter IN to the data area specified by parameter OUT, applicable for scenarios where the content of one string needs to be copied to another string."
    },
    "S_COMP": {
        "instruction_name": "S_COMP",
        "parameters": {
            "Input": [
                {
                    "name": "IN1",
                    "type": "STRING",
                    "description": "WSTRING, input variable, format is STRING / WSTRING."
                },
                {
                    "name": "IN2",
                    "type": "STRING",
                    "description": "WSTRING, input variable, format is STRING / WSTRING."
                }
            ],
            "Output": [
                {
                    "name": "OUT",
                    "type": "BOOL",
                    "description": "The result of the comparison."
                }
            ]
        },
        "example_code": "Provided SCL example code demonstrating how to use the SHL instruction for left shift operation.",
        "additional_info": "Characters are compared starting from the left side based on their ASCII codes. The first different character determines the comparison result.",
        "brief_description": "The function compares the contents of two WSTRING format variables and outputs the comparison result, applicable in scenarios where string comparison is needed."
    },
    "S_CONV": {
        "instruction_name": "S_CONV",
        "parameters": {
            "Input": [
                {
                    "name": "IN",
                    "type": "CHAR",
                    "description": "WCHAR, USINT, UINT, UDINT, ULINT, SINT, INT, DINT, LINT, REAL, LREAL, value to be converted."
                }
            ],
            "Output": [
                {
                    "name": "OUT",
                    "type": "CHAR",
                    "description": "WCHAR, USINT, UINT, UDINT, ULINT, SINT, INT, DINT, LINT, REAL, LREAL, STRING, WSTRING, conversion result."
                }
            ]
        },
        "example_code": "INT_TO_STRING(#inputValueNBR);",
        "additional_info": "The length of the resulting string after conversion depends on the value in the IN input. In SCL, the string returned after computation will overwrite the contents of the variable at the return value location.",
        "brief_description": "The function converts the value in the IN input into the data format specified in the OUT output, and can be applied in scenarios that require conversion between different data types."
    },
    "STRG_VAL": {
        "instruction_name": "STRG_VAL",
        "parameters": {
            "Input": [
                {
                    "name": "IN",
                    "type": "STRING",
                    "description": "WSTRING, the numeric string to be converted."
                },
                {
                    "name": "FORMAT",
                    "type": "WORD",
                    "description": "The input format of the characters."
                },
                {
                    "name": "P",
                    "type": "UINT",
                    "description": "Reference to the first character to be converted."
                }
            ],
            "Output": [
                {
                    "name": "OUT",
                    "type": "USINT",
                    "description": "SINT, UINT, INT, UDINT, DINT, REAL, LREAL, the conversion result."
                }
            ]
        },
        "example_code": "STRG_VAL(IN := #inputSTRING,FORMAT := #resultSformat,P := #pointerSTRG,OUT=>#outputVAL);",
        "additional_info": "Valid characters for conversion include the digits '0' to '9', decimal points, decimal separators, scientific notation 'E' and 'e', as well as the plus and minus sign characters. If any invalid character is encountered, the conversion process will be aborted.",
        "brief_description": "The function converts a string into an integer or floating-point number, applicable for converting text-formatted numbers into numeric types that can be used for calculations."
    },
    "VAL_STRG": {
        "instruction_name": "VAL_STRG",
        "parameters": {
            "Input": [
                {
                    "name": "IN",
                    "type": "USINT",
                    "description": "The value to be converted, which can be SINT, UINT, INT, UDINT, DINT, REAL, LREAL."
                },
                {
                    "name": "SIZE",
                    "type": "USINT",
                    "description": "Number of character bits."
                },
                {
                    "name": "PREC",
                    "type": "USINT",
                    "description": "Number of decimal places."
                },
                {
                    "name": "FORMAT",
                    "type": "WORD",
                    "description": "Output format of the characters."
                }
            ],
            "Output": [
                {
                    "name": "OUT",
                    "type": "STRING",
                    "description": "WSTRING, the conversion result."
                }
            ],
            "InOut": [
                {
                    "name": "P",
                    "type": "UINT",
                    "description": "The character position to start writing the result."
                }
            ]
        },
        "example_code": "VAL_STRG(IN := #inputVAL, SIZE := #sizeSTRG, PREC := #precVAL, FORMAT := #resultV2Sformat, P := #pointer2STRG, OUT => #outputSTRING);",
        "additional_info": "Invalid characters will interrupt the conversion process.",
        "brief_description": "This function converts numeric values to strings. It can be applied in scenarios that require converting SINT, UINT, INT, UDINT, DINT, REAL, LREAL types of numbers into strings, while controlling character bit count, decimal places, and output format."
    },
    "Strg_TO_Chars": {
        "instruction_name": "Strg_TO_Chars",
        "parameters": {
            "Input": [
                {
                    "name": "STRG",
                    "type": "STRING",
                    "description": "WSTRING, the source for the copy operation."
                },
                {
                    "name": "PCHARS",
                    "type": "DINT",
                    "description": "Location in the array of (W)CHAR / BYTE / WORD structure from where to start writing characters."
                }
            ],
            "Output": [
                {
                    "name": "CNT",
                    "type": "UINT",
                    "description": "Number of characters moved."
                }
            ],
            "InOut": [
                {
                    "name": "CHARS",
                    "type": "Variant",
                    "description": "The target of the copy operation."
                }
            ]
        },
        "example_code": "Strg_TO_Chars(Strg := #inputSTRG,pChars := #pointerCHARS,Cnt=>#countCHARS,Chars := #myarrayCHARS);",
        "additional_info": "This operation can only copy ASCII characters. If the number of characters in the target field is less than the number of characters in the source string, only up to the maximum length of the target field will be written.",
        "brief_description": "The function copies a STRING or WSTRING type string to the corresponding character array, applicable in scenarios where string data needs to be converted to character array data."
    },
    "Chars_TO_Strg": {
        "instruction_name": "Chars_TO_Strg",
        "parameters": {
            "Input": [
                {
                    "name": "CHARS",
                    "type": "Variant",
                    "description": "The source for the copy operation."
                },
                {
                    "name": "PCHARS",
                    "type": "DINT",
                    "description": "The position in the array of (W)CHAR / BYTE / WORD from which to start copying characters."
                },
                {
                    "name": "CNT",
                    "type": "UINT",
                    "description": "The number of characters to copy."
                }
            ],
            "Output": [
                {
                    "name": "STRG",
                    "type": "STRING",
                    "description": "The target of the copy operation in WSTRING."
                }
            ]
        },
        "example_code": "Chars_TO_Strg(Chars := inputArrayCHARS,pChars := pointerCHARS,Cnt := countCHARS,Strg=>outputSTRG);",
        "additional_info": "The copy operation only supports ASCII characters. If the length of the string is less than the number of characters in the source domain, the maximum number of characters will be written in the string.",
        "brief_description": "This function copies a character array to a string or WSTRING type string, applicable in scenarios where there is a need to convert a character array into a string type for further processing."
    },
    "MAX_LEN": {
        "instruction_name": "MAX_LEN",
        "parameters": {
            "Input": [
                {
                    "name": "IN",
                    "type": "STRING",
                    "description": "WSTRING, string."
                }
            ],
            "Return": [
                {
                    "name": "OUT",
                    "type": "INT",
                    "description": "DINT, maximum character count."
                }
            ]
        },
        "example_code": "#maxLength := MAX_LEN(IN := #inputSTRING);",
        "additional_info": "(W)STRING data type variable includes two lengths.",
        "brief_description": "The function determines the maximum length of the input string and outputs it as a numeric value. It can be applied in scenarios where the length of a string needs to be obtained for further processing."
    },
    "JOIN": {
        "instruction_name": "JOIN",
        "parameters": {
            "Input": [
                {
                    "name": "Mode",
                    "type": "DWORD",
                    "description": "Specifies the merging method (CSV or FSR)."
                },
                {
                    "name": "RecSeparator",
                    "type": "Variant",
                    "description": "The separator or padding character for the source string."
                },
                {
                    "name": "EndSeparator",
                    "type": "Variant",
                    "description": "The separator for the end of the conversion."
                },
                {
                    "name": "SrcStruct",
                    "type": "Variant",
                    "description": "Pointer to the source string."
                },
                {
                    "name": "Count",
                    "type": "UDINT",
                    "description": "The number of strings to be joined."
                }
            ],
            "InOut": [
                {
                    "name": "DestArray",
                    "type": "Variant",
                    "description": "The area where the converted characters are written."
                },
                {
                    "name": "Position",
                    "type": "UDINT",
                    "description": "An index for the position in the entire string."
                }
            ],
            "Return": [
                {
                    "name": "Ret_Val",
                    "type": "INT",
                    "description": "The status of the instruction."
                }
            ]
        },
        "example_code": "Provides SCL example code showing how to use the SHL instruction for left shift operations.",
        "additional_info": "The JOIN instruction requires attention to the maximum length limit of the strings and the choice of separators when joining strings.",
        "brief_description": "The function is to concatenate multiple strings into an array using specified separators, applicable in scenarios that require integrating scattered string data into a single array format."
    },
    "SPLIT": {
        "instruction_name": "SPLIT",
        "parameters": {
            "Input": [
                {
                    "name": "Mode",
                    "type": "DWord",
                    "description": "Specifies the splitting method."
                },
                {
                    "name": "RecSeparator",
                    "type": "Variant",
                    "description": "The delimiter in CSV format or the padding character in FSR format."
                },
                {
                    "name": "EndSeparator",
                    "type": "Variant",
                    "description": "The delimiter at the end of the complete string."
                },
                {
                    "name": "SrcArray",
                    "type": "Variant",
                    "description": "A pointer to the array to be read."
                }
            ],
            "Output": [
                {
                    "name": "Count",
                    "type": "UDInt",
                    "description": "The number of strings found."
                }
            ],
            "InOut": [
                {
                    "name": "DestStruct",
                    "type": "Variant",
                    "description": "A structure containing the converted strings."
                },
                {
                    "name": "Position",
                    "type": "UDInt",
                    "description": "The position to start reading from the array."
                }
            ],
            "Return": [
                {
                    "name": "Ret_Val",
                    "type": "Int",
                    "description": "The result of the instruction execution/error code."
                }
            ]
        },
        "example_code": "Provided SCL example code demonstrating how to use the SHL instruction for left shift operations.",
        "additional_info": "When using the SPLIT instruction to split strings, different formatting methods and the choice of delimiters need to be considered.",
        "brief_description": "The function splits a character array into multiple strings based on specified delimiters, applicable for processing CSV and FSR formatted data."
    },
    "ATH": {
        "instruction_name": "ATH",
        "parameters": {
            "Input": [
                {
                    "name": "IN",
                    "type": "Variant",
                    "description": "Pointer to an ASCII string."
                },
                {
                    "name": "N",
                    "type": "INT",
                    "description": "Number of ASCII characters to be converted."
                }
            ],
            "Output": [
                {
                    "name": "OUT",
                    "type": "Variant",
                    "description": "Converted hexadecimal number."
                }
            ],
            "Return": [
                {
                    "name": "RET_VAL",
                    "type": "WORD",
                    "description": "Status of the instruction."
                }
            ]
        },
        "example_code": "Provided SCL example code demonstrating how to use the SHL instruction for left shift operations.",
        "additional_info": "The ATH instruction only accepts the digits 0-9 and uppercase or lowercase letters A-F during conversion; other characters will be converted to 0.",
        "brief_description": "Function to convert an ASCII string to the corresponding hexadecimal number, applicable in scenarios requiring the conversion of string representations of hexadecimal numbers to values that can be used for calculations or display."
    },
    "HTA": {
        "instruction_name": "HTA",
        "parameters": {
            "Input": [
                {
                    "name": "IN",
                    "type": "Variant",
                    "description": "The starting address of the hexadecimal number."
                },
                {
                    "name": "N",
                    "type": "UINT",
                    "description": "The number of hexadecimal bytes to be converted."
                }
            ],
            "Output": [
                {
                    "name": "OUT",
                    "type": "Variant",
                    "description": "The storage address of the result."
                }
            ],
            "Return": [
                {
                    "name": "RET_VAL",
                    "type": "WORD",
                    "description": "Error message."
                }
            ]
        },
        "example_code": "SCL example code is provided, demonstrating how to use the SHL instruction for left shift operations.",
        "additional_info": "The HTA instruction will produce an ASCII string whose length is twice that of the input value during conversion.",
        "brief_description": "The function converts hexadecimal numbers into their corresponding ASCII strings, which can be useful in scenarios where hexadecimal data stored in a variable needs to be converted into a readable ASCII string."
    },
    "LEN": {
        "instruction_name": "LEN",
        "parameters": {
            "Input": [
                {
                    "name": "IN",
                    "type": "STRING",
                    "description": "WSTRING, D, L or constant, string."
                }
            ],
            "Return": [
                {
                    "name": "OUT",
                    "type": "INT",
                    "description": "I, Q, M, D, L, number of valid characters."
                }
            ]
        },
        "example_code": "#strLength := LEN(#inputSTRING);",
        "additional_info": "The LEN instruction can read the actual number of characters used in a string; the length of an empty string is zero.",
        "brief_description": "The function is to determine the current length of a (W)STRING data type variable, applicable in scenarios where string length needs to be obtained."
    },
    "CONCAT": {
        "instruction_name": "CONCAT",
        "parameters": {
            "Input": [
                {
                    "name": "IN1",
                    "type": "STRING",
                    "description": "WSTRING, D, L or constant, the first string."
                },
                {
                    "name": "IN2",
                    "type": "STRING",
                    "description": "WSTRING, D, L or constant, the second string."
                }
            ],
            "Return": [
                {
                    "name": "OUT",
                    "type": "STRING",
                    "description": "WSTRING, D, L, the resulting concatenated string."
                }
            ]
        },
        "example_code": "#result := CONCAT(IN1 := #inputstring1, IN2 := #inputstring2);",
        "additional_info": "The CONCAT instruction limits the result to the available length if it exceeds the length of the OUT parameter during merging.",
        "brief_description": "The function is to merge two strings, applicable to scenarios where two strings need to be concatenated."
    },
    "LEFT": {
        "instruction_name": "LEFT",
        "parameters": {
            "Input": [
                {
                    "name": "IN",
                    "type": "STRING",
                    "description": "WSTRING, D, L or constant, string."
                },
                {
                    "name": "L",
                    "type": "BYTE",
                    "description": "INT, SINT, USINT, I, Q, M, D, L or constant, the number of characters to extract."
                }
            ],
            "Return": [
                {
                    "name": "OUT",
                    "type": "STRING",
                    "description": "WSTRING, D, the extracted portion of the string."
                }
            ]
        },
        "example_code": "#result := LEFT(IN := #inputSTRING, L := #extractNumber);",
        "additional_info": "The LEFT instruction returns the entire string if L is greater than the string length during extraction.",
        "brief_description": "This function extracts characters from the left side of a string and can be applied in scenarios where the left portion or the first few characters of a string are needed."
    },
    "RIGHT": {
        "instruction_name": "RIGHT",
        "parameters": {
            "Input": [
                {
                    "name": "IN",
                    "type": "STRING",
                    "description": "WSTRING, D, L or constant, string."
                },
                {
                    "name": "L",
                    "type": "BYTE",
                    "description": "INT, SINT, USINT, I, Q, M, D, L or constant, number of characters to extract."
                }
            ],
            "Return": [
                {
                    "name": "OUT",
                    "type": "STRING",
                    "description": "WSTRING, D, L, extracted substring."
                }
            ]
        },
        "example_code": "#result := RIGHT(IN := #inputSTRING, L := #extractNumber);",
        "additional_info": "The RIGHT instruction returns the entire string if L is greater than the length of the string.",
        "brief_description": "The function extracts characters from the right side of the string, applicable in scenarios where all characters after a certain position in the string need to be obtained."
    },
    "MID": {
        "instruction_name": "MID",
        "parameters": {
            "Input": [
                {
                    "name": "IN",
                    "type": "STRING",
                    "description": "WSTRING, D, L or constant, a string."
                },
                {
                    "name": "L",
                    "type": "BYTE",
                    "description": "INT, SINT, USINT, I, Q, M, D, L or constant, the length of the substring to extract."
                },
                {
                    "name": "P",
                    "type": "BYTE",
                    "description": "INT, SINT, USINT, I, Q, M, D, L or constant, the position of the first character to extract."
                }
            ],
            "Return": [
                {
                    "name": "OUT",
                    "type": "STRING",
                    "description": "WSTRING, D, L, the extracted portion of the string."
                }
            ]
        },
        "example_code": "#result := MID(IN := #inputSTRING, L := #extractNumber, P := #startingPoint);",
        "additional_info": "The MID instruction returns an empty string if P exceeds the length of the string during extraction.",
        "brief_description": "The function is to extract characters from the middle of a string, applicable in scenarios where a substring at a specified position in the string is required."
    },
    "DELETE": {
        "instruction_name": "DELETE",
        "parameters": {
            "Input": [
                {
                    "name": "IN",
                    "type": "STRING",
                    "description": "WSTRING, D, L or constant, string."
                },
                {
                    "name": "L",
                    "type": "BYTE",
                    "description": "INT, SINT, USINT, I, Q, M, D, L or constant, number of characters to delete."
                },
                {
                    "name": "P",
                    "type": "BYTE",
                    "description": "INT, SINT, USINT, I, Q, M, D, L or constant, position of the first character to delete."
                }
            ],
            "Return": [
                {
                    "name": "OUT",
                    "type": "STRING",
                    "description": "WSTRING, D, L, resulting string."
                }
            ]
        },
        "example_code": "#result := MID(IN := #inputSTRING, L := #extractNumber, P := #startingPoint);",
        "additional_info": "The DELETE instruction, when deleting, will return an empty string or the original string if P or L is negative or exceeds the string length.",
        "brief_description": "Function to delete specific characters from a string, applicable in scenarios where there is a need to remove specified positions and quantities of characters from a string."
    },
    "INSERT": {
        "instruction_name": "INSERT",
        "parameters": {
            "Input": [
                {
                    "name": "IN1",
                    "type": "STRING",
                    "description": "WSTRING, D, L, or constant, the original string."
                },
                {
                    "name": "IN2",
                    "type": "STRING",
                    "description": "WSTRING, D, L, or constant, the string to be inserted."
                },
                {
                    "name": "P",
                    "type": "BYTE",
                    "description": "INT, SINT, USINT, I, Q, M, D, L, or constant, the position to insert."
                }
            ],
            "Return": [
                {
                    "name": "OUT",
                    "type": "STRING",
                    "description": "WSTRING, D, L, the resulting string."
                }
            ]
        },
        "example_code": "#result := INSERT(IN1 := #input1_STRING, IN2 := #input2_STRING, P := #startingPoint);",
        "additional_info": "The INSERT instruction, when inserting, if P exceeds the length of IN1, append IN2 after IN1.",
        "brief_description": "The function is to insert characters into a string and can be applied in scenarios where a new string needs to be inserted at a specified position in the original string."
    },
    "REPLACE": {
        "instruction_name": "REPLACE",
        "parameters": {
            "Input": [
                {
                    "name": "IN1",
                    "type": "STRING",
                    "description": "WSTRING, D, L or constant, the string in which characters are to be replaced."
                },
                {
                    "name": "IN2",
                    "type": "STRING",
                    "description": "WSTRING, D, L or constant, the string containing the characters to be inserted."
                },
                {
                    "name": "L",
                    "type": "BYTE",
                    "description": "INT, SINT, USINT, I, Q, M, D, L or constant, the number of characters to be replaced."
                },
                {
                    "name": "P",
                    "type": "BYTE",
                    "description": "INT, SINT, USINT, I, Q, M, D, L or constant, the position of the first character to be replaced."
                }
            ],
            "Return": [
                {
                    "name": "OUT",
                    "type": "STRING",
                    "description": "WSTRING, D, L, the generated string."
                }
            ]
        },
        "example_code": "#result := REPLACE(IN1 := #input1_STRING, IN2 := #input2_STRING, L := #replaceNumber, P := #startingPoint);",
        "additional_info": "The REPLACE instruction returns an empty string if P or L are negative or zero during replacement.",
        "brief_description": "The function replaces characters in a string, applicable in scenarios where specific characters or a specified number of characters in the string need to be replaced with other characters."
    },
    "FIND": {
        "instruction_name": "FIND",
        "parameters": {
            "Input": [
                {
                    "name": "IN1",
                    "type": "STRING",
                    "description": "WSTRING, D, L, or constant, the string to be searched."
                },
                {
                    "name": "IN2",
                    "type": "STRING",
                    "description": "WSTRING, D, L, or constant, the string to search for."
                }
            ],
            "Return": [
                {
                    "name": "OUT",
                    "type": "INT",
                    "description": "I, Q, M, D, L, character position."
                }
            ]
        },
        "example_code": "#result := FIND(IN1 := #inputSTRING, IN2 := #STRINGsearchedFor);",
        "additional_info": "The FIND instruction outputs the position of the first occurrence of the specified value when searching; if there are no matches, it outputs 0.",
        "brief_description": "The function is to find a specific character or substring within a string and return the position of its first occurrence, applicable in scenarios where locating a specific character or substring within a string is needed."
    },
    "GetSymbolName": {
        "instruction_name": "GetSymbolName",
        "parameters": {
            "Input": [
                {
                    "name": "VARIABLE",
                    "type": "PARAMETER",
                    "description": "Selects the local interface to read the name of the input parameter."
                },
                {
                    "name": "SIZE",
                    "type": "DINT",
                    "description": "Limit value for the output character count in the OUT parameter."
                }
            ],
            "Return": [
                {
                    "name": "OUT",
                    "type": "WSTRING",
                    "description": "Output the variable name of the input parameter."
                }
            ]
        },
        "example_code": "SCL example code provided to demonstrate how to use the SHL instruction for left shift operations.",
        "additional_info": "The GetSymbolName instruction may lead to increased code memory requirements and longer program execution time.",
        "brief_description": "Functionality to read the variable name of the input parameter, applicable in scenarios where variable names need to be retrieved."
    },
    "GetSymbolPath": {
        "instruction_name": "GetSymbolPath",
        "parameters": {
            "Input": [
                {
                    "name": "VARIABLE",
                    "type": "PARAMETER",
                    "description": "Select the formal parameter. The name of the corresponding actual parameter will be read at the start of the call path."
                },
                {
                    "name": "SIZE",
                    "type": "DINT",
                    "description": "Output parameter limiting the number of characters."
                }
            ],
            "Output": [
                {
                    "name": "OUT",
                    "type": "WSTRING",
                    "description": "Output the variable name from which the input parameters originate."
                }
            ]
        },
        "example_code": "Provides SCL example code demonstrating how to use the SHL instruction for left shift operations.",
        "additional_info": "The GetSymbolPath instruction may increase code storage space requirements and prolong program execution time.",
        "brief_description": "The function is used to query the actual parameter name from the start of the call path, applicable in scenarios where there is a need to obtain the actual names of parameters passed in a function or method call."
    },
    "GetInstanceName": {
        "instruction_name": "GetInstanceName",
        "parameters": {
            "Input": [
                {
                    "name": "SIZE",
                    "type": "DINT",
                    "description": "Output character count limit at the OUT parameter."
                }
            ],
            "Output": [
                {
                    "name": "OUT",
                    "type": "WSTRING",
                    "description": "D, L, the name of the background data block being read."
                }
            ]
        },
        "example_code": "SCL example code is provided, demonstrating how to use the SHL instruction for a left shift operation.",
        "additional_info": "The GetInstanceName instruction may increase code memory space requirements and prolong program execution time.",
        "brief_description": "This function reads the name of the background data block in a function block, applicable when there is a need to obtain or process the name of the background data block in the program."
    },
    "GetInstancePath": {
        "instruction_name": "GetInstancePath",
        "parameters": {
            "Input": [
                {
                    "name": "SIZE",
                    "type": "DINT",
                    "description": "Limit on the number of characters for the output parameter."
                }
            ],
            "Output": [
                {
                    "name": "OUT",
                    "type": "WSTRING",
                    "description": "D, L, the global name of the read block instance."
                }
            ]
        },
        "example_code": "Provides SCL example code demonstrating how to use the SHL instruction for left shift operations.",
        "additional_info": "The GetInstancePath instruction may increase code memory space requirements and extend program runtime.",
        "brief_description": "The function is to query the composite global name of the block instance, applicable in scenarios where the global name of the block instance needs to be retrieved."
    },
    "GetBlockName": {
        "instruction_name": "GetBlockName",
        "parameters": {
            "Input": [
                {
                    "name": "SIZE",
                    "type": "DINT",
                    "description": "Limit on the number of characters for the RET_VAL parameter output."
                }
            ],
            "Output": [
                {
                    "name": "RET_VAL",
                    "type": "WSTRING",
                    "description": "Reads the program block name."
                }
            ]
        },
        "example_code": "SCL example code is provided, demonstrating how to use the SHL instruction for left shift operations.",
        "additional_info": "The GetBlockName instruction can limit the length of the block name; if the name is truncated, it will be marked with an '...'.",
        "brief_description": "The function is to read the block name, applicable for retrieving the name of a specified block, with the ability to limit the length of the output name. If the block name exceeds the specified length, the end of the name will be indicated by '...'."
    },
    "GetSymbolForReference": {
        "instruction_name": "GetSymbolForReference",
        "parameters": {
            "Input": [
                {
                    "name": "execute",
                    "type": "Bool",
                    "description": "Control parameter: starts the job on the rising edge."
                },
                {
                    "name": "objectRef",
                    "type": "Reference",
                    "description": "Reference to the object whose name is to be determined."
                },
                {
                    "name": "size",
                    "type": "DInt",
                    "description": "Defines the length for name truncation."
                }
            ],
            "Output": [
                {
                    "name": "done",
                    "type": "Bool",
                    "description": "The job has been executed with no errors."
                },
                {
                    "name": "busy",
                    "type": "Bool",
                    "description": "The job is not yet completed."
                },
                {
                    "name": "error",
                    "type": "Bool",
                    "description": "An error occurred during processing."
                },
                {
                    "name": "status",
                    "type": "Int",
                    "description": "The job processing status or error information."
                },
                {
                    "name": "reliability",
                    "type": "Int",
                    "description": "Reserved for future use."
                }
            ],
            "InOut": [
                {
                    "name": "symbol",
                    "type": "WString",
                    "description": "The determined name."
                }
            ]
        },
        "example_code": "Provided SCL example code demonstrating how to use the SHL instruction for left shift operation.",
        "additional_info": "GetSymbolForReference is an asynchronously executed instruction, and job execution can span multiple calls.",
        "brief_description": "The function determines the name of an indirectly addressed object, applicable in scenarios where obtaining the symbol name of an object is needed for further processing."
    }
}