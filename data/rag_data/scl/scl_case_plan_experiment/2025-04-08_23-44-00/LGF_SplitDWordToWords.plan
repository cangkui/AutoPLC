### 算法流程描述

#### 1. 功能概述
该函数用于将一个32位DWord（双字）数据拆分为两个16位Word（字）数据，其中：
- `word1` 存储高16位（MSW - Most Significant Word）
- `word0` 存储低16位（LSW - Least Significant Word）

#### 2. 输入输出定义
- **输入**：
  - `doubleWord`：32位DWord类型数据，待拆分的原始数据
- **输出**：
  - `word1`：16位Word类型数据，存储高16位
  - `word0`：16位Word类型数据，存储低16位

#### 3. 核心逻辑
1. **提取低16位（LSW）**：
   - 使用位掩码（`0xFFFF`）与原始DWord进行按位与操作，直接截取低16位。
   - 赋值给`word0`。

2. **提取高16位（MSW）**：
   - 将原始DWord右移16位，使高16位移动到低16位的位置。
   - 再次使用位掩码（`0xFFFF`）确保只保留低16位（此时为原始高16位）。
   - 赋值给`word1`。

3. **无错误处理**：
   - 该操作是纯位运算，不会产生运行时错误，因此直接设置`ENO := TRUE`表示执行成功。

#### 4. 关键点说明
- **位掩码的作用**：`0xFFFF`（二进制`1111111111111111`）用于确保只保留16位数据，避免移位后的数据污染。
- **移位操作**：右移16位是拆分高低字的核心操作，需注意PLC中移位函数的语法（如Siemens S7使用`SHR(IN, N)`）。
- **数据完整性**：无需检查输入有效性，因为任何32位数据均可合法拆分。

#### 5. 扩展性建议
- 若需支持其他位宽拆分（如DWord到4个Byte），可通过调整掩码和移位位数实现。
- 若需处理异常输入（如非对齐数据），可扩展错误状态码，但当前需求无需此逻辑。

#### 6. 伪代码示意（非必要，仅辅助理解）
```plaintext
FUNCTION SplitDWordToWords
    INPUT: doubleWord (32-bit)
    OUTPUT: word1 (16-bit), word0 (16-bit)

    word0 = doubleWord AND 0xFFFF
    word1 = (doubleWord >> 16) AND 0xFFFF
    RETURN SUCCESS
END_FUNCTION
```