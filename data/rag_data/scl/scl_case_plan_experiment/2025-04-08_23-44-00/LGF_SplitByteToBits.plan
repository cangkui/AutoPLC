### 算法流程描述（Byte to 8-Bit Splitter）

#### **功能概述**  
该函数用于将一个字节（Byte）拆分为8个独立的布尔值（Bit），分别对应字节的每一位（Bit0~Bit7）。输入是一个字节变量，输出是8个布尔变量，表示字节的每一位状态（0或1）。

---

#### **核心逻辑**
1. **输入处理**  
   - 输入参数 `byte` 是一个8位无符号整数（Byte），范围0~255。

2. **位拆分方法**  
   - 使用**位掩码（Bit Mask）**和**右移（SHR）**操作逐位提取：
     - **掩码 `MASK = 16#0001`**（二进制 `0000 0001`）用于提取最低有效位（LSB）。
     - 对每个位 `bitN`（N=0~7）：
       - 先将 `byte` 右移 `N` 位，使目标位移到最低位（LSB）。
       - 再与 `MASK` 进行按位与（AND）操作，提取该位的值（0或1）。
       - 结果赋值给对应的输出位（`bit0`~`bit7`）。

3. **输出映射**  
   - `bit0` = LSB（最低位，右移0位）  
   - `bit7` = MSB（最高位，右移7位）  

4. **错误处理**  
   - 无需特殊错误处理，因为输入为合法字节时，输出必然有效。  
   - 函数执行成功标志 `ENO` 直接设为 `TRUE`。

---

#### **关键点说明**
- **位操作效率**：通过右移和掩码组合实现高效位提取，避免循环或复杂判断。
- **硬件友好性**：直接映射到PLC的位操作指令，适合底层硬件执行。
- **扩展性**：若需支持其他数据类型（如Word、DWord），可复用相同逻辑，仅调整掩码和右移位数。

---

#### **伪代码示意（非具体实现）**
```plaintext
FUNCTION SplitByteToBits(byte):
    MASK = 0x01
    bit0 = (byte >> 0) & MASK
    bit1 = (byte >> 1) & MASK
    ...
    bit7 = (byte >> 7) & MASK
    RETURN bit0..bit7
```

此逻辑清晰、高效，可直接用于生成类似功能的代码。