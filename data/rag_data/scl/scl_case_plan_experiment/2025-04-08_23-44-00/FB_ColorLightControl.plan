### 算法流程描述（思维逻辑）

#### 1. **需求分析**
- **目标**：通过按钮控制三个指示灯（绿、红、黄）的循环点亮顺序。
- **输入**：`controlButton`（布尔型脉冲信号，每次按下时从0跳变到1）。
- **输出**：`greenLight`、`redLight`、`yellowLight`（布尔型，分别控制对应灯的亮灭）。
- **循环顺序**：
  1. 第一次按下：绿灯亮（其他灭）。
  2. 第二次按下：红灯亮（其他灭）。
  3. 第三次按下：黄灯亮（其他灭）。
  4. 第四次按下：三灯全亮。
  5. 第五次按下：三灯全灭。
  6. 第六次按下：重新从绿灯亮开始循环。

#### 2. **核心逻辑设计**
- **状态机模式**：用整数变量`lightState`（1~5）表示当前状态，每次按钮触发时切换状态。
- **边缘检测**：通过比较当前按钮状态和上一次状态（`lastControlButtonState`），确保每次按钮按下只触发一次状态切换。
- **循环控制**：当`lightState`超过5时，重置为1，实现循环。

#### 3. **关键步骤**
1. **检测按钮触发**：
   - 条件：`controlButton`为真且`lastControlButtonState`为假（上升沿）。
   - 动作：`lightState`加1，若超过5则重置为1。
2. **更新按钮历史状态**：
   - 记录当前按钮状态到`lastControlButtonState`，供下一次边缘检测使用。
3. **根据状态控制灯**：
   - 使用`CASE`语句，根据`lightState`的值设置灯的亮灭组合。

#### 4. **异常处理与优化**
- **初始化**：`lightState`初始值为0（或1），确保首次触发时进入正确状态。
- **代码可读性**：用明确的`CASE`分支代替复杂逻辑，便于维护。
- **扩展性**：若未来需增加灯或状态，只需扩展`CASE`分支和`lightState`范围。

#### 5. **伪代码流程**
```plaintext
IF 检测到按钮上升沿 THEN
    lightState += 1
    IF lightState > 5 THEN
        lightState := 1
    END_IF
END_IF

根据lightState的值：
    1 → 绿灯亮，其他灭
    2 → 红灯亮，其他灭
    3 → 黄灯亮，其他灭
    4 → 三灯全亮
    5 → 三灯全灭
```

#### 6. **与参考代码的差异**
- 参考代码中`lightState`初始值为0，首次触发后变为1（绿灯亮），符合需求。
- 未显式处理初始化问题，但实际运行中首次触发会正确进入状态1。
- 输出直接赋值，无需额外写入逻辑。

#### 7. **总结**
- **核心**：状态机 + 边缘检测。
- **简洁性**：用5个状态覆盖所有灯的组合，避免冗余判断。
- **可靠性**：边缘检测确保每次按钮动作仅触发一次状态切换。