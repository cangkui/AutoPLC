### 算法流程描述（Endianness Detection Function）

#### **功能概述**
该函数用于检测当前系统的字节序（Endianness），返回 `TRUE` 表示系统采用大端序（Big-Endian），否则为小端序（Little-Endian）。

#### **核心逻辑**
1. **初始化常量**：
   - `BIT_PATTERN_ONE`：一个16位的字（`Word`），初始值为 `16#0001`（即二进制 `0000 0000 0000 0001`）。
   - `MOVE_BIT_POS`：位移位数（15），用于将 `BIT_PATTERN_ONE` 的最高有效位（MSB）左移至最高位。

2. **检测逻辑**：
   - 使用 `SHL`（左移）指令将 `BIT_PATTERN_ONE` 左移15位，得到 `tempSixteenBits`（结果应为 `1000 0000 0000 0000`）。
   - 检查 `tempSixteenBits` 的最低字节（`%B0`）是否为 `B#16#00`：
     - 如果是 `B#16#00`，说明系统是小端序（Little-Endian），因为最低字节存储的是高位数据。
     - 如果不是 `B#16#00`，说明系统是大端序（Big-Endian），因为最低字节存储的是低位数据。

3. **返回值**：
   - 返回 `TRUE` 表示大端序，`FALSE` 表示小端序。

#### **关键点**
- **位移操作**：通过左移操作，将 `BIT_PATTERN_ONE` 的最高位设置为1，其余位为0。
- **字节序检测**：检查最低字节的值，判断数据在内存中的存储方式。
- **无输入参数**：该函数仅依赖系统本身的字节序，无需外部输入。

#### **适用场景**
- 适用于需要根据系统字节序进行数据处理的场景（如网络通信、跨平台数据交换）。
- 适用于S7-1200/1500系列PLC，兼容TIA Portal工程环境。

#### **优化与扩展**
- 如果未来需要支持更多字节序检测（如混合字节序），可以扩展逻辑。
- 可以封装成更通用的函数，支持不同数据宽度（如DWord、LWord）的检测。

---

### **总结**
该函数通过位移和字节检查的方式，高效地检测系统字节序，适用于嵌入式系统和工业自动化场景。核心逻辑简单直接，无需复杂计算，适合在PLC等资源受限环境中运行。