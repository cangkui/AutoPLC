### 算法流程描述

#### 1. **功能概述**
该功能块用于计算给定数据集的箱线图（Boxplot）统计信息，包括四分位数、中位数、极值、异常值以及偏度。通过输入参数`execute`的上升沿触发计算，输入参数`rangeOutlier`用于控制异常值的检测范围。

#### 2. **输入输出定义**
- **输入参数**：
  - `execute`：布尔型，上升沿触发计算。
  - `rangeOutlier`：实数型，异常值检测范围参数（默认1.5）。
  - `values`：实数数组，待计算的数据集（输入输出参数）。
  
- **输出参数**：
  - 统计信息：包括`min`（最小值）、`max`（最大值）、`q25`（第一四分位数）、`median`（中位数）、`q75`（第三四分位数）、`outlierMin`（下限异常值百分比）、`outlierMax`（上限异常值百分比）、`skewness`（偏度）。
  - 状态信息：`error`（错误标志）、`status`（状态码）、`subfunctionStatus`（子功能状态码）。

#### 3. **算法流程**
1. **触发检测**：
   - 检测`execute`的上升沿，触发计算。
   - 若`execute`为假，则标记状态为未调用（`STATUS_NO_CALL`）。

2. **输入验证**：
   - 检查`rangeOutlier`是否合法（必须大于1.0或等于0.0）。
   - 检查数组`values`的下界是否为非负数。

3. **数据预处理**：
   - 计算数组元素数量。
   - 调用排序功能块（`LGF_ShellSort_LReal`）对数组进行排序。

4. **统计计算**：
   - **中位数（median）**：
     - 若元素数量为偶数，取中间两个数的平均值。
     - 若为奇数，取中间值。
   - **四分位数（q25和q75）**：
     - 通过插值法计算第一和第三四分位数。
   - **异常值检测**（若`rangeOutlier ≠ 0`）：
     - 计算四分位距（IQR = q75 - q25）。
     - 根据`rangeOutlier`计算异常值边界（下限：q25 - rangeOutlier * IQR；上限：q75 + rangeOutlier * IQR）。
     - 遍历数组，统计超出边界的异常值数量，并计算异常值百分比。
   - **偏度（skewness）**：
     - 公式：`(q25 + q75 - 2 * median) / (q75 - q25)`。

5. **输出更新**：
   - 根据`rangeOutlier`是否为0，选择输出原始极值或剔除异常值后的极值。
   - 更新所有统计信息和状态码。

#### 4. **状态与错误处理**
- 状态码：
  - `STATUS_EXECUTION_FINISHED`：计算完成。
  - `STATUS_NO_CALL`：未触发计算。
  - `ERR_RANGE_NOT_OK`：`rangeOutlier`非法。
  - `ERR_NEG_ARR_BOUND`：数组下界为负。
  - `ERR_SHELL_SORT`：排序失败。
- 错误标志`error`为状态码的最高位（位15）。

#### 5. **注意事项**
- 数组必须为非空且已初始化。
- 若`rangeOutlier = 0`，跳过异常值检测，直接使用原始极值。
- 排序功能块的错误会终止计算并返回错误状态。

### 代码生成指导
1. **变量定义**：
   - 内部变量用于存储中间结果（如`statQuartil25`、`statMedian`等）。
   - 常量定义异常值检测的边界值（如`RANGE_OUTLIER_LOWER_BORDER = 1.0`）。

2. **主逻辑**：
   - 使用`CASE`或`IF-ELSIF`结构处理不同状态。
   - 排序和统计计算分步实现，确保可读性。

3. **边缘情况处理**：
   - 空数组或非法输入时直接返回错误。
   - 避免除以零（如计算偏度时检查`q75 - q25 ≠ 0`）。

4. **性能优化**：
   - 排序算法选择高效的实现（如Shell排序）。
   - 减少不必要的循环和计算。