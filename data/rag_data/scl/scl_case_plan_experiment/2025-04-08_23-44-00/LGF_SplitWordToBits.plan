### 算法流程描述

#### 1. **功能概述**
该函数 `LGF_SplitWordToBits` 用于将一个 16 位的 Word 变量拆分为 16 个独立的布尔（Bool）变量，每个布尔变量对应 Word 中的一个位（bit）。输入是一个 Word 变量，输出是 16 个 Bool 变量，分别对应 Word 的 bit0（最低位）到 bit15（最高位）。

#### 2. **输入和输出**
- **输入**：
  - `word`：16 位的 Word 变量，需要拆分为 16 个位。
- **输出**：
  - `bit0` 到 `bit15`：16 个 Bool 变量，分别对应 `word` 的每一位。

#### 3. **核心逻辑**
- **位提取方法**：
  - 使用 **位掩码（Bit Mask）** 和 **右移（Shift Right, SHR）** 操作来提取每一位的值。
  - 掩码 `MASK` 定义为 `16#0001`（即二进制 `0000 0000 0000 0001`），用于提取最低位。
  - 对于 `bitN`（N 从 0 到 15）：
    - 将 `word` 右移 N 位，使目标位移动到最低位。
    - 使用 `AND` 操作与 `MASK` 进行掩码，提取最低位的值。
    - 如果结果为非零，则 `bitN` 为 `TRUE`，否则为 `FALSE`。

#### 4. **实现步骤**
1. **初始化掩码**：
   - 定义一个常量 `MASK`，值为 `16#0001`（即 `1`）。
2. **提取每一位**：
   - 对于 `bit0`：
     - 直接使用 `word AND MASK` 提取最低位。
   - 对于 `bit1` 到 `bit15`：
     - 将 `word` 右移 N 位（N 为 1 到 15），然后与 `MASK` 进行 `AND` 操作。
3. **输出赋值**：
   - 将提取的每一位值赋给对应的输出变量 `bit0` 到 `bit15`。
4. **错误处理**：
   - 此函数无需错误处理，始终执行成功（`ENO := TRUE`）。

#### 5. **优化与扩展**
- **可读性优化**：
  - 可以使用循环结构（如 `FOR` 循环）简化代码，但 SCL 中可能不支持动态输出变量赋值，因此直接展开更可靠。
- **扩展性**：
  - 如果需要支持其他数据类型（如 DWord），可以扩展掩码和移位逻辑。

#### 6. **伪代码示例（非实际 SCL 代码）**
```
FUNCTION LGF_SplitWordToBits
INPUT:
    word: Word
OUTPUT:
    bit0..bit15: Bool

CONSTANT:
    MASK = 0x0001

BEGIN
    bit0 = word AND MASK
    bit1 = (word >> 1) AND MASK
    ...
    bit15 = (word >> 15) AND MASK
    ENO = TRUE
END
```

#### 7. **注意事项**
- **位序**：
  - `bit0` 是最低位（LSB），`bit15` 是最高位（MSB），符合常规位序约定。
- **性能**：
  - 直接展开的移位和掩码操作效率高，适合实时控制场景。

### 总结
该函数的核心是通过移位和掩码操作提取 Word 的每一位，逻辑清晰且高效。适用于需要单独访问 Word 中每一位的场景（如状态标志解析、位控设备驱动等）。