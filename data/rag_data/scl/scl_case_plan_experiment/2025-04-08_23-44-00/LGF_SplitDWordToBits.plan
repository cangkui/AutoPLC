### 算法流程描述（DWord 拆分为 32 位布尔值）

#### 1. **需求理解**
- **输入**：一个 32 位无符号整数（DWord）。
- **输出**：32 个布尔变量，分别对应输入 DWord 的每一位（bit31 为最高位，bit0 为最低位）。
- **功能**：将输入的 DWord 按位拆解，每一位的值（0 或 1）转换为对应的布尔输出（FALSE 或 TRUE）。

#### 2. **核心逻辑**
- **位提取方法**：
  - 使用 **位掩码（Bit Mask）** 和 **右移（SHR）** 操作提取每一位的值。
  - 掩码 `MASK = 16#0001`（即二进制 `0000_0000_0000_0001`），用于提取最低位。
  - 对输入 DWord 进行右移 `N` 位后，再与 `MASK` 进行按位与（AND）操作，得到第 `N` 位的值（0 或 1）。
  - 由于 SCL 的布尔类型会自动将非零值转换为 `TRUE`，因此无需额外转换。

#### 3. **实现步骤**
1. **初始化掩码**：
   - 定义一个常量 `MASK`，值为 `16#0001`（即二进制最低位为 1，其余为 0）。
2. **提取每一位**：
   - **bit0**（最低位）：直接 `#doubleWord AND MASK`。
   - **bit1~bit31**：
     - 先对 `#doubleWord` 右移 `N` 位（`SHR(IN := #doubleWord, N := N)`），将目标位移至最低位。
     - 再与 `MASK` 进行按位与操作，提取该位的值。
3. **输出赋值**：
   - 将提取的每一位值（0 或 1）赋值给对应的布尔输出变量。
4. **错误处理**：
   - 此功能无需错误处理，直接设置 `ENO := TRUE` 表示执行成功。

#### 4. **优化与扩展性**
- **代码冗余**：由于每一位的提取逻辑相同，可以通过循环或宏定义减少重复代码（但 SCL 不支持运行时循环展开，需手动编写）。
- **可读性**：可以通过注释明确每一位的提取逻辑，或使用更直观的位操作函数（如 `BIT` 指令，如果支持）。
- **性能**：位操作是底层硬件支持的高效操作，无需优化。

#### 5. **边界情况**
- **输入为 0**：所有输出位均为 `FALSE`。
- **输入为全 1**（`16#FFFF_FFFF`）：所有输出位均为 `TRUE`。
- **部分位为 1**：仅对应位输出 `TRUE`，其余为 `FALSE`。

#### 6. **替代方案**
- 如果 PLC 支持 `BIT` 指令（如 `#bit0 := BIT(#doubleWord, 0)`），可直接使用，代码更简洁。
- 若输出需要打包为数组（如 `ARRAY[0..31] OF BOOL`），可优化接口设计。

### 总结
该功能的核心是 **位掩码 + 右移** 操作，通过逐位提取实现 DWord 到 32 个布尔值的拆分。代码直接、高效，适合硬件级操作。