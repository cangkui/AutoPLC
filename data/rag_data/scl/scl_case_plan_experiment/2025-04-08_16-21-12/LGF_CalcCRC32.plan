### 算法流程描述

#### 1. **功能概述**
该函数`LGF_CalcCRC32`用于计算给定数据流的CRC-32校验值。CRC（循环冗余校验）是一种常用的错误检测算法，广泛应用于数据通信和存储领域。该函数支持自定义初始值、生成多项式（mask）和计算的数据长度。

#### 2. **输入参数**
- **initValue**：CRC计算的初始值（32位无符号整数）。
- **mask**：生成多项式（32位无符号整数），用于CRC计算中的异或操作。
- **noOfElements**：指定参与CRC计算的数组元素数量（无符号整数）。如果为0，则使用整个数组。
- **array**：输入的数据流（字节数组），用于计算CRC值。

#### 3. **输出参数**
- **error**：布尔值，表示是否发生错误。
- **status**：状态码，指示函数执行的状态（如成功或错误类型）。
- **返回值**：计算得到的CRC-32值（32位无符号整数）。

#### 4. **状态码**
- `16#0000`（`STATUS_NO_ERROR`）：无错误，计算成功。
- `16#8400`（`ERR_NO_OF_ELEMENTS`）：指定的`noOfElements`超出数组范围。

#### 5. **算法流程**
1. **初始化**
   - 将`tempCRC`初始化为`initValue`。
   - 计算输入数组的上下限（`tempLowerLimit`和`tempUpperLimit`）。
   - 检查`noOfElements`是否合法：
     - 如果`noOfElements > 0`，检查是否超出数组范围。如果超出，设置错误状态并返回。
     - 否则，调整`tempUpperLimit`为`tempLowerLimit + noOfElements - 1`。

2. **CRC计算**
   - 遍历数组中的每个字节（从`tempLowerLimit`到`tempUpperLimit`）：
     - 将当前字节左移24位（转换为32位整数的高字节），并与`tempCRC`进行异或操作。
     - 对`tempCRC`进行8次位操作（每次处理1位）：
       - 检查最高位（`tempCRC.%X31`）是否为1：
         - 如果是，左移1位后与`mask`异或。
         - 否则，仅左移1位。

3. **输出结果**
   - 将最终的`tempCRC`作为返回值。
   - 设置`status`为`STATUS_NO_ERROR`，`error`为`FALSE`，`ENO`为`TRUE`。

#### 6. **关键点**
- **位操作**：CRC的核心是通过移位和异或操作实现多项式除法。
- **错误处理**：检查输入参数的合法性，避免数组越界。
- **性能优化**：使用临时变量减少重复计算，循环展开（8次位操作）提高效率。

#### 7. **代码调整建议**
- **输入验证**：可以增加对`mask`是否为0的检查，避免无效的生成多项式。
- **常量定义**：将`SHIFT_ONE_BIT`和`SHIFT_THREE_BYTES`等常量定义为全局常量，便于维护。
- **注释补充**：在关键步骤（如异或和移位操作）添加注释，说明其数学意义。

#### 8. **示例调用**
```scl
VAR
  data : Array[1..4] of Byte := [16#01, 16#02, 16#03, 16#04];
  crcValue : DWord;
  err : Bool;
  stat : Word;
END_VAR

crcValue := "LGF_CalcCRC32"(
  initValue := 16#FFFFFFFF,
  mask := 16#EDB88320,
  noOfElements := 4,
  array := data,
  error => err,
  status => stat
);
```

### 总结
该函数实现了标准的CRC-32算法，通过输入参数灵活控制计算过程，并通过状态码和错误标志提供可靠的错误处理机制。代码结构清晰，适合嵌入到需要数据校验的自动化系统中。