### 算法流程描述（用于指导代码实现）

#### 1. **功能目标**
   - 检测当前系统的字节序（Endianness），判断是否为小端模式（Little Endian）。
   - 返回 `TRUE` 表示系统是小端模式，否则返回 `FALSE`。

#### 2. **核心逻辑**
   - **小端模式的定义**：在小端模式下，数据的低字节存储在低地址，高字节存储在高地址。
   - **检测方法**：
     1. 构造一个特定的位模式（如 `0x0001`）。
     2. 通过位操作（如左移）将该位模式转换为一个可检测的形式（如 `0x8000`）。
     3. 检查该数据的低字节是否为 `0x00`：
        - 如果是，说明系统是小端模式（因为低字节存储的是高地址的内容）。
        - 如果不是，说明系统是大端模式。

#### 3. **变量定义**
   - **临时变量**：
     - `tempSixteenBits`（`Word` 类型）：用于存储位操作后的结果。
   - **常量**：
     - `BIT_PATTERN_ONE`（`Word` 类型，初始值 `0x0001`）：用于构造检测用的位模式。
     - `MOVE_BIT_POS`（`UDInt` 类型，初始值 `15`）：用于左移操作的位数（将 `0x0001` 左移 15 位得到 `0x8000`）。

#### 4. **算法步骤**
   1. **位操作**：
      - 将 `BIT_PATTERN_ONE` 左移 `MOVE_BIT_POS` 位，得到 `tempSixteenBits`（值为 `0x8000`）。
   2. **检测低字节**：
      - 检查 `tempSixteenBits` 的最低字节（`%B0`）是否为 `0x00`：
        - 如果是，返回 `TRUE`（小端模式）。
        - 否则，返回 `FALSE`（大端模式）。
   3. **设置函数状态**：
      - 将 `ENO` 设为 `TRUE`，表示函数执行成功。

#### 5. **代码调整建议**
   - **可读性优化**：
     - 在注释中明确说明检测逻辑（如“小端模式下，低字节存储的是高地址的内容”）。
   - **扩展性优化**：
     - 如果需要支持更多字节序检测（如混合字节序），可以扩展逻辑。
   - **错误处理**：
     - 当前逻辑假设函数始终成功，但可以增加错误处理（如输入验证）。

#### 6. **伪代码描述**
   ```plaintext
   FUNCTION LGF_IsLittleEndian : Bool
   VAR_TEMP
      tempSixteenBits : Word;
   VAR_CONSTANT
      BIT_PATTERN_ONE := 0x0001;
      MOVE_BIT_POS := 15;
   BEGIN
      // 构造检测用的位模式（0x0001左移15位得到0x8000）
      tempSixteenBits := SHL(BIT_PATTERN_ONE, MOVE_BIT_POS);
      
      // 检查低字节是否为0x00（小端模式下为真）
      LGF_IsLittleEndian := (tempSixteenBits.%B0 = 0x00);
      
      // 标记函数执行成功
      ENO := TRUE;
   END_FUNCTION
   ```

#### 7. **总结**
   - 该函数通过位操作和低字节检测实现了小端模式的判断。
   - 逻辑简洁高效，适合嵌入式或PLC环境。
   - 可直接用于代码生成，无需大幅调整。