### 算法流程描述：单字节CRC-8计算器（LGF_CalcCRC8For1Byte）

#### **1. 功能概述**
- 该函数用于计算单字节数据的CRC-8校验值，适用于数据传输时的错误检测。
- 输入参数：
  - `initValue`（初始值，默认`16#00`）
  - `mask`（生成多项式，默认`16#00`）
  - `value`（待计算CRC的数据字节）
- 输出：
  - 返回计算后的CRC-8校验值（`Byte`类型）

#### **2. 核心算法逻辑**
1. **初始化阶段**
   - 将`initValue`与`value`进行**异或（XOR）**运算，得到初始CRC值：
     ```plaintext
     tempCRC = initValue XOR value
     ```

2. **CRC计算循环（8次迭代）**
   - 循环范围：`0`到`7`（对应8位数据）
   - 每次循环执行以下步骤：
     - **检查最高位（MSB）是否为1**：
       - 如果`tempCRC.%X7`（第7位）为`TRUE`：
         - 执行**左移1位**（`SHL`），然后与`mask`进行**异或（XOR）**运算：
           ```plaintext
           tempCRC = (tempCRC << 1) XOR mask
           ```
       - 如果`tempCRC.%X7`为`FALSE`：
         - 仅执行**左移1位**：
           ```plaintext
           tempCRC = tempCRC << 1
           ```

3. **结果输出**
   - 最终`tempCRC`即为计算完成的CRC-8值，直接赋值给函数返回值：
     ```plaintext
     LGF_CalcCRC8For1Byte := tempCRC
     ```

#### **3. 关键点说明**
- **生成多项式（mask）**：决定了CRC的校验规则，需根据具体协议选择（如`0x07`、`0x31`等）。
- **循环次数固定为8**：因为输入是单字节（8位），每次处理1位。
- **无错误处理**：函数默认始终成功（`ENO := TRUE`）。

#### **4. 代码优化建议**
- 如果`mask`是固定值（如`0x07`），可移除输入参数`mask`，改为常量定义。
- 可扩展为多字节CRC计算（需增加循环和缓冲区处理）。

#### **5. 示例流程**
假设：
- `initValue = 0x00`
- `mask = 0x07`（CRC-8标准多项式）
- `value = 0xA2`（待校验数据）

计算步骤：
1. `tempCRC = 0x00 XOR 0xA2 = 0xA2`
2. 循环8次：
   - 第1次：`0xA2`（`10100010`）→ MSB=1 → `(0xA2 << 1) XOR 0x07 = 0x43`
   - 第2次：`0x43`（`01000011`）→ MSB=0 → `0x43 << 1 = 0x86`
   - ...（后续步骤类似）
3. 最终结果：`0xXX`（具体值取决于循环结果）