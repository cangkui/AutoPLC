### 算法流程描述（适用于类似的生产线控制需求）

#### 1. **模式切换处理**
- **核心思想**：通过`Mode`输入区分手动/自动模式，两种模式逻辑完全独立。
- **手动模式**：
  - 直接映射按钮信号到电机输出（`ForwardButton→MotorForward`，`ReverseButton→MotorReverse`）。
  - **互锁逻辑**：确保正反转不能同时激活（`AND NOT`实现）。
- **自动模式**：
  - 重置状态机到初始状态（`STATE_A`），避免模式切换残留状态。

#### 2. **自动状态机设计**
- **状态划分**（通用模板）：
  - **STATE_A**：等待工作站A就绪（`SensorA && ButtonA`）→ 启动电机正转，进入下一状态。
  - **STATE_B**：等待工作站B就绪（`SensorB && ButtonB`）→ 启动电机正转，进入下一状态。
  - **STATE_C**：等待工作站C就绪（`SensorC && ButtonC`）→ 点亮完成灯，进入结束状态。
  - **STATE_D**：完成状态，检测产品离开（`!SensorC`）→ 熄灭完成灯，复位到初始状态。
- **关键逻辑**：
  - 每个状态需同时满足**传感器检测**和**按钮触发**条件。
  - 状态迁移后立即执行动作（如启动电机），无需额外延时。

#### 3. **输出处理优化**
- **临时变量使用**：通过`tempMotorForward`等中间变量集中处理输出逻辑，避免直接修改输出引发竞争条件。
- **自动模式安全限制**：强制关闭反向输出（`tempMotorReverse := FALSE`），确保单向流动。

#### 4. **扩展性建议**
- **状态机增强**：若需故障处理，可增加`STATE_ERROR`和超时检测。
- **传感器去抖动**：高频应用中可在输入验证区域添加滤波逻辑。
- **模块化设计**：将状态机拆分为单独函数，便于维护多工位扩展。

> 注：此设计模式适用于任何需要**顺序控制+手动/自动切换**的场景（如装配线、物流分拣），仅需调整状态数量和迁移条件。