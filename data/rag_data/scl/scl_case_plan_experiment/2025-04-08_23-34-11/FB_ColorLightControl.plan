### 算法流程描述（适用于类似需求的控制逻辑）

#### 1. **状态机设计思想**
- **核心思路**：将灯光的切换逻辑抽象为**有限状态机**，每个状态对应一种灯光组合。
- **适用场景**：任何需要按固定顺序切换输出状态的循环控制（如指示灯、多工位设备等）。

#### 2. **关键变量定义**
- **输入检测**：  
  - `controlButton`（脉冲输入）：需通过**边沿检测**（当前为1且上一次为0）判断有效触发。
  - `lastControlButtonState`：存储上一次按钮状态，用于边沿检测。
- **状态管理**：  
  - `lightState`（整数型）：记录当前状态（1~5），循环递增后复位。
- **输出控制**：  
  - `greenLight`/`redLight`/`yellowLight`：直接由状态决定。

#### 3. **主逻辑流程**
1. **边沿检测**：  
   - 检测按钮的上升沿（`controlButton=1 AND lastControlButtonState=0`）。
   - 若触发，则状态变量`lightState`加1；若超过最大值（5），则复位为1。

2. **状态映射输出**：  
   - 使用`CASE`语句将`lightState`映射到对应的灯光组合（如状态1→仅绿灯亮）。
   - 注：状态与输出的关系可灵活配置（例如通过数组或查表法）。

#### 4. **扩展性建议**
- **状态扩展**：若需更多状态（如6种），仅需修改`lightState`的最大值判断（如`>6`）和`CASE`分支。
- **输出扩展**：增加输出变量（如`blueLight`）时，需在`CASE`中补充对应逻辑。
- **参数化设计**：可将状态-输出映射定义为常量数组，便于维护。

#### 5. **代码优化方向**
- **输入验证**：可添加对`controlButton`的防抖处理（如延时确认）。
- **输出区域**：若输出逻辑复杂（如需滤波），可在独立区域处理。

### 调整后的伪代码流程
```plaintext
IF 检测到按钮上升沿 THEN
    lightState ← (lightState + 1) MOD 5  // 循环1~5
END_IF

CASE lightState OF
    1: 输出[绿灯=ON, 其他=OFF]
    2: 输出[红灯=ON, 其他=OFF]
    ...
    5: 输出[全OFF]
END_CASE
```

### 总结
该设计通过**状态机+边沿检测**实现循环控制，适用于任何需要顺序切换输出的场景。核心是分离**状态管理**和**输出映射**，保证可扩展性和可读性。