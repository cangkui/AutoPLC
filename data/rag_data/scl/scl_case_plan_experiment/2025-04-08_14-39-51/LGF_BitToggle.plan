

算法流程描述：

1. 位号有效性处理：
   - 通过MOD 32运算将输入的bitNo限制在0-31范围内（对应DWORD的32位结构）

2. 掩码生成：
   - 将数值1（二进制第0位为1）左移处理后的bitNo位数
   - 例如bitNo=3 → 生成掩码0b1000（16#00000008）

3. 位翻转操作：
   - 使用异或(XOR)运算符将原始value与生成的掩码进行位运算
   - XOR特性：当两个操作数对应位不同时为1，保证目标位被翻转，其他位保持不变

4. 结果输出：
   - 直接返回异或运算后的结果
   - 不进行错误状态处理（如超出bitNo范围的错误）

关键调整点：
- 移除原代码中的TRUE_BOOL_BIT常量定义（可直接用1替代）
- 将MOD运算直接硬编码为32（因DWORD固定为32位，无需通过常量传递）
- 简化注释说明，聚焦核心逻辑

优化后的伪代码流程：
输入：value(DWORD), bitNo(USINT)
输出：返回DWORD

BEGIN
    // 核心操作仅需1行
    RETURN value XOR (1 << (bitNo % 32));
END