

### 算法流程描述

#### 核心逻辑流程
1. **触发检测**  
   - 检测`execute`输入的上升沿，触发计算流程  
   - 获取输入数组的上下边界`tempArrLowBound`/`tempArrUppBound`  
   - 初始化所有统计变量为默认值

2. **输入验证**  
   - 检查`rangeOutlier`有效性：必须>1.0或=0.0  
   - 验证数组下边界非负  
   - 任一检查失败时设置对应错误码

3. **数据预处理**  
   - 调用`LGF_ShellSort_UDInt`对输入数组进行原地排序  
   - 捕获排序错误时设置`ERR_SHELL_SORT`状态

4. **基础统计计算**  
   - **中位数计算**  
     - 偶元素数：取中间两数平均  
     - 奇元素数：取中间值  
   - **四分位数计算**  
     - Q25：使用公式`k=(n+3)/4`进行线性插值  
     - Q75：使用公式`k=(3n+1)/4`进行线性插值

5. **离群值分析**  
   - 当`rangeOutlier≠0`时：  
     a. 计算四分位距`delta=Q75-Q25`  
     b. 确定离群边界：  
        - 下限：`Q25 - range*delta`  
        - 上限：`Q75 + range*delta`  
     c. 双向扫描排序数组：  
        - 正向扫描找首个≥下限的值作为新min  
        - 反向扫描找首个≤上限的值作为新max  
     d. 计算离群百分比：  
        - 下限离群率 = (离群点数/总数)*100%  
        - 上限离群率同理

6. **偏度计算**  
   - 使用公式：`(Q25 + Q75 - 2*median)/(Q75 - Q25)`

#### 输出处理
- **数据输出选择**：  
  `rangeOutlier≠0`时使用调整后的min/max，否则使用原始极值
- **状态映射**：  
  - `error`标志取自状态字最高位  
  - 主状态码直接映射到`status`输出
- **强制使能输出**：  
  始终设置ENO=true，通过专用error信号传递错误

#### 异常处理策略
| 错误码       | 触发条件                     | 处理措施                     |
|--------------|----------------------------|----------------------------|
| ERR_RANGE_NOT_OK | 无效的rangeOutlier参数     | 中止计算，锁定错误状态       |
| ERR_NEG_ARR_BOUND | 数组下界为负              | 立即停止流程                |
| ERR_SHELL_SORT   | 排序功能块报错            | 继承子功能块状态码          |

#### 关键计算点说明
1. **四分位插值算法**  
   采用线性插值法处理非整数位置：  
   `value = floor(k)_value + (k - floor(k)) * (ceil(k)_value - floor(k)_value)`

2. **离群扫描优化**  
   利用已排序数组特性：  
   - 下限扫描一旦发现首个非离群值，后续必定更大，可提前终止  
   - 上限扫描采用反向遍历，发现首个非离群值即终止

3. **偏度计算简化式**  
   使用基于四分位数的近似公式，避免计算高阶矩，降低计算量

#### 状态机流转
``` 
[IDLE]  
   ↑↓ execute上升沿  
[VALIDATING] → 错误? → [ERROR]  
   ↓ 校验通过  
[CALCULATING]  
   ↓  
[OUTPUT] → 循环结束返回IDLE
```

#### 性能优化点
1. **原地排序**：直接修改输入数组，避免内存拷贝  
2. **边界缓存**：提前计算数组上下界并复用  
3. **短路扫描**：离群检测时满足条件立即跳出循环  
4. **类型转换优化**：使用UDINT_TO_LREAL代替隐式转换

该流程设计确保在保持统计精度的同时，满足工业控制器对实时性的要求，特别适用于大规模数据集的快速分析。