

### 算法流程描述

#### 功能目标
实现在DWORD类型变量中设置指定二进制位的功能，将目标位置位（设为1）。输入参数为原始数值和位序号，输出为修改后的DWORD值。

---

#### 变量定义
1. **输入参数**
   - `value`（DWord）：待修改的原始数值
   - `bitNo`（USInt）：需设置的位序号（0-31，超过则自动取模）
2. **内部常量**
   - `TRUE_BOOL_BIT`（DWord := 16#0001）：表示最低位为1的掩码
   - `MAX_NO_OF_BITS`（USInt := 32）：DWORD最大位数约束
3. **返回值**
   - 修改后的DWord数值（`#LGF_BitSet`）

---

#### 执行逻辑
1. **位序号约束**  
   - 通过 `bitNo MOD 32` 确保位序号始终在 **0-31** 范围内（例如输入33 → 1，输入64 → 0）
   
2. **生成位掩码**  
   - 将 `TRUE_BOOL_BIT`（即二进制 `0000...0001`）左移 `bitNo` 位  
   - 示例：若 `bitNo=3`，掩码为 `0000...1000`

3. **合并数值**  
   - 对原始 `value` 和掩码进行 **逻辑或（OR）** 操作  
   - 特性：原数值的指定位被强制置1，其余位保持不变

4. **无错误处理**  
   - 隐式通过取模操作规避越界问题，`ENO` 固定返回 `TRUE`（无需错误状态码）

---

#### 流程公式
```plaintext
Result = value | (1 << (bitNo % 32))
```

---

### 与代码的差异说明
- **输入有效性处理**  
  示例代码未显式检查 `bitNo` 是否超过31，而是通过 `MOD 32` 隐式约束。若需严格限制位序号范围（如强制0-31），需额外添加边界判断逻辑。
  
- **掩码生成优化**  
  代码中直接使用 `SHL(IN := 1, N := bitNo)` 等效于 `1 << bitNo`，但通过预定义 `TRUE_BOOL_BIT` 增强可读性，避免硬编码魔法数值。