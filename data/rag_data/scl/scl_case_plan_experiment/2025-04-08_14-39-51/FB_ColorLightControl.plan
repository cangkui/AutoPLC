

### 算法流程描述（基于需求与代码调整后的逻辑）

#### **核心逻辑流程**
1. **上升沿检测机制**  
   - 通过 `lastControlButtonState` 变量存储按钮上一周期的状态  
   - **触发条件**: 当 `controlButton` 当前状态为 `TRUE` 且上一次状态为 `FALSE` 时（即检测到上升沿）

2. **状态机循环控制**  
   - 初始化 `lightState = 0`（对应所有灯关闭的初始状态）  
   - **每次触发上升沿时**:  
     - `lightState` 自增 `1`  
     - 当 `lightState > 5` 时，重置为 `1`（实现 6th+ 触发后循环）

3. **灯状态映射规则**  
   根据 `lightState` 值直接设置输出：  
   | 状态值 | 绿灯 | 红灯 | 黄灯 | 说明                |  
   |--------|------|------|------|-------------------|  
   | **1**  | ON   | OFF  | OFF  | 仅绿灯亮            |  
   | **2**  | OFF  | ON   | OFF  | 仅红灯亮            |  
   | **3**  | OFF  | OFF  | ON   | 仅黄灯亮            |  
   | **4**  | ON   | ON   | ON   | 全亮               |  
   | **5**  | OFF  | OFF  | OFF  | 全灭（触发后循环起点） |  

#### **代码关键调整点**  
- **初始化逻辑优化**:  
  初始 `lightState = 0` 时无灯亮，符合未触发时的自然状态  
- **循环边界处理**:  
  判断 `lightState > 5` 而非 `>=6`，使第6次触发时 `lightState` 从 `5→6→1`，精准对应需求描述的循环起点  
- **直接输出赋值**:  
  在 `CASE` 语句中直接操作输出变量，无需额外中间变量  

#### **思维链示意图**  
```  
[按钮触发]  
  → 检测上升沿  
    → 更新 lightState (自增+循环重置)  
      → 根据 lightState 映射灯状态  
        → 输出至 greenLight/redLight/yellowLight  
```