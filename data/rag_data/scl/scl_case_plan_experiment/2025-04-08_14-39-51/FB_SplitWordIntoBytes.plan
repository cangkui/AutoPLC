

### 算法流程描述

#### 功能目标
将16位二进制数按4位一组分解为4个独立变量，并计算非零变量的平均值。

---

#### 核心步骤分解

##### **步骤1：分解16位数为4个4位字节**
- **位掩码+右移提取**  
  通过位掩码 `16#000F`（二进制 `0000_0000_0000_1111`）提取每4位：
  - **Byte0**（最低4位）：  
    直接取输入字的低4位：`InputWord AND 16#000F`。
  - **Byte1**（次低4位）：  
    输入字右移4位后取低4位：`SHR(InputWord, 4) AND 16#000F`。
  - **Byte2**（次高4位）：  
    输入字右移8位后取低4位：`SHR(InputWord, 8) AND 16#000F`。
  - **Byte3**（最高4位）：  
    输入字右移12位后取低4位：`SHR(InputWord, 12) AND 16#000F`。

##### **步骤2：计算非零字节平均值**
- **初始化累加器**  
  临时变量 `sum`（总和）和 `count`（非零计数器）初始化为0。
- **遍历四个字节**  
  依次检查每个字节是否非零：
  - 若 `ByteX ≠ 0`，将值累加到 `sum`，且 `count` 加1。
- **计算平均值**  
  - 若 `count > 0`：  
    平均值 = `sum / count`（转换为浮点数计算）。
  - 若 `count = 0`：  
    平均值设为0。

---

#### 代码调整建议
1. **变量类型优化**  
   - 输入输出字节类型为 `Byte`，但掩码操作结果为16位整数，需显式截断为8位：  
     ```scl
     #Byte0 := BYTE_TO_WORD(#InputWord) AND 16#000F;  // 确保类型匹配
     ```
2. **临时变量生命周期**  
   - `sum` 和 `count` 应在每次调用时重置，使用 `VAR_TEMP`（如当前代码）而非 `VAR` 避免残留值。

---

### 流程对比说明
| 需求描述               | 代码实现逻辑                                                                 | 关键一致性验证               |
|------------------------|-----------------------------------------------------------------------------|------------------------------|
| 分解16位到4个4位字节   | 通过右移和掩码逐段提取（`SHR` + `AND 16#000F`）                              | ✅ 掩码和移位位宽正确         |
| 非零字节平均值计算      | 遍历四个字节累加非零值，最终除法计算（`sum/count`）                           | ✅ 处理零值逻辑与需求一致      |
| 数据类型匹配           | 输出字节直接赋值，隐式截断（依赖PLC编译器）                                    | ⚠️ 建议显式类型转换提高可读性 |