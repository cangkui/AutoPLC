

以下是基于需求及代码的算法流程描述：

1. **使能信号处理**
   - 检测`enable`上升沿→激活计算流程，状态置为"STATUS_IN_OPERATION"
   - 检测`enable`下降沿→停止计算，状态重置为"STATUS_NO_CALL"
   - 持续检测使能状态，非激活时跳过后续计算

2. **时间数据获取**
   - 调用`RD_SYS_T`读取UTC系统时间
   - 调用`RD_LOC_T`获取官方本地时间
   - 计算时区偏移量：`(UTC时间 - 本地时间)/小时数`

3. **日期预处理**
   - 构造当年1月1日日期对象
   - 计算当前是年度第几天：`当前日期 - 1月1日 + 1`

4. **输入校验**
   ```plaintext
   if 纬度绝对值 > 90°
       → ERR_LATITUDE_VALUE
   if 经度绝对值 > 180°
       → ERR_LONGITUDE_VALUE
   ```

5. **天文计算核心**
   *日出计算分支*
   - 设置近似时间6:00基准
   - 计算太阳参数：
     ```
     平均近点角 = 0.9856 * 近似时间 - 3.289
     真太阳时 = 平均近点角 + 282.634 + 1.916*sin(平均近点角) + 0.02*sin(2*平均近点角)
     赤经 = atan(0.91764*tan(真太阳时)) 经度修正
     赤纬 = asin(0.39782*sin(真太阳时))
     ```
   - 计算时角：
     ```
     cos(时角) = [cos(96°)-sin(赤纬)*sin(纬度)] / [cos(赤纬)*cos(纬度)]
     时角修正为360°-acos(...)
     ```

   *日落计算分支*
   - 设置近似时间18:00基准
   - 重复太阳参数计算，时角取acos(...)正值

6. **时间转换处理**
   - 本地平均时转换：`时角/15 + 赤经修正 - 0.06571*天数 - 6.622`
   - UTC时间修正：`减去经度小时数`
   - 时区调整：`UTC时间 - 时区偏移`
   - DTL时间构造：
     ```plaintext
     取当前日期年、月、日
     小时数×3.6e6→时间值
     叠加偏移量(offsetSunrise/Sunset)
     ```

7. **昼夜判断逻辑**
   ```plaintext
   isDaytime = (当前时间 ≥ 日出时间) AND (当前时间 ≤ 日落时间)
   考虑偏移量后的实际时间比较
   ```

8. **错误处理机制**
   - 系统时间读取错误→ ERR_RD_SYS_T
   - 本地时间读取错误→ ERR_RD_LOC_T
   - 错误码映射：`error = status.15位（最高位）`

9. **状态机管理**
   ```plaintext
   valid = 非错误状态 AND 忙碌状态
   busy = 计算进行中标志
   status包含主错误/状态码
   subFunctionStatus记录子函数返回值
   ```

调整点说明：
1. 将日出/日落计算合并描述，突出分支差异点
2. 简化三角函数计算的具体系数，保留关键参数
3. 强调时间转换链：天文计算→本地时→UTC→时区调整
4. 增加错误位映射说明（最高位表示错误）
5. 明确状态标志间的逻辑关系（valid/busy/error）

此流程覆盖了从使能触发到天文计算的核心路径，同时明确了错误处理和数据转换的关键节点，可作为代码实现的指导框架。