
# TODO：实现一个从编码和debug过程中学习经验策略的agent
import json
from autoplc_scl.agents.clients import OpenAIClient
from typing import List, Dict, Tuple, Any, Optional

import logging
logger = logging.getLogger("autoplc_scl")

class LearnAgent():
    """
    分别从相似案例、算法描述中推荐
    
    """
    # 定义一个类变量，用于存储基础日志文件夹的路径
    base_logs_folder: str = None

    @classmethod
    def extract_content(cls,response) -> str:
        """
        提取大模型响应的content
        """
        if hasattr(response, 'choices'):
            choice = response.choices[0]
            if hasattr(choice, 'message') and hasattr(choice.message, 'content'):
                content = choice.message.content
            else:
                content = choice['message']['content']
        else:
            content = response.content[0].text
        return content
    
    @classmethod
    def get_json_from_content(cls,content:str) : 
        try:
            json_start = content.index('```json') + len('```json')
            json_end = content.index('```', json_start)
            json_str = content[json_start:json_end].strip()
            json_data = json.loads(json_str)
        except (ValueError, json.JSONDecodeError) as e:
            logger.exception(e)
            json_data = None
        return json_data

    @classmethod
    def run_learn_from_coding(cls, task: dict, prediction_scl: str, groundtruth_scl: str, openai_client:OpenAIClient) -> dict:
        """
        Summarize the differences and provide feedback based on the prediction and the groundtruth code.
        
        Args:
        task (dict): The task provided by the user.
        prediction_scl (str): The SCL code generated by AutoPLC.
        groundtruth_scl (str): The reference code provided by an expert.
        
        Returns:
        dict: A summary of strengths, weaknesses, and future improvement suggestions.
        """
        # Prepare the prompt based on the provided information
        learn_from_task_with_data = learn_from_task_user.format(
            task=str(task),
            prediction_scl=prediction_scl,
            groundtruth_scl=groundtruth_scl
        )
        
        # Call the LLM to analyze the task and provide a reflection
        response = openai_client.call(
            messages=[{"role": "system", "content": learn_from_task},{"role": "user", "content": learn_from_task_with_data}],
            task_name="learn_from_task",
            role_name="learn_agent"
        )
        
        # Extract the content from the LLM response
        content = cls.extract_content(response)
        
        # Parse the response content to get the structured feedback
        feedback_summary = cls.get_json_from_content(content)
        
        return feedback_summary


    @classmethod
    def run_learn_from_debug(cls, task: dict, groundtruth_scl: str, debug_history: List[dict], openai_client:OpenAIClient) -> dict:
        """
        Summarize the common errors based on the current task's the debug history.
        
        Args:
        task (dict): The task provided by the user.
        groundtruth_scl (str): The reference code provided by an expert.
        debug_history (List[dict]): List of debugging messages from the conversation history:
            {
            "scl_before_fix" : "", 
            "compiler" : "", // TIA Portal output
            "assistant" : "" // AI output
            }
        
        Returns:
        dict: A summary of errors and improvement suggestions.
        """
        # Prepare the prompt based on the provided information
        learn_from_complier_with_data = learn_from_complier_user.format(
            task=task,
            debug_history="\n".join([f"Debug Step: {step}" for step in debug_history]),
            groundtruth_scl=groundtruth_scl
        )
        
        # Call the LLM to analyze the task and provide a reflection
        response = openai_client.call(
            messages=[{"role": "system", "content": learn_from_complier},{"role": "user", "content": learn_from_complier_with_data}],
            task_name="learn_from_debug",
            role_name="learn_agent"
        )
        
        # Extract the content from the LLM response
        content = cls.extract_content(response)
        
        # Parse the response content to get the structured error details
        error_summary = cls.get_json_from_content(content)
        
        return error_summary


learn_from_complier = """
角色：你是一位经验丰富的 PLC 编程指导助手，擅长从编译错误与修复记录中总结经验，提炼出后续代码生成应注意的风险点与建议提示。

任务目标：
根据本次任务中遇到的编译错误及其最终的修复方式，总结出本类错误的通用触发条件、误用场景及下次应该提醒代码生成器（LogicComposer）避免的写法。

请以结构化形式输出以下内容：
```json
[{
    "错误类型": "简洁描述错误类别（如变量未声明、数据类型不匹配、函数参数缺失等）",
    "错误信息": "原始编译错误提示",
    "错误原因": "造成错误的本质原因",
    "修复方式": "本次修复采用的方式",
    "下次提示建议": "如何在生成代码时主动规避或提醒"
},{...}]
```
要求：
- 输出应针对“泛化”错误模式，而非仅限当前变量；
- 提示建议应适合用作 future system prompt 的内容，能直接注入到 LogicComposer；
- 多个错误可分条输出；
"""


learn_from_complier_user = """
## 需求
{task}

## Debug过程
{debug_history}

## 正确答案
{groundtruth_scl}

"""
learn_from_task = """
Role: You are a PLC code generation agent capable of self-reflection. After each generation task, you must conduct a structured review to extract reusable coding strategies and identify critical risks.

Target Platform:
Your code is written in **Structured Control Language (SCL)** for **Siemens S7-1200 and S7-1500 series PLCs**, within the TIA Portal environment. 

Input:
- task description
- The code snippet you generated for your task
- The engineer-provided reference implementation (ground truth)

Task Objective:
Compare your generated code with the reference code, focusing on areas such as:
- Control logic structure
- Expression clarity
- Complex data manipulation (e.g., arrays, structures, timers)
- Use of internal memory and system functions

Then, provide up to three concise and different insights for each of the following:

1. **Key Strategy** — Valuable and generalizable coding practices that should be applied in future tasks.
2. **Key Risk** — Critical mistakes or omissions that should be avoided in future tasks, as they may cause functional errors, poor maintainability, or integration failure.

Use the following format:
```json
{
  "key_strategy": [
    "When [condition], do [recommended practice], because [justification].",
    "...",
    "..."
  ],
  "key_risk": [
    "When [condition], not doing [expected action] may cause [negative consequence].",
    "...",
    "..."
  ]
}

Instructions:
- Focus on the most significant insights; do not list minor stylistic differences.
- Prioritize observations related to S7 platform constraints and real-time control behavior.
- If any part of the reference code is unclear to you, say so explicitly—do not guess.
"""

learn_from_task_user = """
## task
{task}

## Your generated code
{prediction_scl}

## Best answer
{groundtruth_scl}

"""