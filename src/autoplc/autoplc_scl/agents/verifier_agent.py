import os
import re
import json
import time
from typing import Tuple, List
from common import Config
from autoplc_scl.tools import APIDataLoader, TIAPortalCompiler
from autoplc_scl.agents.clients import ClientManager, OpenAIClient
import logging
logger = logging.getLogger("autoplc_scl")

class AutoDebugger():
    """
    AutoDebugger class

    This class is responsible for validating and improving SCL code. It tries to compile the given SCL code through the compiler and fixes it with AI-generated patches when an error is found.
    This process is repeated until the code is successfully compiled or the maximum number of attempts is reached.

    Class variables:
    -base_logs_folder: str
        The path used to store the underlying log folder.

    method:
    -run_debugger_with_compiler(cls, task: dict, scl_code: str) -> Tuple[str, int, int]
        Perform verification and improvement processes. Receive a task dictionary and a piece of SCL code, try to compile and verify the code.
        If there are errors in the code, you will try to fix these errors with patches generated by the AI.
        Returns the repaired SCL code and the token consumption of input and output.
    """

    base_logs_folder: str = None

    @classmethod
    def run_debugger_with_compiler(
        cls, 
        task: dict,
        scl_code: str,
        max_verify_count: int,
        openai_client: OpenAIClient,
        load_few_shots: bool = True,
    ) -> str:
        """
        Perform verification and improvement processes.
    
        This method receives a task dictionary and a piece of SCL code, and then tries to compile and verify the code.
        If there are errors in the code, it will try to fix these errors with patches generated by the AI.
        This process is repeated until the code is successfully compiled or the maximum number of attempts is reached.
    
        parameter:
        -task: A dictionary containing task information, such as task name.
        -scl_code: SCL code that needs to be compiled and verified.
        -max_verify_count : Maximum number of verifications
        -openai_client : The big model client used to call
        -load_few_shots: Whether to load few-shot

        return:
        -scl_code: Fixed SCL code
        """
    
        # Define log file path
        verify_information_log = os.path.join(cls.base_logs_folder, f"{task['name']}/verify_info.jsonl")

        logger.info(f"verify_information_log is > {verify_information_log}")

        # Initialize verification counter and compiler instance
        verify_count = 0
        compiler = TIAPortalCompiler()
        start_time = time.time()
        
        # System prompt information for building a validator
        verifier_system_prompt_with_data = verifier_system_prompt.format(
            api_details = APIDataLoader.api_details_str,
            programming_guidance = programming_guidance
        )

        verifier_messages = [{"role": "system", "content": verifier_system_prompt_with_data}]

        # TODO: few-shot is not aligned with openness, commented temporarily
        if load_few_shots:
            # verifier_fewshots = cls.load_debug_shots()
            # verifier_messages.extend(verifier_fewshots)
            pass

        # Try to verify and fix the code until successful or maximum attempts are reached
        while verify_count < max_verify_count:
            debugging_process_data = {
                "scl_before_fix": "",
                "compiler":[],
                "assistant":""
            }
            verify_count += 1

            check_result = compiler.scl_syntax_check(task['name'], scl_code)
            no_error = check_result.success
            
            if no_error:
                logger.info(f"{task['name']} SUCCESS!")
                break
            else:
                error_list = []
                
                # The preferred Data Section error is because the Data Section error will throw a cascading error
                for error in check_result.errors:
                    if error.error_type == "Declaration Section Error":
                        logger.info(f"Declaration Section Error >>> {str(error)}")
                        error_list.append(error.to_dict())

                # If there is no Data Section error, check for Program Section errors
                if not error_list:
                    for error in check_result.errors:
                        if error.error_type == "Implementation Section Error":
                            logger.info(f'Implementation Section Error >>>> {str(error)}')
                            error_list.append(error.to_dict())

                error_log = '\n'.join([str(err) for err in error_list])
                logger.info(f'{task["name"]} Start Verification!')

                # Record all error messages
                debugging_process_data["compiler"] = [error.to_dict() for error in check_result.errors]

            verifier_instance_prompt_with_data = verifier_instance_prompt.format(
                static_analysis_results = error_log,
                scl_code = scl_code
            )
            verifier_messages.append({"role": "user", "content": verifier_instance_prompt_with_data})
            debugging_process_data["scl_before_fix"] = scl_code

            # Generate fix patches using llm
            response = openai_client.call(
                messages=verifier_messages,
                task_name=task['name'],
                role_name="verifier"
            )

            verify_result = cls.extract_content(response)
    
            verifier_messages.append({"role": "assistant", "content": verify_result})
            debugging_process_data["assistant"] = verify_result
            segments_and_patches = cls.parse_patch(verify_result)
    
            # Apply repair patches to code
            for buggy, patch in segments_and_patches:
                scl_code = scl_code.replace(buggy, patch)
            
            with open(verify_information_log, "a+", encoding="utf-8") as fp:
                json.dump(debugging_process_data, fp, ensure_ascii=False)
                fp.write('\n')
                    
            logger.info(f"{task['name']} End-Verify_and_improver ({verify_count}) -Execution time: {(time.time() - start_time):.6f} Seconds")
        
        # Write the final code result to a file. For easy reading, directly overwrite the previous content written
        code_output_file = os.path.join(cls.base_logs_folder, f"{task['name']}/{task['name']}_{verify_count}.scl")
        logger.info(f"output file is {code_output_file}")
        with open(code_output_file, "w", encoding="utf-8") as fp:
            fp.write(scl_code)

        return scl_code

    @classmethod
    def extract_content(cls,response) -> str:
        """
        Extract the SCL code in the response content.

        This method extracts the generated SCL code from the response of the AI ​​model. The response may contain multiple choices,
        Each selection may contain a message object that contains the required content.

        parameter:
        -response: The response object of the AI ​​model.

        return:
        -scl_code: Extracted SCL code string.
        """
        if hasattr(response, 'choices'):
            choice = response.choices[0]
            if hasattr(choice, 'message') and hasattr(choice.message, 'content'):
                scl_code = choice.message.content
            else:
                scl_code = choice['message']['content']
        else:
            scl_code = response.content[0].text
        return scl_code

    @classmethod
    def parse_patch(cls, text: str) -> List[str]:
        """
        Parses snippets and patches in the given text.
    
        This method uses regular expressions to find and extract snippets and patch pairs in text that match the criteria.
        It mainly focuses on the text content surrounded by <code_segment> and <patch> tags, and extracts it as a pair of buggy code and corresponding patch.
    
        parameter:
        -text: str -text that needs parsing.
    
        return:
        -List[str] -A list of multiple tuples, each containing two strings:
          1. buggy code (code before repair).
          2. patch (patch to fix the issue).
        """
        # Compile a regular expression pattern to match the content between the <code_segment> and <patch> tags.
        # Use the re.DOTALL flag to make . match all characters including newlines.
        pattern = re.compile(
            r'<code_segment>(.*?)</code_segment>\s*<patch>(.*?)</patch>', 
            re.DOTALL
        )
    
        # Find all matches using compiled regular expressions.
        matches: List[str] = pattern.findall(text)
        results = []
        for buggy, patch in matches:
            # After removing the matching buggy code and patch, add it to the result list as a tuple.
            results.append((buggy.strip(), patch.strip()))
    
        # Returns the processed result list.
        return results
    
    @classmethod
    def load_debug_shots(cls, SHOT_DATA_DIR:str):
        """
        [Deprecated] Load and format code verification examples and algorithms into few-shot prompts and add them to the shots list.
        
        parameters:
        - SHOT_DATA_DIR (str): The directory path where the shot data is located.
        """
        SHOT_DATA_DIR = Config.SHOT_DATA_DIR
        shot_prompt = verifier_instance_prompt
        verifier_shots= []
        
        # Few-Shot example for reading validator
        with open(f'{SHOT_DATA_DIR}/verifier_fewshot.txt','r') as fp:
            verifier_fewshots = fp.read()
    
        verifier_fewshots = verifier_fewshots.split("=====")
        for example in verifier_fewshots:
            buggy_code, check_feedback, response_patch = example.split("&&&&&")
            verifier_icl = shot_prompt.format(
                static_analysis_results = check_feedback,
                scl_code = buggy_code
            )
            verifier_shots.append({"role": "user", "content": verifier_icl})
            verifier_shots.append({"role": "assistant", "content": response_patch})
    
        return verifier_shots


verifier_system_prompt = """
ROLE: 
You are an expert in Siemens SCL (Structured Control Language) programming for S7-1200/1500 PLCs, 
specializing in identifying and correcting syntax and semantic errors based on compilation feedback from TIA Portal.

GOALS: 
Generate accurate patch fixes.

WORKFLOW:
1.Analyze TIA Portal's compilation error messages and locate the actual erroneous SCL segment.
2.Explain why the error occurred using S7-1200/1500 syntax rules.
3.Provide detailed corrective suggestions for each identified issue.
4.Output a patch using the following required format.

IMPORTANT:
- Assume compilation is done via TIA Portal for S7-1200/1500 targets, and conform to its dialect of Structured Control Language (SCL, IEC 61131-3).
- <code_segment> must be verbatim copied from the original SCL code, including indentation and comments.
- <patch> must be a direct replacement of the segment, and must be syntactically correct for S7-1200/1500 PLCs in TIA Portal.
- Identify and explain violated SCL syntax rules or Siemens-specific library usage rules.
- Sometimes the error message is due to cascading errors, reason through the control flow and dependencies to find the real issue.
- Avoid changing the algorithmic behavior unless absolutely necessary for correctness.

OUTPUT FORMAT:
```plaintext
- Fix suggestion 1: [Clear and actionable error fix suggestion]
- Fix suggestion k: [Clear and actionable error fix suggestion]
(1)
<code_segment>
# code here
</code_segment>
<patch>
# your patch here
</patch>
(n)
<code_segment>
# code here
</code_segment>
<patch>
# your patch here
</patch>
```
--Appendix--
SCL Library Functions:
{api_details}
SCL Programming Guidelines:
{programming_guidance}
"""

verifier_instance_prompt = """
Input structured in XML format:
<!-- Code with errors. -->
<SCLCode>
{scl_code}
</SCLCode>
<!-- Errors. -->
<Errors>
{static_analysis_results}
</Errors>
"""

programming_guidance = "NO PROGRAMMING GUIDANCE"
